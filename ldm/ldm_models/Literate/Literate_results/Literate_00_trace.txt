
Phase: Creating schema and survey of Literate_01
Generate schema...
as yaml - warnings =  False
Annotation  Qualified:  <class 'ldm.Literate_01.Annotation'>
Annotation  MRO:  ['Annotation', 'PydanticMixin', 'object']
Any  Qualified:  typing.Any
Any  MRO:  ['Any', 'object']
AsValue  Qualified:  <class 'utils.class_pom_token.AsValue'>
AsValue  MRO:  ['AsValue', 'PresentableBoolean', 'PresentableToken', 'PydanticMixin', 'object']
Attribute  Qualified:  <class 'ldm.Literate_01.Attribute'>
Attribute  MRO:  ['Attribute', 'Component', 'MinorComponent', 'PydanticMixin', 'object']
AttributeName  Qualified:  <class 'ldm.Literate_01.AttributeName'>
AttributeName  MRO:  ['AttributeName', 'LowerCamel', 'CamelCase', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
AttributeReference  Qualified:  <class 'ldm.Literate_01.AttributeReference'>
AttributeReference  MRO:  ['AttributeReference', 'PydanticMixin', 'object']
AttributeSection  Qualified:  <class 'ldm.Literate_01.AttributeSection'>
AttributeSection  MRO:  ['AttributeSection', 'Component', 'MinorComponent', 'PydanticMixin', 'object']
AttributeSectionName  Qualified:  <class 'ldm.Literate_01.AttributeSectionName'>
AttributeSectionName  MRO:  ['AttributeSectionName', 'NormalCase', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
BaseDataType  Qualified:  <class 'ldm.Literate_01.BaseDataType'>
BaseDataType  MRO:  ['BaseDataType', 'DataType', 'PydanticMixin', 'object']
CamelCase  Qualified:  <class 'utils.class_casing.CamelCase'>
CamelCase  MRO:  ['CamelCase', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
Casing  Qualified:  <class 'utils.class_casing.Casing'>
Casing  MRO:  ['Casing', 'PresentableToken', 'PydanticMixin', 'object']
Class  Qualified:  <class 'ldm.Literate_01.Class'>
Class  MRO:  ['Class', 'Component', 'MinorComponent', 'PydanticMixin', 'object']
ClassName  Qualified:  <class 'ldm.Literate_01.ClassName'>
ClassName  MRO:  ['ClassName', 'UpperCamel', 'CamelCase', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
ClassReference  Qualified:  <class 'ldm.Literate_01.ClassReference'>
ClassReference  MRO:  ['ClassReference', 'ClassName', 'UpperCamel', 'CamelCase', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
Class  Qualified:  <class 'ldm.Literate_01.Class'>
Class  MRO:  ['Class', 'Component', 'MinorComponent', 'PydanticMixin', 'object']
CodeBlock  Qualified:  <class 'ldm.Literate_01.CodeBlock'>
CodeBlock  MRO:  ['CodeBlock', 'PydanticMixin', 'object']
CodeType  Qualified:  <class 'ldm.Literate_01.CodeType'>
CodeType  MRO:  ['CodeType', 'ValueType', 'Class', 'Component', 'MinorComponent', 'PydanticMixin', 'object']
Component  Qualified:  <class 'ldm.Literate_01.Component'>
Component  MRO:  ['Component', 'MinorComponent', 'PydanticMixin', 'object']
Constraint  Qualified:  <class 'ldm.Literate_01.Constraint'>
Constraint  MRO:  ['Constraint', 'Formula', 'MinorComponent', 'PydanticMixin', 'object']
DataType  Qualified:  <class 'ldm.Literate_01.DataType'>
DataType  MRO:  ['DataType', 'PydanticMixin', 'object']
DataTypeClause  Qualified:  <class 'ldm.Literate_01.DataTypeClause'>
DataTypeClause  MRO:  ['DataTypeClause', 'PydanticMixin', 'object']
Default  Qualified:  <class 'ldm.Literate_01.Default'>
Default  MRO:  ['Default', 'Formula', 'MinorComponent', 'PydanticMixin', 'object']
Derivation  Qualified:  <class 'ldm.Literate_01.Derivation'>
Derivation  MRO:  ['Derivation', 'Formula', 'MinorComponent', 'PydanticMixin', 'object']
Diagnostic  Qualified:  <class 'ldm.Literate_01.Diagnostic'>
Diagnostic  MRO:  ['Diagnostic', 'PydanticMixin', 'object']
DotCase  Qualified:  <class 'utils.class_casing.DotCase'>
DotCase  MRO:  ['DotCase', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
Emoji  Qualified:  <class 'utils.class_pom_token.Emoji'>
Emoji  MRO:  ['Emoji', 'PresentableToken', 'PydanticMixin', 'object']
Formula  Qualified:  <class 'ldm.Literate_01.Formula'>
Formula  MRO:  ['Formula', 'MinorComponent', 'PydanticMixin', 'object']
FormulaCoding  Qualified:  <class 'ldm.Literate_01.FormulaCoding'>
FormulaCoding  MRO:  ['FormulaCoding', 'PydanticMixin', 'object']
InitVar  Qualified:  <class 'dataclasses.InitVar'>
InitVar  MRO:  ['InitVar', 'object']
IsExclusive  Qualified:  <class 'utils.class_pom_token.IsExclusive'>
IsExclusive  MRO:  ['IsExclusive', 'PresentableBoolean', 'PresentableToken', 'PydanticMixin', 'object']
IsExhaustive  Qualified:  <class 'utils.class_pom_token.IsExhaustive'>
IsExhaustive  MRO:  ['IsExhaustive', 'PresentableBoolean', 'PresentableToken', 'PydanticMixin', 'object']
IsOptional  Qualified:  <class 'utils.class_pom_token.IsOptional'>
IsOptional  MRO:  ['IsOptional', 'PresentableBoolean', 'PresentableToken', 'PydanticMixin', 'object']
Kebab  Qualified:  <class 'utils.class_casing.Kebab'>
Kebab  MRO:  ['Kebab', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
Label  Qualified:  <class 'ldm.Literate_01.Label'>
Label  MRO:  ['Label', 'LowerCamel', 'CamelCase', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
ListDataType  Qualified:  <class 'ldm.Literate_01.ListDataType'>
ListDataType  MRO:  ['ListDataType', 'DataType', 'PydanticMixin', 'object']
LiterateModel  Qualified:  <class 'ldm.Literate_01.LiterateModel'>
LiterateModel  MRO:  ['LiterateModel', 'SubjectB', 'SubjectC', 'SubjectD', 'SubjectE', 'Component', 'MinorComponent', 'PydanticMixin', 'object']
LowerCamel  Qualified:  <class 'utils.class_casing.LowerCamel'>
LowerCamel  MRO:  ['LowerCamel', 'CamelCase', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
MappingDataType  Qualified:  <class 'ldm.Literate_01.MappingDataType'>
MappingDataType  MRO:  ['MappingDataType', 'DataType', 'PydanticMixin', 'object']
MinorComponent  Qualified:  <class 'ldm.Literate_01.MinorComponent'>
MinorComponent  MRO:  ['MinorComponent', 'PydanticMixin', 'object']
ModelName  Qualified:  <class 'ldm.Literate_01.ModelName'>
ModelName  MRO:  ['ModelName', 'NormalCase', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
SnakeCase  Qualified:  <class 'utils.class_casing.SnakeCase'>
SnakeCase  MRO:  ['SnakeCase', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
Natural  Qualified:  <class 'ldm.Literate_01.Natural'>
Natural  MRO:  ['Natural', 'PydanticMixin', 'object']
NormalCase  Qualified:  <class 'utils.class_casing.NormalCase'>
NormalCase  MRO:  ['NormalCase', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
OneLiner  Qualified:  <class 'ldm.Literate_01.OneLiner'>
OneLiner  MRO:  ['OneLiner', 'Natural', 'PydanticMixin', 'object']
Paragraph  Qualified:  <class 'ldm.Literate_01.Paragraph'>
Paragraph  MRO:  ['Paragraph', 'Natural', 'PydanticMixin', 'object']
PascalCase  Qualified:  <class 'utils.class_casing.PascalCase'>
PascalCase  MRO:  ['PascalCase', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
PomTemplate  Qualified:  <class 'utils.class_templates.PomTemplate'>
PomTemplate  MRO:  ['PomTemplate', 'object']
PresentableBoolean  Qualified:  <class 'utils.class_pom_token.PresentableBoolean'>
PresentableBoolean  MRO:  ['PresentableBoolean', 'PresentableToken', 'PydanticMixin', 'object']
PresentableToken  Qualified:  <class 'utils.class_pom_token.PresentableToken'>
PresentableToken  MRO:  ['PresentableToken', 'PydanticMixin', 'object']
PydanticMixin  Qualified:  <class 'utils.util_pydantic.PydanticMixin'>
PydanticMixin  MRO:  ['PydanticMixin', 'object']
ReferenceType  Qualified:  <class 'ldm.Literate_01.ReferenceType'>
ReferenceType  MRO:  ['ReferenceType', 'Class', 'Component', 'MinorComponent', 'PydanticMixin', 'object']
SetDataType  Qualified:  <class 'ldm.Literate_01.SetDataType'>
SetDataType  MRO:  ['SetDataType', 'DataType', 'PydanticMixin', 'object']
SnakeCase  Qualified:  <class 'utils.class_casing.SnakeCase'>
SnakeCase  MRO:  ['SnakeCase', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
SubjectB  Qualified:  <class 'ldm.Literate_01.SubjectB'>
SubjectB  MRO:  ['SubjectB', 'SubjectC', 'SubjectD', 'SubjectE', 'Component', 'MinorComponent', 'PydanticMixin', 'object']
SubjectB  Qualified:  <class 'ldm.Literate_01.SubjectB'>
SubjectB  MRO:  ['SubjectB', 'SubjectC', 'SubjectD', 'SubjectE', 'Component', 'MinorComponent', 'PydanticMixin', 'object']
SubjectC  Qualified:  <class 'ldm.Literate_01.SubjectC'>
SubjectC  MRO:  ['SubjectC', 'SubjectD', 'SubjectE', 'Component', 'MinorComponent', 'PydanticMixin', 'object']
SubjectD  Qualified:  <class 'ldm.Literate_01.SubjectD'>
SubjectD  MRO:  ['SubjectD', 'SubjectE', 'Component', 'MinorComponent', 'PydanticMixin', 'object']
SubjectE  Qualified:  <class 'ldm.Literate_01.SubjectE'>
SubjectE  MRO:  ['SubjectE', 'Component', 'MinorComponent', 'PydanticMixin', 'object']
SubjectName  Qualified:  <class 'ldm.Literate_01.SubjectName'>
SubjectName  MRO:  ['SubjectName', 'NormalCase', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
SubtypeBy  Qualified:  <class 'ldm.Literate_01.SubtypeBy'>
SubtypeBy  MRO:  ['SubtypeBy', 'PydanticMixin', 'object']
Subtyping  Qualified:  <class 'ldm.Literate_01.Subtyping'>
Subtyping  MRO:  ['Subtyping', 'PydanticMixin', 'object']
SubtypingName  Qualified:  <class 'ldm.Literate_01.SubtypingName'>
SubtypingName  MRO:  ['SubtypingName', 'LowerCamel', 'CamelCase', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
UpperSnake  Qualified:  <class 'utils.class_casing.UpperSnake'>
UpperSnake  MRO:  ['UpperSnake', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
TrainCase  Qualified:  <class 'utils.class_casing.TrainCase'>
TrainCase  MRO:  ['TrainCase', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
UpperSnake  Qualified:  <class 'utils.class_casing.UpperSnake'>
UpperSnake  MRO:  ['UpperSnake', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
UpperCamel  Qualified:  <class 'utils.class_casing.UpperCamel'>
UpperCamel  MRO:  ['UpperCamel', 'CamelCase', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
UpperCamel  Qualified:  <class 'utils.class_casing.UpperCamel'>
UpperCamel  MRO:  ['UpperCamel', 'CamelCase', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
UpperSnake  Qualified:  <class 'utils.class_casing.UpperSnake'>
UpperSnake  MRO:  ['UpperSnake', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
ValueType  Qualified:  <class 'ldm.Literate_01.ValueType'>
ValueType  MRO:  ['ValueType', 'Class', 'Component', 'MinorComponent', 'PydanticMixin', 'object']
DotCase  Qualified:  <class 'utils.class_casing.DotCase'>
DotCase  MRO:  ['DotCase', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
Kebab  Qualified:  <class 'utils.class_casing.Kebab'>
Kebab  MRO:  ['Kebab', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
LowerCamel  Qualified:  <class 'utils.class_casing.LowerCamel'>
LowerCamel  MRO:  ['LowerCamel', 'CamelCase', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
PascalCase  Qualified:  <class 'utils.class_casing.PascalCase'>
PascalCase  MRO:  ['PascalCase', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
SnakeCase  Qualified:  <class 'utils.class_casing.SnakeCase'>
SnakeCase  MRO:  ['SnakeCase', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
TrainCase  Qualified:  <class 'utils.class_casing.TrainCase'>
TrainCase  MRO:  ['TrainCase', 'Casing', 'PresentableToken', 'PydanticMixin', 'object']
as yaml - warnings =  False

Phase: Parsing model: ldm/ldm_models/Literate/Literate.md
PARSING ldm/ldm_models/Literate/Literate.md

Phase: Deriving dict from parse => {yaml_dict_file}
DerivingDict for Part:  Document
DerivingDict for Part:  LiterateModel
Full header:  # Literate Data Model

handlers:  ParseHeader()


===
ParsingHeader header: # Literate Data Model

PARSED AS INPUT LINE  {'line_type': 'LiterateModel', 'prefix': '#', 'rest_of_line': 'Literate Data Model'}
Header dict is:  {'prefix': '#', 'name': SubjectName(content='Literate Data Model', _type='SubjectName'), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  SubjectB
Full header:  ## Preliminaries - the basic structure of the model

handlers:  ParseHeader()


===
ParsingHeader header: ## Preliminaries - the basic structure of the model

PARSED AS INPUT LINE  {'line_type': 'Section2', 'prefix': '##', 'rest_of_line': 'Preliminaries - the basic structure of the model'}
Header dict is:  {'prefix': '##', 'name': SubjectName(content='Preliminaries', _type='SubjectName'), 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure of the model'}, 'parenthetical': ''}
DerivingDict for Part:  Class
Full header:  _ **Component** - An element or building block of the literate data model

handlers:  ParseHeader()


===
ParsingHeader header: _ **Component** - An element or building block of the literate data model

PARSED AS INPUT LINE  {'line_type': 'Class', 'prefix': '_', 'rest_of_line': '**Component** - An element or building block of the literate data model'}
Header dict is:  {'prefix': '_', 'name': ClassName(content='Component', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': ''}
DerivingDict for Part:  Attribute
Full header:  - **normalName** - the name of the component, not in camel case (*String*)

handlers:  ParseHeader()


===
ParsingHeader header: - **normalName** - the name of the component, not in camel case (*String*)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**normalName** - the name of the component, not in camel case (*String*)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='normalName', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'String'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Annotation
Parsing annotation:  ⚠️ Warning: This is a warning with emoji

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': '⚠️ Warning', 'value': 'This is a warning with emoji'}
trimmed label is  Warning
emojis are:  [{'match_start': 0, 'match_end': 2, 'emoji': '⚠️'}]
Final annoation dict is:  {'emoji': '', 'label': Label(content='warning', _type='Label'), 'content': OneLiner(content='This is a warning with emoji')}
DerivingDict for Part:  Attribute
Full header:  - **name** - The name of the component (CamelName)

handlers:  ParseHeader()


===
ParsingHeader header: - **name** - The name of the component (CamelName)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**name** - The name of the component (CamelName)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='name', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'CamelName'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **qualifiedName** - (*QualifiedCamel*)

handlers:  ParseHeader()


===
ParsingHeader header: - **qualifiedName** - (*QualifiedCamel*)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**qualifiedName** - (*QualifiedCamel*)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='qualifiedName', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'QualifiedCamel'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **abbreviatedName** - a short form of the component's name, used for cross references and improved readability. (*CamelName*)

handlers:  ParseHeader()


===
ParsingHeader header: - **abbreviatedName** - a short form of the component's name, used for cross references and improved readability. (*CamelName*)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': "**abbreviatedName** - a short form of the component's name, used for cross references and improved readability. (*CamelName*)"}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='abbreviatedName', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'CamelName'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Annotation
Parsing annotation:  ***Example***: "LDM" is the short form of "Literate Data Model".

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Example', 'value': '"LDM" is the short form of "Literate Data Model".'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='example', _type='Label'), 'content': OneLiner(content='"LDM" is the short form of "Literate Data Model".')}
DerivingDict for Part:  Default
Dict for Formula {'_type': 'Default', 'one_liner': OneLiner(content=' name -  how do you say name in english?\n')}
DerivingDict for Part:  Constraint
Dict for Formula {'_type': 'Constraint', 'one_liner': [OneLiner(content=' the abbreviated name should be shorter than the actual name\n')]}
DerivingDict for Part:  Annotation
Parsing annotation:  Note: Does this annotation find it's way to the Constraint? YES! It's fixed!

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': "Does this annotation find it's way to the Constraint? YES! It's fixed!"}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content="Does this annotation find it's way to the Constraint? YES! It's fixed!")}
DerivingDict for Part:  Attribute
Full header:  - **oneLiner** - A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _(OneLiner)_

handlers:  ParseHeader()


===
ParsingHeader header: - **oneLiner** - A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _(OneLiner)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**oneLiner** - A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _(OneLiner)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='oneLiner', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'OneLiner', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'OneLiner'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **elaboration** - A more detailed explanation or discussion of the component _(RichText)_

handlers:  ParseHeader()


===
ParsingHeader header: - **elaboration** - A more detailed explanation or discussion of the component _(RichText)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**elaboration** - A more detailed explanation or discussion of the component _(RichText)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='elaboration', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'RichText'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  AttributeSection
Full header:  __  ***For Machinery*** - mechanical attributes

handlers:  ParseHeader()


===
ParsingHeader header: __  ***For Machinery*** - mechanical attributes

PARSED AS INPUT LINE  {'line_type': 'AttributeSection', 'prefix': '__', 'rest_of_line': '***For Machinery*** - mechanical attributes'}
Header dict is:  {'prefix': '__', 'name': AttributeSectionName(content='For Machinery', _type='AttributeSectionName'), 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': ''}
DerivingDict for Part:  Attribute
Full header:  - **isEmbellishment** - Indicates whether this component is an embellishment added during post-parsing processing _(Boolean)_

handlers:  ParseHeader()


===
ParsingHeader header: - **isEmbellishment** - Indicates whether this component is an embellishment added during post-parsing processing _(Boolean)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**isEmbellishment** - Indicates whether this component is an embellishment added during post-parsing processing _(Boolean)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='isEmbellishment', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Boolean'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Default
Dict for Formula {'_type': 'Default', 'one_liner': OneLiner(content=' false\n')}
DerivingDict for Part:  Annotation
Parsing annotation:  ℹ️ ***Note***: This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'ℹ️ Note', 'value': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}
trimmed label is  Note
emojis are:  [{'match_start': 0, 'match_end': 2, 'emoji': 'ℹ️'}]
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.')}
DerivingDict for Part:  Class
Full header:  _ **AnnotationType** - a kind of note, or aside, used to call attention to additional information about some Component.

handlers:  ParseHeader()


===
ParsingHeader header: _ **AnnotationType** - a kind of note, or aside, used to call attention to additional information about some Component.

PARSED AS INPUT LINE  {'line_type': 'Class', 'prefix': '_', 'rest_of_line': '**AnnotationType** - a kind of note, or aside, used to call attention to additional information about some Component.'}
Header dict is:  {'prefix': '_', 'name': ClassName(content='AnnotationType', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': ''}
ParseNameList returning:  [ClassReference(content='LiterateDataModel', _type='ClassReference')]
Using ATT_NAME  based_on for based on
Adding value in ddforpart. based_on -. [ClassReference(content='LiterateDataModel', _type='ClassReference')]
DerivingDict for Part:  Annotation
Parsing annotation:  ***Note***: Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.
But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.
Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.')}
DerivingDict for Part:  Attribute
Full header:  - **emoji** - an emoji (Emoji)

handlers:  ParseHeader()


===
ParsingHeader header: - **emoji** - an emoji (Emoji)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**emoji** - an emoji (Emoji)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='emoji', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Emoji'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **emojiName** - an emoji (String)

handlers:  ParseHeader()


===
ParsingHeader header: - **emojiName** - an emoji (String)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**emojiName** - an emoji (String)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='emojiName', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'String'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **emojiUnicode** - the Unicode for the emoji (Unicode)

handlers:  ParseHeader()


===
ParsingHeader header: - **emojiUnicode** - the Unicode for the emoji (Unicode)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**emojiUnicode** - the Unicode for the emoji (Unicode)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='emojiUnicode', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Unicode'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **label** - A short label to indicate the purpose of the annotation _(CamelName)_

handlers:  ParseHeader()


===
ParsingHeader header: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**label** - A short label to indicate the purpose of the annotation _(CamelName)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='label', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'CamelName'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **plural** - the plural form of the label (*UpperCamel*).

handlers:  ParseHeader()


===
ParsingHeader header: - **plural** - the plural form of the label (*UpperCamel*).

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**plural** - the plural form of the label (*UpperCamel*).'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='plural', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'UpperCamel'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Default
Dict for Formula {'_type': 'Default', 'one_liner': OneLiner(content=' based on label\n')}
DerivingDict for Part:  Attribute
Full header:  - **Purpose** - the intended reason for the annotation. (OneLiner)

handlers:  ParseHeader()


===
ParsingHeader header: - **Purpose** - the intended reason for the annotation. (OneLiner)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**Purpose** - the intended reason for the annotation. (OneLiner)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='purpose', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': 'OneLiner', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'OneLiner'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Class
Full header:  _ **Annotation**  - A note or comment associated with a model element

handlers:  ParseHeader()


===
ParsingHeader header: _ **Annotation**  - A note or comment associated with a model element

PARSED AS INPUT LINE  {'line_type': 'Class', 'prefix': '_', 'rest_of_line': '**Annotation**  - A note or comment associated with a model element'}
Header dict is:  {'prefix': '_', 'name': ClassName(content='Annotation', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'A note or comment associated with a model element'}, 'parenthetical': ''}
ParseNameList returning:  [ClassReference(content='Component', _type='ClassReference')]
Using ATT_NAME  based_on for based on
Adding value in ddforpart. based_on -. [ClassReference(content='Component', _type='ClassReference')]
DerivingDict for Part:  Attribute
Full header:  - **annotationType** - (optional Annotation Type)

handlers:  ParseHeader()


===
ParsingHeader header: - **annotationType** - (optional Annotation Type)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**annotationType** - (optional Annotation Type)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='annotationType', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'AnnotationType'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': True}, 'cardinality': None}}
DerivingDict for Part:  Annotation
Parsing annotation:  Note: An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.')}
DerivingDict for Part:  Annotation
Parsing annotation:  Note: Should be a Value  Type

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'Should be a Value  Type'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='Should be a Value  Type')}
DerivingDict for Part:  Attribute
Full header:  - **label** - A short label to indicate the purpose of the annotation _(CamelName)_

handlers:  ParseHeader()


===
ParsingHeader header: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**label** - A short label to indicate the purpose of the annotation _(CamelName)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='label', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'CamelName'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Default
Dict for Formula {'_type': 'Default', 'one_liner': OneLiner(content=' from annotationType\n')}
DerivingDict for Part:  Attribute
Full header:  - **Emoji** - (optional Emoji)

handlers:  ParseHeader()


===
ParsingHeader header: - **Emoji** - (optional Emoji)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**Emoji** - (optional Emoji)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='emoji', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'optional Emoji', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Emoji'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': True}, 'cardinality': None}}
DerivingDict for Part:  Default
Dict for Formula {'_type': 'Default', 'one_liner': OneLiner(content=' from annotation type\n')}
DerivingDict for Part:  Attribute
Full header:  - **content** - The content or body of the annotation (*RichText*)​​​​​​​

handlers:  ParseHeader()


===
ParsingHeader header: - **content** - The content or body of the annotation (*RichText*)​​​​​​​

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**content** - The content or body of the annotation (*RichText*)\u200b\u200b\u200b\u200b\u200b\u200b\u200b'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='content', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'RichText'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  AttributeSection
Full header:  __***For Machinery***

handlers:  ParseHeader()


===
ParsingHeader header: __***For Machinery***

PARSED AS INPUT LINE  {'line_type': 'AttributeSection', 'prefix': '__', 'rest_of_line': '***For Machinery***'}
Header dict is:  {'prefix': '__', 'name': AttributeSectionName(content='For Machinery', _type='AttributeSectionName'), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  Attribute
Full header:  - **isEmbellishment** - Indicates whether this annotation is an embellishment added during post-parsing processing _(Boolean)_

handlers:  ParseHeader()


===
ParsingHeader header: - **isEmbellishment** - Indicates whether this annotation is an embellishment added during post-parsing processing _(Boolean)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**isEmbellishment** - Indicates whether this annotation is an embellishment added during post-parsing processing _(Boolean)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='isEmbellishment', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Boolean'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Default
Dict for Formula {'_type': 'Default', 'one_liner': OneLiner(content=' false\n')}
DerivingDict for Part:  Annotation
Parsing annotation:  ℹ️ ***Note***: This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'ℹ️ Note', 'value': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}
trimmed label is  Note
emojis are:  [{'match_start': 0, 'match_end': 2, 'emoji': 'ℹ️'}]
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.')}
DerivingDict for Part:  SubjectB
Full header:  ## The Model and its Subjects

handlers:  ParseHeader()


===
ParsingHeader header: ## The Model and its Subjects

PARSED AS INPUT LINE  {'line_type': 'Section2', 'prefix': '##', 'rest_of_line': 'The Model and its Subjects'}
Header dict is:  {'prefix': '##', 'name': SubjectName(content='The Model and its Subjects', _type='SubjectName'), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  Class
Full header:  _ **LiterateDataModel** - A representation of a domain's entities, attributes, and relationships,
along with explanatory text and examples
handlers:  ParseHeader()


===
ParsingHeader header: _ **LiterateDataModel** - A representation of a domain's entities, attributes, and relationships,
along with explanatory text and examples
PARSED AS INPUT LINE  {'line_type': 'Class', 'prefix': '_', 'rest_of_line': "**LiterateDataModel** - A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}
Header dict is:  {'prefix': '_', 'name': ClassName(content='LiterateDataModel', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': ''}
parsing subtypeOfs:   Component

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
DerivingDict for Part:  Attribute
Full header:  - name (UpperCamel )

handlers:  ParseHeader()


===
ParsingHeader header: - name (UpperCamel )

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': 'name (UpperCamel )'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='name', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'UpperCamel', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'UpperCamel'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - allSubjects - list of all classes in the model, as ordered in the
definition of the model. (List of Classes)
handlers:  ParseHeader()


===
ParsingHeader header: - allSubjects - list of all classes in the model, as ordered in the
definition of the model. (List of Classes)
PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': 'allSubjects - list of all classes in the model, as ordered in the\ndefinition of the model. (List of Classes)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='allSubjects', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Classes'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Derivation
Dict for Formula {'_type': 'Derivation', 'one_liner': OneLiner(content=' gathering s.allSubjects over s in subjectAreas\n')}
DerivingDict for Part:  Constraint
Dict for Formula {'_type': 'Constraint', 'one_liner': [OneLiner(content=' Subject names must be unique across the model.\n')]}
DerivingDict for Part:  Attribute
Full header:  - allClasses - list of all classes in the model, as ordered in the definition of the model. (List of Classes)

handlers:  ParseHeader()


===
ParsingHeader header: - allClasses - list of all classes in the model, as ordered in the definition of the model. (List of Classes)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': 'allClasses - list of all classes in the model, as ordered in the definition of the model. (List of Classes)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='allClasses', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Classes'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Derivation
Dict for Formula {'_type': 'Derivation', 'one_liner': OneLiner(content=' gathering s.allClasses over s in allSubjects.\n')}
DerivingDict for Part:  Constraint
Dict for Formula {'_type': 'Constraint', 'one_liner': [OneLiner(content=' Class names must be unique across the model.\n')]}
DerivingDict for Part:  AttributeSection
Full header:  __ 	***Modeling Configuration***

handlers:  ParseHeader()


===
ParsingHeader header: __ 	***Modeling Configuration***

PARSED AS INPUT LINE  {'line_type': 'AttributeSection', 'prefix': '__', 'rest_of_line': '***Modeling Configuration***'}
Header dict is:  {'prefix': '__', 'name': AttributeSectionName(content='Modeling Configuration', _type='AttributeSectionName'), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  Attribute
Full header:  - **annotationTypes** - (List of AnnotationTypes)

handlers:  ParseHeader()


===
ParsingHeader header: - **annotationTypes** - (List of AnnotationTypes)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**annotationTypes** - (List of AnnotationTypes)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='annotationTypes', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'AnnotationTypes'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **Preferred Coding Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Coding Language).

handlers:  ParseHeader()


===
ParsingHeader header: - **Preferred Coding Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Coding Language).

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**Preferred Coding Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Coding Language).'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='preferredCodingLanguage', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'CodingLanguage'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Default
Dict for Formula {'_type': 'Default', 'one_liner': OneLiner(content=' OCL\n')}
DerivingDict for Part:  Attribute
Full header:  - **alternate Coding Languages** -  (optional List of Coding Languages).

handlers:  ParseHeader()


===
ParsingHeader header: - **alternate Coding Languages** -  (optional List of Coding Languages).

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**alternate Coding Languages** -  (optional List of Coding Languages).'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='alternateCodingLanguages', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'CodingLanguages'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': True}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **Preferred Template Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Template Language).

handlers:  ParseHeader()


===
ParsingHeader header: - **Preferred Template Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Template Language).

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**Preferred Template Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Template Language).'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='preferredTemplateLanguage', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'TemplateLanguage'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Default
Dict for Formula {'_type': 'Default', 'one_liner': OneLiner(content=' Handlebars\n')}
DerivingDict for Part:  Attribute
Full header:  - **alternate Template Languages** -  (optional List of Template Languages).

handlers:  ParseHeader()


===
ParsingHeader header: - **alternate Template Languages** -  (optional List of Template Languages).

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**alternate Template Languages** -  (optional List of Template Languages).'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='alternateTemplateLanguages', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'TemplateLanguages'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': True}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **aiFunctions** - A list of functions that require sophisticated AI-powered implementation *(List of String)*

handlers:  ParseHeader()


===
ParsingHeader header: - **aiFunctions** - A list of functions that require sophisticated AI-powered implementation *(List of String)*

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**aiFunctions** - A list of functions that require sophisticated AI-powered implementation *(List of String)*'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='aiFunctions', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'String'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Derivation
Dict for Formula {'_type': 'Derivation', 'one_liner': OneLiner(content=" ['aiEnglishPlural()']\n")}
DerivingDict for Part:  Class
Full header:  _ **Subject**  - A specific topic or theme within the model

handlers:  ParseHeader()


===
ParsingHeader header: _ **Subject**  - A specific topic or theme within the model

PARSED AS INPUT LINE  {'line_type': 'Class', 'prefix': '_', 'rest_of_line': '**Subject**  - A specific topic or theme within the model'}
Header dict is:  {'prefix': '_', 'name': ClassName(content='Subject', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'A specific topic or theme within the model'}, 'parenthetical': ''}
parsing subtypeOfs:   Component

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
ParseNameList returning:  [ClassReference(content='LiterateDataModel', _type='ClassReference')]
Using ATT_NAME  based_on for based on
Adding value in ddforpart. based_on -. [ClassReference(content='LiterateDataModel', _type='ClassReference')]
DerivingDict for Part:  Attribute
Full header:  - name (UpperCamel )

handlers:  ParseHeader()


===
ParsingHeader header: - name (UpperCamel )

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': 'name (UpperCamel )'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='name', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'UpperCamel', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'UpperCamel'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **parentSubject** - The parent subject, if any, under which this subject is nested _(optional Subject)_

handlers:  ParseHeader()


===
ParsingHeader header: - **parentSubject** - The parent subject, if any, under which this subject is nested _(optional Subject)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**parentSubject** - The parent subject, if any, under which this subject is nested _(optional Subject)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='parentSubject', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Subject'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': True}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **Classes** - The major classes related to this subject, in the order in which they should be presented _(ListOf Classes)_

handlers:  ParseHeader()


===
ParsingHeader header: - **Classes** - The major classes related to this subject, in the order in which they should be presented _(ListOf Classes)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**Classes** - The major classes related to this subject, in the order in which they should be presented _(ListOf Classes)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='classes', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Classes'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Annotation
Parsing annotation:  ***Issue***: define chapter, section, subsection as levels?
***DSL***: Generally, it is best to present the classes within a Subject in top down order...
* Each Class should be followed first by the classes that are dependent on it, and then
* By its subtype classes.
Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Issue', 'value': 'define chapter, section, subsection as levels?'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='issue', _type='Label'), 'content': OneLiner(content='define chapter, section, subsection as levels?')}
DerivingDict for Part:  Attribute
Full header:  - **childSubjects** - Any child subjects nested under this subject, in the order in which they should be presented _(ListOf Subjects)_

handlers:  ParseHeader()


===
ParsingHeader header: - **childSubjects** - Any child subjects nested under this subject, in the order in which they should be presented _(ListOf Subjects)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**childSubjects** - Any child subjects nested under this subject, in the order in which they should be presented _(ListOf Subjects)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='childSubjects', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Subjects'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Class
Full header:  _ **SubjectArea**  - A main topic or area of focus within the model, containing related subjects and classes

handlers:  ParseHeader()


===
ParsingHeader header: _ **SubjectArea**  - A main topic or area of focus within the model, containing related subjects and classes

PARSED AS INPUT LINE  {'line_type': 'Class', 'prefix': '_', 'rest_of_line': '**SubjectArea**  - A main topic or area of focus within the model, containing related subjects and classes'}
Header dict is:  {'prefix': '_', 'name': ClassName(content='SubjectArea', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'A main topic or area of focus within the model, containing related subjects and classes'}, 'parenthetical': ''}
parsing subtypeOfs:   Subject

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Subject', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Subject', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
ParseNameList returning:  [ClassReference(content='LiterateModel', _type='ClassReference'), ClassReference(content='Xyz', _type='ClassReference')]
Using ATT_NAME  based_on for based on
Adding value in ddforpart. based_on -. [ClassReference(content='LiterateModel', _type='ClassReference'), ClassReference(content='Xyz', _type='ClassReference')]
DerivingDict for Part:  SubjectC
Full header:  ### Classes

handlers:  ParseHeader()


===
ParsingHeader header: ### Classes

PARSED AS INPUT LINE  {'line_type': 'Section3', 'prefix': '###', 'rest_of_line': 'Classes'}
Header dict is:  {'prefix': '###', 'name': SubjectName(content='Classes', _type='SubjectName'), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  Class
Full header:  _ **Class** - A key entity or object type in the model, often corresponding to a real-world concept

handlers:  ParseHeader()


===
ParsingHeader header: _ **Class** - A key entity or object type in the model, often corresponding to a real-world concept

PARSED AS INPUT LINE  {'line_type': 'Class', 'prefix': '_', 'rest_of_line': '**Class** - A key entity or object type in the model, often corresponding to a real-world concept'}
Header dict is:  {'prefix': '_', 'name': ClassName(content='Class', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': ''}
parsing subtypeOfs:   Component

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
DerivingDict for Part:  Constraint
Dict for Formula {'_type': 'Constraint', 'one_liner': [OneLiner(content=' Within each Class, attribute names must be unique.\n')]}
DerivingDict for Part:  Attribute
Full header:  - **pluralForm** - the normal English plural form of the name of the Class (UpperName)

handlers:  ParseHeader()


===
ParsingHeader header: - **pluralForm** - the normal English plural form of the name of the Class (UpperName)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**pluralForm** - the normal English plural form of the name of the Class (UpperName)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='pluralForm', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'UpperName'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Annotation
Parsing annotation:  Note: When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.')}
DerivingDict for Part:  Default
Dict for Formula {'_type': 'Default', 'one_liner': OneLiner(content=' the regular plural, formed by adding "s" or "es".\n')}
DerivingDict for Part:  Attribute
Full header:  - **basedOn** - the Class or Classes on which this class is dependent (SetOf Classes).

handlers:  ParseHeader()


===
ParsingHeader header: - **basedOn** - the Class or Classes on which this class is dependent (SetOf Classes).

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**basedOn** - the Class or Classes on which this class is dependent (SetOf Classes).'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='basedOn', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Classes'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Annotation
Parsing annotation:  Note: that basedOn and dependentOf are being used synonymousle in this metamodel.
ToDo - fix that
Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='that basedOn and dependentOf are being used synonymousle in this metamodel.')}
DerivingDict for Part:  Attribute
Full header:  - **supertypes** - The parent class(es) from which this class inherits attributes _(ListOf Classes)_

handlers:  ParseHeader()


===
ParsingHeader header: - **supertypes** - The parent class(es) from which this class inherits attributes _(ListOf Classes)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**supertypes** - The parent class(es) from which this class inherits attributes _(ListOf Classes)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='supertypes', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Es'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **subtypings** - the criteria, or dimensions, by which the class can be divided into subtypes (list of Subtypings).

handlers:  ParseHeader()


===
ParsingHeader header: - **subtypings** - the criteria, or dimensions, by which the class can be divided into subtypes (list of Subtypings).

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**subtypings** - the criteria, or dimensions, by which the class can be divided into subtypes (list of Subtypings).'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='subtypings', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Subtypings'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Annotation
Parsing annotation:  Example: in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Example', 'value': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='example', _type='Label'), 'content': OneLiner(content='in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).')}
DerivingDict for Part:  Attribute
Full header:  - **subtypes** - Any subtypes or specializations of this class based on it’s subtypings. _(ListOf Classes)_

handlers:  ParseHeader()


===
ParsingHeader header: - **subtypes** - Any subtypes or specializations of this class based on it’s subtypings. _(ListOf Classes)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**subtypes** - Any subtypes or specializations of this class based on it’s subtypings. _(ListOf Classes)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='subtypes', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Classes'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Annotation
Parsing annotation:  Example: For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Example', 'value': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='example', _type='Label'), 'content': OneLiner(content='For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.')}
DerivingDict for Part:  Attribute
Full header:  - **attributes** - The attributes or properties of the class, in the order in which they should be presented _(ListOf Attributes)_

handlers:  ParseHeader()


===
ParsingHeader header: - **attributes** - The attributes or properties of the class, in the order in which they should be presented _(ListOf Attributes)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**attributes** - The attributes or properties of the class, in the order in which they should be presented _(ListOf Attributes)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='attributes', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Attributes'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **attributeSections** - additional attributes or properties of the class, grouped for clarity and elaboration.  _(ListOf AttributeSections)_

handlers:  ParseHeader()


===
ParsingHeader header: - **attributeSections** - additional attributes or properties of the class, grouped for clarity and elaboration.  _(ListOf AttributeSections)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**attributeSections** - additional attributes or properties of the class, grouped for clarity and elaboration.  _(ListOf AttributeSections)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='attributeSections', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'AttributeSections'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **constraints** - Any constraints, rules, or validations specific to this class _(ListOf Constraints)_

handlers:  ParseHeader()


===
ParsingHeader header: - **constraints** - Any constraints, rules, or validations specific to this class _(ListOf Constraints)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**constraints** - Any constraints, rules, or validations specific to this class _(ListOf Constraints)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='constraints', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Constraints'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Annotation
Parsing annotation:  Note: Constraints may be expressed on either the Class or the Attribute. Always?
Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.
Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'Constraints may be expressed on either the Class or the Attribute. Always?'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='Constraints may be expressed on either the Class or the Attribute. Always?')}
DerivingDict for Part:  Attribute
Full header:  - **methods** - Any behaviors or operations associated with this class _(ListOf Methods)_

handlers:  ParseHeader()


===
ParsingHeader header: - **methods** - Any behaviors or operations associated with this class _(ListOf Methods)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**methods** - Any behaviors or operations associated with this class _(ListOf Methods)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='methods', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Methods'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  AttributeSection
Full header:  __  ***Implied Attributes***

handlers:  ParseHeader()


===
ParsingHeader header: __  ***Implied Attributes***

PARSED AS INPUT LINE  {'line_type': 'AttributeSection', 'prefix': '__', 'rest_of_line': '***Implied Attributes***'}
Header dict is:  {'prefix': '__', 'name': AttributeSectionName(content='Implied Attributes', _type='AttributeSectionName'), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  Attribute
Full header:  - **dependents** - the Classes which are basedOn this Class (optional SetOf Classes).

handlers:  ParseHeader()


===
ParsingHeader header: - **dependents** - the Classes which are basedOn this Class (optional SetOf Classes).

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**dependents** - the Classes which are basedOn this Class (optional SetOf Classes).'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='dependents', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Classes'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': True}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - UniqueKeys - (optional Set of UniqueKeys).

handlers:  ParseHeader()


===
ParsingHeader header: - UniqueKeys - (optional Set of UniqueKeys).

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': 'UniqueKeys - (optional Set of UniqueKeys).'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='uniqueKeys', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'UniqueKeys'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': True}, 'cardinality': None}}
DerivingDict for Part:  Class
Full header:  _ **Subtyping** - a way in which subtypes of a Class may be classified (Subtype of Component).

handlers:  ParseHeader()


===
ParsingHeader header: _ **Subtyping** - a way in which subtypes of a Class may be classified (Subtype of Component).

PARSED AS INPUT LINE  {'line_type': 'Class', 'prefix': '_', 'rest_of_line': '**Subtyping** - a way in which subtypes of a Class may be classified (Subtype of Component).'}
Header dict is:  {'prefix': '_', 'name': ClassName(content='Subtyping', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component'}
ParseNameList returning:  [ClassReference(content='Class', _type='ClassReference')]
Using ATT_NAME  based_on for based on
Adding value in ddforpart. based_on -. [ClassReference(content='Class', _type='ClassReference')]
DerivingDict for Part:  Attribute
Full header:  - **name** (Upper Name).
Usually ByThis or ByThat
handlers:  ParseHeader()


===
ParsingHeader header: - **name** (Upper Name).
Usually ByThis or ByThat
PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**name** (Upper Name).\nUsually ByThis or ByThat'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='name', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'Upper Name', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'UpperName'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **is exclusive** (Boolean).

handlers:  ParseHeader()


===
ParsingHeader header: - **is exclusive** (Boolean).

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**is exclusive** (Boolean).'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='isExclusive', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'Boolean', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Boolean'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Default
Dict for Formula {'_type': 'Default', 'one_liner': OneLiner(content=' true\n')}
DerivingDict for Part:  Attribute
Full header:  - **is exhaustive** (Boolean).

handlers:  ParseHeader()


===
ParsingHeader header: - **is exhaustive** (Boolean).

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**is exhaustive** (Boolean).'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='isExhaustive', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'Boolean', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Boolean'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Default
Dict for Formula {'_type': 'Default', 'one_liner': OneLiner(content=' true\n')}
DerivingDict for Part:  Attribute
Full header:  - **classes** (List of Classes).

handlers:  ParseHeader()


===
ParsingHeader header: - **classes** (List of Classes).

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**classes** (List of Classes).'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='classes', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'List of Classes', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Classes'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Annotation
Parsing annotation:  Note: every class can have an unnamed subtyping.
Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.
Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'every class can have an unnamed subtyping.'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='every class can have an unnamed subtyping.')}
parsing subtypeOfs:   Class

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Class', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Class', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
DerivingDict for Part:  Class
Full header:  _ **Reference Type** - A class that is presumed to be used as a reference, rather than a value

handlers:  ParseHeader()


===
ParsingHeader header: _ **Reference Type** - A class that is presumed to be used as a reference, rather than a value

PARSED AS INPUT LINE  {'line_type': 'Class', 'prefix': '_', 'rest_of_line': '**Reference Type** - A class that is presumed to be used as a reference, rather than a value'}
Header dict is:  {'prefix': '_', 'name': ClassName(content='ReferenceType', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'A class that is presumed to be used as a reference, rather than a value'}, 'parenthetical': ''}
parsing subtypeOfs:   Class

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Class', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Class', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
DerivingDict for Part:  ValueType
Full header:  ValueType:  **CodeType**   - A data type or enumeration used in the model

handlers:  ParseHeader()


===
ParsingHeader header: ValueType:  **CodeType**   - A data type or enumeration used in the model

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**CodeType**   - A data type or enumeration used in the model'}
raw name = CodeType, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='CodeType', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'A data type or enumeration used in the model'}, 'parenthetical': ''}
DerivingDict for Part:  Attribute
Full header:  - isCaptive - the code type was implied by use in an attribute and is only used for that attribute (Boolean)

handlers:  ParseHeader()


===
ParsingHeader header: - isCaptive - the code type was implied by use in an attribute and is only used for that attribute (Boolean)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': 'isCaptive - the code type was implied by use in an attribute and is only used for that attribute (Boolean)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='isCaptive', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Boolean'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType:  **CodeType**   - A data type or enumeration used in the model
. . Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ Attribute_Head: - isCaptive - the code type was implied by use in an attribute and is only used for that attribute (Boolean)

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='CodeType', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'A data type or enumeration used in the model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'_type': 'AttributeName', 'content': 'isCaptive', '_html_id': ''}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Boolean'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}}}]}
DerivingDict for Part:  ValueType
Full header:  ValueType:  **Code Value** - A possible value for an enumerated data class

handlers:  ParseHeader()


===
ParsingHeader header: ValueType:  **Code Value** - A possible value for an enumerated data class

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**Code Value** - A possible value for an enumerated data class'}
raw name = Code Value, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='CodeValue', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'A possible value for an enumerated data class'}, 'parenthetical': ''}
ParseNameList returning:  [ClassReference(content='CodeType', _type='ClassReference')]
Using ATT_NAME  based_on for based on
Adding value in ddforpart. based_on -. [ClassReference(content='CodeType', _type='ClassReference')]
DerivingDict for Part:  Attribute
Full header:  - **code** - A short code or abbreviationi for the value _(NameString)_

handlers:  ParseHeader()


===
ParsingHeader header: - **code** - A short code or abbreviationi for the value _(NameString)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**code** - A short code or abbreviationi for the value _(NameString)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='code', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'NameString'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **description** - an explanation of what the code means (*RichText*)

handlers:  ParseHeader()


===
ParsingHeader header: - **description** - an explanation of what the code means (*RichText*)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**description** - an explanation of what the code means (*RichText*)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='description', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'RichText'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Annotation
Parsing annotation:  Note: Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:
* List the code values as a bulletted list inside the description of the attribute in the form
‘**code**: description’
* A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.
Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content="Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:")}
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType:  **Code Value** - A possible value for an enumerated data class
_ _ BASED_ON: based on: CodeType
. . Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ Attribute_Head: - **code** - A short code or abbreviationi for the value _(NameString)_
. . Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ Attribute_Head: - **description** - an explanation of what the code means (*RichText*)
. . . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ _ NOTE: Note: Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:* List the code values as a bulletted list inside the description of the attribute in the form 
+ ‘**code**: description’ 
+ * A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='CodeValue', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'A possible value for an enumerated data class'}, 'parenthetical': '', 'based_on': [ClassReference(content='CodeType', _type='ClassReference')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'_type': 'AttributeName', 'content': 'code', '_html_id': ''}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'NameString'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'_type': 'AttributeName', 'content': 'description', '_html_id': ''}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'RichText'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': {'_type': 'Label', 'content': 'note'}, 'content': {'_type': 'OneLiner', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}}]}]}
DerivingDict for Part:  Class
Full header:  _ **Key** - a list of attributes of a class

handlers:  ParseHeader()


===
ParsingHeader header: _ **Key** - a list of attributes of a class

PARSED AS INPUT LINE  {'line_type': 'Class', 'prefix': '_', 'rest_of_line': '**Key** - a list of attributes of a class'}
Header dict is:  {'prefix': '_', 'name': ClassName(content='Key', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': ''}
parsing subtypeOfs:   Component

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
ParseNameList returning:  [ClassReference(content='Class', _type='ClassReference')]
Using ATT_NAME  based_on for based on
Adding value in ddforpart. based_on -. [ClassReference(content='Class', _type='ClassReference')]
DerivingDict for Part:  Attribute
Full header:  - keyAttributes - the attributes of the base Class. (List of Attributes ).

handlers:  ParseHeader()


===
ParsingHeader header: - keyAttributes - the attributes of the base Class. (List of Attributes ).

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': 'keyAttributes - the attributes of the base Class. (List of Attributes ).'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='keyAttributes', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Attributes'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Constraint
Dict for Formula {'_type': 'Constraint', 'one_liner': [OneLiner(content=' each attribute must be a direct or inherited of the base class.\n')]}
DerivingDict for Part:  Constraint
Dict for Formula {'_type': 'Constraint', 'one_liner': [OneLiner(content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}
DerivingDict for Part:  Annotation
Parsing annotation:  Issue: need ascending descending to support index keys or ordering keys.

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Issue', 'value': 'need ascending descending to support index keys or ordering keys.'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='issue', _type='Label'), 'content': OneLiner(content='need ascending descending to support index keys or ordering keys.')}
DerivingDict for Part:  Class
Full header:  _ **UniqueKey** - a list of attributes on which instances of the base class may be keyed.

handlers:  ParseHeader()


===
ParsingHeader header: _ **UniqueKey** - a list of attributes on which instances of the base class may be keyed.

PARSED AS INPUT LINE  {'line_type': 'Class', 'prefix': '_', 'rest_of_line': '**UniqueKey** - a list of attributes on which instances of the base class may be keyed.'}
Header dict is:  {'prefix': '_', 'name': ClassName(content='UniqueKey', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': ''}
parsing subtypeOfs:   Key

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Key', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Key', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
DerivingDict for Part:  Annotation
Parsing annotation:  Note: order unimportant for Unique Keys.

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'order unimportant for Unique Keys.'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='order unimportant for Unique Keys.')}
DerivingDict for Part:  SubjectB
Full header:  ## Attributes

handlers:  ParseHeader()


===
ParsingHeader header: ## Attributes

PARSED AS INPUT LINE  {'line_type': 'Section2', 'prefix': '##', 'rest_of_line': 'Attributes'}
Header dict is:  {'prefix': '##', 'name': SubjectName(content='Attributes', _type='SubjectName'), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  Class
Full header:  _ **Attribute Section** - a group of attributes for a class that merit a shared explanation.

handlers:  ParseHeader()


===
ParsingHeader header: _ **Attribute Section** - a group of attributes for a class that merit a shared explanation.

PARSED AS INPUT LINE  {'line_type': 'Class', 'prefix': '_', 'rest_of_line': '**Attribute Section** - a group of attributes for a class that merit a shared explanation.'}
Header dict is:  {'prefix': '_', 'name': ClassName(content='AttributeSection', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': ''}
parsing subtypeOfs:   Component.

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
ParseNameList returning:  [ClassReference(content='Class', _type='ClassReference')]
Using ATT_NAME  based_on for based on
Adding value in ddforpart. based_on -. [ClassReference(content='Class', _type='ClassReference')]
DerivingDict for Part:  Attribute
Full header:  -	isOptional - whether the attributes in this section, taken together, are optional. (Boolean)

handlers:  ParseHeader()


===
ParsingHeader header: -	isOptional - whether the attributes in this section, taken together, are optional. (Boolean)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': 'isOptional - whether the attributes in this section, taken together, are optional. (Boolean)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='isOptional', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Boolean'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Class
Full header:  _ **Attribute**  - A property or characteristic of a class

handlers:  ParseHeader()


===
ParsingHeader header: _ **Attribute**  - A property or characteristic of a class

PARSED AS INPUT LINE  {'line_type': 'Class', 'prefix': '_', 'rest_of_line': '**Attribute**  - A property or characteristic of a class'}
Header dict is:  {'prefix': '_', 'name': ClassName(content='Attribute', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'A property or characteristic of a class'}, 'parenthetical': ''}
parsing subtypeOfs:   Component

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
ParseNameList returning:  [ClassReference(content='AttributeSection', _type='ClassReference')]
Using ATT_NAME  based_on for based on
Adding value in ddforpart. based_on -. [ClassReference(content='AttributeSection', _type='ClassReference')]
DerivingDict for Part:  Attribute
Full header:  - **name** - (Lower Camel).

handlers:  ParseHeader()


===
ParsingHeader header: - **name** - (Lower Camel).

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**name** - (Lower Camel).'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='name', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'Lower Camel', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'LowerCamel'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **dataType** - The kind of object to which the attribute refers.  _(DataType)_
H
In the simplest cases, the data type will be a class. And the specifier is the just the name of that class.
handlers:  ParseHeader()


===
ParsingHeader header: - **dataType** - The kind of object to which the attribute refers.  _(DataType)_
H
In the simplest cases, the data type will be a class. And the specifier is the just the name of that class.
PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**dataType** - The kind of object to which the attribute refers.  _(DataType)_\nH\nIn the simplest cases, the data type will be a class. And the specifier is the just the name of that class.'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='dataType', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'DataType'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Annotation
Parsing annotation:  ***See***: the section below on Data Type Specifiers.

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'See', 'value': 'the section below on Data Type Specifiers.'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='see', _type='Label'), 'content': OneLiner(content='the section below on Data Type Specifiers.')}
DerivingDict for Part:  AttributeSection
Full header:  __ **Cardinalities**.

handlers:  ParseHeader()


===
ParsingHeader header: __ **Cardinalities**.

PARSED AS INPUT LINE  {'line_type': 'AttributeSection', 'prefix': '__', 'rest_of_line': '**Cardinalities**.'}
Header dict is:  {'prefix': '__', 'name': AttributeSectionName(content='Cardinalities', _type='AttributeSectionName'), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  Attribute
Full header:  - **isOptional** - Indicates whether the attribute must have a value for every instance of the class _(Boolean)_

handlers:  ParseHeader()


===
ParsingHeader header: - **isOptional** - Indicates whether the attribute must have a value for every instance of the class _(Boolean)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**isOptional** - Indicates whether the attribute must have a value for every instance of the class _(Boolean)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='isOptional', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Boolean'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Default
Dict for Formula {'_type': 'Default', 'one_liner': OneLiner(content='*** False\n')}
DerivingDict for Part:  Attribute
Full header:  - **cardinality** - The cardinality of the relationship represented by the attribute _(CardinalityCode)_

handlers:  ParseHeader()


===
ParsingHeader header: - **cardinality** - The cardinality of the relationship represented by the attribute _(CardinalityCode)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**cardinality** - The cardinality of the relationship represented by the attribute _(CardinalityCode)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='cardinality', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'CardinalityCode'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Default
Dict for Formula {'_type': 'Default', 'one_liner': OneLiner(content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.')}
DerivingDict for Part:  Annotation
Parsing annotation:  For example:

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'For example', 'value': ''}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='forExample', _type='Label'), 'content': OneLiner(content='')}
DerivingDict for Part:  Attribute
Full header:  - author (1:1 Author)

handlers:  ParseHeader()


===
ParsingHeader header: - author (1:1 Author)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': 'author (1:1 Author)'}
Inventing name for:  1:1 Author
Header dict is:  {'prefix': '-', 'name': AttributeName(content='author', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': '1:1 Author', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'InventedName'}, 'as_value_type': {'_type': 'AsValue', 'content': False}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - books (optional N:M Set of Books)

handlers:  ParseHeader()


===
ParsingHeader header: - books (optional N:M Set of Books)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': 'books (optional N:M Set of Books)'}
Inventing name for:  N:M Set of Books
Header dict is:  {'prefix': '-', 'name': AttributeName(content='books', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'InventedName'}, 'as_value_type': {'_type': 'AsValue', 'content': False}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': True}, 'cardinality': None}}
DerivingDict for Part:  Annotation
Parsing annotation:  ***Note***: how this works with optionality

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'how this works with optionality'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='how this works with optionality')}
DerivingDict for Part:  AttributeSection
Full header:  __  ***Inverse Attributes***

handlers:  ParseHeader()


===
ParsingHeader header: __  ***Inverse Attributes***

PARSED AS INPUT LINE  {'line_type': 'AttributeSection', 'prefix': '__', 'rest_of_line': '***Inverse Attributes***'}
Header dict is:  {'prefix': '__', 'name': AttributeSectionName(content='Inverse Attributes', _type='AttributeSectionName'), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  Attribute
Full header:  - **isInvertible** - (Boolean)

handlers:  ParseHeader()


===
ParsingHeader header: - **isInvertible** - (Boolean)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**isInvertible** - (Boolean)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='isInvertible', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'Boolean', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Boolean'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Derivation
Dict for Formula {'_type': 'Derivation', 'one_liner': OneLiner(content=' true if the data type is a class or a simple collection of members of a class.\n')}
DerivingDict for Part:  Attribute
Full header:  - **inverseClass** - the class which contains, or would contain the inverse attribute (optional Class)

handlers:  ParseHeader()


===
ParsingHeader header: - **inverseClass** - the class which contains, or would contain the inverse attribute (optional Class)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**inverseClass** - the class which contains, or would contain the inverse attribute (optional Class)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='inverseClass', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Class'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': True}, 'cardinality': None}}
DerivingDict for Part:  Derivation
Dict for Formula {'_type': 'Derivation', 'one_liner': OneLiner(content=' from the data type. Null unless arrribute is invertible.\n')}
DerivingDict for Part:  Attribute
Full header:  - **inverseAttribute** - (optional Attribute)

handlers:  ParseHeader()


===
ParsingHeader header: - **inverseAttribute** - (optional Attribute)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**inverseAttribute** - (optional Attribute)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='inverseAttribute', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'optional Attribute', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Attribute'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': True}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **inverseIsOptional** - (optional Attribute)

handlers:  ParseHeader()


===
ParsingHeader header: - **inverseIsOptional** - (optional Attribute)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**inverseIsOptional** - (optional Attribute)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='inverseIsOptional', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'optional Attribute', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Attribute'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': True}, 'cardinality': None}}
DerivingDict for Part:  AttributeSection
Full header:  __ ***Formulas***

handlers:  ParseHeader()


===
ParsingHeader header: __ ***Formulas***

PARSED AS INPUT LINE  {'line_type': 'AttributeSection', 'prefix': '__', 'rest_of_line': '***Formulas***'}
Header dict is:  {'prefix': '__', 'name': AttributeSectionName(content='Formulas', _type='AttributeSectionName'), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  Attribute
Full header:  - **default** - The rule or formula for calculating the value, if no value is supplied
Now running to a second line with the parenthentical on yet a third line
(optional Derivation)
handlers:  ParseHeader()


===
ParsingHeader header: - **default** - The rule or formula for calculating the value, if no value is supplied
Now running to a second line with the parenthentical on yet a third line
(optional Derivation)
PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**default** - The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line\n(optional Derivation)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='default', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Derivation'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': True}, 'cardinality': None}}
DerivingDict for Part:  Annotation
Parsing annotation:  Note: even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.
And let's see if the note can span extra lines, too
Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.')}
DerivingDict for Part:  Attribute
Full header:  - **derivation** - For derived attributes, the rule or formula for calculating the value _(optional Derivation)_

handlers:  ParseHeader()


===
ParsingHeader header: - **derivation** - For derived attributes, the rule or formula for calculating the value _(optional Derivation)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**derivation** - For derived attributes, the rule or formula for calculating the value _(optional Derivation)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='derivation', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Derivation'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': True}, 'cardinality': None}}
DerivingDict for Part:  Annotation
Parsing annotation:  ***Issue***: on insert vs on access?

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Issue', 'value': 'on insert vs on access?'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='issue', _type='Label'), 'content': OneLiner(content='on insert vs on access?')}
DerivingDict for Part:  Attribute
Full header:  - **constraints** - Any validation rules specific to this attribute _(ListOf Constraints)_

handlers:  ParseHeader()


===
ParsingHeader header: - **constraints** - Any validation rules specific to this attribute _(ListOf Constraints)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**constraints** - Any validation rules specific to this attribute _(ListOf Constraints)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='constraints', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Constraints'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Annotation
Parsing annotation:  Note: from Class.constraints

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'from Class.constraints'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='from Class.constraints')}
DerivingDict for Part:  AttributeSection
Full header:  __ Override Tracking

handlers:  ParseHeader()


===
ParsingHeader header: __ Override Tracking

PARSED AS INPUT LINE  {'line_type': 'AttributeSection', 'prefix': '__', 'rest_of_line': 'Override Tracking'}
Header dict is:  {'prefix': '__', 'name': AttributeSectionName(content='Override Tracking', _type='AttributeSectionName'), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  Attribute
Full header:  - Overrides

handlers:  ParseHeader()


===
ParsingHeader header: - Overrides

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': 'Overrides'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='overrides', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  ValueType
Full header:  ValueType:   **Derivation**  - A rule or formula for deriving the value of an attribute

handlers:  ParseHeader()


===
ParsingHeader header: ValueType:   **Derivation**  - A rule or formula for deriving the value of an attribute

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**Derivation**  - A rule or formula for deriving the value of an attribute'}
raw name = Derivation, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='Derivation', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'A rule or formula for deriving the value of an attribute'}, 'parenthetical': ''}
DerivingDict for Part:  Attribute
Full header:  - **statement** - An English language statement of the derivation rule _(RichText)_

handlers:  ParseHeader()


===
ParsingHeader header: - **statement** - An English language statement of the derivation rule _(RichText)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**statement** - An English language statement of the derivation rule _(RichText)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='statement', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'RichText'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **expression** - The formal expression of the derivation in a programming language _(CodeExpression)_

handlers:  ParseHeader()


===
ParsingHeader header: - **expression** - The formal expression of the derivation in a programming language _(CodeExpression)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**expression** - The formal expression of the derivation in a programming language _(CodeExpression)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='expression', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'CodeExpression'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType:   **Derivation**  - A rule or formula for deriving the value of an attribute
_ _ PLURAL: Plural: Derivations
. . Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ Attribute_Head: - **statement** - An English language statement of the derivation rule _(RichText)_
. . Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ Attribute_Head: - **expression** - The formal expression of the derivation in a programming language _(CodeExpression)_

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='Derivation', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'A rule or formula for deriving the value of an attribute'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'_type': 'AttributeName', 'content': 'statement', '_html_id': ''}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'RichText'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'_type': 'AttributeName', 'content': 'expression', '_html_id': ''}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'CodeExpression'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}}}]}
DerivingDict for Part:  ValueType
Full header:  ValueType:    **Constraint**  - A rule, condition, or validation that must be satisfied by the model

handlers:  ParseHeader()


===
ParsingHeader header: ValueType:    **Constraint**  - A rule, condition, or validation that must be satisfied by the model

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**Constraint**  - A rule, condition, or validation that must be satisfied by the model'}
raw name = Constraint, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='Constraint', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'A rule, condition, or validation that must be satisfied by the model'}, 'parenthetical': ''}
parsing subtypeOfs:   Component

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
DerivingDict for Part:  Attribute
Full header:  - **statement** - An English language statement of the constraint _(RichText)_

handlers:  ParseHeader()


===
ParsingHeader header: - **statement** - An English language statement of the constraint _(RichText)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**statement** - An English language statement of the constraint _(RichText)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='statement', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'RichText'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **expression** - The formal expression of the constraint in a programming language (e.g., OCL _(CodeExpression)_

handlers:  ParseHeader()


===
ParsingHeader header: - **expression** - The formal expression of the constraint in a programming language (e.g., OCL _(CodeExpression)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**expression** - The formal expression of the constraint in a programming language (e.g., OCL _(CodeExpression)_'}
Inventing name for:  e.g., OCL _(CodeExpression
Header dict is:  {'prefix': '-', 'name': AttributeName(content='expression', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'InventedName'}, 'as_value_type': {'_type': 'AsValue', 'content': False}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **severity** -  (Code)

handlers:  ParseHeader()


===
ParsingHeader header: - **severity** -  (Code)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**severity** -  (Code)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='severity', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'Code', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Code'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType:    **Constraint**  - A rule, condition, or validation that must be satisfied by the model
_ _ PLURAL: Plural: Constraints
_ _ SUBTYPE_OF: Subtype of: Component
. . Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ Attribute_Head: - **statement** - An English language statement of the constraint _(RichText)_
. . Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ Attribute_Head: - **expression** - The formal expression of the constraint in a programming language (e.g., OCL _(CodeExpression)_
. . Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ Attribute_Head: - **severity** -  (Code)
_ _ _ ELABORATION: [TypedLine(type_label='CODE_FENCE', line_Type=None, content='```codes', extra_text=['Warning, nothing fatal; just a caution', 'Error, serious. Fix now', '```'])]

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='Constraint', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'A rule, condition, or validation that must be satisfied by the model'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'_type': 'AttributeName', 'content': 'statement', '_html_id': ''}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'RichText'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'_type': 'AttributeName', 'content': 'expression', '_html_id': ''}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'InventedName'}, 'as_value_type': {'_type': 'AsValue', 'content': False}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'_type': 'AttributeName', 'content': 'severity', '_html_id': ''}, 'parenthetical': 'Code', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Code'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}}, 'elaboration': [{'_type': 'CodeBlock', 'content': '```codes\nWarning, nothing fatal; just a caution\nError, serious. Fix now\n```'}]}]}
DerivingDict for Part:  ValueType
Full header:  ValueType:  **Message** - (Template)

handlers:  ParseHeader()


===
ParsingHeader header: ValueType:  **Message** - (Template)

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**Message** - (Template)'}
raw name = Message, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='Message', _type='ClassName'), 'one_liner': None, 'parenthetical': 'Template'}
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType:  **Message** - (Template)

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='Message', _type='ClassName'), 'one_liner': None, 'parenthetical': 'Template'}
DerivingDict for Part:  ValueType
Full header:  ValueType:   **Class Constraint**

handlers:  ParseHeader()


===
ParsingHeader header: ValueType:   **Class Constraint**

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**Class Constraint**'}
raw name = Class Constraint, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='ClassConstraint', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
parsing subtypeOfs:   Constraint

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Constraint', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Constraint', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
ParseNameList returning:  [ClassReference(content='Class', _type='ClassReference')]
Using ATT_NAME  based_on for based on
Adding value in ddforpart. based_on -. [ClassReference(content='Class', _type='ClassReference')]
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType:   **Class Constraint**
_ _ SUBTYPE_OF: **Subtype of**: Constraint
_ _ BASED_ON: ***Based on***: Class.

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='ClassConstraint', _type='ClassName'), 'one_liner': None, 'parenthetical': '', 'subtype_of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Constraint', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}], 'based_on': [ClassReference(content='Class', _type='ClassReference')]}
DerivingDict for Part:  ValueType
Full header:  ValueType:   **Attribute Constraint**

handlers:  ParseHeader()


===
ParsingHeader header: ValueType:   **Attribute Constraint**

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**Attribute Constraint**'}
raw name = Attribute Constraint, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='AttributeConstraint', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
parsing subtypeOfs:   Constraint

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Constraint', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Constraint', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
ParseNameList returning:  [ClassReference(content='Attribute', _type='ClassReference')]
Using ATT_NAME  based_on for based on
Adding value in ddforpart. based_on -. [ClassReference(content='Attribute', _type='ClassReference')]
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType:   **Attribute Constraint**
_ _ SUBTYPE_OF: ***Subtype of***: Constraint
_ _ BASED_ON: ***Based on***: Attribute

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='AttributeConstraint', _type='ClassName'), 'one_liner': None, 'parenthetical': '', 'subtype_of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Constraint', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}], 'based_on': [ClassReference(content='Attribute', _type='ClassReference')]}
DerivingDict for Part:  ValueType
Full header:  ValueType:   **CodeExpression**

handlers:  ParseHeader()


===
ParsingHeader header: ValueType:   **CodeExpression**

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**CodeExpression**'}
raw name = CodeExpression, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='CodeExpression', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  Attribute
Full header:  - **Language** - the programming language (Code)

handlers:  ParseHeader()


===
ParsingHeader header: - **Language** - the programming language (Code)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**Language** - the programming language (Code)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='language', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Code'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **Expression** (String)

handlers:  ParseHeader()


===
ParsingHeader header: - **Expression** (String)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**Expression** (String)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='expression', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'String', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'String'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType:   **CodeExpression**
. . Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ Attribute_Head: - **Language** - the programming language (Code)
_ _ _ ELABORATION: [TypedLine(type_label='CODE_FENCE', line_Type=None, content='``` code', extra_text=['OCL, Object Constraint Language', 'Java, Java', '```'])]
. . Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ Attribute_Head: - **Expression** (String)

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='CodeExpression', _type='ClassName'), 'one_liner': None, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'_type': 'AttributeName', 'content': 'language', '_html_id': ''}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Code'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}}, 'elaboration': [{'_type': 'CodeBlock', 'content': '``` code\nOCL, Object Constraint Language\nJava, Java\n```'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'_type': 'AttributeName', 'content': 'expression', '_html_id': ''}, 'parenthetical': 'String', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'String'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}}}]}
DerivingDict for Part:  SubjectB
Full header:  ## Methods

handlers:  ParseHeader()


===
ParsingHeader header: ## Methods

PARSED AS INPUT LINE  {'line_type': 'Section2', 'prefix': '##', 'rest_of_line': 'Methods'}
Header dict is:  {'prefix': '##', 'name': SubjectName(content='Methods', _type='SubjectName'), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  Class
Full header:  _ **Method**  - A behavior or operation associated with a class

handlers:  ParseHeader()


===
ParsingHeader header: _ **Method**  - A behavior or operation associated with a class

PARSED AS INPUT LINE  {'line_type': 'Class', 'prefix': '_', 'rest_of_line': '**Method**  - A behavior or operation associated with a class'}
Header dict is:  {'prefix': '_', 'name': ClassName(content='Method', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'A behavior or operation associated with a class'}, 'parenthetical': ''}
parsing subtypeOfs:   Component

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
DerivingDict for Part:  Attribute
Full header:  - **parameters** - The input parameters of the method _(ListOf Parameters)_

handlers:  ParseHeader()


===
ParsingHeader header: - **parameters** - The input parameters of the method _(ListOf Parameters)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**parameters** - The input parameters of the method _(ListOf Parameters)_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='parameters', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Parameters'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **returnType** - The data type of the value returned by the method _(DataType )_

handlers:  ParseHeader()


===
ParsingHeader header: - **returnType** - The data type of the value returned by the method _(DataType )_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**returnType** - The data type of the value returned by the method _(DataType )_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='returnType', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'DataType'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Class
Full header:  _ **Parameter**
An input to a method
handlers:  ParseHeader()


===
ParsingHeader header: _ **Parameter**
An input to a method
PARSED AS INPUT LINE  {'line_type': 'Class', 'prefix': '_', 'rest_of_line': '**Parameter**\nAn input to a method'}
Header dict is:  {'prefix': '_', 'name': ClassName(content='ParameterAnInputToAMethod', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
parsing subtypeOfs:   Component

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
DerivingDict for Part:  Attribute
Full header:  - **type** - The data type of the parameter _(DataType )_

handlers:  ParseHeader()


===
ParsingHeader header: - **type** - The data type of the parameter _(DataType )_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**type** - The data type of the parameter _(DataType )_'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='type', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'DataType'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **cardinality** - The cardinality of the parameter (e.g., optional, required) _(AttributeCardinality)_

handlers:  ParseHeader()


===
ParsingHeader header: - **cardinality** - The cardinality of the parameter (e.g., optional, required) _(AttributeCardinality)_

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**cardinality** - The cardinality of the parameter (e.g., optional, required) _(AttributeCardinality)_'}
Inventing name for:  e.g., optional, required
Header dict is:  {'prefix': '-', 'name': AttributeName(content='cardinality', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'InventedName'}, 'as_value_type': {'_type': 'AsValue', 'content': False}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  SubjectB
Full header:  ## Data Types

handlers:  ParseHeader()


===
ParsingHeader header: ## Data Types

PARSED AS INPUT LINE  {'line_type': 'Section2', 'prefix': '##', 'rest_of_line': 'Data Types'}
Header dict is:  {'prefix': '##', 'name': SubjectName(content='Data Types', _type='SubjectName'), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  ValueType
Full header:  ValueType: **Data Type**

handlers:  ParseHeader()


===
ParsingHeader header: ValueType: **Data Type**

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**Data Type**'}
raw name = Data Type, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='DataType', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType: **Data Type**

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='DataType', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  ValueType
Full header:  ValueType:   **Simple Data Type**
***SubtpeOf***: DataType
handlers:  ParseHeader()


===
ParsingHeader header: ValueType:   **Simple Data Type**
***SubtpeOf***: DataType
PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**Simple Data Type**\n***SubtpeOf***: DataType'}
raw name = Simple Data Type
SubtpeOf DataType, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='SimpleDataTypeSubtpeOfDataType', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  Attribute
Full header:  - **coreClass** - (Class)

handlers:  ParseHeader()


===
ParsingHeader header: - **coreClass** - (Class)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**coreClass** - (Class)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='coreClass', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'Class', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Class'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType:   **Simple Data Type*****SubtpeOf***: DataType
. . Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ Attribute_Head: - **coreClass** - (Class)

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='SimpleDataTypeSubtpeOfDataType', _type='ClassName'), 'one_liner': None, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'_type': 'AttributeName', 'content': 'coreClass', '_html_id': ''}, 'parenthetical': 'Class', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Class'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}}}]}
DerivingDict for Part:  ValueType
Full header:  ValueType:   **Complex Data Type**

handlers:  ParseHeader()


===
ParsingHeader header: ValueType:   **Complex Data Type**

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**Complex Data Type**'}
raw name = Complex Data Type, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='ComplexDataType', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  Attribute
Full header:  - **aggregation** (Aggregating Operator)

handlers:  ParseHeader()


===
ParsingHeader header: - **aggregation** (Aggregating Operator)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**aggregation** (Aggregating Operator)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='aggregation', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'AggregatingOperator'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **aggregatedTypes** (List of DataTypes)

handlers:  ParseHeader()


===
ParsingHeader header: - **aggregatedTypes** (List of DataTypes)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**aggregatedTypes** (List of DataTypes)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='aggregatedTypes', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'DataTypes'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType:   **Complex Data Type**
. . Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ Attribute_Head: - **aggregation** (Aggregating Operator)
. . Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ Attribute_Head: - **aggregatedTypes** (List of DataTypes)

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='ComplexDataType', _type='ClassName'), 'one_liner': None, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'_type': 'AttributeName', 'content': 'aggregation', '_html_id': ''}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'AggregatingOperator'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'_type': 'AttributeName', 'content': 'aggregatedTypes', '_html_id': ''}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'DataTypes'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}}}]}
DerivingDict for Part:  ValueType
Full header:  ValueType:   **Aggregating Operator**

handlers:  ParseHeader()


===
ParsingHeader header: ValueType:   **Aggregating Operator**

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**Aggregating Operator**'}
raw name = Aggregating Operator, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='AggregatingOperator', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  Attribute
Full header:  - **Name**- (Code)

handlers:  ParseHeader()


===
ParsingHeader header: - **Name**- (Code)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**Name**- (Code)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='name', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'Code', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Code'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **arity** - (Integer)

handlers:  ParseHeader()


===
ParsingHeader header: - **arity** - (Integer)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**arity** - (Integer)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='arity', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'Integer', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Integer'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **spelling** - (Template)

handlers:  ParseHeader()


===
ParsingHeader header: - **spelling** - (Template)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**spelling** - (Template)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='spelling', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'Template', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Template'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType:   **Aggregating Operator**
. . Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ Attribute_Head: - **Name**- (Code)
_ _ _ ELABORATION: [TypedLine(type_label='CODE_FENCE', line_Type=None, content='``` code', extra_text=['SetOf', 'ListOf', 'Mapping', '```'])]
. . Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ Attribute_Head: - **arity** - (Integer)
. . Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ Attribute_Head: - **spelling** - (Template)

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='AggregatingOperator', _type='ClassName'), 'one_liner': None, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'_type': 'AttributeName', 'content': 'name', '_html_id': ''}, 'parenthetical': 'Code', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Code'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}}, 'elaboration': [{'_type': 'CodeBlock', 'content': '``` code\nSetOf\nListOf\nMapping\n```'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'_type': 'AttributeName', 'content': 'arity', '_html_id': ''}, 'parenthetical': 'Integer', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Integer'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'_type': 'AttributeName', 'content': 'spelling', '_html_id': ''}, 'parenthetical': 'Template', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Template'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}}}]}
DerivingDict for Part:  SubjectB
Full header:  ## Low level Data Types

handlers:  ParseHeader()


===
ParsingHeader header: ## Low level Data Types

PARSED AS INPUT LINE  {'line_type': 'Section2', 'prefix': '##', 'rest_of_line': 'Low level Data Types'}
Header dict is:  {'prefix': '##', 'name': SubjectName(content='Low level Data Types', _type='SubjectName'), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  ValueType
Full header:  ValueType: Emoji

handlers:  ParseHeader()


===
ParsingHeader header: ValueType: Emoji

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': 'Emoji'}
raw name = Emoji, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='Emoji', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType: Emoji

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='Emoji', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  ValueType
Full header:  ValueType: String

handlers:  ParseHeader()


===
ParsingHeader header: ValueType: String

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': 'String'}
raw name = String, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='String', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType: String

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='String', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  ValueType
Full header:  ValueType: **CamelName**

handlers:  ParseHeader()


===
ParsingHeader header: ValueType: **CamelName**

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**CamelName**'}
raw name = CamelName, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='CamelName', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
parsing subtypeOfs:   String

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
DerivingDict for Part:  Attribute
Full header:  - value: the string (String)

handlers:  ParseHeader()


===
ParsingHeader header: - value: the string (String)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': 'value: the string (String)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='valueTheString', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': 'String', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'String'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Constraint
Dict for Formula {'_type': 'Constraint', 'one_liner': [OneLiner(content=' Must follow the camel case naming convention and not be empty.\n')]}
DerivingDict for Part:  Annotation
Parsing annotation:  Example:  "firstName", "orderDate", "customerID"

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Example', 'value': '"firstName", "orderDate", "customerID"'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='example', _type='Label'), 'content': OneLiner(content='"firstName", "orderDate", "customerID"')}
DerivingDict for Part:  Annotation
Parsing annotation:  *ModelingNote:* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'ModelingNote', 'value': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='modelingNote', _type='Label'), 'content': OneLiner(content='* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.')}
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType: **CamelName**
_ _ ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.', extra_text=[])], extra_text=[])]
_ _ SUBTYPE_OF: ***Subtype of***: String
. . Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ Attribute_Head: - value: the string (String)
. . . Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ _ CONSTRAINT: 🚫 ***Constraint***: Must follow the camel case naming convention and not be empty.
. . . . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ _ _ EXAMPLE: Example:  "firstName", "orderDate", "customerID"
_ _ _ _ _ ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.', extra_text=[])], extra_text=[])]
. . . . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ _ _ WILD: *ModelingNote:* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='CamelName', _type='ClassName'), 'one_liner': None, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'_type': 'AttributeName', 'content': 'valueTheString', '_html_id': ''}, 'parenthetical': 'String', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'String'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}}, 'constraints': [{'_type': 'Constraint', 'one_liner': [{'_type': 'OneLiner', 'content': ' Must follow the camel case naming convention and not be empty.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': {'_type': 'Label', 'content': 'example'}, 'content': {'_type': 'OneLiner', 'content': '"firstName", "orderDate", "customerID"'}, 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': {'_type': 'Label', 'content': 'modelingNote'}, 'content': {'_type': 'OneLiner', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}}]}]}]}
DerivingDict for Part:  ValueType
Full header:  ValueType:  **UpperCamel**- a CamelName that begins with a capital letter

handlers:  ParseHeader()


===
ParsingHeader header: ValueType:  **UpperCamel**- a CamelName that begins with a capital letter

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**UpperCamel**- a CamelName that begins with a capital letter'}
raw name = UpperCamel, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='UpperCamel', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': ''}
parsing subtypeOfs:   CamelName

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='CamelName', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='CamelName', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
DerivingDict for Part:  Annotation
Parsing annotation:  Example:_ "Customer", "ProductCategory", "PaymentMethod"

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Example', 'value': '_ "Customer", "ProductCategory", "PaymentMethod"'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='example', _type='Label'), 'content': OneLiner(content='_ "Customer", "ProductCategory", "PaymentMethod"')}
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType:  **UpperCamel**- a CamelName that begins with a capital letter
_ _ SUBTYPE_OF: **Subtype of**: CamelName
_ _ WHERE: **Where**: content begins with an upper case letter.
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ EXAMPLE: Example:_ "Customer", "ProductCategory", "PaymentMethod"

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='UpperCamel', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='CamelName', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': {'_type': 'Label', 'content': 'example'}, 'content': {'_type': 'OneLiner', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}}]}
DerivingDict for Part:  ValueType
Full header:  ValueType:   **LowerCamel** - a CamelName that begins with a lower case letter

handlers:  ParseHeader()


===
ParsingHeader header: ValueType:   **LowerCamel** - a CamelName that begins with a lower case letter

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**LowerCamel** - a CamelName that begins with a lower case letter'}
raw name = LowerCamel, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='LowerCamel', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': ''}
parsing subtypeOfs:   CamelName

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='CamelName', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='CamelName', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
DerivingDict for Part:  Annotation
Parsing annotation:  Example:  "firstName", "orderTotal", "shippingAddress"

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Example', 'value': '"firstName", "orderTotal", "shippingAddress"'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='example', _type='Label'), 'content': OneLiner(content='"firstName", "orderTotal", "shippingAddress"')}
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType:   **LowerCamel** - a CamelName that begins with a lower case letter
_ _ SUBTYPE_OF: **Subtype of**: CamelName
_ _ WHERE: **Where**: content begins with a lower case letter.
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ EXAMPLE: Example:  "firstName", "orderTotal", "shippingAddress"

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='LowerCamel', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='CamelName', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': {'_type': 'Label', 'content': 'example'}, 'content': {'_type': 'OneLiner', 'content': '"firstName", "orderTotal", "shippingAddress"'}}]}
DerivingDict for Part:  ValueType
Full header:  ValueType:   **Qualified Camel** - an expression consisting of Camel Names separated by periods

handlers:  ParseHeader()


===
ParsingHeader header: ValueType:   **Qualified Camel** - an expression consisting of Camel Names separated by periods

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**Qualified Camel** - an expression consisting of Camel Names separated by periods'}
raw name = Qualified Camel, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='QualifiedCamel', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': ''}
parsing subtypeOfs:   String

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
DerivingDict for Part:  Constraint
Dict for Formula {'_type': 'Constraint', 'one_liner': [OneLiner(content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType:   **Qualified Camel** - an expression consisting of Camel Names separated by periods
_ _ SUBTYPE_OF: ***Subtype of***: String
. . Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ CONSTRAINT: ***Constraint***: content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='QualifiedCamel', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}], 'constraints': [{'_type': 'Constraint', 'one_liner': [{'_type': 'OneLiner', 'content': ' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n'}]}]}
DerivingDict for Part:  Class
Full header:  _ **RichText** - A string with markup for block level formatting.

handlers:  ParseHeader()


===
ParsingHeader header: _ **RichText** - A string with markup for block level formatting.

PARSED AS INPUT LINE  {'line_type': 'Class', 'prefix': '_', 'rest_of_line': '**RichText** - A string with markup for block level formatting.'}
Header dict is:  {'prefix': '_', 'name': ClassName(content='RichText', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'A string with markup for block level formatting.'}, 'parenthetical': ''}
parsing subtypeOfs:   String

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
DerivingDict for Part:  Attribute
Full header:  - **value** - the string content (string)

handlers:  ParseHeader()


===
ParsingHeader header: - **value** - the string content (string)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**value** - the string content (string)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='value', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'String'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Attribute
Full header:  - **format** - the rich text coding language used (Code)

handlers:  ParseHeader()


===
ParsingHeader header: - **format** - the rich text coding language used (Code)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**format** - the rich text coding language used (Code)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='format', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'Code'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  ValueType
Full header:  ValueType:  **OneLiner**   - String with markup for line level formatting.

handlers:  ParseHeader()


===
ParsingHeader header: ValueType:  **OneLiner**   - String with markup for line level formatting.

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**OneLiner**   - String with markup for line level formatting.'}
raw name = OneLiner, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='OneLiner', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': ''}
parsing subtypeOfs:   RichText

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='RichText', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='RichText', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
DerivingDict for Part:  Attribute
Full header:  - **value** - the string content (string)

handlers:  ParseHeader()


===
ParsingHeader header: - **value** - the string content (string)

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': '**value** - the string content (string)'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='value', _type='AttributeName', _html_id=''), 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'String'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}, 'cardinality': None}}
DerivingDict for Part:  Constraint
Dict for Formula {'_type': 'Constraint', 'one_liner': [OneLiner(content=' must not containa line break or new line character\n')]}
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType:  **OneLiner**   - String with markup for line level formatting.
_ _ SUBTYPE_OF: ***SubtypeOf***: RichText
. . Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ Attribute_Head: - **value** - the string content (string)
. . . Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ _ CONSTRAINT: ***Constraint***: must not containa line break or new line character
_ _ _ _ MESSAGE: Message: A line can't span two lines

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='OneLiner', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='RichText', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'_type': 'AttributeName', 'content': 'value', '_html_id': ''}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'_type': 'DataTypeClause', 'data_type': {'_type': 'BaseDataType', 'class_name': {'_type': 'ClassReference', 'content': 'String'}, 'as_value_type': {'_type': 'AsValue', 'content': True}}, 'is_optional_lit': {'_type': 'IsOptional', 'content': False}}, 'constraints': [{'_type': 'Constraint', 'one_liner': [{'_type': 'OneLiner', 'content': ' must not containa line break or new line character\n'}], 'message': " A line can't span two lines\n"}]}]}
DerivingDict for Part:  ValueType
Full header:  ValueType:  **PrimitiveType**  - A basic, built-in data type

handlers:  ParseHeader()


===
ParsingHeader header: ValueType:  **PrimitiveType**  - A basic, built-in data type

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**PrimitiveType**  - A basic, built-in data type'}
raw name = PrimitiveType, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='PrimitiveType', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'A basic, built-in data type'}, 'parenthetical': ''}
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType:  **PrimitiveType**  - A basic, built-in data type

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='PrimitiveType', _type='ClassName'), 'one_liner': {'_type': 'OneLiner', 'content': 'A basic, built-in data type'}, 'parenthetical': ''}
DerivingDict for Part:  ValueType
Full header:  ValueType: **String**

handlers:  ParseHeader()


===
ParsingHeader header: ValueType: **String**

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**String**'}
raw name = String, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='String', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
parsing subtypeOfs:   PrimitiveType

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType: **String**
_ _ SUBTYPE_OF: SubtypeOf: PrimitiveType

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='String', _type='ClassName'), 'one_liner': None, 'parenthetical': '', 'subtype_of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
DerivingDict for Part:  ValueType
Full header:  ValueType: **Integer**

handlers:  ParseHeader()


===
ParsingHeader header: ValueType: **Integer**

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**Integer**'}
raw name = Integer, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='Integer', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
parsing subtypeOfs:   PrimitiveType

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType: **Integer**
_ _ SUBTYPE_OF: SubtypeOf: PrimitiveType

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='Integer', _type='ClassName'), 'one_liner': None, 'parenthetical': '', 'subtype_of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
DerivingDict for Part:  ValueType
Full header:  ValueType: **Decimal**

handlers:  ParseHeader()


===
ParsingHeader header: ValueType: **Decimal**

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**Decimal**'}
raw name = Decimal, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='Decimal', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
parsing subtypeOfs:   PrimitiveType

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType: **Decimal**
_ _ SUBTYPE_OF: SubtypeOf: PrimitiveType

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='Decimal', _type='ClassName'), 'one_liner': None, 'parenthetical': '', 'subtype_of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
DerivingDict for Part:  ValueType
Full header:  ValueType: **Boolean**

handlers:  ParseHeader()


===
ParsingHeader header: ValueType: **Boolean**

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**Boolean**'}
raw name = Boolean, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='Boolean', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
parsing subtypeOfs:   PrimitiveType

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType: **Boolean**
_ _ SUBTYPE_OF: SubtypeOf: PrimitiveType

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='Boolean', _type='ClassName'), 'one_liner': None, 'parenthetical': '', 'subtype_of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
DerivingDict for Part:  ValueType
Full header:  ValueType: **Date**

handlers:  ParseHeader()


===
ParsingHeader header: ValueType: **Date**

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**Date**'}
raw name = Date, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='Date', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
parsing subtypeOfs:   PrimitiveType

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType: **Date**
_ _ SUBTYPE_OF: SubtypeOf: PrimitiveType

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='Date', _type='ClassName'), 'one_liner': None, 'parenthetical': '', 'subtype_of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
DerivingDict for Part:  ValueType
Full header:  ValueType: **Time**

handlers:  ParseHeader()


===
ParsingHeader header: ValueType: **Time**

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**Time**'}
raw name = Time, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='Time', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
parsing subtypeOfs:   PrimitiveType

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType: **Time**
_ _ SUBTYPE_OF: SubtypeOf: PrimitiveType

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='Time', _type='ClassName'), 'one_liner': None, 'parenthetical': '', 'subtype_of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
DerivingDict for Part:  ValueType
Full header:  ValueType: **DateTime**

handlers:  ParseHeader()


===
ParsingHeader header: ValueType: **DateTime**

PARSED AS INPUT LINE  {'line_type': 'ValueType', 'prefix': 'ValueType:', 'rest_of_line': '**DateTime**'}
raw name = DateTime, deep = None
Header dict is:  {'prefix': 'ValueType:', 'name': ClassName(content='DateTime', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
parsing subtypeOfs:   PrimitiveType

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
. ValueType - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ ValueType_Head: ValueType: **DateTime**
_ _ SUBTYPE_OF: SubtypeOf: PrimitiveType

DerivedDict for Part:  ValueType
{'_type': 'ValueType', 'prefix': 'ValueType:', 'name': ClassName(content='DateTime', _type='ClassName'), 'one_liner': None, 'parenthetical': '', 'subtype_of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
DerivingDict for Part:  SubjectC
Full header:  ### Annotation Types Used

handlers:  ParseHeader()


===
ParsingHeader header: ### Annotation Types Used

PARSED AS INPUT LINE  {'line_type': 'Section3', 'prefix': '###', 'rest_of_line': 'Annotation Types Used'}
Header dict is:  {'prefix': '###', 'name': SubjectName(content='Annotation Types Used', _type='SubjectName'), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  SubjectC
Full header:  ### Annotation types as CSV

handlers:  ParseHeader()


===
ParsingHeader header: ### Annotation types as CSV

PARSED AS INPUT LINE  {'line_type': 'Section3', 'prefix': '###', 'rest_of_line': 'Annotation types as CSV'}
Header dict is:  {'prefix': '###', 'name': SubjectName(content='Annotation types as CSV', _type='SubjectName'), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  SubjectB
Full header:  ## Appendices - various sidebars to include
Insert More Sidebars.md
Insert Overrides.md
insert LDM Intro.md
Insert OCL.md
Insert Camel Case.md
handlers:  ParseHeader()


===
ParsingHeader header: ## Appendices - various sidebars to include
Insert More Sidebars.md
Insert Overrides.md
insert LDM Intro.md
Insert OCL.md
Insert Camel Case.md
PARSED AS INPUT LINE  {'line_type': 'Section2', 'prefix': '##', 'rest_of_line': 'Appendices - various sidebars to include\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md'}
Header dict is:  {'prefix': '##', 'name': SubjectName(content='Appendices', _type='SubjectName'), 'one_liner': {'_type': 'OneLiner', 'content': 'various sidebars to include\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md'}, 'parenthetical': ''}
DerivingDict for Part:  Attribute
Full header:  - minor component

handlers:  ParseHeader()


===
ParsingHeader header: - minor component

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': 'minor component'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='minorComponent', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  Attribute
Full header:  - embellishment

handlers:  ParseHeader()


===
ParsingHeader header: - embellishment

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': 'embellishment'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='embellishment', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': ''}
DerivingDict for Part:  Attribute
Full header:  - words and phrases

handlers:  ParseHeader()


===
ParsingHeader header: - words and phrases

PARSED AS INPUT LINE  {'line_type': 'Attribute', 'prefix': '-', 'rest_of_line': 'words and phrases'}
Header dict is:  {'prefix': '-', 'name': AttributeName(content='wordsAndPhrases', _type='AttributeName', _html_id=''), 'one_liner': None, 'parenthetical': ''}
as yaml - warnings =  False

Phase: .. full dict saved  in ldm/ldm_models/Literate/Literate_results/Literate_PD_02.dict.yaml

Phase: Creating model with from_typed_dict() => to_typed_dict() => ldm/ldm_models/Literate/Literate_results/Literate_PD_03.model.yaml
Calling LiterateModel.from_typed_dict ...
In AttSection post-init for For Machinery, is_optional = None
backfilling attributes for  Component
	backfilled  normalName
	backfilled  name
	backfilled  qualifiedName
	backfilled  abbreviatedName
	backfilled  oneLiner
	backfilled  elaboration
	backfilled  isEmbellishment
backfilling attributes for  AnnotationType
	backfilled  emoji
	backfilled  emojiName
	backfilled  emojiUnicode
	backfilled  label
	backfilled  plural
	backfilled  purpose
In AttSection post-init for For Machinery, is_optional = None
backfilling attributes for  Annotation
	backfilled  annotationType
	backfilled  label
	backfilled  emoji
	backfilled  content
	backfilled  isEmbellishment
In AttSection post-init for Modeling Configuration, is_optional = None
backfilling attributes for  LiterateDataModel
	backfilled  name
	backfilled  allSubjects
	backfilled  allClasses
	backfilled  annotationTypes
	backfilled  preferredCodingLanguage
	backfilled  alternateCodingLanguages
	backfilled  preferredTemplateLanguage
	backfilled  alternateTemplateLanguages
	backfilled  aiFunctions
backfilling attributes for  Subject
	backfilled  name
	backfilled  parentSubject
	backfilled  classes
	backfilled  childSubjects
In AttSection post-init for Implied Attributes, is_optional = None
backfilling attributes for  Class
	backfilled  pluralForm
	backfilled  basedOn
	backfilled  supertypes
	backfilled  subtypings
	backfilled  subtypes
	backfilled  attributes
	backfilled  attributeSections
	backfilled  constraints
	backfilled  methods
	backfilled  dependents
	backfilled  uniqueKeys
backfilling attributes for  Subtyping
	backfilled  name
	backfilled  isExclusive
	backfilled  isExhaustive
	backfilled  classes
backfilling attributes for  CodeType
	backfilled  isCaptive
backfilling attributes for  CodeValue
	backfilled  code
	backfilled  description
backfilling attributes for  Key
	backfilled  keyAttributes
backfilling attributes for  AttributeSection
	backfilled  isOptional
In AttSection post-init for Cardinalities, is_optional = None
In AttSection post-init for Inverse Attributes, is_optional = None
In AttSection post-init for Formulas, is_optional = None
In AttSection post-init for Override Tracking, is_optional = None
backfilling attributes for  Attribute
	backfilled  name
	backfilled  dataType
	backfilled  isOptional
	backfilled  cardinality
	backfilled  author
	backfilled  books
	backfilled  isInvertible
	backfilled  inverseClass
	backfilled  inverseAttribute
	backfilled  inverseIsOptional
	backfilled  default
	backfilled  derivation
	backfilled  constraints
	backfilled  overrides
backfilling attributes for  Derivation
	backfilled  statement
	backfilled  expression
backfilling attributes for  Constraint
	backfilled  statement
	backfilled  expression
	backfilled  severity
backfilling attributes for  CodeExpression
	backfilled  language
	backfilled  expression
backfilling attributes for  Method
	backfilled  parameters
	backfilled  returnType
backfilling attributes for  ParameterAnInputToAMethod
	backfilled  type
	backfilled  cardinality
backfilling attributes for  SimpleDataTypeSubtpeOfDataType
	backfilled  coreClass
backfilling attributes for  ComplexDataType
	backfilled  aggregation
	backfilled  aggregatedTypes
backfilling attributes for  AggregatingOperator
	backfilled  name
	backfilled  arity
	backfilled  spelling
backfilling attributes for  CamelName
	backfilled  valueTheString
backfilling attributes for  RichText
	backfilled  value
	backfilled  format
backfilling attributes for  OneLiner
	backfilled  value

Phase: have py  model from dict

Phase: Creating model_dict from model => ldm/ldm_models/Literate/Literate_results/Literate_PD_03.model.yaml
as yaml - warnings =  False

Phase: Validating model tp ldm/ldm_models/Literate/Literate_results/Literate_PD_04.v_model.yaml
All class names are {'Date', 'Key', 'Message', 'ClassConstraint', 'AttributeConstraint', 'Decimal', 'Boolean', 'CamelName', 'Emoji', 'AggregatingOperator', 'DateTime', 'PrimitiveType', 'Component', 'SimpleDataTypeSubtpeOfDataType', 'Subject', 'CodeValue', 'ReferenceType', 'CodeType', 'String', 'AnnotationType', 'DataType', 'QualifiedCamel', 'UniqueKey', 'OneLiner', 'Class', 'LiterateDataModel', 'Method', 'UpperCamel', 'Attribute', 'Annotation', 'SubjectArea', 'Derivation', 'ParameterAnInputToAMethod', 'ComplexDataType', 'CodeExpression', 'Integer', 'Constraint', 'LowerCamel', 'Time', 'RichText', 'Subtyping', 'AttributeSection'}
all plural names are  {'Derivations', 'CodeTypes', 'ReferenceTypes', 'Dates', 'ComplexDataTypes', 'QualifiedCamels', 'Subjects', 'CodeValues', 'Messages', 'AnnotationTypes', 'Parameters', 'CamelNames', 'LowerCamels', 'AttributeConstraints', 'Classes', 'Booleans', 'SubjectAreas', 'CodeExpressions', 'Decimals', 'Integers', 'Strings', 'LiterateDataModels', 'OneLiners', 'DateTimes', 'ClassConstraints', 'Methods', 'UniqueKeys', 'Annotations', 'SimpleDataTypeSubtpeOfDataTypes', 'AggregatingOperators', 'Emojis', 'RichTexts', 'PrimitiveTypes', 'AttributeSections', 'Keys', 'Components', 'UpperCamels', 'Times', 'Attributes', 'DataTypes', 'Subtypings', 'Constraints'}
All classes names (singular and plural are: 
	"AggregatingOperator",
	"AggregatingOperators",
	"Annotation",
	"AnnotationType",
	"AnnotationTypes",
	"Annotations",
	"Attribute",
	"AttributeConstraint",
	"AttributeConstraints",
	"AttributeSection",
	"AttributeSections",
	"Attributes",
	"Boolean",
	"Booleans",
	"CamelName",
	"CamelNames",
	"Class",
	"ClassConstraint",
	"ClassConstraints",
	"Classes",
	"CodeExpression",
	"CodeExpressions",
	"CodeType",
	"CodeTypes",
	"CodeValue",
	"CodeValues",
	"ComplexDataType",
	"ComplexDataTypes",
	"Component",
	"Components",
	"Constraint",
	"Constraints",
	"DataType",
	"DataTypes",
	"Date",
	"DateTime",
	"DateTimes",
	"Dates",
	"Decimal",
	"Decimals",
	"Derivation",
	"Derivations",
	"Emoji",
	"Emojis",
	"Integer",
	"Integers",
	"Key",
	"Keys",
	"LiterateDataModel",
	"LiterateDataModels",
	"LowerCamel",
	"LowerCamels",
	"Message",
	"Messages",
	"Method",
	"Methods",
	"OneLiner",
	"OneLiners",
	"ParameterAnInputToAMethod",
	"Parameters",
	"PrimitiveType",
	"PrimitiveTypes",
	"QualifiedCamel",
	"QualifiedCamels",
	"ReferenceType",
	"ReferenceTypes",
	"RichText",
	"RichTexts",
	"SimpleDataTypeSubtpeOfDataType",
	"SimpleDataTypeSubtpeOfDataTypes",
	"String",
	"Strings",
	"Subject",
	"SubjectArea",
	"SubjectAreas",
	"Subjects",
	"Subtyping",
	"Subtypings",
	"Time",
	"Times",
	"UniqueKey",
	"UniqueKeys",
	"UpperCamel",
	"UpperCamels",
Attributes Index = 
 defaultdict(<function <lambda> at 0x000001FC555A8D60>, {'Component': defaultdict(<class 'list'>, {'normalName': Attribute(one_liner=OneLiner(content='the name of the component, not in camel case'), elaboration=[], annotations=[Annotation(label=Label(content='warning', _type='Label'), content=OneLiner(content='This is a warning with emoji'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='normalName', _type='AttributeName', _html_id='Component__normalName'), parenthetical='*String*', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='String', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Component__normalName'), 'name': Attribute(one_liner=OneLiner(content='The name of the component'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='name', _type='AttributeName', _html_id='Component__name'), parenthetical='CamelName', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='CamelName', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Component__name'), 'qualifiedName': Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='qualifiedName', _type='AttributeName', _html_id='Component__qualifiedName'), parenthetical='*QualifiedCamel*', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='QualifiedCamel', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Component__qualifiedName'), 'abbreviatedName': Attribute(one_liner=OneLiner(content="a short form of the component's name, used for cross references and improved readability."), elaboration=[], annotations=[Annotation(label=Label(content='example', _type='Label'), content=OneLiner(content='"LDM" is the short form of "Literate Data Model".'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='abbreviatedName', _type='AttributeName', _html_id='Component__abbreviatedName'), parenthetical='*CamelName*', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='CamelName', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(content=' name -  how do you say name in english?\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=' x.name == y\n'), constraints=[Constraint(one_liner=[OneLiner(content=' the abbreviated name should be shorter than the actual name\n')], elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content="Does this annotation find it's way to the Constraint? YES! It's fixed!"), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, ocl=' len(abbreviatedName) < len(name)\n', message='  Why have an abbreviation longer than the name?\n', severity=' Warning\n')], _html_id='Component__abbreviatedName'), 'oneLiner': Attribute(one_liner=OneLiner(content='A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='oneLiner', _type='AttributeName', _html_id='Component__oneLiner'), parenthetical='OneLiner', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='OneLiner', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Component__oneLiner'), 'elaboration': Attribute(one_liner=OneLiner(content='A more detailed explanation or discussion of the component _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='elaboration', _type='AttributeName', _html_id='Component__elaboration'), parenthetical='RichText', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='RichText', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Component__elaboration')}), 'AnnotationType': defaultdict(<class 'list'>, {'emoji': Attribute(one_liner=OneLiner(content='an emoji'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='emoji', _type='AttributeName', _html_id='AnnotationType__emoji'), parenthetical='Emoji', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Emoji', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='AnnotationType__emoji'), 'emojiName': Attribute(one_liner=OneLiner(content='an emoji'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='emojiName', _type='AttributeName', _html_id='AnnotationType__emojiName'), parenthetical='String', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='String', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='AnnotationType__emojiName'), 'emojiUnicode': Attribute(one_liner=OneLiner(content='the Unicode for the emoji'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='emojiUnicode', _type='AttributeName', _html_id='AnnotationType__emojiUnicode'), parenthetical='Unicode', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Unicode', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='AnnotationType__emojiUnicode'), 'label': Attribute(one_liner=OneLiner(content='A short label to indicate the purpose of the annotation _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='label', _type='AttributeName', _html_id='AnnotationType__label'), parenthetical='CamelName', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='CamelName', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='AnnotationType__label'), 'plural': Attribute(one_liner=OneLiner(content='the plural form of the label'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='plural', _type='AttributeName', _html_id='AnnotationType__plural'), parenthetical='*UpperCamel*', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='UpperCamel', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(content=' based on label\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[], _html_id='AnnotationType__plural'), 'purpose': Attribute(one_liner=OneLiner(content='the intended reason for the annotation.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='purpose', _type='AttributeName', _html_id='AnnotationType__purpose'), parenthetical='OneLiner', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='OneLiner', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='AnnotationType__purpose')}), 'Annotation': defaultdict(<class 'list'>, {'annotationType': Attribute(one_liner=None, elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'), emoji=None, elaboration=[]), Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='Should be a Value  Type'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='annotationType', _type='AttributeName', _html_id='Annotation__annotationType'), parenthetical='optional Annotation Type', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='AnnotationType', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Annotation__annotationType'), 'label': Attribute(one_liner=OneLiner(content='A short label to indicate the purpose of the annotation _'), elaboration=[Paragraph(content='But any short label is valid.\n')], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='label', _type='AttributeName', _html_id='Annotation__label'), parenthetical='CamelName', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='CamelName', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(content=' from annotationType\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[], _html_id='Annotation__label'), 'emoji': Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='emoji', _type='AttributeName', _html_id='Annotation__emoji'), parenthetical='optional Emoji', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Emoji', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(content=' from annotation type\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[], _html_id='Annotation__emoji'), 'content': Attribute(one_liner=OneLiner(content='The content or body of the annotation'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='content', _type='AttributeName', _html_id='Annotation__content'), parenthetical='*RichText*', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='RichText', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Annotation__content')}), 'LiterateDataModel': defaultdict(<class 'list'>, {'name': Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='name', _type='AttributeName', _html_id='LiterateDataModel__name'), parenthetical='UpperCamel', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='UpperCamel', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='LiterateDataModel__name'), 'allSubjects': Attribute(one_liner=OneLiner(content='list of all classes in the model, as ordered in the\ndefinition of the model.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='allSubjects', _type='AttributeName', _html_id='LiterateDataModel__allSubjects'), parenthetical='List of Classes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Classes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=Derivation(one_liner=OneLiner(content=' gathering s.allSubjects over s in subjectAreas\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), default=None, constraints=[Constraint(one_liner=[OneLiner(content=' Subject names must be unique across the model.\n')], elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl='', message=Paragraph(content=''), severity=None)], _html_id='LiterateDataModel__allSubjects'), 'allClasses': Attribute(one_liner=OneLiner(content='list of all classes in the model, as ordered in the definition of the model.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='allClasses', _type='AttributeName', _html_id='LiterateDataModel__allClasses'), parenthetical='List of Classes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Classes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=Derivation(one_liner=OneLiner(content=' gathering s.allClasses over s in allSubjects.\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), default=None, constraints=[Constraint(one_liner=[OneLiner(content=' Class names must be unique across the model.\n')], elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl='', message=Paragraph(content=''), severity=None)], _html_id='LiterateDataModel__allClasses')}), 'Subject': defaultdict(<class 'list'>, {'name': Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='name', _type='AttributeName', _html_id='Subject__name'), parenthetical='UpperCamel', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='UpperCamel', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Subject__name'), 'parentSubject': Attribute(one_liner=OneLiner(content='The parent subject, if any, under which this subject is nested _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='parentSubject', _type='AttributeName', _html_id='Subject__parentSubject'), parenthetical='optional Subject', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Subject', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Subject__parentSubject'), 'classes': Attribute(one_liner=OneLiner(content='The major classes related to this subject, in the order in which they should be presented _'), elaboration=[], annotations=[Annotation(label=Label(content='issue', _type='Label'), content=OneLiner(content='define chapter, section, subsection as levels?'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='classes', _type='AttributeName', _html_id='Subject__classes'), parenthetical='ListOf Classes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Classes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Subject__classes'), 'childSubjects': Attribute(one_liner=OneLiner(content='Any child subjects nested under this subject, in the order in which they should be presented _'), elaboration=[Paragraph(content='***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n')], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='childSubjects', _type='AttributeName', _html_id='Subject__childSubjects'), parenthetical='ListOf Subjects', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Subjects', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=AttributeReference(class_name=ClassReference(content='Subject', _type='ClassReference'), attribute_name=AttributeName(content='parentSubject', _type='AttributeName', _html_id='')), inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Subject__childSubjects')}), 'Class': defaultdict(<class 'list'>, {'pluralForm': Attribute(one_liner=OneLiner(content='the normal English plural form of the name of the Class'), elaboration=[Paragraph(content='Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n')], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.'), emoji=None, elaboration=[Paragraph(content='The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n')])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='pluralForm', _type='AttributeName', _html_id='Class__pluralForm'), parenthetical='UpperName', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='UpperName', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(content=' the regular plural, formed by adding "s" or "es".\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[], _html_id='Class__pluralForm'), 'basedOn': Attribute(one_liner=OneLiner(content='the Class or Classes on which this class is dependent'), elaboration=[Paragraph(content='This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n')], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='that basedOn and dependentOf are being used synonymousle in this metamodel.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='basedOn', _type='AttributeName', _html_id='Class__basedOn'), parenthetical='SetOf Classes', abbreviation=None, data_type_clause=DataTypeClause(data_type=SetDataType(element_type=BaseDataType(class_name=ClassReference(content='Classes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Class__basedOn'), 'supertypes': Attribute(one_liner=OneLiner(content='The parent class'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='supertypes', _type='AttributeName', _html_id='Class__supertypes'), parenthetical='es', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Es', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Class__supertypes'), 'subtypings': Attribute(one_liner=OneLiner(content='the criteria, or dimensions, by which the class can be divided into subtypes'), elaboration=[], annotations=[Annotation(label=Label(content='example', _type='Label'), content=OneLiner(content='in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='subtypings', _type='AttributeName', _html_id='Class__subtypings'), parenthetical='list of Subtypings', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Subtypings', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Class__subtypings'), 'subtypes': Attribute(one_liner=OneLiner(content='Any subtypes or specializations of this class based on it’s subtypings. _'), elaboration=[], annotations=[Annotation(label=Label(content='example', _type='Label'), content=OneLiner(content='For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='subtypes', _type='AttributeName', _html_id='Class__subtypes'), parenthetical='ListOf Classes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Classes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Class__subtypes'), 'attributes': Attribute(one_liner=OneLiner(content='The attributes or properties of the class, in the order in which they should be presented _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='attributes', _type='AttributeName', _html_id='Class__attributes'), parenthetical='ListOf Attributes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Attributes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Class__attributes'), 'attributeSections': Attribute(one_liner=OneLiner(content='additional attributes or properties of the class, grouped for clarity and elaboration.  _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='attributeSections', _type='AttributeName', _html_id='Class__attributeSections'), parenthetical='ListOf AttributeSections', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='AttributeSections', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Class__attributeSections'), 'constraints': Attribute(one_liner=OneLiner(content='Any constraints, rules, or validations specific to this class _'), elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='Constraints may be expressed on either the Class or the Attribute. Always?'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='constraints', _type='AttributeName', _html_id='Class__constraints'), parenthetical='ListOf Constraints', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Constraints', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Class__constraints'), 'methods': Attribute(one_liner=OneLiner(content='Any behaviors or operations associated with this class _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='methods', _type='AttributeName', _html_id='Class__methods'), parenthetical='ListOf Methods', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Methods', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Class__methods')}), 'Subtyping': defaultdict(<class 'list'>, {'name': Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='name', _type='AttributeName', _html_id='Subtyping__name'), parenthetical='Upper Name', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='UpperName', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Subtyping__name'), 'isExclusive': Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='isExclusive', _type='AttributeName', _html_id='Subtyping__isExclusive'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Boolean', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(content=' true\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[], _html_id='Subtyping__isExclusive'), 'isExhaustive': Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='isExhaustive', _type='AttributeName', _html_id='Subtyping__isExhaustive'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Boolean', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(content=' true\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[], _html_id='Subtyping__isExhaustive'), 'classes': Attribute(one_liner=None, elaboration=[Paragraph(content='***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n')], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='every class can have an unnamed subtyping.'), emoji=None, elaboration=[Paragraph(content='ValueType - A class that is presumed to be used a value, rather than a reference\n')])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='classes', _type='AttributeName', _html_id='Subtyping__classes'), parenthetical='List of Classes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Classes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Subtyping__classes')}), 'CodeType': defaultdict(<class 'list'>, {'isCaptive': Attribute(one_liner=OneLiner(content='the code type was implied by use in an attribute and is only used for that attribute'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='isCaptive', _type='AttributeName', _html_id='CodeType__isCaptive'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Boolean', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='CodeType__isCaptive')}), 'CodeValue': defaultdict(<class 'list'>, {'code': Attribute(one_liner=OneLiner(content='A short code or abbreviationi for the value _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='code', _type='AttributeName', _html_id='CodeValue__code'), parenthetical='NameString', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='NameString', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='CodeValue__code'), 'description': Attribute(one_liner=OneLiner(content='an explanation of what the code means'), elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content="Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='description', _type='AttributeName', _html_id='CodeValue__description'), parenthetical='*RichText*', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='RichText', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='CodeValue__description')}), 'Key': defaultdict(<class 'list'>, {'keyAttributes': Attribute(one_liner=OneLiner(content='the attributes of the base Class.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='keyAttributes', _type='AttributeName', _html_id='Key__keyAttributes'), parenthetical='List of Attributes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Attributes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[Constraint(one_liner=[OneLiner(content=' each attribute must be a direct or inherited of the base class.\n')], elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl='', message=Paragraph(content=''), severity=None), Constraint(one_liner=[OneLiner(content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')], elaboration=[], annotations=[Annotation(label=Label(content='issue', _type='Label'), content=OneLiner(content='need ascending descending to support index keys or ordering keys.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, ocl='', message=Paragraph(content=''), severity=None)], _html_id='Key__keyAttributes')}), 'AttributeSection': defaultdict(<class 'list'>, {'isOptional': Attribute(one_liner=OneLiner(content='whether the attributes in this section, taken together, are optional.'), elaboration=[Paragraph(content='If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n')], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='isOptional', _type='AttributeName', _html_id='AttributeSection__isOptional'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Boolean', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='AttributeSection__isOptional')}), 'Attribute': defaultdict(<class 'list'>, {'name': Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='name', _type='AttributeName', _html_id='Attribute__name'), parenthetical='Lower Camel', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='LowerCamel', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=AttributeReference(class_name='CamelName', attribute_name=None), inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Attribute__name'), 'dataType': Attribute(one_liner=OneLiner(content='The kind of object to which the attribute refers.  _'), elaboration=[Paragraph(content='But,\n \n+ * List of Editions\n \n+ * Set of Edition\n \n+ * ... and more complicated cases.\n')], annotations=[Annotation(label=Label(content='see', _type='Label'), content=OneLiner(content='the section below on Data Type Specifiers.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='dataType', _type='AttributeName', _html_id='Attribute__dataType'), parenthetical='DataType', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='DataType', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Attribute__dataType')}), 'Derivation': defaultdict(<class 'list'>, {'statement': Attribute(one_liner=OneLiner(content='An English language statement of the derivation rule _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='statement', _type='AttributeName', _html_id='Derivation__statement'), parenthetical='RichText', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='RichText', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Derivation__statement'), 'expression': Attribute(one_liner=OneLiner(content='The formal expression of the derivation in a programming language _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='expression', _type='AttributeName', _html_id='Derivation__expression'), parenthetical='CodeExpression', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='CodeExpression', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Derivation__expression')}), 'Constraint': defaultdict(<class 'list'>, {'statement': Attribute(one_liner=OneLiner(content='An English language statement of the constraint _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='statement', _type='AttributeName', _html_id='Constraint__statement'), parenthetical='RichText', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='RichText', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Constraint__statement'), 'expression': Attribute(one_liner=OneLiner(content='The formal expression of the constraint in a programming language'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='expression', _type='AttributeName', _html_id='Constraint__expression'), parenthetical='e.g., OCL _(CodeExpression', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='InventedName', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Constraint__expression'), 'severity': Attribute(one_liner=None, elaboration=[CodeBlock(content='```codes\nWarning, nothing fatal; just a caution\nError, serious. Fix now\n```')], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='severity', _type='AttributeName', _html_id='Constraint__severity'), parenthetical='Code', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Code', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Constraint__severity')}), 'CodeExpression': defaultdict(<class 'list'>, {'language': Attribute(one_liner=OneLiner(content='the programming language'), elaboration=[CodeBlock(content='``` code\nOCL, Object Constraint Language\nJava, Java\n```')], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='language', _type='AttributeName', _html_id='CodeExpression__language'), parenthetical='Code', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Code', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='CodeExpression__language'), 'expression': Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='expression', _type='AttributeName', _html_id='CodeExpression__expression'), parenthetical='String', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='String', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='CodeExpression__expression')}), 'Method': defaultdict(<class 'list'>, {'parameters': Attribute(one_liner=OneLiner(content='The input parameters of the method _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='parameters', _type='AttributeName', _html_id='Method__parameters'), parenthetical='ListOf Parameters', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Parameters', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Method__parameters'), 'returnType': Attribute(one_liner=OneLiner(content='The data type of the value returned by the method _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='returnType', _type='AttributeName', _html_id='Method__returnType'), parenthetical='DataType', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='DataType', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Method__returnType')}), 'ParameterAnInputToAMethod': defaultdict(<class 'list'>, {'type': Attribute(one_liner=OneLiner(content='The data type of the parameter _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='type', _type='AttributeName', _html_id='ParameterAnInputToAMethod__type'), parenthetical='DataType', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='DataType', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='ParameterAnInputToAMethod__type'), 'cardinality': Attribute(one_liner=OneLiner(content='The cardinality of the parameter'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='cardinality', _type='AttributeName', _html_id='ParameterAnInputToAMethod__cardinality'), parenthetical='e.g., optional, required', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='InventedName', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='ParameterAnInputToAMethod__cardinality')}), 'SimpleDataTypeSubtpeOfDataType': defaultdict(<class 'list'>, {'coreClass': Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='coreClass', _type='AttributeName', _html_id='SimpleDataTypeSubtpeOfDataType__coreClass'), parenthetical='Class', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Class', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='SimpleDataTypeSubtpeOfDataType__coreClass')}), 'ComplexDataType': defaultdict(<class 'list'>, {'aggregation': Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='aggregation', _type='AttributeName', _html_id='ComplexDataType__aggregation'), parenthetical='Aggregating Operator', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='AggregatingOperator', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='ComplexDataType__aggregation'), 'aggregatedTypes': Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='aggregatedTypes', _type='AttributeName', _html_id='ComplexDataType__aggregatedTypes'), parenthetical='List of DataTypes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='DataTypes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='ComplexDataType__aggregatedTypes')}), 'AggregatingOperator': defaultdict(<class 'list'>, {'name': Attribute(one_liner=None, elaboration=[CodeBlock(content='``` code\nSetOf\nListOf\nMapping\n```')], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='name', _type='AttributeName', _html_id='AggregatingOperator__name'), parenthetical='Code', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Code', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='AggregatingOperator__name'), 'arity': Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='arity', _type='AttributeName', _html_id='AggregatingOperator__arity'), parenthetical='Integer', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Integer', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='AggregatingOperator__arity'), 'spelling': Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='spelling', _type='AttributeName', _html_id='AggregatingOperator__spelling'), parenthetical='Template', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Template', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='AggregatingOperator__spelling')}), 'CamelName': defaultdict(<class 'list'>, {'valueTheString': Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='valueTheString', _type='AttributeName', _html_id='CamelName__valueTheString'), parenthetical='String', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='String', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[Constraint(one_liner=[OneLiner(content=' Must follow the camel case naming convention and not be empty.\n')], elaboration=[], annotations=[Annotation(label=Label(content='example', _type='Label'), content=OneLiner(content='"firstName", "orderDate", "customerID"'), emoji=None, elaboration=[Paragraph(content='> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n')]), Annotation(label=Label(content='modelingNote', _type='Label'), content=OneLiner(content='* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, ocl='', message=Paragraph(content=''), severity=None)], _html_id='CamelName__valueTheString')}), 'RichText': defaultdict(<class 'list'>, {'value': Attribute(one_liner=OneLiner(content='the string content'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='value', _type='AttributeName', _html_id='RichText__value'), parenthetical='string', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='String', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='RichText__value'), 'format': Attribute(one_liner=OneLiner(content='the rich text coding language used'), elaboration=[CodeBlock(content='```code\nHTML\nMarkDown\n```')], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='format', _type='AttributeName', _html_id='RichText__format'), parenthetical='Code', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Code', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='RichText__format')}), 'OneLiner': defaultdict(<class 'list'>, {'value': Attribute(one_liner=OneLiner(content='the string content'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='value', _type='AttributeName', _html_id='OneLiner__value'), parenthetical='string', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='String', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[Constraint(one_liner=[OneLiner(content=' must not containa line break or new line character\n')], elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl='', message=" A line can't span two lines\n", severity=None)], _html_id='OneLiner__value')})})
Class:  Component
	 normalName
	 name
	 qualifiedName
	 abbreviatedName
	 oneLiner
	 elaboration
Class:  AnnotationType
	 emoji
	 emojiName
	 emojiUnicode
	 label
	 plural
	 purpose
Class:  Annotation
	 annotationType
	 label
	 emoji
	 content
Class:  LiterateDataModel
	 name
	 allSubjects
	 allClasses
Class:  Subject
	 name
	 parentSubject
	 classes
	 childSubjects
Class:  Class
	 pluralForm
	 basedOn
	 supertypes
	 subtypings
	 subtypes
	 attributes
	 attributeSections
	 constraints
	 methods
Class:  Subtyping
	 name
	 isExclusive
	 isExhaustive
	 classes
Class:  CodeType
	 isCaptive
Class:  CodeValue
	 code
	 description
Class:  Key
	 keyAttributes
Class:  AttributeSection
	 isOptional
Class:  Attribute
	 name
	 dataType
Class:  Derivation
	 statement
	 expression
Class:  Constraint
	 statement
	 expression
	 severity
Class:  CodeExpression
	 language
	 expression
Class:  Method
	 parameters
	 returnType
Class:  ParameterAnInputToAMethod
	 type
	 cardinality
Class:  SimpleDataTypeSubtpeOfDataType
	 coreClass
Class:  ComplexDataType
	 aggregation
	 aggregatedTypes
Class:  AggregatingOperator
	 name
	 arity
	 spelling
Class:  CamelName
	 valueTheString
Class:  RichText
	 value
	 format
Class:  OneLiner
	 value
Calc Dependents
b is  LiterateDataModel
AnnotationType is based on LiterateDataModel
b is  Component
Annotation is based on Component
b is  LiterateDataModel
Subject is based on LiterateDataModel
b is  LiterateModel
SubjectArea is based on LiterateModel
b is  Xyz
SubjectArea is based on Xyz
b is  Class
Subtyping is based on Class
b is  CodeType
CodeValue is based on CodeType
b is  Class
Key is based on Class
b is  Class
AttributeSection is based on Class
b is  AttributeSection
Attribute is based on AttributeSection
b is  Class
ClassConstraint is based on Class
b is  Attribute
AttributeConstraint is based on Attribute
Dependents of  LiterateDataModel  are  ['AnnotationType', 'Subject']
Dependents of  Component  are  ['Annotation']
Dependents of  LiterateModel  are  ['SubjectArea']
Class not found
Dependents of  Xyz  are  ['SubjectArea']
Class not found
Dependents of  Class  are  ['Subtyping', 'Key', 'AttributeSection', 'ClassConstraint']
Dependents of  CodeType  are  ['CodeValue']
Dependents of  AttributeSection  are  ['Attribute']
Dependents of  Attribute  are  ['AttributeConstraint']
Class: LiterateDataModel is subtype of Component via subtypes
Class: Subject is subtype of Component via subtypes
Class: SubjectArea is subtype of Subject via subtypes
Class: Class is subtype of Component via subtypes
Class: ReferenceType is subtype of Class via subtypes
Class: Key is subtype of Component via subtypes
Class: UniqueKey is subtype of Key via subtypes
Class: AttributeSection is subtype of Component via subtypes
Class: Attribute is subtype of Component via subtypes
Valuetype: Constraint is subtype of Component via subtypes
Valuetype: ClassConstraint is subtype of Constraint via subtypes
Valuetype: AttributeConstraint is subtype of Constraint via subtypes
Class: Method is subtype of Component via subtypes
Class: ParameterAnInputToAMethod is subtype of Component via subtypes
Valuetype: CamelName is subtype of String via subtypes
Valuetype: UpperCamel is subtype of CamelName via subtypes
Valuetype: LowerCamel is subtype of CamelName via subtypes
Valuetype: QualifiedCamel is subtype of String via subtypes
Class: RichText is subtype of String via subtypes
Valuetype: OneLiner is subtype of RichText via subtypes
Valuetype: String is subtype of PrimitiveType via subtypes
Valuetype: Integer is subtype of PrimitiveType via subtypes
Valuetype: Decimal is subtype of PrimitiveType via subtypes
Valuetype: Boolean is subtype of PrimitiveType via subtypes
Valuetype: Date is subtype of PrimitiveType via subtypes
Valuetype: Time is subtype of PrimitiveType via subtypes
Valuetype: DateTime is subtype of PrimitiveType via subtypes
All Subtypings
Component  => 
	subtypes: ['LiterateDataModel', 'Subject', 'Class', 'Key', 'AttributeSection', 'Attribute', 'Constraint', 'Method', 'ParameterAnInputToAMethod']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Subtyping object is  Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='LiterateDataModel', _type='ClassReference'), ClassReference(content='Subject', _type='ClassReference'), ClassReference(content='Class', _type='ClassReference'), ClassReference(content='Key', _type='ClassReference'), ClassReference(content='AttributeSection', _type='ClassReference'), ClassReference(content='Attribute', _type='ClassReference'), ClassReference(content='Constraint', _type='ClassReference'), ClassReference(content='Method', _type='ClassReference'), ClassReference(content='ParameterAnInputToAMethod', _type='ClassReference')])
Subject  => 
	subtypes: ['SubjectArea']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Subtyping object is  Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='SubjectArea', _type='ClassReference')])
Class  => 
	subtypes: ['ReferenceType']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Subtyping object is  Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='ReferenceType', _type='ClassReference')])
Key  => 
	subtypes: ['UniqueKey']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Subtyping object is  Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='UniqueKey', _type='ClassReference')])
Constraint  => 
	subtypes: ['ClassConstraint', 'AttributeConstraint']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Subtyping object is  Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='ClassConstraint', _type='ClassReference'), ClassReference(content='AttributeConstraint', _type='ClassReference')])
String  => 
	subtypes: ['CamelName', 'QualifiedCamel', 'RichText']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Subtyping object is  Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='CamelName', _type='ClassReference'), ClassReference(content='QualifiedCamel', _type='ClassReference'), ClassReference(content='RichText', _type='ClassReference')])
CamelName  => 
	subtypes: ['UpperCamel', 'LowerCamel']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Subtyping object is  Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='UpperCamel', _type='ClassReference'), ClassReference(content='LowerCamel', _type='ClassReference')])
RichText  => 
	subtypes: ['OneLiner']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Subtyping object is  Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='OneLiner', _type='ClassReference')])
PrimitiveType  => 
	subtypes: ['String', 'Integer', 'Decimal', 'Boolean', 'Date', 'Time', 'DateTime']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Subtyping object is  Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='String', _type='ClassReference'), ClassReference(content='Integer', _type='ClassReference'), ClassReference(content='Decimal', _type='ClassReference'), ClassReference(content='Boolean', _type='ClassReference'), ClassReference(content='Date', _type='ClassReference'), ClassReference(content='Time', _type='ClassReference'), ClassReference(content='DateTime', _type='ClassReference')])
CALC MROS - index has  {'Component': Class(one_liner=OneLiner(content='An element or building block of the literate data model'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='Component', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Components', presumed_plural='Components', subtype_of=[], subtypings=[Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='LiterateDataModel', _type='ClassReference'), ClassReference(content='Subject', _type='ClassReference'), ClassReference(content='Class', _type='ClassReference'), ClassReference(content='Key', _type='ClassReference'), ClassReference(content='AttributeSection', _type='ClassReference'), ClassReference(content='Attribute', _type='ClassReference'), ClassReference(content='Constraint', _type='ClassReference'), ClassReference(content='Method', _type='ClassReference'), ClassReference(content='ParameterAnInputToAMethod', _type='ClassReference')])], subtypes=[], based_on=[], dependents=[ClassReference(content='Annotation', _type='ClassReference')], is_value_type=False, where=None, constraints=[], attributes=[Attribute(one_liner=OneLiner(content='the name of the component, not in camel case'), elaboration=[], annotations=[Annotation(label=Label(content='warning', _type='Label'), content=OneLiner(content='This is a warning with emoji'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='normalName', _type='AttributeName', _html_id='Component__normalName'), parenthetical='*String*', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='String', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Component__normalName'), Attribute(one_liner=OneLiner(content='The name of the component'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='name', _type='AttributeName', _html_id='Component__name'), parenthetical='CamelName', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='CamelName', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Component__name'), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='qualifiedName', _type='AttributeName', _html_id='Component__qualifiedName'), parenthetical='*QualifiedCamel*', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='QualifiedCamel', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Component__qualifiedName'), Attribute(one_liner=OneLiner(content="a short form of the component's name, used for cross references and improved readability."), elaboration=[], annotations=[Annotation(label=Label(content='example', _type='Label'), content=OneLiner(content='"LDM" is the short form of "Literate Data Model".'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='abbreviatedName', _type='AttributeName', _html_id='Component__abbreviatedName'), parenthetical='*CamelName*', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='CamelName', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(content=' name -  how do you say name in english?\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=' x.name == y\n'), constraints=[Constraint(one_liner=[OneLiner(content=' the abbreviated name should be shorter than the actual name\n')], elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content="Does this annotation find it's way to the Constraint? YES! It's fixed!"), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, ocl=' len(abbreviatedName) < len(name)\n', message='  Why have an abbreviation longer than the name?\n', severity=' Warning\n')], _html_id='Component__abbreviatedName'), Attribute(one_liner=OneLiner(content='A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='oneLiner', _type='AttributeName', _html_id='Component__oneLiner'), parenthetical='OneLiner', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='OneLiner', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Component__oneLiner'), Attribute(one_liner=OneLiner(content='A more detailed explanation or discussion of the component _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='elaboration', _type='AttributeName', _html_id='Component__elaboration'), parenthetical='RichText', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='RichText', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Component__elaboration')], attribute_sections=[AttributeSection(one_liner=OneLiner(content='mechanical attributes'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='__', name=AttributeSectionName(content='For Machinery', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[Attribute(one_liner=OneLiner(content='Indicates whether this component is an embellishment added during post-parsing processing _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='isEmbellishment', _type='AttributeName', _html_id='Component__isEmbellishment'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Boolean', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(content=' false\n'), elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, ocl=''), constraints=[], _html_id='Component__isEmbellishment')])]), 'AnnotationType': Class(one_liner=OneLiner(content='a kind of note, or aside, used to call attention to additional information about some Component.'), elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='AnnotationType', _type='ClassName'), parenthetical=None, abbreviation=None, plural='AnnotationTypes', presumed_plural='AnnotationTypes', subtype_of=[], subtypings=[], subtypes=[], based_on=[ClassReference(content='LiterateDataModel', _type='ClassReference')], dependents=[], is_value_type=False, where=None, constraints=[], attributes=[Attribute(one_liner=OneLiner(content='an emoji'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='emoji', _type='AttributeName', _html_id='AnnotationType__emoji'), parenthetical='Emoji', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Emoji', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='AnnotationType__emoji'), Attribute(one_liner=OneLiner(content='an emoji'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='emojiName', _type='AttributeName', _html_id='AnnotationType__emojiName'), parenthetical='String', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='String', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='AnnotationType__emojiName'), Attribute(one_liner=OneLiner(content='the Unicode for the emoji'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='emojiUnicode', _type='AttributeName', _html_id='AnnotationType__emojiUnicode'), parenthetical='Unicode', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Unicode', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='AnnotationType__emojiUnicode'), Attribute(one_liner=OneLiner(content='A short label to indicate the purpose of the annotation _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='label', _type='AttributeName', _html_id='AnnotationType__label'), parenthetical='CamelName', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='CamelName', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='AnnotationType__label'), Attribute(one_liner=OneLiner(content='the plural form of the label'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='plural', _type='AttributeName', _html_id='AnnotationType__plural'), parenthetical='*UpperCamel*', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='UpperCamel', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(content=' based on label\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[], _html_id='AnnotationType__plural'), Attribute(one_liner=OneLiner(content='the intended reason for the annotation.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='purpose', _type='AttributeName', _html_id='AnnotationType__purpose'), parenthetical='OneLiner', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='OneLiner', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='AnnotationType__purpose')], attribute_sections=[]), 'Annotation': Class(one_liner=OneLiner(content='A note or comment associated with a model element'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='Annotation', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Annotations', presumed_plural='Annotations', subtype_of=[], subtypings=[], subtypes=[], based_on=[ClassReference(content='Component', _type='ClassReference')], dependents=[], is_value_type=False, where=None, constraints=[], attributes=[Attribute(one_liner=None, elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'), emoji=None, elaboration=[]), Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='Should be a Value  Type'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='annotationType', _type='AttributeName', _html_id='Annotation__annotationType'), parenthetical='optional Annotation Type', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='AnnotationType', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Annotation__annotationType'), Attribute(one_liner=OneLiner(content='A short label to indicate the purpose of the annotation _'), elaboration=[Paragraph(content='But any short label is valid.\n')], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='label', _type='AttributeName', _html_id='Annotation__label'), parenthetical='CamelName', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='CamelName', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(content=' from annotationType\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[], _html_id='Annotation__label'), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='emoji', _type='AttributeName', _html_id='Annotation__emoji'), parenthetical='optional Emoji', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Emoji', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(content=' from annotation type\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[], _html_id='Annotation__emoji'), Attribute(one_liner=OneLiner(content='The content or body of the annotation'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='content', _type='AttributeName', _html_id='Annotation__content'), parenthetical='*RichText*', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='RichText', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Annotation__content')], attribute_sections=[AttributeSection(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='__', name=AttributeSectionName(content='For Machinery', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[Attribute(one_liner=OneLiner(content='Indicates whether this annotation is an embellishment added during post-parsing processing _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='isEmbellishment', _type='AttributeName', _html_id='Annotation__isEmbellishment'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Boolean', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(content=' false\n'), elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, ocl=''), constraints=[], _html_id='Annotation__isEmbellishment')])]), 'LiterateDataModel': Class(one_liner=OneLiner(content="A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='LiterateDataModel', _type='ClassName'), parenthetical=None, abbreviation='LDM', plural='LiterateDataModels', presumed_plural='LiterateDataModels', subtype_of=[SubtypeBy(class_name=ClassReference(content='Component', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[ClassReference(content='AnnotationType', _type='ClassReference'), ClassReference(content='Subject', _type='ClassReference')], is_value_type=False, where=None, constraints=[], attributes=[Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='name', _type='AttributeName', _html_id='LiterateDataModel__name'), parenthetical='UpperCamel', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='UpperCamel', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='LiterateDataModel__name'), Attribute(one_liner=OneLiner(content='list of all classes in the model, as ordered in the\ndefinition of the model.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='allSubjects', _type='AttributeName', _html_id='LiterateDataModel__allSubjects'), parenthetical='List of Classes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Classes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=Derivation(one_liner=OneLiner(content=' gathering s.allSubjects over s in subjectAreas\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), default=None, constraints=[Constraint(one_liner=[OneLiner(content=' Subject names must be unique across the model.\n')], elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl='', message=Paragraph(content=''), severity=None)], _html_id='LiterateDataModel__allSubjects'), Attribute(one_liner=OneLiner(content='list of all classes in the model, as ordered in the definition of the model.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='allClasses', _type='AttributeName', _html_id='LiterateDataModel__allClasses'), parenthetical='List of Classes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Classes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=Derivation(one_liner=OneLiner(content=' gathering s.allClasses over s in allSubjects.\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), default=None, constraints=[Constraint(one_liner=[OneLiner(content=' Class names must be unique across the model.\n')], elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl='', message=Paragraph(content=''), severity=None)], _html_id='LiterateDataModel__allClasses')], attribute_sections=[AttributeSection(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='__', name=AttributeSectionName(content='Modeling Configuration', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='annotationTypes', _type='AttributeName', _html_id='LiterateDataModel__annotationTypes'), parenthetical='List of AnnotationTypes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='AnnotationTypes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='LiterateDataModel__annotationTypes'), Attribute(one_liner=OneLiner(content='the recommended lanquage  for expressing derivation, defaults, and constraints'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='preferredCodingLanguage', _type='AttributeName', _html_id='LiterateDataModel__preferredCodingLanguage'), parenthetical='Coding Language', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='CodingLanguage', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(content=' OCL\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[], _html_id='LiterateDataModel__preferredCodingLanguage'), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='alternateCodingLanguages', _type='AttributeName', _html_id='LiterateDataModel__alternateCodingLanguages'), parenthetical='optional List of Coding Languages', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='CodingLanguages', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='LiterateDataModel__alternateCodingLanguages'), Attribute(one_liner=OneLiner(content='the recommended lanquage  for expressing derivation, defaults, and constraints'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='preferredTemplateLanguage', _type='AttributeName', _html_id='LiterateDataModel__preferredTemplateLanguage'), parenthetical='Template Language', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='TemplateLanguage', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(content=' Handlebars\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[], _html_id='LiterateDataModel__preferredTemplateLanguage'), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='alternateTemplateLanguages', _type='AttributeName', _html_id='LiterateDataModel__alternateTemplateLanguages'), parenthetical='optional List of Template Languages', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='TemplateLanguages', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='LiterateDataModel__alternateTemplateLanguages'), Attribute(one_liner=OneLiner(content='A list of functions that require sophisticated AI-powered implementation *'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='aiFunctions', _type='AttributeName', _html_id='LiterateDataModel__aiFunctions'), parenthetical='List of String', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='String', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=Derivation(one_liner=OneLiner(content=" ['aiEnglishPlural()']\n"), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), default=None, constraints=[], _html_id='LiterateDataModel__aiFunctions')])]), 'Subject': Class(one_liner=OneLiner(content='A specific topic or theme within the model'), elaboration=[Paragraph(content='Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n')], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='Subject', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Subjects', presumed_plural='Subjects', subtype_of=[SubtypeBy(class_name=ClassReference(content='Component', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='SubjectArea', _type='ClassReference')])], subtypes=[], based_on=[ClassReference(content='LiterateDataModel', _type='ClassReference')], dependents=[], is_value_type=False, where=None, constraints=[], attributes=[Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='name', _type='AttributeName', _html_id='Subject__name'), parenthetical='UpperCamel', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='UpperCamel', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Subject__name'), Attribute(one_liner=OneLiner(content='The parent subject, if any, under which this subject is nested _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='parentSubject', _type='AttributeName', _html_id='Subject__parentSubject'), parenthetical='optional Subject', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Subject', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Subject__parentSubject'), Attribute(one_liner=OneLiner(content='The major classes related to this subject, in the order in which they should be presented _'), elaboration=[], annotations=[Annotation(label=Label(content='issue', _type='Label'), content=OneLiner(content='define chapter, section, subsection as levels?'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='classes', _type='AttributeName', _html_id='Subject__classes'), parenthetical='ListOf Classes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Classes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Subject__classes'), Attribute(one_liner=OneLiner(content='Any child subjects nested under this subject, in the order in which they should be presented _'), elaboration=[Paragraph(content='***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n')], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='childSubjects', _type='AttributeName', _html_id='Subject__childSubjects'), parenthetical='ListOf Subjects', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Subjects', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=AttributeReference(class_name=ClassReference(content='Subject', _type='ClassReference'), attribute_name=AttributeName(content='parentSubject', _type='AttributeName', _html_id='')), inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Subject__childSubjects')], attribute_sections=[]), 'SubjectArea': Class(one_liner=OneLiner(content='A main topic or area of focus within the model, containing related subjects and classes'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='SubjectArea', _type='ClassName'), parenthetical=None, abbreviation=None, plural='SubjectAreas', presumed_plural='SubjectAreas', subtype_of=[SubtypeBy(class_name=ClassReference(content='Subject', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[ClassReference(content='LiterateModel', _type='ClassReference'), ClassReference(content='Xyz', _type='ClassReference')], dependents=[], is_value_type=False, where=' parentSubject is absent\n', constraints=[], attributes=[], attribute_sections=[]), 'Class': Class(one_liner=OneLiner(content='A key entity or object type in the model, often corresponding to a real-world concept'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='Class', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Classes', presumed_plural='Classes', subtype_of=[SubtypeBy(class_name=ClassReference(content='Component', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='ReferenceType', _type='ClassReference')])], subtypes=[], based_on=[], dependents=[ClassReference(content='Subtyping', _type='ClassReference'), ClassReference(content='Key', _type='ClassReference'), ClassReference(content='AttributeSection', _type='ClassReference'), ClassReference(content='ClassConstraint', _type='ClassReference')], is_value_type=False, where=None, constraints=[Constraint(one_liner=[OneLiner(content=' Within each Class, attribute names must be unique.\n')], elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl='', message=Paragraph(content=''), severity=None)], attributes=[Attribute(one_liner=OneLiner(content='the normal English plural form of the name of the Class'), elaboration=[Paragraph(content='Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n')], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.'), emoji=None, elaboration=[Paragraph(content='The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n')])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='pluralForm', _type='AttributeName', _html_id='Class__pluralForm'), parenthetical='UpperName', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='UpperName', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(content=' the regular plural, formed by adding "s" or "es".\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[], _html_id='Class__pluralForm'), Attribute(one_liner=OneLiner(content='the Class or Classes on which this class is dependent'), elaboration=[Paragraph(content='This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n')], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='that basedOn and dependentOf are being used synonymousle in this metamodel.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='basedOn', _type='AttributeName', _html_id='Class__basedOn'), parenthetical='SetOf Classes', abbreviation=None, data_type_clause=DataTypeClause(data_type=SetDataType(element_type=BaseDataType(class_name=ClassReference(content='Classes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Class__basedOn'), Attribute(one_liner=OneLiner(content='The parent class'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='supertypes', _type='AttributeName', _html_id='Class__supertypes'), parenthetical='es', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Es', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Class__supertypes'), Attribute(one_liner=OneLiner(content='the criteria, or dimensions, by which the class can be divided into subtypes'), elaboration=[], annotations=[Annotation(label=Label(content='example', _type='Label'), content=OneLiner(content='in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='subtypings', _type='AttributeName', _html_id='Class__subtypings'), parenthetical='list of Subtypings', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Subtypings', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Class__subtypings'), Attribute(one_liner=OneLiner(content='Any subtypes or specializations of this class based on it’s subtypings. _'), elaboration=[], annotations=[Annotation(label=Label(content='example', _type='Label'), content=OneLiner(content='For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='subtypes', _type='AttributeName', _html_id='Class__subtypes'), parenthetical='ListOf Classes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Classes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Class__subtypes'), Attribute(one_liner=OneLiner(content='The attributes or properties of the class, in the order in which they should be presented _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='attributes', _type='AttributeName', _html_id='Class__attributes'), parenthetical='ListOf Attributes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Attributes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Class__attributes'), Attribute(one_liner=OneLiner(content='additional attributes or properties of the class, grouped for clarity and elaboration.  _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='attributeSections', _type='AttributeName', _html_id='Class__attributeSections'), parenthetical='ListOf AttributeSections', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='AttributeSections', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Class__attributeSections'), Attribute(one_liner=OneLiner(content='Any constraints, rules, or validations specific to this class _'), elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='Constraints may be expressed on either the Class or the Attribute. Always?'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='constraints', _type='AttributeName', _html_id='Class__constraints'), parenthetical='ListOf Constraints', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Constraints', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Class__constraints'), Attribute(one_liner=OneLiner(content='Any behaviors or operations associated with this class _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='methods', _type='AttributeName', _html_id='Class__methods'), parenthetical='ListOf Methods', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Methods', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Class__methods')], attribute_sections=[AttributeSection(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='__', name=AttributeSectionName(content='Implied Attributes', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[Attribute(one_liner=OneLiner(content='the Classes which are basedOn this Class'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='dependents', _type='AttributeName', _html_id='Class__dependents'), parenthetical='optional SetOf Classes', abbreviation=None, data_type_clause=DataTypeClause(data_type=SetDataType(element_type=BaseDataType(class_name=ClassReference(content='Classes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=None), overrides=None, inverse=AttributeReference(class_name=ClassReference(content='Class', _type='ClassReference'), attribute_name=AttributeName(content='basedOn', _type='AttributeName', _html_id='')), inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Class__dependents'), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='uniqueKeys', _type='AttributeName', _html_id='Class__uniqueKeys'), parenthetical='optional Set of UniqueKeys', abbreviation=None, data_type_clause=DataTypeClause(data_type=SetDataType(element_type=BaseDataType(class_name=ClassReference(content='UniqueKeys', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=None), overrides=None, inverse=AttributeReference(class_name=ClassReference(content='UniqueKey', _type='ClassReference'), attribute_name=AttributeName(content='basedOn', _type='AttributeName', _html_id='')), inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Class__uniqueKeys')])]), 'Subtyping': Class(one_liner=OneLiner(content='a way in which subtypes of a Class may be classified'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='Subtyping', _type='ClassName'), parenthetical='Subtype of Component', abbreviation=None, plural='Subtypings', presumed_plural='Subtypings', subtype_of=[], subtypings=[], subtypes=[], based_on=[ClassReference(content='Class', _type='ClassReference')], dependents=[], is_value_type=False, where=None, constraints=[], attributes=[Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='name', _type='AttributeName', _html_id='Subtyping__name'), parenthetical='Upper Name', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='UpperName', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Subtyping__name'), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='isExclusive', _type='AttributeName', _html_id='Subtyping__isExclusive'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Boolean', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(content=' true\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[], _html_id='Subtyping__isExclusive'), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='isExhaustive', _type='AttributeName', _html_id='Subtyping__isExhaustive'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Boolean', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(content=' true\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[], _html_id='Subtyping__isExhaustive'), Attribute(one_liner=None, elaboration=[Paragraph(content='***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n')], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='every class can have an unnamed subtyping.'), emoji=None, elaboration=[Paragraph(content='ValueType - A class that is presumed to be used a value, rather than a reference\n')])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='classes', _type='AttributeName', _html_id='Subtyping__classes'), parenthetical='List of Classes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Classes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Subtyping__classes')], attribute_sections=[]), 'ReferenceType': Class(one_liner=OneLiner(content='A class that is presumed to be used as a reference, rather than a value'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='ReferenceType', _type='ClassName'), parenthetical=None, abbreviation=None, plural='ReferenceTypes', presumed_plural='ReferenceTypes', subtype_of=[SubtypeBy(class_name=ClassReference(content='Class', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=False, where=None, constraints=[], attributes=[], attribute_sections=[]), 'CodeType': ValueType(one_liner=OneLiner(content='A data type or enumeration used in the model'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='CodeType', _type='ClassName'), parenthetical=None, abbreviation=None, plural='CodeTypes', presumed_plural='CodeTypes', subtype_of=[], subtypings=[], subtypes=[], based_on=[], dependents=[ClassReference(content='CodeValue', _type='ClassReference')], is_value_type=True, where=None, constraints=[], attributes=[Attribute(one_liner=OneLiner(content='the code type was implied by use in an attribute and is only used for that attribute'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='isCaptive', _type='AttributeName', _html_id='CodeType__isCaptive'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Boolean', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='CodeType__isCaptive')], attribute_sections=[]), 'CodeValue': ValueType(one_liner=OneLiner(content='A possible value for an enumerated data class'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='CodeValue', _type='ClassName'), parenthetical=None, abbreviation=None, plural='CodeValues', presumed_plural='CodeValues', subtype_of=[], subtypings=[], subtypes=[], based_on=[ClassReference(content='CodeType', _type='ClassReference')], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[Attribute(one_liner=OneLiner(content='A short code or abbreviationi for the value _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='code', _type='AttributeName', _html_id='CodeValue__code'), parenthetical='NameString', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='NameString', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='CodeValue__code'), Attribute(one_liner=OneLiner(content='an explanation of what the code means'), elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content="Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='description', _type='AttributeName', _html_id='CodeValue__description'), parenthetical='*RichText*', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='RichText', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='CodeValue__description')], attribute_sections=[]), 'Key': Class(one_liner=OneLiner(content='a list of attributes of a class'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='Key', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Keys', presumed_plural='Keys', subtype_of=[SubtypeBy(class_name=ClassReference(content='Component', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='UniqueKey', _type='ClassReference')])], subtypes=[], based_on=[ClassReference(content='Class', _type='ClassReference')], dependents=[], is_value_type=False, where=None, constraints=[], attributes=[Attribute(one_liner=OneLiner(content='the attributes of the base Class.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='keyAttributes', _type='AttributeName', _html_id='Key__keyAttributes'), parenthetical='List of Attributes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Attributes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[Constraint(one_liner=[OneLiner(content=' each attribute must be a direct or inherited of the base class.\n')], elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl='', message=Paragraph(content=''), severity=None), Constraint(one_liner=[OneLiner(content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')], elaboration=[], annotations=[Annotation(label=Label(content='issue', _type='Label'), content=OneLiner(content='need ascending descending to support index keys or ordering keys.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, ocl='', message=Paragraph(content=''), severity=None)], _html_id='Key__keyAttributes')], attribute_sections=[]), 'UniqueKey': Class(one_liner=OneLiner(content='a list of attributes on which instances of the base class may be keyed.'), elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='order unimportant for Unique Keys.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='UniqueKey', _type='ClassName'), parenthetical=None, abbreviation=None, plural='UniqueKeys', presumed_plural='UniqueKeys', subtype_of=[SubtypeBy(class_name=ClassReference(content='Key', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=False, where=None, constraints=[], attributes=[], attribute_sections=[]), 'AttributeSection': Class(one_liner=OneLiner(content='a group of attributes for a class that merit a shared explanation.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='AttributeSection', _type='ClassName'), parenthetical=None, abbreviation=None, plural='AttributeSections', presumed_plural='AttributeSections', subtype_of=[SubtypeBy(class_name=ClassReference(content='Component', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[ClassReference(content='Class', _type='ClassReference')], dependents=[ClassReference(content='Attribute', _type='ClassReference')], is_value_type=False, where=None, constraints=[], attributes=[Attribute(one_liner=OneLiner(content='whether the attributes in this section, taken together, are optional.'), elaboration=[Paragraph(content='If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n')], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='isOptional', _type='AttributeName', _html_id='AttributeSection__isOptional'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Boolean', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='AttributeSection__isOptional')], attribute_sections=[]), 'Attribute': Class(one_liner=OneLiner(content='A property or characteristic of a class'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='Attribute', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Attributes', presumed_plural='Attributes', subtype_of=[SubtypeBy(class_name=ClassReference(content='Component', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[ClassReference(content='AttributeSection', _type='ClassReference')], dependents=[ClassReference(content='AttributeConstraint', _type='ClassReference')], is_value_type=False, where=None, constraints=[], attributes=[Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='name', _type='AttributeName', _html_id='Attribute__name'), parenthetical='Lower Camel', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='LowerCamel', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=AttributeReference(class_name='CamelName', attribute_name=None), inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Attribute__name'), Attribute(one_liner=OneLiner(content='The kind of object to which the attribute refers.  _'), elaboration=[Paragraph(content='But,\n \n+ * List of Editions\n \n+ * Set of Edition\n \n+ * ... and more complicated cases.\n')], annotations=[Annotation(label=Label(content='see', _type='Label'), content=OneLiner(content='the section below on Data Type Specifiers.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='dataType', _type='AttributeName', _html_id='Attribute__dataType'), parenthetical='DataType', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='DataType', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Attribute__dataType')], attribute_sections=[AttributeSection(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='__', name=AttributeSectionName(content='Cardinalities', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[Attribute(one_liner=OneLiner(content='Indicates whether the attribute must have a value for every instance of the class _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='isOptional', _type='AttributeName', _html_id='Attribute__isOptional'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Boolean', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(content='*** False\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[], _html_id='Attribute__isOptional'), Attribute(one_liner=OneLiner(content='The cardinality of the relationship represented by the attribute _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='cardinality', _type='AttributeName', _html_id='Attribute__cardinality'), parenthetical='CardinalityCode', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='CardinalityCode', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), elaboration=[Paragraph(content='***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n')], annotations=[Annotation(label=Label(content='forExample', _type='Label'), content=OneLiner(content=''), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, ocl=''), constraints=[], _html_id='Attribute__cardinality'), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='author', _type='AttributeName', _html_id='Attribute__author'), parenthetical='1:1 Author', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='InventedName', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Attribute__author'), Attribute(one_liner=None, elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='how this works with optionality'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='books', _type='AttributeName', _html_id='Attribute__books'), parenthetical='optional N:M Set of Books', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='InventedName', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Attribute__books')]), AttributeSection(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='__', name=AttributeSectionName(content='Inverse Attributes', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='isInvertible', _type='AttributeName', _html_id='Attribute__isInvertible'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Boolean', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=Derivation(one_liner=OneLiner(content=' true if the data type is a class or a simple collection of members of a class.\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), default=None, constraints=[], _html_id='Attribute__isInvertible'), Attribute(one_liner=OneLiner(content='the class which contains, or would contain the inverse attribute'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='inverseClass', _type='AttributeName', _html_id='Attribute__inverseClass'), parenthetical='optional Class', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Class', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=Derivation(one_liner=OneLiner(content=' from the data type. Null unless arrribute is invertible.\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), default=None, constraints=[], _html_id='Attribute__inverseClass'), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='inverseAttribute', _type='AttributeName', _html_id='Attribute__inverseAttribute'), parenthetical='optional Attribute', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Attribute', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Attribute__inverseAttribute'), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='inverseIsOptional', _type='AttributeName', _html_id='Attribute__inverseIsOptional'), parenthetical='optional Attribute', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Attribute', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Attribute__inverseIsOptional')]), AttributeSection(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='__', name=AttributeSectionName(content='Formulas', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[Attribute(one_liner=OneLiner(content='The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'), elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.'), emoji=None, elaboration=[Paragraph(content="Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"), Paragraph(content='Last paragraph here\n')])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='default', _type='AttributeName', _html_id='Attribute__default'), parenthetical='optional Derivation', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Derivation', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Attribute__default'), Attribute(one_liner=OneLiner(content='For derived attributes, the rule or formula for calculating the value _'), elaboration=[], annotations=[Annotation(label=Label(content='issue', _type='Label'), content=OneLiner(content='on insert vs on access?'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='derivation', _type='AttributeName', _html_id='Attribute__derivation'), parenthetical='optional Derivation', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Derivation', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Attribute__derivation'), Attribute(one_liner=OneLiner(content='Any validation rules specific to this attribute _'), elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='from Class.constraints'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='constraints', _type='AttributeName', _html_id='Attribute__constraints'), parenthetical='ListOf Constraints', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Constraints', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Attribute__constraints')]), AttributeSection(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='__', name=AttributeSectionName(content='Override Tracking', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='overrides', _type='AttributeName', _html_id='Attribute__overrides'), parenthetical=None, abbreviation=None, data_type_clause=None, overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Attribute__overrides')])]), 'Derivation': ValueType(one_liner=OneLiner(content='A rule or formula for deriving the value of an attribute'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='Derivation', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Derivations', presumed_plural='Derivations', subtype_of=[], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[Attribute(one_liner=OneLiner(content='An English language statement of the derivation rule _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='statement', _type='AttributeName', _html_id='Derivation__statement'), parenthetical='RichText', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='RichText', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Derivation__statement'), Attribute(one_liner=OneLiner(content='The formal expression of the derivation in a programming language _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='expression', _type='AttributeName', _html_id='Derivation__expression'), parenthetical='CodeExpression', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='CodeExpression', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Derivation__expression')], attribute_sections=[]), 'Constraint': ValueType(one_liner=OneLiner(content='A rule, condition, or validation that must be satisfied by the model'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='Constraint', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Constraints', presumed_plural='Constraints', subtype_of=[SubtypeBy(class_name=ClassReference(content='Component', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='ClassConstraint', _type='ClassReference'), ClassReference(content='AttributeConstraint', _type='ClassReference')])], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[Attribute(one_liner=OneLiner(content='An English language statement of the constraint _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='statement', _type='AttributeName', _html_id='Constraint__statement'), parenthetical='RichText', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='RichText', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Constraint__statement'), Attribute(one_liner=OneLiner(content='The formal expression of the constraint in a programming language'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='expression', _type='AttributeName', _html_id='Constraint__expression'), parenthetical='e.g., OCL _(CodeExpression', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='InventedName', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Constraint__expression'), Attribute(one_liner=None, elaboration=[CodeBlock(content='```codes\nWarning, nothing fatal; just a caution\nError, serious. Fix now\n```')], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='severity', _type='AttributeName', _html_id='Constraint__severity'), parenthetical='Code', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Code', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Constraint__severity')], attribute_sections=[]), 'Message': ValueType(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='Message', _type='ClassName'), parenthetical='Template', abbreviation=None, plural='Messages', presumed_plural='Messages', subtype_of=[], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), 'ClassConstraint': ValueType(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='ClassConstraint', _type='ClassName'), parenthetical=None, abbreviation=None, plural='ClassConstraints', presumed_plural='ClassConstraints', subtype_of=[SubtypeBy(class_name=ClassReference(content='Constraint', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[ClassReference(content='Class', _type='ClassReference')], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), 'AttributeConstraint': ValueType(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='AttributeConstraint', _type='ClassName'), parenthetical=None, abbreviation=None, plural='AttributeConstraints', presumed_plural='AttributeConstraints', subtype_of=[SubtypeBy(class_name=ClassReference(content='Constraint', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[ClassReference(content='Attribute', _type='ClassReference')], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), 'CodeExpression': ValueType(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='CodeExpression', _type='ClassName'), parenthetical=None, abbreviation=None, plural='CodeExpressions', presumed_plural='CodeExpressions', subtype_of=[], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[Attribute(one_liner=OneLiner(content='the programming language'), elaboration=[CodeBlock(content='``` code\nOCL, Object Constraint Language\nJava, Java\n```')], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='language', _type='AttributeName', _html_id='CodeExpression__language'), parenthetical='Code', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Code', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='CodeExpression__language'), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='expression', _type='AttributeName', _html_id='CodeExpression__expression'), parenthetical='String', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='String', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='CodeExpression__expression')], attribute_sections=[]), 'Method': Class(one_liner=OneLiner(content='A behavior or operation associated with a class'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='Method', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Methods', presumed_plural='Methods', subtype_of=[SubtypeBy(class_name=ClassReference(content='Component', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=False, where=None, constraints=[], attributes=[Attribute(one_liner=OneLiner(content='The input parameters of the method _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='parameters', _type='AttributeName', _html_id='Method__parameters'), parenthetical='ListOf Parameters', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='Parameters', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Method__parameters'), Attribute(one_liner=OneLiner(content='The data type of the value returned by the method _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='returnType', _type='AttributeName', _html_id='Method__returnType'), parenthetical='DataType', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='DataType', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='Method__returnType')], attribute_sections=[]), 'ParameterAnInputToAMethod': Class(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='ParameterAnInputToAMethod', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Parameters', presumed_plural='ParameterAnInputToAMethods', subtype_of=[SubtypeBy(class_name=ClassReference(content='Component', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=False, where=None, constraints=[], attributes=[Attribute(one_liner=OneLiner(content='The data type of the parameter _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='type', _type='AttributeName', _html_id='ParameterAnInputToAMethod__type'), parenthetical='DataType', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='DataType', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='ParameterAnInputToAMethod__type'), Attribute(one_liner=OneLiner(content='The cardinality of the parameter'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='cardinality', _type='AttributeName', _html_id='ParameterAnInputToAMethod__cardinality'), parenthetical='e.g., optional, required', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='InventedName', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='ParameterAnInputToAMethod__cardinality')], attribute_sections=[]), 'DataType': ValueType(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='DataType', _type='ClassName'), parenthetical=None, abbreviation=None, plural='DataTypes', presumed_plural='DataTypes', subtype_of=[], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), 'SimpleDataTypeSubtpeOfDataType': ValueType(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='SimpleDataTypeSubtpeOfDataType', _type='ClassName'), parenthetical=None, abbreviation=None, plural='SimpleDataTypeSubtpeOfDataTypes', presumed_plural='SimpleDataTypeSubtpeOfDataTypes', subtype_of=[], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='coreClass', _type='AttributeName', _html_id='SimpleDataTypeSubtpeOfDataType__coreClass'), parenthetical='Class', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Class', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='SimpleDataTypeSubtpeOfDataType__coreClass')], attribute_sections=[]), 'ComplexDataType': ValueType(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='ComplexDataType', _type='ClassName'), parenthetical=None, abbreviation=None, plural='ComplexDataTypes', presumed_plural='ComplexDataTypes', subtype_of=[], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='aggregation', _type='AttributeName', _html_id='ComplexDataType__aggregation'), parenthetical='Aggregating Operator', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='AggregatingOperator', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='ComplexDataType__aggregation'), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='aggregatedTypes', _type='AttributeName', _html_id='ComplexDataType__aggregatedTypes'), parenthetical='List of DataTypes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(element_type=BaseDataType(class_name=ClassReference(content='DataTypes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='ComplexDataType__aggregatedTypes')], attribute_sections=[]), 'AggregatingOperator': ValueType(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='AggregatingOperator', _type='ClassName'), parenthetical=None, abbreviation=None, plural='AggregatingOperators', presumed_plural='AggregatingOperators', subtype_of=[], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[Attribute(one_liner=None, elaboration=[CodeBlock(content='``` code\nSetOf\nListOf\nMapping\n```')], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='name', _type='AttributeName', _html_id='AggregatingOperator__name'), parenthetical='Code', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Code', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='AggregatingOperator__name'), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='arity', _type='AttributeName', _html_id='AggregatingOperator__arity'), parenthetical='Integer', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Integer', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='AggregatingOperator__arity'), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='spelling', _type='AttributeName', _html_id='AggregatingOperator__spelling'), parenthetical='Template', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Template', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='AggregatingOperator__spelling')], attribute_sections=[]), 'Emoji': ValueType(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='Emoji', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Emojis', presumed_plural='Emojis', subtype_of=[], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), 'String': ValueType(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='String', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Strings', presumed_plural='Strings', subtype_of=[SubtypeBy(class_name=ClassReference(content='PrimitiveType', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='CamelName', _type='ClassReference'), ClassReference(content='QualifiedCamel', _type='ClassReference'), ClassReference(content='RichText', _type='ClassReference')])], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), 'CamelName': ValueType(one_liner=None, elaboration=[Paragraph(content='A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n')], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='CamelName', _type='ClassName'), parenthetical=None, abbreviation=None, plural='CamelNames', presumed_plural='CamelNames', subtype_of=[SubtypeBy(class_name=ClassReference(content='String', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='UpperCamel', _type='ClassReference'), ClassReference(content='LowerCamel', _type='ClassReference')])], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='valueTheString', _type='AttributeName', _html_id='CamelName__valueTheString'), parenthetical='String', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='String', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[Constraint(one_liner=[OneLiner(content=' Must follow the camel case naming convention and not be empty.\n')], elaboration=[], annotations=[Annotation(label=Label(content='example', _type='Label'), content=OneLiner(content='"firstName", "orderDate", "customerID"'), emoji=None, elaboration=[Paragraph(content='> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n')]), Annotation(label=Label(content='modelingNote', _type='Label'), content=OneLiner(content='* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, ocl='', message=Paragraph(content=''), severity=None)], _html_id='CamelName__valueTheString')], attribute_sections=[]), 'UpperCamel': ValueType(one_liner=OneLiner(content='a CamelName that begins with a capital letter'), elaboration=[], annotations=[Annotation(label=Label(content='example', _type='Label'), content=OneLiner(content='_ "Customer", "ProductCategory", "PaymentMethod"'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='UpperCamel', _type='ClassName'), parenthetical=None, abbreviation=None, plural='UpperCamels', presumed_plural='UpperCamels', subtype_of=[SubtypeBy(class_name=ClassReference(content='CamelName', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=' content begins with an upper case letter.\n', constraints=[], attributes=[], attribute_sections=[]), 'LowerCamel': ValueType(one_liner=OneLiner(content='a CamelName that begins with a lower case letter'), elaboration=[], annotations=[Annotation(label=Label(content='example', _type='Label'), content=OneLiner(content='"firstName", "orderTotal", "shippingAddress"'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='LowerCamel', _type='ClassName'), parenthetical=None, abbreviation=None, plural='LowerCamels', presumed_plural='LowerCamels', subtype_of=[SubtypeBy(class_name=ClassReference(content='CamelName', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=' content begins with a lower case letter.\n', constraints=[], attributes=[], attribute_sections=[]), 'QualifiedCamel': ValueType(one_liner=OneLiner(content='an expression consisting of Camel Names separated by periods'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='QualifiedCamel', _type='ClassName'), parenthetical=None, abbreviation=None, plural='QualifiedCamels', presumed_plural='QualifiedCamels', subtype_of=[SubtypeBy(class_name=ClassReference(content='String', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[Constraint(one_liner=[OneLiner(content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')], elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl='', message=Paragraph(content=''), severity=None)], attributes=[], attribute_sections=[]), 'RichText': Class(one_liner=OneLiner(content='A string with markup for block level formatting.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='RichText', _type='ClassName'), parenthetical=None, abbreviation=None, plural='RichTexts', presumed_plural='RichTexts', subtype_of=[SubtypeBy(class_name=ClassReference(content='String', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='OneLiner', _type='ClassReference')])], subtypes=[], based_on=[], dependents=[], is_value_type=False, where=None, constraints=[], attributes=[Attribute(one_liner=OneLiner(content='the string content'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='value', _type='AttributeName', _html_id='RichText__value'), parenthetical='string', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='String', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='RichText__value'), Attribute(one_liner=OneLiner(content='the rich text coding language used'), elaboration=[CodeBlock(content='```code\nHTML\nMarkDown\n```')], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='format', _type='AttributeName', _html_id='RichText__format'), parenthetical='Code', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Code', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[], _html_id='RichText__format')], attribute_sections=[]), 'OneLiner': ValueType(one_liner=OneLiner(content='String with markup for line level formatting.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='OneLiner', _type='ClassName'), parenthetical=None, abbreviation=None, plural='OneLiners', presumed_plural='OneLiners', subtype_of=[SubtypeBy(class_name=ClassReference(content='RichText', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[Attribute(one_liner=OneLiner(content='the string content'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(content='value', _type='AttributeName', _html_id='OneLiner__value'), parenthetical='string', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='String', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=None), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[Constraint(one_liner=[OneLiner(content=' must not containa line break or new line character\n')], elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl='', message=" A line can't span two lines\n", severity=None)], _html_id='OneLiner__value')], attribute_sections=[]), 'PrimitiveType': ValueType(one_liner=OneLiner(content='A basic, built-in data type'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='PrimitiveType', _type='ClassName'), parenthetical=None, abbreviation=None, plural='PrimitiveTypes', presumed_plural='PrimitiveTypes', subtype_of=[], subtypings=[Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='String', _type='ClassReference'), ClassReference(content='Integer', _type='ClassReference'), ClassReference(content='Decimal', _type='ClassReference'), ClassReference(content='Boolean', _type='ClassReference'), ClassReference(content='Date', _type='ClassReference'), ClassReference(content='Time', _type='ClassReference'), ClassReference(content='DateTime', _type='ClassReference')])], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), 'Integer': ValueType(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='Integer', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Integers', presumed_plural='Integers', subtype_of=[SubtypeBy(class_name=ClassReference(content='PrimitiveType', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), 'Decimal': ValueType(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='Decimal', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Decimals', presumed_plural='Decimals', subtype_of=[SubtypeBy(class_name=ClassReference(content='PrimitiveType', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), 'Boolean': ValueType(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='Boolean', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Booleans', presumed_plural='Booleans', subtype_of=[SubtypeBy(class_name=ClassReference(content='PrimitiveType', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), 'Date': ValueType(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='Date', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Dates', presumed_plural='Dates', subtype_of=[SubtypeBy(class_name=ClassReference(content='PrimitiveType', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), 'Time': ValueType(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='Time', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Times', presumed_plural='Times', subtype_of=[SubtypeBy(class_name=ClassReference(content='PrimitiveType', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), 'DateTime': ValueType(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='DateTime', _type='ClassName'), parenthetical=None, abbreviation=None, plural='DateTimes', presumed_plural='DateTimes', subtype_of=[SubtypeBy(class_name=ClassReference(content='PrimitiveType', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[])}
Calc MRO for  Component
	MRO is:  []
Calc MRO for  AnnotationType
	MRO is:  []
Calc MRO for  Annotation
	MRO is:  []
Calc MRO for  LiterateDataModel
MRO for LiterateDataModel =>  ['Component']
	MRO is:  ['Component']
Calc MRO for  Subject
MRO for Subject =>  ['Component']
	MRO is:  ['Component']
Calc MRO for  SubjectArea
MRO for SubjectArea =>  ['Subject', 'Component']
	MRO is:  ['Subject', 'Component']
Calc MRO for  Class
MRO for Class =>  ['Component']
	MRO is:  ['Component']
Calc MRO for  Subtyping
	MRO is:  []
Calc MRO for  ReferenceType
MRO for ReferenceType =>  ['Class', 'Component']
	MRO is:  ['Class', 'Component']
Calc MRO for  CodeType
	MRO is:  []
Calc MRO for  CodeValue
	MRO is:  []
Calc MRO for  Key
MRO for Key =>  ['Component']
	MRO is:  ['Component']
Calc MRO for  UniqueKey
MRO for UniqueKey =>  ['Key', 'Component']
	MRO is:  ['Key', 'Component']
Calc MRO for  AttributeSection
MRO for AttributeSection =>  ['Component']
	MRO is:  ['Component']
Calc MRO for  Attribute
MRO for Attribute =>  ['Component']
	MRO is:  ['Component']
Calc MRO for  Derivation
	MRO is:  []
Calc MRO for  Constraint
MRO for Constraint =>  ['Component']
	MRO is:  ['Component']
Calc MRO for  Message
	MRO is:  []
Calc MRO for  ClassConstraint
MRO for ClassConstraint =>  ['Constraint', 'Component']
	MRO is:  ['Constraint', 'Component']
Calc MRO for  AttributeConstraint
MRO for AttributeConstraint =>  ['Constraint', 'Component']
	MRO is:  ['Constraint', 'Component']
Calc MRO for  CodeExpression
	MRO is:  []
Calc MRO for  Method
MRO for Method =>  ['Component']
	MRO is:  ['Component']
Calc MRO for  ParameterAnInputToAMethod
MRO for ParameterAnInputToAMethod =>  ['Component']
	MRO is:  ['Component']
Calc MRO for  DataType
	MRO is:  []
Calc MRO for  SimpleDataTypeSubtpeOfDataType
	MRO is:  []
Calc MRO for  ComplexDataType
	MRO is:  []
Calc MRO for  AggregatingOperator
	MRO is:  []
Calc MRO for  Emoji
	MRO is:  []
Calc MRO for  String
MRO for String =>  ['PrimitiveType']
	MRO is:  ['PrimitiveType']
Calc MRO for  CamelName
MRO for CamelName =>  ['String', 'PrimitiveType']
	MRO is:  ['String', 'PrimitiveType']
Calc MRO for  UpperCamel
MRO for UpperCamel =>  ['CamelName', 'String', 'PrimitiveType']
	MRO is:  ['CamelName', 'String', 'PrimitiveType']
Calc MRO for  LowerCamel
MRO for LowerCamel =>  ['CamelName', 'String', 'PrimitiveType']
	MRO is:  ['CamelName', 'String', 'PrimitiveType']
Calc MRO for  QualifiedCamel
MRO for QualifiedCamel =>  ['String', 'PrimitiveType']
	MRO is:  ['String', 'PrimitiveType']
Calc MRO for  RichText
MRO for RichText =>  ['String', 'PrimitiveType']
	MRO is:  ['String', 'PrimitiveType']
Calc MRO for  OneLiner
MRO for OneLiner =>  ['RichText', 'String', 'PrimitiveType']
	MRO is:  ['RichText', 'String', 'PrimitiveType']
Calc MRO for  PrimitiveType
	MRO is:  []
Calc MRO for  Integer
MRO for Integer =>  ['PrimitiveType']
	MRO is:  ['PrimitiveType']
Calc MRO for  Decimal
MRO for Decimal =>  ['PrimitiveType']
	MRO is:  ['PrimitiveType']
Calc MRO for  Boolean
MRO for Boolean =>  ['PrimitiveType']
	MRO is:  ['PrimitiveType']
Calc MRO for  Date
MRO for Date =>  ['PrimitiveType']
	MRO is:  ['PrimitiveType']
Calc MRO for  Time
MRO for Time =>  ['PrimitiveType']
	MRO is:  ['PrimitiveType']
Calc MRO for  DateTime
MRO for DateTime =>  ['PrimitiveType']
	MRO is:  ['PrimitiveType']
0  classes in final model
0  classes in final model
Validating LiterateModel
in calc attribute, attname is  AttributeName(content='normalName', _type='AttributeName', _html_id='Component__normalName')
finding value types...
Considering Component.normalName for inversion... 
	dtc =  optional  String
	dt  =   String  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ String ]
is String in Valuetypes?
	SKIPPING Component.normalName, a  String. core type String is a value type
in calc attribute, attname is  AttributeName(content='name', _type='AttributeName', _html_id='Component__name')
finding value types...
Considering Component.name for inversion... 
	dtc =  optional  CamelName
	dt  =   CamelName  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ CamelName ]
is CamelName in Valuetypes?
	SKIPPING Component.name, a  CamelName. core type CamelName is a value type
in calc attribute, attname is  AttributeName(content='qualifiedName', _type='AttributeName', _html_id='Component__qualifiedName')
finding value types...
Considering Component.qualifiedName for inversion... 
	dtc =  optional  QualifiedCamel
	dt  =   QualifiedCamel  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ QualifiedCamel ]
is QualifiedCamel in Valuetypes?
	SKIPPING Component.qualifiedName, a  QualifiedCamel. core type QualifiedCamel is a value type
in calc attribute, attname is  AttributeName(content='abbreviatedName', _type='AttributeName', _html_id='Component__abbreviatedName')
finding value types...
Considering Component.abbreviatedName for inversion... 
	dtc =  optional  CamelName
	dt  =   CamelName  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ CamelName ]
is CamelName in Valuetypes?
	SKIPPING Component.abbreviatedName, a  CamelName. core type CamelName is a value type
in calc attribute, attname is  AttributeName(content='oneLiner', _type='AttributeName', _html_id='Component__oneLiner')
finding value types...
Considering Component.oneLiner for inversion... 
	dtc =  optional  OneLiner
	dt  =   OneLiner  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ OneLiner ]
is OneLiner in Valuetypes?
	SKIPPING Component.oneLiner, a  OneLiner. core type OneLiner is a value type
in calc attribute, attname is  AttributeName(content='elaboration', _type='AttributeName', _html_id='Component__elaboration')
finding value types...
Considering Component.elaboration for inversion... 
	dtc =  optional  RichText
	dt  =   RichText  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ RichText ]
is RichText in Valuetypes?
	Inverting Component.elaboration, a  RichText. core type RichText not a value type
validating datatype:   String
... base types are:  ['String']
	no problem with  String
validating datatype:   CamelName
... base types are:  ['CamelName']
	no problem with  CamelName
validating datatype:   QualifiedCamel
... base types are:  ['QualifiedCamel']
	no problem with  QualifiedCamel
validating datatype:   CamelName
... base types are:  ['CamelName']
	no problem with  CamelName
validating datatype:   OneLiner
... base types are:  ['OneLiner']
	no problem with  OneLiner
validating datatype:   RichText
... base types are:  ['RichText']
	no problem with  RichText
validating datatype:   Boolean
... base types are:  ['Boolean']
	no problem with  Boolean
in calc attribute, attname is  AttributeName(content='emoji', _type='AttributeName', _html_id='AnnotationType__emoji')
finding value types...
Considering AnnotationType.emoji for inversion... 
	dtc =  optional  Emoji
	dt  =   Emoji  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ Emoji ]
is Emoji in Valuetypes?
	SKIPPING AnnotationType.emoji, a  Emoji. core type Emoji is a value type
in calc attribute, attname is  AttributeName(content='emojiName', _type='AttributeName', _html_id='AnnotationType__emojiName')
finding value types...
Considering AnnotationType.emojiName for inversion... 
	dtc =  optional  String
	dt  =   String  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ String ]
is String in Valuetypes?
	SKIPPING AnnotationType.emojiName, a  String. core type String is a value type
in calc attribute, attname is  AttributeName(content='emojiUnicode', _type='AttributeName', _html_id='AnnotationType__emojiUnicode')
finding value types...
Considering AnnotationType.emojiUnicode for inversion... 
	dtc =  optional  Unicode
	dt  =   Unicode  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ Unicode ]
is Unicode in Valuetypes?
	Inverting AnnotationType.emojiUnicode, a  Unicode. core type Unicode not a value type
in calc attribute, attname is  AttributeName(content='label', _type='AttributeName', _html_id='AnnotationType__label')
finding value types...
Considering AnnotationType.label for inversion... 
	dtc =  optional  CamelName
	dt  =   CamelName  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ CamelName ]
is CamelName in Valuetypes?
	SKIPPING AnnotationType.label, a  CamelName. core type CamelName is a value type
in calc attribute, attname is  AttributeName(content='plural', _type='AttributeName', _html_id='AnnotationType__plural')
finding value types...
Considering AnnotationType.plural for inversion... 
	dtc =  optional  UpperCamel
	dt  =   UpperCamel  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ UpperCamel ]
is UpperCamel in Valuetypes?
	SKIPPING AnnotationType.plural, a  UpperCamel. core type UpperCamel is a value type
in calc attribute, attname is  AttributeName(content='purpose', _type='AttributeName', _html_id='AnnotationType__purpose')
finding value types...
Considering AnnotationType.purpose for inversion... 
	dtc =  optional  OneLiner
	dt  =   OneLiner  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ OneLiner ]
is OneLiner in Valuetypes?
	SKIPPING AnnotationType.purpose, a  OneLiner. core type OneLiner is a value type
validating datatype:   Emoji
... base types are:  ['Emoji']
	no problem with  Emoji
validating datatype:   String
... base types are:  ['String']
	no problem with  String
validating datatype:   Unicode
... base types are:  ['Unicode']
Base type error for  Unicode  in dt   Unicode
validating datatype:   CamelName
... base types are:  ['CamelName']
	no problem with  CamelName
validating datatype:   UpperCamel
... base types are:  ['UpperCamel']
	no problem with  UpperCamel
validating datatype:   OneLiner
... base types are:  ['OneLiner']
	no problem with  OneLiner
in calc attribute, attname is  AttributeName(content='annotationType', _type='AttributeName', _html_id='Annotation__annotationType')
finding value types...
Considering Annotation.annotationType for inversion... 
	dtc =  optional  AnnotationType
	dt  =   AnnotationType  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ AnnotationType ]
is AnnotationType in Valuetypes?
	Inverting Annotation.annotationType, a  AnnotationType. core type AnnotationType not a value type
in calc attribute, attname is  AttributeName(content='label', _type='AttributeName', _html_id='Annotation__label')
finding value types...
Considering Annotation.label for inversion... 
	dtc =  optional  CamelName
	dt  =   CamelName  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ CamelName ]
is CamelName in Valuetypes?
	SKIPPING Annotation.label, a  CamelName. core type CamelName is a value type
in calc attribute, attname is  AttributeName(content='emoji', _type='AttributeName', _html_id='Annotation__emoji')
finding value types...
Considering Annotation.emoji for inversion... 
	dtc =  optional  Emoji
	dt  =   Emoji  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ Emoji ]
is Emoji in Valuetypes?
	SKIPPING Annotation.emoji, a  Emoji. core type Emoji is a value type
in calc attribute, attname is  AttributeName(content='content', _type='AttributeName', _html_id='Annotation__content')
finding value types...
Considering Annotation.content for inversion... 
	dtc =  optional  RichText
	dt  =   RichText  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ RichText ]
is RichText in Valuetypes?
	Inverting Annotation.content, a  RichText. core type RichText not a value type
validating datatype:   AnnotationType
... base types are:  ['AnnotationType']
	no problem with  AnnotationType
validating datatype:   CamelName
... base types are:  ['CamelName']
	no problem with  CamelName
validating datatype:   Emoji
... base types are:  ['Emoji']
	no problem with  Emoji
validating datatype:   RichText
... base types are:  ['RichText']
	no problem with  RichText
validating datatype:   Boolean
... base types are:  ['Boolean']
	no problem with  Boolean
in calc attribute, attname is  AttributeName(content='name', _type='AttributeName', _html_id='LiterateDataModel__name')
Found override for LiterateDataModel.name in Component
Attribute name =  name
.. and as AName:  AttributeName(content='name', _type='AttributeName', _html_id='')
finding value types...
Considering LiterateDataModel.name for inversion... 
	dtc =  optional  UpperCamel
	dt  =   UpperCamel  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ UpperCamel ]
is UpperCamel in Valuetypes?
	SKIPPING LiterateDataModel.name, a  UpperCamel. core type UpperCamel is a value type
in calc attribute, attname is  AttributeName(content='allSubjects', _type='AttributeName', _html_id='LiterateDataModel__allSubjects')
finding value types...
Considering LiterateDataModel.allSubjects for inversion... 
	dtc =  optional List of  Classes
	dt  =  List of  Classes  --  <class 'Literate_01.ListDataType'>
	core type is [  Classes ]
is Classes in Valuetypes?
	Inverting LiterateDataModel.allSubjects, a List of  Classes. core type Classes not a value type
in calc attribute, attname is  AttributeName(content='allClasses', _type='AttributeName', _html_id='LiterateDataModel__allClasses')
finding value types...
Considering LiterateDataModel.allClasses for inversion... 
	dtc =  optional List of  Classes
	dt  =  List of  Classes  --  <class 'Literate_01.ListDataType'>
	core type is [  Classes ]
is Classes in Valuetypes?
	Inverting LiterateDataModel.allClasses, a List of  Classes. core type Classes not a value type
validating datatype:   UpperCamel
... base types are:  ['UpperCamel']
	no problem with  UpperCamel
validating datatype:  List of  Classes
... base types are:  ['Classes']
	no problem with  Classes
validating datatype:  List of  Classes
... base types are:  ['Classes']
	no problem with  Classes
validating datatype:  List of  AnnotationTypes
... base types are:  ['AnnotationTypes']
	no problem with  AnnotationTypes
validating datatype:   CodingLanguage
... base types are:  ['CodingLanguage']
Base type error for  CodingLanguage  in dt   CodingLanguage
validating datatype:  List of  CodingLanguages
... base types are:  ['CodingLanguages']
Base type error for  CodingLanguages  in dt  List of  CodingLanguages
validating datatype:   TemplateLanguage
... base types are:  ['TemplateLanguage']
Base type error for  TemplateLanguage  in dt   TemplateLanguage
validating datatype:  List of  TemplateLanguages
... base types are:  ['TemplateLanguages']
Base type error for  TemplateLanguages  in dt  List of  TemplateLanguages
validating datatype:  List of  String
... base types are:  ['String']
	no problem with  String
in calc attribute, attname is  AttributeName(content='name', _type='AttributeName', _html_id='Subject__name')
Found override for Subject.name in Component
Attribute name =  name
.. and as AName:  AttributeName(content='name', _type='AttributeName', _html_id='')
finding value types...
Considering Subject.name for inversion... 
	dtc =  optional  UpperCamel
	dt  =   UpperCamel  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ UpperCamel ]
is UpperCamel in Valuetypes?
	SKIPPING Subject.name, a  UpperCamel. core type UpperCamel is a value type
in calc attribute, attname is  AttributeName(content='parentSubject', _type='AttributeName', _html_id='Subject__parentSubject')
finding value types...
Considering Subject.parentSubject for inversion... 
	dtc =  optional  Subject
	dt  =   Subject  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ Subject ]
is Subject in Valuetypes?
	Inverting Subject.parentSubject, a  Subject. core type Subject not a value type
in calc attribute, attname is  AttributeName(content='classes', _type='AttributeName', _html_id='Subject__classes')
finding value types...
Considering Subject.classes for inversion... 
	dtc =  optional List of  Classes
	dt  =  List of  Classes  --  <class 'Literate_01.ListDataType'>
	core type is [  Classes ]
is Classes in Valuetypes?
	Inverting Subject.classes, a List of  Classes. core type Classes not a value type
in calc attribute, attname is  AttributeName(content='childSubjects', _type='AttributeName', _html_id='Subject__childSubjects')
finding value types...
Considering Subject.childSubjects for inversion... 
	dtc =  optional List of  Subjects
	dt  =  List of  Subjects  --  <class 'Literate_01.ListDataType'>
	core type is [  Subjects ]
is Subjects in Valuetypes?
	Inverting Subject.childSubjects, a List of  Subjects. core type Subjects not a value type
validating datatype:   UpperCamel
... base types are:  ['UpperCamel']
	no problem with  UpperCamel
validating datatype:   Subject
... base types are:  ['Subject']
	no problem with  Subject
validating datatype:  List of  Classes
... base types are:  ['Classes']
	no problem with  Classes
validating datatype:  List of  Subjects
... base types are:  ['Subjects']
	no problem with  Subjects
in calc attribute, attname is  AttributeName(content='pluralForm', _type='AttributeName', _html_id='Class__pluralForm')
finding value types...
Considering Class.pluralForm for inversion... 
	dtc =  optional  UpperName
	dt  =   UpperName  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ UpperName ]
is UpperName in Valuetypes?
	Inverting Class.pluralForm, a  UpperName. core type UpperName not a value type
in calc attribute, attname is  AttributeName(content='basedOn', _type='AttributeName', _html_id='Class__basedOn')
finding value types...
Considering Class.basedOn for inversion... 
	dtc =  optional Set of  Classes
	dt  =  Set of  Classes  --  <class 'Literate_01.SetDataType'>
	core type is [  Classes ]
is Classes in Valuetypes?
	Inverting Class.basedOn, a Set of  Classes. core type Classes not a value type
in calc attribute, attname is  AttributeName(content='supertypes', _type='AttributeName', _html_id='Class__supertypes')
finding value types...
Considering Class.supertypes for inversion... 
	dtc =  optional  Es
	dt  =   Es  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ Es ]
is Es in Valuetypes?
	Inverting Class.supertypes, a  Es. core type Es not a value type
in calc attribute, attname is  AttributeName(content='subtypings', _type='AttributeName', _html_id='Class__subtypings')
finding value types...
Considering Class.subtypings for inversion... 
	dtc =  optional List of  Subtypings
	dt  =  List of  Subtypings  --  <class 'Literate_01.ListDataType'>
	core type is [  Subtypings ]
is Subtypings in Valuetypes?
	Inverting Class.subtypings, a List of  Subtypings. core type Subtypings not a value type
in calc attribute, attname is  AttributeName(content='subtypes', _type='AttributeName', _html_id='Class__subtypes')
finding value types...
Considering Class.subtypes for inversion... 
	dtc =  optional List of  Classes
	dt  =  List of  Classes  --  <class 'Literate_01.ListDataType'>
	core type is [  Classes ]
is Classes in Valuetypes?
	Inverting Class.subtypes, a List of  Classes. core type Classes not a value type
in calc attribute, attname is  AttributeName(content='attributes', _type='AttributeName', _html_id='Class__attributes')
finding value types...
Considering Class.attributes for inversion... 
	dtc =  optional List of  Attributes
	dt  =  List of  Attributes  --  <class 'Literate_01.ListDataType'>
	core type is [  Attributes ]
is Attributes in Valuetypes?
	Inverting Class.attributes, a List of  Attributes. core type Attributes not a value type
in calc attribute, attname is  AttributeName(content='attributeSections', _type='AttributeName', _html_id='Class__attributeSections')
finding value types...
Considering Class.attributeSections for inversion... 
	dtc =  optional List of  AttributeSections
	dt  =  List of  AttributeSections  --  <class 'Literate_01.ListDataType'>
	core type is [  AttributeSections ]
is AttributeSections in Valuetypes?
	Inverting Class.attributeSections, a List of  AttributeSections. core type AttributeSections not a value type
in calc attribute, attname is  AttributeName(content='constraints', _type='AttributeName', _html_id='Class__constraints')
finding value types...
Considering Class.constraints for inversion... 
	dtc =  optional List of  Constraints
	dt  =  List of  Constraints  --  <class 'Literate_01.ListDataType'>
	core type is [  Constraints ]
is Constraints in Valuetypes?
	Inverting Class.constraints, a List of  Constraints. core type Constraints not a value type
in calc attribute, attname is  AttributeName(content='methods', _type='AttributeName', _html_id='Class__methods')
finding value types...
Considering Class.methods for inversion... 
	dtc =  optional List of  Methods
	dt  =  List of  Methods  --  <class 'Literate_01.ListDataType'>
	core type is [  Methods ]
is Methods in Valuetypes?
	Inverting Class.methods, a List of  Methods. core type Methods not a value type
validating datatype:   UpperName
... base types are:  ['UpperName']
Base type error for  UpperName  in dt   UpperName
validating datatype:  Set of  Classes
... base types are:  ['Classes']
	no problem with  Classes
validating datatype:   Es
... base types are:  ['Es']
Base type error for  Es  in dt   Es
validating datatype:  List of  Subtypings
... base types are:  ['Subtypings']
	no problem with  Subtypings
validating datatype:  List of  Classes
... base types are:  ['Classes']
	no problem with  Classes
validating datatype:  List of  Attributes
... base types are:  ['Attributes']
	no problem with  Attributes
validating datatype:  List of  AttributeSections
... base types are:  ['AttributeSections']
	no problem with  AttributeSections
validating datatype:  List of  Constraints
... base types are:  ['Constraints']
	no problem with  Constraints
validating datatype:  List of  Methods
... base types are:  ['Methods']
	no problem with  Methods
validating datatype:  Set of  Classes
... base types are:  ['Classes']
	no problem with  Classes
validating datatype:  Set of  UniqueKeys
... base types are:  ['UniqueKeys']
	no problem with  UniqueKeys
in calc attribute, attname is  AttributeName(content='name', _type='AttributeName', _html_id='Subtyping__name')
finding value types...
Considering Subtyping.name for inversion... 
	dtc =  optional  UpperName
	dt  =   UpperName  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ UpperName ]
is UpperName in Valuetypes?
	Inverting Subtyping.name, a  UpperName. core type UpperName not a value type
in calc attribute, attname is  AttributeName(content='isExclusive', _type='AttributeName', _html_id='Subtyping__isExclusive')
finding value types...
Considering Subtyping.isExclusive for inversion... 
	dtc =  optional  Boolean
	dt  =   Boolean  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ Boolean ]
is Boolean in Valuetypes?
	SKIPPING Subtyping.isExclusive, a  Boolean. core type Boolean is a value type
in calc attribute, attname is  AttributeName(content='isExhaustive', _type='AttributeName', _html_id='Subtyping__isExhaustive')
finding value types...
Considering Subtyping.isExhaustive for inversion... 
	dtc =  optional  Boolean
	dt  =   Boolean  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ Boolean ]
is Boolean in Valuetypes?
	SKIPPING Subtyping.isExhaustive, a  Boolean. core type Boolean is a value type
in calc attribute, attname is  AttributeName(content='classes', _type='AttributeName', _html_id='Subtyping__classes')
finding value types...
Considering Subtyping.classes for inversion... 
	dtc =  optional List of  Classes
	dt  =  List of  Classes  --  <class 'Literate_01.ListDataType'>
	core type is [  Classes ]
is Classes in Valuetypes?
	Inverting Subtyping.classes, a List of  Classes. core type Classes not a value type
validating datatype:   UpperName
... base types are:  ['UpperName']
Base type error for  UpperName  in dt   UpperName
validating datatype:   Boolean
... base types are:  ['Boolean']
	no problem with  Boolean
validating datatype:   Boolean
... base types are:  ['Boolean']
	no problem with  Boolean
validating datatype:  List of  Classes
... base types are:  ['Classes']
	no problem with  Classes
in calc attribute, attname is  AttributeName(content='isCaptive', _type='AttributeName', _html_id='CodeType__isCaptive')
finding value types...
Considering CodeType.isCaptive for inversion... 
	dtc =  optional  Boolean
	dt  =   Boolean  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ Boolean ]
is Boolean in Valuetypes?
	SKIPPING CodeType.isCaptive, a  Boolean. core type Boolean is a value type
validating datatype:   Boolean
... base types are:  ['Boolean']
	no problem with  Boolean
in calc attribute, attname is  AttributeName(content='code', _type='AttributeName', _html_id='CodeValue__code')
finding value types...
Considering CodeValue.code for inversion... 
	dtc =  optional  NameString
	dt  =   NameString  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ NameString ]
is NameString in Valuetypes?
	Inverting CodeValue.code, a  NameString. core type NameString not a value type
in calc attribute, attname is  AttributeName(content='description', _type='AttributeName', _html_id='CodeValue__description')
finding value types...
Considering CodeValue.description for inversion... 
	dtc =  optional  RichText
	dt  =   RichText  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ RichText ]
is RichText in Valuetypes?
	Inverting CodeValue.description, a  RichText. core type RichText not a value type
validating datatype:   NameString
... base types are:  ['NameString']
Base type error for  NameString  in dt   NameString
validating datatype:   RichText
... base types are:  ['RichText']
	no problem with  RichText
in calc attribute, attname is  AttributeName(content='keyAttributes', _type='AttributeName', _html_id='Key__keyAttributes')
finding value types...
Considering Key.keyAttributes for inversion... 
	dtc =  optional List of  Attributes
	dt  =  List of  Attributes  --  <class 'Literate_01.ListDataType'>
	core type is [  Attributes ]
is Attributes in Valuetypes?
	Inverting Key.keyAttributes, a List of  Attributes. core type Attributes not a value type
validating datatype:  List of  Attributes
... base types are:  ['Attributes']
	no problem with  Attributes
in calc attribute, attname is  AttributeName(content='isOptional', _type='AttributeName', _html_id='AttributeSection__isOptional')
finding value types...
Considering AttributeSection.isOptional for inversion... 
	dtc =  optional  Boolean
	dt  =   Boolean  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ Boolean ]
is Boolean in Valuetypes?
	SKIPPING AttributeSection.isOptional, a  Boolean. core type Boolean is a value type
validating datatype:   Boolean
... base types are:  ['Boolean']
	no problem with  Boolean
in calc attribute, attname is  AttributeName(content='name', _type='AttributeName', _html_id='Attribute__name')
Found override for Attribute.name in Component
Attribute name =  name
.. and as AName:  AttributeName(content='name', _type='AttributeName', _html_id='')
finding value types...
Considering Attribute.name for inversion... 
	dtc =  optional  LowerCamel
	dt  =   LowerCamel  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ LowerCamel ]
is LowerCamel in Valuetypes?
	SKIPPING Attribute.name, a  LowerCamel. core type LowerCamel is a value type
in calc attribute, attname is  AttributeName(content='dataType', _type='AttributeName', _html_id='Attribute__dataType')
finding value types...
Considering Attribute.dataType for inversion... 
	dtc =  optional  DataType
	dt  =   DataType  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ DataType ]
is DataType in Valuetypes?
	SKIPPING Attribute.dataType, a  DataType. core type DataType is a value type
validating datatype:   LowerCamel
... base types are:  ['LowerCamel']
	no problem with  LowerCamel
validating datatype:   DataType
... base types are:  ['DataType']
	no problem with  DataType
validating datatype:   Boolean
... base types are:  ['Boolean']
	no problem with  Boolean
validating datatype:   CardinalityCode
... base types are:  ['CardinalityCode']
Base type error for  CardinalityCode  in dt   CardinalityCode
validating datatype:  value InventedName
... base types are:  ['InventedName']
Base type error for  InventedName  in dt  value InventedName
validating datatype:  value InventedName
... base types are:  ['InventedName']
Base type error for  InventedName  in dt  value InventedName
validating datatype:   Boolean
... base types are:  ['Boolean']
	no problem with  Boolean
validating datatype:   Class
... base types are:  ['Class']
	no problem with  Class
validating datatype:   Attribute
... base types are:  ['Attribute']
	no problem with  Attribute
validating datatype:   Attribute
... base types are:  ['Attribute']
	no problem with  Attribute
validating datatype:   Derivation
... base types are:  ['Derivation']
	no problem with  Derivation
validating datatype:   Derivation
... base types are:  ['Derivation']
	no problem with  Derivation
validating datatype:  List of  Constraints
... base types are:  ['Constraints']
	no problem with  Constraints
in calc attribute, attname is  AttributeName(content='statement', _type='AttributeName', _html_id='Derivation__statement')
finding value types...
Considering Derivation.statement for inversion... 
	dtc =  optional  RichText
	dt  =   RichText  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ RichText ]
is RichText in Valuetypes?
	Inverting Derivation.statement, a  RichText. core type RichText not a value type
in calc attribute, attname is  AttributeName(content='expression', _type='AttributeName', _html_id='Derivation__expression')
finding value types...
Considering Derivation.expression for inversion... 
	dtc =  optional  CodeExpression
	dt  =   CodeExpression  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ CodeExpression ]
is CodeExpression in Valuetypes?
	SKIPPING Derivation.expression, a  CodeExpression. core type CodeExpression is a value type
validating datatype:   RichText
... base types are:  ['RichText']
	no problem with  RichText
validating datatype:   CodeExpression
... base types are:  ['CodeExpression']
	no problem with  CodeExpression
in calc attribute, attname is  AttributeName(content='statement', _type='AttributeName', _html_id='Constraint__statement')
finding value types...
Considering Constraint.statement for inversion... 
	dtc =  optional  RichText
	dt  =   RichText  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ RichText ]
is RichText in Valuetypes?
	Inverting Constraint.statement, a  RichText. core type RichText not a value type
in calc attribute, attname is  AttributeName(content='expression', _type='AttributeName', _html_id='Constraint__expression')
finding value types...
Considering Constraint.expression for inversion... 
	dtc =  optional value InventedName
	dt  =  value InventedName  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ InventedName ]
is InventedName in Valuetypes?
	Inverting Constraint.expression, a value InventedName. core type InventedName not a value type
in calc attribute, attname is  AttributeName(content='severity', _type='AttributeName', _html_id='Constraint__severity')
finding value types...
Considering Constraint.severity for inversion... 
	dtc =  optional  Code
	dt  =   Code  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ Code ]
is Code in Valuetypes?
	Inverting Constraint.severity, a  Code. core type Code not a value type
validating datatype:   RichText
... base types are:  ['RichText']
	no problem with  RichText
validating datatype:  value InventedName
... base types are:  ['InventedName']
Base type error for  InventedName  in dt  value InventedName
validating datatype:   Code
... base types are:  ['Code']
Base type error for  Code  in dt   Code
in calc attribute, attname is  AttributeName(content='language', _type='AttributeName', _html_id='CodeExpression__language')
finding value types...
Considering CodeExpression.language for inversion... 
	dtc =  optional  Code
	dt  =   Code  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ Code ]
is Code in Valuetypes?
	Inverting CodeExpression.language, a  Code. core type Code not a value type
in calc attribute, attname is  AttributeName(content='expression', _type='AttributeName', _html_id='CodeExpression__expression')
finding value types...
Considering CodeExpression.expression for inversion... 
	dtc =  optional  String
	dt  =   String  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ String ]
is String in Valuetypes?
	SKIPPING CodeExpression.expression, a  String. core type String is a value type
validating datatype:   Code
... base types are:  ['Code']
Base type error for  Code  in dt   Code
validating datatype:   String
... base types are:  ['String']
	no problem with  String
in calc attribute, attname is  AttributeName(content='parameters', _type='AttributeName', _html_id='Method__parameters')
finding value types...
Considering Method.parameters for inversion... 
	dtc =  optional List of  Parameters
	dt  =  List of  Parameters  --  <class 'Literate_01.ListDataType'>
	core type is [  Parameters ]
is Parameters in Valuetypes?
	Inverting Method.parameters, a List of  Parameters. core type Parameters not a value type
in calc attribute, attname is  AttributeName(content='returnType', _type='AttributeName', _html_id='Method__returnType')
finding value types...
Considering Method.returnType for inversion... 
	dtc =  optional  DataType
	dt  =   DataType  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ DataType ]
is DataType in Valuetypes?
	SKIPPING Method.returnType, a  DataType. core type DataType is a value type
validating datatype:  List of  Parameters
... base types are:  ['Parameters']
	no problem with  Parameters
validating datatype:   DataType
... base types are:  ['DataType']
	no problem with  DataType
in calc attribute, attname is  AttributeName(content='type', _type='AttributeName', _html_id='ParameterAnInputToAMethod__type')
finding value types...
Considering ParameterAnInputToAMethod.type for inversion... 
	dtc =  optional  DataType
	dt  =   DataType  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ DataType ]
is DataType in Valuetypes?
	SKIPPING ParameterAnInputToAMethod.type, a  DataType. core type DataType is a value type
in calc attribute, attname is  AttributeName(content='cardinality', _type='AttributeName', _html_id='ParameterAnInputToAMethod__cardinality')
finding value types...
Considering ParameterAnInputToAMethod.cardinality for inversion... 
	dtc =  optional value InventedName
	dt  =  value InventedName  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ InventedName ]
is InventedName in Valuetypes?
	Inverting ParameterAnInputToAMethod.cardinality, a value InventedName. core type InventedName not a value type
validating datatype:   DataType
... base types are:  ['DataType']
	no problem with  DataType
validating datatype:  value InventedName
... base types are:  ['InventedName']
Base type error for  InventedName  in dt  value InventedName
in calc attribute, attname is  AttributeName(content='coreClass', _type='AttributeName', _html_id='SimpleDataTypeSubtpeOfDataType__coreClass')
finding value types...
Considering SimpleDataTypeSubtpeOfDataType.coreClass for inversion... 
	dtc =  optional  Class
	dt  =   Class  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ Class ]
is Class in Valuetypes?
	Inverting SimpleDataTypeSubtpeOfDataType.coreClass, a  Class. core type Class not a value type
validating datatype:   Class
... base types are:  ['Class']
	no problem with  Class
in calc attribute, attname is  AttributeName(content='aggregation', _type='AttributeName', _html_id='ComplexDataType__aggregation')
finding value types...
Considering ComplexDataType.aggregation for inversion... 
	dtc =  optional  AggregatingOperator
	dt  =   AggregatingOperator  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ AggregatingOperator ]
is AggregatingOperator in Valuetypes?
	SKIPPING ComplexDataType.aggregation, a  AggregatingOperator. core type AggregatingOperator is a value type
in calc attribute, attname is  AttributeName(content='aggregatedTypes', _type='AttributeName', _html_id='ComplexDataType__aggregatedTypes')
finding value types...
Considering ComplexDataType.aggregatedTypes for inversion... 
	dtc =  optional List of  DataTypes
	dt  =  List of  DataTypes  --  <class 'Literate_01.ListDataType'>
	core type is [  DataTypes ]
is DataTypes in Valuetypes?
	Inverting ComplexDataType.aggregatedTypes, a List of  DataTypes. core type DataTypes not a value type
validating datatype:   AggregatingOperator
... base types are:  ['AggregatingOperator']
	no problem with  AggregatingOperator
validating datatype:  List of  DataTypes
... base types are:  ['DataTypes']
	no problem with  DataTypes
in calc attribute, attname is  AttributeName(content='name', _type='AttributeName', _html_id='AggregatingOperator__name')
finding value types...
Considering AggregatingOperator.name for inversion... 
	dtc =  optional  Code
	dt  =   Code  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ Code ]
is Code in Valuetypes?
	Inverting AggregatingOperator.name, a  Code. core type Code not a value type
in calc attribute, attname is  AttributeName(content='arity', _type='AttributeName', _html_id='AggregatingOperator__arity')
finding value types...
Considering AggregatingOperator.arity for inversion... 
	dtc =  optional  Integer
	dt  =   Integer  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ Integer ]
is Integer in Valuetypes?
	SKIPPING AggregatingOperator.arity, a  Integer. core type Integer is a value type
in calc attribute, attname is  AttributeName(content='spelling', _type='AttributeName', _html_id='AggregatingOperator__spelling')
finding value types...
Considering AggregatingOperator.spelling for inversion... 
	dtc =  optional  Template
	dt  =   Template  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ Template ]
is Template in Valuetypes?
	Inverting AggregatingOperator.spelling, a  Template. core type Template not a value type
validating datatype:   Code
... base types are:  ['Code']
Base type error for  Code  in dt   Code
validating datatype:   Integer
... base types are:  ['Integer']
	no problem with  Integer
validating datatype:   Template
... base types are:  ['Template']
Base type error for  Template  in dt   Template
in calc attribute, attname is  AttributeName(content='valueTheString', _type='AttributeName', _html_id='CamelName__valueTheString')
finding value types...
Considering CamelName.valueTheString for inversion... 
	dtc =  optional  String
	dt  =   String  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ String ]
is String in Valuetypes?
	SKIPPING CamelName.valueTheString, a  String. core type String is a value type
validating datatype:   String
... base types are:  ['String']
	no problem with  String
in calc attribute, attname is  AttributeName(content='value', _type='AttributeName', _html_id='RichText__value')
finding value types...
Considering RichText.value for inversion... 
	dtc =  optional  String
	dt  =   String  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ String ]
is String in Valuetypes?
	SKIPPING RichText.value, a  String. core type String is a value type
in calc attribute, attname is  AttributeName(content='format', _type='AttributeName', _html_id='RichText__format')
finding value types...
Considering RichText.format for inversion... 
	dtc =  optional  Code
	dt  =   Code  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ Code ]
is Code in Valuetypes?
	Inverting RichText.format, a  Code. core type Code not a value type
validating datatype:   String
... base types are:  ['String']
	no problem with  String
validating datatype:   Code
... base types are:  ['Code']
Base type error for  Code  in dt   Code
in calc attribute, attname is  AttributeName(content='value', _type='AttributeName', _html_id='OneLiner__value')
Found override for OneLiner.value in RichText
Attribute name =  value
.. and as AName:  AttributeName(content='value', _type='AttributeName', _html_id='')
finding value types...
Considering OneLiner.value for inversion... 
	dtc =  optional  String
	dt  =   String  --  <class 'Literate_01.BaseDataType'>
	a base data type2
	core type is [ String ]
is String in Valuetypes?
	SKIPPING OneLiner.value, a  String. core type String is a value type
validating datatype:   String
... base types are:  ['String']
	no problem with  String
Call to Validating references...
Before validating:  0  classes in model
Validating references
Validation class refs for  Component with att =  based_on  -  []
Validation class refs for  Component with att =  dependents  -  [ClassReference(content='Annotation', _type='ClassReference')]
Validation class refs for  AnnotationType with att =  based_on  -  [ClassReference(content='LiterateDataModel', _type='ClassReference')]
Validation class refs for  AnnotationType with att =  dependents  -  []
Validation class refs for  Annotation with att =  based_on  -  [ClassReference(content='Component', _type='ClassReference')]
Validation class refs for  Annotation with att =  dependents  -  []
Validation class refs for  LiterateDataModel with att =  based_on  -  []
Validation class refs for  LiterateDataModel with att =  dependents  -  [ClassReference(content='AnnotationType', _type='ClassReference'), ClassReference(content='Subject', _type='ClassReference')]
Validation class refs for  Subject with att =  based_on  -  [ClassReference(content='LiterateDataModel', _type='ClassReference')]
Validation class refs for  Subject with att =  dependents  -  []
Validation class refs for  SubjectArea with att =  based_on  -  [ClassReference(content='LiterateModel', _type='ClassReference'), ClassReference(content='Xyz', _type='ClassReference')]
Validation class refs for  SubjectArea with att =  dependents  -  []
Validation class refs for  Class with att =  based_on  -  []
Validation class refs for  Class with att =  dependents  -  [ClassReference(content='Subtyping', _type='ClassReference'), ClassReference(content='Key', _type='ClassReference'), ClassReference(content='AttributeSection', _type='ClassReference'), ClassReference(content='ClassConstraint', _type='ClassReference')]
Validation class refs for  Subtyping with att =  based_on  -  [ClassReference(content='Class', _type='ClassReference')]
Validation class refs for  Subtyping with att =  dependents  -  []
Validation class refs for  ReferenceType with att =  based_on  -  []
Validation class refs for  ReferenceType with att =  dependents  -  []
Validation class refs for  CodeType with att =  based_on  -  []
Validation class refs for  CodeType with att =  dependents  -  [ClassReference(content='CodeValue', _type='ClassReference')]
Validation class refs for  CodeValue with att =  based_on  -  [ClassReference(content='CodeType', _type='ClassReference')]
Validation class refs for  CodeValue with att =  dependents  -  []
Validation class refs for  Key with att =  based_on  -  [ClassReference(content='Class', _type='ClassReference')]
Validation class refs for  Key with att =  dependents  -  []
Validation class refs for  UniqueKey with att =  based_on  -  []
Validation class refs for  UniqueKey with att =  dependents  -  []
Validation class refs for  AttributeSection with att =  based_on  -  [ClassReference(content='Class', _type='ClassReference')]
Validation class refs for  AttributeSection with att =  dependents  -  [ClassReference(content='Attribute', _type='ClassReference')]
Validation class refs for  Attribute with att =  based_on  -  [ClassReference(content='AttributeSection', _type='ClassReference')]
Validation class refs for  Attribute with att =  dependents  -  [ClassReference(content='AttributeConstraint', _type='ClassReference')]
Validation class refs for  Derivation with att =  based_on  -  []
Validation class refs for  Derivation with att =  dependents  -  []
Validation class refs for  Constraint with att =  based_on  -  []
Validation class refs for  Constraint with att =  dependents  -  []
Validation class refs for  Message with att =  based_on  -  []
Validation class refs for  Message with att =  dependents  -  []
Validation class refs for  ClassConstraint with att =  based_on  -  [ClassReference(content='Class', _type='ClassReference')]
Validation class refs for  ClassConstraint with att =  dependents  -  []
Validation class refs for  AttributeConstraint with att =  based_on  -  [ClassReference(content='Attribute', _type='ClassReference')]
Validation class refs for  AttributeConstraint with att =  dependents  -  []
Validation class refs for  CodeExpression with att =  based_on  -  []
Validation class refs for  CodeExpression with att =  dependents  -  []
Validation class refs for  Method with att =  based_on  -  []
Validation class refs for  Method with att =  dependents  -  []
Validation class refs for  ParameterAnInputToAMethod with att =  based_on  -  []
Validation class refs for  ParameterAnInputToAMethod with att =  dependents  -  []
Validation class refs for  DataType with att =  based_on  -  []
Validation class refs for  DataType with att =  dependents  -  []
Validation class refs for  SimpleDataTypeSubtpeOfDataType with att =  based_on  -  []
Validation class refs for  SimpleDataTypeSubtpeOfDataType with att =  dependents  -  []
Validation class refs for  ComplexDataType with att =  based_on  -  []
Validation class refs for  ComplexDataType with att =  dependents  -  []
Validation class refs for  AggregatingOperator with att =  based_on  -  []
Validation class refs for  AggregatingOperator with att =  dependents  -  []
Validation class refs for  Emoji with att =  based_on  -  []
Validation class refs for  Emoji with att =  dependents  -  []
Validation class refs for  String with att =  based_on  -  []
Validation class refs for  String with att =  dependents  -  []
Validation class refs for  CamelName with att =  based_on  -  []
Validation class refs for  CamelName with att =  dependents  -  []
Validation class refs for  UpperCamel with att =  based_on  -  []
Validation class refs for  UpperCamel with att =  dependents  -  []
Validation class refs for  LowerCamel with att =  based_on  -  []
Validation class refs for  LowerCamel with att =  dependents  -  []
Validation class refs for  QualifiedCamel with att =  based_on  -  []
Validation class refs for  QualifiedCamel with att =  dependents  -  []
Validation class refs for  RichText with att =  based_on  -  []
Validation class refs for  RichText with att =  dependents  -  []
Validation class refs for  OneLiner with att =  based_on  -  []
Validation class refs for  OneLiner with att =  dependents  -  []
Validation class refs for  PrimitiveType with att =  based_on  -  []
Validation class refs for  PrimitiveType with att =  dependents  -  []
Validation class refs for  String with att =  based_on  -  []
Validation class refs for  String with att =  dependents  -  []
Validation class refs for  Integer with att =  based_on  -  []
Validation class refs for  Integer with att =  dependents  -  []
Validation class refs for  Decimal with att =  based_on  -  []
Validation class refs for  Decimal with att =  dependents  -  []
Validation class refs for  Boolean with att =  based_on  -  []
Validation class refs for  Boolean with att =  dependents  -  []
Validation class refs for  Date with att =  based_on  -  []
Validation class refs for  Date with att =  dependents  -  []
Validation class refs for  Time with att =  based_on  -  []
Validation class refs for  Time with att =  dependents  -  []
Validation class refs for  DateTime with att =  based_on  -  []
Validation class refs for  DateTime with att =  dependents  -  []
After validating:  0  classes in model
Validation diagnostics: 48
- Error (Tester) on Constraint named : Let's see how Constraints handle diagnostics
- Bug (Field Error) on Constraint named : For field 'one_liner' - expected typing.Optional[Literate_01.OneLiner], but got <class 'list'>
- Bug (Field Error) on Constraint named : For field 'message' - expected typing.Optional[Literate_01.Paragraph], but got <class 'str'>
- Warning (Style) on Attribute named oneLiner: oneLiner is too long. (116 chars).
- Warning (Style) on Attribute named isEmbellishment: oneLiner is too long. (91 chars).
- Warning (Style) on Class named AnnotationType: oneLiner is too long. (96 chars).
- Warning (Style) on Attribute named isEmbellishment: oneLiner is too long. (92 chars).
- Warning (Style) on Class named LiterateDataModel: oneLiner is too long. (112 chars).
- Error (Tester) on Constraint named : Let's see how Constraints handle diagnostics
- Error (NonPresence) on Constraint named : Missing value for required field: 'ocl'
- Bug (Field Error) on Constraint named : For field 'one_liner' - expected typing.Optional[Literate_01.OneLiner], but got <class 'list'>
- Error (Tester) on Constraint named : Let's see how Constraints handle diagnostics
- Error (NonPresence) on Constraint named : Missing value for required field: 'ocl'
- Bug (Field Error) on Constraint named : For field 'one_liner' - expected typing.Optional[Literate_01.OneLiner], but got <class 'list'>
- Bug (Field Error) on Class named LiterateDataModel: For field 'abbreviation' - expected typing.Optional[utils.class_casing.CamelCase], but got <class 'str'>
- Warning (Style) on Attribute named classes: oneLiner is too long. (91 chars).
- Warning (Style) on Attribute named childSubjects: oneLiner is too long. (94 chars).
- Bug (Field Error) on Class named SubjectArea: For field 'where' - expected typing.Optional[Literate_01.OneLiner], but got <class 'str'>
- Error (Tester) on Constraint named : Let's see how Constraints handle diagnostics
- Error (NonPresence) on Constraint named : Missing value for required field: 'ocl'
- Bug (Field Error) on Constraint named : For field 'one_liner' - expected typing.Optional[Literate_01.OneLiner], but got <class 'list'>
- Warning (Style) on Attribute named attributes: oneLiner is too long. (91 chars).
- Error (Tester) on Constraint named : Let's see how Constraints handle diagnostics
- Error (NonPresence) on Constraint named : Missing value for required field: 'ocl'
- Bug (Field Error) on Constraint named : For field 'one_liner' - expected typing.Optional[Literate_01.OneLiner], but got <class 'list'>
- Warning (Style) on Constraint named : Formula one_liner is too long (99 chars)
- Error (Tester) on Constraint named : Let's see how Constraints handle diagnostics
- Error (NonPresence) on Constraint named : Missing value for required field: 'ocl'
- Bug (Field Error) on Constraint named : For field 'one_liner' - expected typing.Optional[Literate_01.OneLiner], but got <class 'list'>
- Warning (Style) on Default named : Formula one_liner is too long (220 chars)
- Warning (Style) on Attribute named default: oneLiner is too long. (143 chars).
- Bug (Field Error) on Attribute named overrides: Required field 'data_type_clause' is missing
- Error (Tester) on Constraint named : Let's see how Constraints handle diagnostics
- Error (NonPresence) on Constraint named : Missing value for required field: 'ocl'
- Bug (Field Error) on Constraint named : For field 'one_liner' - expected typing.Optional[Literate_01.OneLiner], but got <class 'list'>
- Bug (Field Error) on ValueType named UpperCamel: For field 'where' - expected typing.Optional[Literate_01.OneLiner], but got <class 'str'>
- Bug (Field Error) on ValueType named LowerCamel: For field 'where' - expected typing.Optional[Literate_01.OneLiner], but got <class 'str'>
- Warning (Style) on Constraint named : Formula one_liner is too long (152 chars)
- Error (Tester) on Constraint named : Let's see how Constraints handle diagnostics
- Error (NonPresence) on Constraint named : Missing value for required field: 'ocl'
- Bug (Field Error) on Constraint named : For field 'one_liner' - expected typing.Optional[Literate_01.OneLiner], but got <class 'list'>
- Error (Tester) on Constraint named : Let's see how Constraints handle diagnostics
- Error (NonPresence) on Constraint named : Missing value for required field: 'ocl'
- Bug (Field Error) on Constraint named : For field 'one_liner' - expected typing.Optional[Literate_01.OneLiner], but got <class 'list'>
- Bug (Field Error) on Constraint named : For field 'message' - expected typing.Optional[Literate_01.Paragraph], but got <class 'str'>
- Warning (Style) on SubjectB named Appendices: oneLiner is too long. (126 chars).
- Error (Invalid class reference) on Class named SubjectArea: Invalid reference to 'LiterateModel' in based_on
- Error (Invalid class reference) on Class named SubjectArea: Invalid reference to 'Xyz' in based_on
as yaml - warnings =  False
..Created dict for validated model: ldm/ldm_models/Literate/Literate_results/Literate_PD_04.v_model.yaml

Phase: counting diagnostics
{'Error - Tester': 9, 'Bug - Field Error': 16, 'Warning - Style': 13, 'Error - NonPresence': 8, 'Error - Invalid class reference': 2}
9 	 Error - Tester
16 	 Bug - Field Error
13 	 Warning - Style
8 	 Error - NonPresence
2 	 Error - Invalid class reference
pattern is ldm/ldm_models/Literate/Literate_results/*dict*.yaml
pattern is ldm/ldm_models/Literate/Literate_results/*model*.yaml
Dict names are:  ['Literate_PD_02.dict.yaml', 'Literate_PD_03.model.yaml', 'Literate_PD_04.v_model.yaml']
All combos are:
['Literate_PD_02.dict.yaml', 'Literate_PD_03.model.yaml']
['Literate_PD_03.model.yaml', 'Literate_PD_04.v_model.yaml']
Combo is: ['Literate_PD_02.dict.yaml', 'Literate_PD_03.model.yaml']
Including:  Literate_PD_02.dict.yaml
Including:  Literate_PD_03.model.yaml
as yaml - warnings =  False
Combo is: ['Literate_PD_03.model.yaml', 'Literate_PD_04.v_model.yaml']
Including:  Literate_PD_03.model.yaml
Including:  Literate_PD_04.v_model.yaml
as yaml - warnings =  False

Phase: Skipping Render to Markdown

Phase: Skipping Render to HTML AS

Phase: Creating HTML using the Faculty
for attribute  subtypes  class_names_clause handed:  [ClassReference(content='LiterateDataModel', _type='ClassReference'), ClassReference(content='Subject', _type='ClassReference'), ClassReference(content='Class', _type='ClassReference'), ClassReference(content='Key', _type='ClassReference'), ClassReference(content='AttributeSection', _type='ClassReference'), ClassReference(content='Attribute', _type='ClassReference'), ClassReference(content='Constraint', _type='ClassReference'), ClassReference(content='Method', _type='ClassReference'), ClassReference(content='ParameterAnInputToAMethod', _type='ClassReference')]
class_names are:  ['LiterateDataModel', 'Subject', 'Class', 'Key', 'AttributeSection', 'Attribute', 'Constraint', 'Method', 'ParameterAnInputToAMethod']
class_anchors are:  [FluentTag(<a class="base_class" href="#LiterateDataModel">LiterateDataModel</a>), FluentTag(<a class="base_class" href="#Subject">Subject</a>), FluentTag(<a class="base_class" href="#Class">Class</a>), FluentTag(<a class="base_class" href="#Key">Key</a>), FluentTag(<a class="base_class" href="#AttributeSection">AttributeSection</a>), FluentTag(<a class="base_class" href="#Attribute">Attribute</a>), FluentTag(<a class="base_class" href="#Constraint">Constraint</a>), FluentTag(<a class="base_class" href="#Method">Method</a>), FluentTag(<a class="base_class" href="#ParameterAnInputToAMethod">ParameterAnInputToAMethod</a>)]
for attribute  subtypes  class_names_clause handed:  [ClassReference(content='SubjectArea', _type='ClassReference')]
class_names are:  ['SubjectArea']
class_anchors are:  [FluentTag(<a class="base_class" href="#SubjectArea">SubjectArea</a>)]
for attribute  subtypes  class_names_clause handed:  [ClassReference(content='ReferenceType', _type='ClassReference')]
class_names are:  ['ReferenceType']
class_anchors are:  [FluentTag(<a class="base_class" href="#ReferenceType">ReferenceType</a>)]
for attribute  subtypes  class_names_clause handed:  [ClassReference(content='UniqueKey', _type='ClassReference')]
class_names are:  ['UniqueKey']
class_anchors are:  [FluentTag(<a class="base_class" href="#UniqueKey">UniqueKey</a>)]
for attribute  subtypes  class_names_clause handed:  [ClassReference(content='ClassConstraint', _type='ClassReference'), ClassReference(content='AttributeConstraint', _type='ClassReference')]
class_names are:  ['ClassConstraint', 'AttributeConstraint']
class_anchors are:  [FluentTag(<a class="base_class" href="#ClassConstraint">ClassConstraint</a>), FluentTag(<a class="base_class" href="#AttributeConstraint">AttributeConstraint</a>)]
for attribute  subtypes  class_names_clause handed:  [ClassReference(content='UpperCamel', _type='ClassReference'), ClassReference(content='LowerCamel', _type='ClassReference')]
class_names are:  ['UpperCamel', 'LowerCamel']
class_anchors are:  [FluentTag(<a class="base_class" href="#UpperCamel">UpperCamel</a>), FluentTag(<a class="base_class" href="#LowerCamel">LowerCamel</a>)]
for attribute  subtypes  class_names_clause handed:  [ClassReference(content='OneLiner', _type='ClassReference')]
class_names are:  ['OneLiner']
class_anchors are:  [FluentTag(<a class="base_class" href="#OneLiner">OneLiner</a>)]
for attribute  subtypes  class_names_clause handed:  [ClassReference(content='String', _type='ClassReference'), ClassReference(content='Integer', _type='ClassReference'), ClassReference(content='Decimal', _type='ClassReference'), ClassReference(content='Boolean', _type='ClassReference'), ClassReference(content='Date', _type='ClassReference'), ClassReference(content='Time', _type='ClassReference'), ClassReference(content='DateTime', _type='ClassReference')]
class_names are:  ['String', 'Integer', 'Decimal', 'Boolean', 'Date', 'Time', 'DateTime']
class_anchors are:  [FluentTag(<a class="base_class" href="#String">String</a>), FluentTag(<a class="base_class" href="#Integer">Integer</a>), FluentTag(<a class="base_class" href="#Decimal">Decimal</a>), FluentTag(<a class="base_class" href="#Boolean">Boolean</a>), FluentTag(<a class="base_class" href="#Date">Date</a>), FluentTag(<a class="base_class" href="#Time">Time</a>), FluentTag(<a class="base_class" href="#DateTime">DateTime</a>)]
for attribute  subtypes  class_names_clause handed:  [ClassReference(content='CamelName', _type='ClassReference'), ClassReference(content='QualifiedCamel', _type='ClassReference'), ClassReference(content='RichText', _type='ClassReference')]
class_names are:  ['CamelName', 'QualifiedCamel', 'RichText']
class_anchors are:  [FluentTag(<a class="base_class" href="#CamelName">CamelName</a>), FluentTag(<a class="base_class" href="#QualifiedCamel">QualifiedCamel</a>), FluentTag(<a class="base_class" href="#RichText">RichText</a>)]
PUML png file saved to: ldm/ldm_models/Literate/Literate_results/assets/diagram1.png
PUML svg file saved to: ldm/ldm_models/Literate/Literate_results/assets/diagram1.svg
Body classes are None
Saved styled dictionary to ldm/ldm_models/Literate/Literate_results/Literate_PD_07_as.html
Body classes are ['reviewing']
Saved styled dictionary (for review) to ldm/ldm_models/Literate/Literate_results/Literate_PD_07_as.review.html

Phase: Skipping PDF creation
