
Phase: Creating schema and survey of Literate_01
Generate schema...

Phase: Parsing model: ldm/ldm_models/Literate/Literate.md
PARSING ldm/ldm_models/Literate/Literate.md

Phase: Deriving dict from parse => {yaml_dict_file}
Full header:  # Literate Data Model

Full header:  ## Preliminaries - the basic structure of the model

Full header:  _ **Component** - An element or building block of the literate data model

Full header:  - **normalName** - the name of the component, not in camel case (*String*)

Parsing annotation:  ‚ö†Ô∏è Warning: This is a warning with emoji

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': '‚ö†Ô∏è Warning', 'value': 'This is a warning with emoji'}
trimmed label is  Warning
emojis are:  [{'match_start': 0, 'match_end': 2, 'emoji': '‚ö†Ô∏è'}]
Final annoation dict is:  {'emoji': '', 'label': Label(content='warning', _type='Label'), 'content': OneLiner(content='This is a warning with emoji')}
Full header:  - **name** - The name of the component (CamelName)

Full header:  - **qualifiedName** - (*QualifiedCamel*)

Full header:  - **abbreviatedName** - a short form of the component's name, used for cross references and improved readability. (*CamelName*)

Parsing annotation:  ***Example***: "LDM" is the short form of "Literate Data Model".

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Example', 'value': '"LDM" is the short form of "Literate Data Model".'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='example', _type='Label'), 'content': OneLiner(content='"LDM" is the short form of "Literate Data Model".')}
derive_clause_dict for DEFAULT: ***Default***: name -  how do you say name in english?
Using handlers:  ParseTrivial()
adding name value. one_liner -.  name -  how do you say name in english?

thedict[one_liner] = {'_type': 'OneLiner', 'content': ' name -  how do you say name in english?\n'}
{'one_liner': {'_type': 'OneLiner', 'content': ' name -  how do you say name in english?\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' name -  how do you say name in english?\n'}}
Calling absorb with line type:  MajorClause(line_label='DEFAULT', priority=1, class_started='Default', word='Default', attribute_name='one_liner', is_list=False, is_cum=False, special_pattern='', plural='one_liner_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*Default[_\\*:]*')
Dict for Formula {'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': ' name -  how do you say name in english?\n'}}
derive_clause_dict for OCL: ocl: x.name == y
Using handlers:  ParseTrivial()
adding name value. ocl -.  x.name == y

thedict[ocl] =  x.name == y

{'ocl': ' x.name == y\n'}
Clause line dict is {'ocl': ' x.name == y\n'}
Calling absorb with line type:  MinorClause(line_label='OCL', priority=1, word='ocl', attribute_name='ocl', is_list=False, is_cum=False, special_pattern='', plural='ocl_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*ocl[_\\*:]*')
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: ***Default***: name -  how do you say name in english?
_ _ OCL: ocl: x.name == y

DerivedDict for Part:  Default
{'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': ' name -  how do you say name in english?\n'}, 'ocl': ' x.name == y\n'}
derive_clause_dict for CONSTRAINT: constraint: the abbreviated name should be shorter than the actual name
Using handlers:  ParseTrivial()
adding name value. one_liner -.  the abbreviated name should be shorter than the actual name

thedict[one_liner] = {'_type': 'OneLiner', 'content': ' the abbreviated name should be shorter than the actual name\n'}
{'one_liner': {'_type': 'OneLiner', 'content': ' the abbreviated name should be shorter than the actual name\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' the abbreviated name should be shorter than the actual name\n'}}
Calling absorb with line type:  MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*')
Dict for Formula {'_type': 'Constraint', 'one_liner': {'_type': 'OneLiner', 'content': ' the abbreviated name should be shorter than the actual name\n'}}
derive_clause_dict for OCL: ocl: len(abbreviatedName) < len(name)
Using handlers:  ParseTrivial()
adding name value. ocl -.  len(abbreviatedName) < len(name)

thedict[ocl] =  len(abbreviatedName) < len(name)

{'ocl': ' len(abbreviatedName) < len(name)\n'}
Clause line dict is {'ocl': ' len(abbreviatedName) < len(name)\n'}
Calling absorb with line type:  MinorClause(line_label='OCL', priority=1, word='ocl', attribute_name='ocl', is_list=False, is_cum=False, special_pattern='', plural='ocl_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*ocl[_\\*:]*')
derive_clause_dict for SEVERITY: severity: Warning
Using handlers:  ParseTrivial()
adding name value. severity -.  Warning

thedict[severity] =  Warning

{'severity': ' Warning\n'}
Clause line dict is {'severity': ' Warning\n'}
Calling absorb with line type:  MinorClause(line_label='SEVERITY', priority=1, word='severity', attribute_name='severity', is_list=False, is_cum=False, special_pattern='', plural='severity_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*severity[_\\*:]*')
derive_clause_dict for MESSAGE: message:  Why have an abbreviation longer than the name?
Using handlers:  ParseTrivial()
adding name value. message -.   Why have an abbreviation longer than the name?

thedict[message] =   Why have an abbreviation longer than the name?

{'message': '  Why have an abbreviation longer than the name?\n'}
Clause line dict is {'message': '  Why have an abbreviation longer than the name?\n'}
Calling absorb with line type:  MinorClause(line_label='MESSAGE', priority=1, word='message', attribute_name='message', is_list=False, is_cum=False, special_pattern='', plural='message_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*message[_\\*:]*')
Parsing annotation:  Note: Does this annotation find it's way to the Constraint? YES! It's fixed!

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': "Does this annotation find it's way to the Constraint? YES! It's fixed!"}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content="Does this annotation find it's way to the Constraint? YES! It's fixed!")}
. Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ CONSTRAINT: constraint: the abbreviated name should be shorter than the actual name
_ _ OCL: ocl: len(abbreviatedName) < len(name)
_ _ SEVERITY: severity: Warning
_ _ MESSAGE: message:  Why have an abbreviation longer than the name?
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ NOTE: Note: Does this annotation find it's way to the Constraint? YES! It's fixed!

DerivedDict for Part:  Constraint
{'_type': 'Constraint', 'one_liner': {'_type': 'OneLiner', 'content': ' the abbreviated name should be shorter than the actual name\n'}, 'ocl': ' len(abbreviatedName) < len(name)\n', 'severity': ' Warning\n', 'message': '  Why have an abbreviation longer than the name?\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': {'_type': 'Label', 'content': 'note'}, 'content': {'_type': 'OneLiner', 'content': "Does this annotation find it's way to the Constraint? YES! It's fixed!"}}]}
Full header:  - **oneLiner** - A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _(OneLiner)_

Full header:  - **elaboration** - A more detailed explanation or discussion of the component _(RichText)_

Full header:  __  ***For Machinery*** - mechanical attributes

Full header:  - **isEmbellishment** - Indicates whether this component is an embellishment added during post-parsing processing _(Boolean)_

derive_clause_dict for DEFAULT: üîÑ ***Default***: false
Using handlers:  ParseTrivial()
adding name value. one_liner -.  false

thedict[one_liner] = {'_type': 'OneLiner', 'content': ' false\n'}
{'one_liner': {'_type': 'OneLiner', 'content': ' false\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' false\n'}}
Calling absorb with line type:  MajorClause(line_label='DEFAULT', priority=1, class_started='Default', word='Default', attribute_name='one_liner', is_list=False, is_cum=False, special_pattern='', plural='one_liner_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*Default[_\\*:]*')
Dict for Formula {'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': ' false\n'}}
Parsing annotation:  ‚ÑπÔ∏è ***Note***: This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': '‚ÑπÔ∏è Note', 'value': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}
trimmed label is  Note
emojis are:  [{'match_start': 0, 'match_end': 2, 'emoji': '‚ÑπÔ∏è'}]
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.')}
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: üîÑ ***Default***: false
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ NOTE: ‚ÑπÔ∏è ***Note***: This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.

DerivedDict for Part:  Default
{'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': ' false\n'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': {'_type': 'Label', 'content': 'note'}, 'content': {'_type': 'OneLiner', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}}]}
Full header:  _ **AnnotationType** - a kind of note, or aside, used to call attention to additional information about some Component.

derive_clause_dict for BASED_ON: ***Based on*** : Literate Data Model
Using handlers:  ParseNameList()
ParseNameList returning:  [ClassReference(content='LiterateDataModel', _type='ClassReference')]
adding name value. based on -. [ClassReference(content='LiterateDataModel', _type='ClassReference')]
thedict[based on] = [ClassReference(content='LiterateDataModel', _type='ClassReference')]
{'based on': [ClassReference(content='LiterateDataModel', _type='ClassReference')]}
Clause line dict is {'based on': [ClassReference(content='LiterateDataModel', _type='ClassReference')]}
Using ATT_NAME  based_on for based on
Adding value in ddforpart. based_on -. [ClassReference(content='LiterateDataModel', _type='ClassReference')]
Calling absorb with line type:  MinorClause(line_label='BASED_ON', priority=1, word='based on', attribute_name='based on', is_list=True, is_cum=True, special_pattern='', plural='based on', handlers=ParseNameList(), kw_pattern='[_\\*]*based\\s?on[_\\*:]*')
Parsing annotation:  ***Note***: Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.
But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.
Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.')}
Full header:  - **emoji** - an emoji (Emoji)

Full header:  - **emojiName** - an emoji (String)

Full header:  - **emojiUnicode** - the Unicode for the emoji (String)

Full header:  - **label** - A short label to indicate the purpose of the annotation _(LowerCamel)_

Full header:  - **plural** - the plural form of the label (*UpperCamel*).

derive_clause_dict for DEFAULT: Default: based on label
Using handlers:  ParseTrivial()
adding name value. one_liner -.  based on label

thedict[one_liner] = {'_type': 'OneLiner', 'content': ' based on label\n'}
{'one_liner': {'_type': 'OneLiner', 'content': ' based on label\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' based on label\n'}}
Calling absorb with line type:  MajorClause(line_label='DEFAULT', priority=1, class_started='Default', word='Default', attribute_name='one_liner', is_list=False, is_cum=False, special_pattern='', plural='one_liner_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*Default[_\\*:]*')
Dict for Formula {'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': ' based on label\n'}}
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: Default: based on label

DerivedDict for Part:  Default
{'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': ' based on label\n'}}
Full header:  - **Purpose** - the intended reason for the annotation. (OneLiner)

Full header:  _ **Annotation**  - A note or comment associated with a model element

derive_clause_dict for BASED_ON: ***Based on***: Component
Using handlers:  ParseNameList()
ParseNameList returning:  [ClassReference(content='Component', _type='ClassReference')]
adding name value. based on -. [ClassReference(content='Component', _type='ClassReference')]
thedict[based on] = [ClassReference(content='Component', _type='ClassReference')]
{'based on': [ClassReference(content='Component', _type='ClassReference')]}
Clause line dict is {'based on': [ClassReference(content='Component', _type='ClassReference')]}
Using ATT_NAME  based_on for based on
Adding value in ddforpart. based_on -. [ClassReference(content='Component', _type='ClassReference')]
Calling absorb with line type:  MinorClause(line_label='BASED_ON', priority=1, word='based on', attribute_name='based on', is_list=True, is_cum=True, special_pattern='', plural='based on', handlers=ParseNameList(), kw_pattern='[_\\*]*based\\s?on[_\\*:]*')
Full header:  - **annotationType** - (optional Annotation Type)

Parsing annotation:  Note: An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.')}
Parsing annotation:  Note: Should be a Value  Type

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'Should be a Value  Type'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='Should be a Value  Type')}
Full header:  - **label** - A short label to indicate the purpose of the annotation _(CamelName)_

derive_clause_dict for DEFAULT: Default: from annotationType
Using handlers:  ParseTrivial()
adding name value. one_liner -.  from annotationType

thedict[one_liner] = {'_type': 'OneLiner', 'content': ' from annotationType\n'}
{'one_liner': {'_type': 'OneLiner', 'content': ' from annotationType\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' from annotationType\n'}}
Calling absorb with line type:  MajorClause(line_label='DEFAULT', priority=1, class_started='Default', word='Default', attribute_name='one_liner', is_list=False, is_cum=False, special_pattern='', plural='one_liner_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*Default[_\\*:]*')
Dict for Formula {'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': ' from annotationType\n'}}
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: Default: from annotationType

DerivedDict for Part:  Default
{'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': ' from annotationType\n'}}
Full header:  - **Emoji** - (optional Emoji)

derive_clause_dict for DEFAULT: Default: from annotation type
Using handlers:  ParseTrivial()
adding name value. one_liner -.  from annotation type

thedict[one_liner] = {'_type': 'OneLiner', 'content': ' from annotation type\n'}
{'one_liner': {'_type': 'OneLiner', 'content': ' from annotation type\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' from annotation type\n'}}
Calling absorb with line type:  MajorClause(line_label='DEFAULT', priority=1, class_started='Default', word='Default', attribute_name='one_liner', is_list=False, is_cum=False, special_pattern='', plural='one_liner_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*Default[_\\*:]*')
Dict for Formula {'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': ' from annotation type\n'}}
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: Default: from annotation type

DerivedDict for Part:  Default
{'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': ' from annotation type\n'}}
Full header:  - **content** - The content or body of the annotation (*RichText*)‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã

Full header:  __***For Machinery***

Full header:  - **isEmbellishment** - Indicates whether this annotation is an embellishment added during post-parsing processing _(Boolean)_

derive_clause_dict for DEFAULT: üîÑ ***Default***: false
Using handlers:  ParseTrivial()
adding name value. one_liner -.  false

thedict[one_liner] = {'_type': 'OneLiner', 'content': ' false\n'}
{'one_liner': {'_type': 'OneLiner', 'content': ' false\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' false\n'}}
Calling absorb with line type:  MajorClause(line_label='DEFAULT', priority=1, class_started='Default', word='Default', attribute_name='one_liner', is_list=False, is_cum=False, special_pattern='', plural='one_liner_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*Default[_\\*:]*')
Dict for Formula {'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': ' false\n'}}
Parsing annotation:  ‚ÑπÔ∏è ***Note***: This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': '‚ÑπÔ∏è Note', 'value': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}
trimmed label is  Note
emojis are:  [{'match_start': 0, 'match_end': 2, 'emoji': '‚ÑπÔ∏è'}]
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.')}
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: üîÑ ***Default***: false
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ NOTE: ‚ÑπÔ∏è ***Note***: This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.

DerivedDict for Part:  Default
{'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': ' false\n'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': {'_type': 'Label', 'content': 'note'}, 'content': {'_type': 'OneLiner', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}}]}
Full header:  ## The Model and its Subjects

Full header:  _ **LiterateDataModel** - A representation of a domain's entities, attributes, and relationships,
along with explanatory text and examples
derive_clause_dict for ABBREVIATION: ***Abbreviation***: LDM
Using handlers:  ParseName()
adding name value. abbreviation -. LDM
thedict[abbreviation] = LDM
{'abbreviation': 'LDM'}
Clause line dict is {'abbreviation': 'LDM'}
Calling absorb with line type:  MinorClause(line_label='ABBREVIATION', priority=1, word='abbreviation', attribute_name='abbreviation', is_list=False, is_cum=False, special_pattern='', plural='abbreviation_s', handlers=ParseName(), kw_pattern='[_\\*]*abbreviation[_\\*:]*')
derive_clause_dict for PLURAL: Plural: LiterateDataModels
Using handlers:  ParseTrivial()
adding name value. plural -.  LiterateDataModels

thedict[plural] =  LiterateDataModels

{'plural': ' LiterateDataModels\n'}
Clause line dict is {'plural': ' LiterateDataModels\n'}
Calling absorb with line type:  MinorClause(line_label='PLURAL', priority=1, word='plural', attribute_name='plural', is_list=False, is_cum=False, special_pattern='', plural='plural_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*plural[_\\*:]*')
derive_clause_dict for SUBTYPE_OF: Subtype of: Component
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   Component

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
Full header:  - name (UpperCamel )

Full header:  - allSubjects - list of all classes in the model, as ordered in the
definition of the model. (List of Classes)
derive_clause_dict for DERIVATION: Derivation: gathering s.allSubjects over s in subjectAreas
Using handlers:  ParseTrivial()
adding name value. one_liner -.  gathering s.allSubjects over s in subjectAreas

thedict[one_liner] = {'_type': 'OneLiner', 'content': ' gathering s.allSubjects over s in subjectAreas\n'}
{'one_liner': {'_type': 'OneLiner', 'content': ' gathering s.allSubjects over s in subjectAreas\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' gathering s.allSubjects over s in subjectAreas\n'}}
Calling absorb with line type:  MajorClause(line_label='DERIVATION', priority=1, class_started='Derivation', word='Derivation', attribute_name='one_liner', is_list=False, is_cum=False, special_pattern='', plural='one_liner_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*Derivation[_\\*:]*')
Dict for Formula {'_type': 'Derivation', 'one_liner': {'_type': 'OneLiner', 'content': ' gathering s.allSubjects over s in subjectAreas\n'}}
. Derivation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DERIVATION: Derivation: gathering s.allSubjects over s in subjectAreas

DerivedDict for Part:  Derivation
{'_type': 'Derivation', 'one_liner': {'_type': 'OneLiner', 'content': ' gathering s.allSubjects over s in subjectAreas\n'}}
derive_clause_dict for CONSTRAINT: ***Constraint***: Subject names must be unique across the model.
Using handlers:  ParseTrivial()
adding name value. one_liner -.  Subject names must be unique across the model.

thedict[one_liner] = {'_type': 'OneLiner', 'content': ' Subject names must be unique across the model.\n'}
{'one_liner': {'_type': 'OneLiner', 'content': ' Subject names must be unique across the model.\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' Subject names must be unique across the model.\n'}}
Calling absorb with line type:  MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*')
Dict for Formula {'_type': 'Constraint', 'one_liner': {'_type': 'OneLiner', 'content': ' Subject names must be unique across the model.\n'}}
. Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ CONSTRAINT: ***Constraint***: Subject names must be unique across the model.

DerivedDict for Part:  Constraint
{'_type': 'Constraint', 'one_liner': {'_type': 'OneLiner', 'content': ' Subject names must be unique across the model.\n'}}
Full header:  - allClasses - list of all classes in the model, as ordered in the definition of the model. (List of Classes)

derive_clause_dict for DERIVATION: Derivation: gathering s.allClasses over s in allSubjects.
Using handlers:  ParseTrivial()
adding name value. one_liner -.  gathering s.allClasses over s in allSubjects.

thedict[one_liner] = {'_type': 'OneLiner', 'content': ' gathering s.allClasses over s in allSubjects.\n'}
{'one_liner': {'_type': 'OneLiner', 'content': ' gathering s.allClasses over s in allSubjects.\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' gathering s.allClasses over s in allSubjects.\n'}}
Calling absorb with line type:  MajorClause(line_label='DERIVATION', priority=1, class_started='Derivation', word='Derivation', attribute_name='one_liner', is_list=False, is_cum=False, special_pattern='', plural='one_liner_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*Derivation[_\\*:]*')
Dict for Formula {'_type': 'Derivation', 'one_liner': {'_type': 'OneLiner', 'content': ' gathering s.allClasses over s in allSubjects.\n'}}
. Derivation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DERIVATION: Derivation: gathering s.allClasses over s in allSubjects.

DerivedDict for Part:  Derivation
{'_type': 'Derivation', 'one_liner': {'_type': 'OneLiner', 'content': ' gathering s.allClasses over s in allSubjects.\n'}}
derive_clause_dict for CONSTRAINT: ***Constraint***: Class names must be unique across the model.
Using handlers:  ParseTrivial()
adding name value. one_liner -.  Class names must be unique across the model.

thedict[one_liner] = {'_type': 'OneLiner', 'content': ' Class names must be unique across the model.\n'}
{'one_liner': {'_type': 'OneLiner', 'content': ' Class names must be unique across the model.\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' Class names must be unique across the model.\n'}}
Calling absorb with line type:  MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*')
Dict for Formula {'_type': 'Constraint', 'one_liner': {'_type': 'OneLiner', 'content': ' Class names must be unique across the model.\n'}}
. Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ CONSTRAINT: ***Constraint***: Class names must be unique across the model.

DerivedDict for Part:  Constraint
{'_type': 'Constraint', 'one_liner': {'_type': 'OneLiner', 'content': ' Class names must be unique across the model.\n'}}
Full header:  __ 	***Modeling Configuration***

Full header:  - **annotationTypes** - (List of AnnotationTypes)

Full header:  - **Preferred Coding Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Coding Language).

derive_clause_dict for DEFAULT: Default: OCL
Using handlers:  ParseTrivial()
adding name value. one_liner -.  OCL

thedict[one_liner] = {'_type': 'OneLiner', 'content': ' OCL\n'}
{'one_liner': {'_type': 'OneLiner', 'content': ' OCL\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' OCL\n'}}
Calling absorb with line type:  MajorClause(line_label='DEFAULT', priority=1, class_started='Default', word='Default', attribute_name='one_liner', is_list=False, is_cum=False, special_pattern='', plural='one_liner_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*Default[_\\*:]*')
Dict for Formula {'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': ' OCL\n'}}
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: Default: OCL

DerivedDict for Part:  Default
{'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': ' OCL\n'}}
Full header:  - **alternate Coding Languages** -  (optional List of Coding Languages).

Full header:  - **Preferred Template Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Template Language).

derive_clause_dict for DEFAULT: Default: Handlebars
Using handlers:  ParseTrivial()
adding name value. one_liner -.  Handlebars

thedict[one_liner] = {'_type': 'OneLiner', 'content': ' Handlebars\n'}
{'one_liner': {'_type': 'OneLiner', 'content': ' Handlebars\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' Handlebars\n'}}
Calling absorb with line type:  MajorClause(line_label='DEFAULT', priority=1, class_started='Default', word='Default', attribute_name='one_liner', is_list=False, is_cum=False, special_pattern='', plural='one_liner_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*Default[_\\*:]*')
Dict for Formula {'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': ' Handlebars\n'}}
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: Default: Handlebars

DerivedDict for Part:  Default
{'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': ' Handlebars\n'}}
Full header:  - **alternate Template Languages** -  (optional List of Template Languages).

Full header:  - **aiFunctions** - A list of functions that require sophisticated AI-powered implementation *(List of String)*

derive_clause_dict for DERIVATION: Derivation: ['aiEnglishPlural()']
Using handlers:  ParseTrivial()
adding name value. one_liner -.  ['aiEnglishPlural()']

thedict[one_liner] = {'_type': 'OneLiner', 'content': " ['aiEnglishPlural()']\n"}
{'one_liner': {'_type': 'OneLiner', 'content': " ['aiEnglishPlural()']\n"}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': " ['aiEnglishPlural()']\n"}}
Calling absorb with line type:  MajorClause(line_label='DERIVATION', priority=1, class_started='Derivation', word='Derivation', attribute_name='one_liner', is_list=False, is_cum=False, special_pattern='', plural='one_liner_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*Derivation[_\\*:]*')
Dict for Formula {'_type': 'Derivation', 'one_liner': {'_type': 'OneLiner', 'content': " ['aiEnglishPlural()']\n"}}
. Derivation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DERIVATION: Derivation: ['aiEnglishPlural()']

DerivedDict for Part:  Derivation
{'_type': 'Derivation', 'one_liner': {'_type': 'OneLiner', 'content': " ['aiEnglishPlural()']\n"}}
Full header:  _ **Subject**  - A specific topic or theme within the model

derive_clause_dict for PLURAL: Plural: Subjects
Using handlers:  ParseTrivial()
adding name value. plural -.  Subjects

thedict[plural] =  Subjects

{'plural': ' Subjects\n'}
Clause line dict is {'plural': ' Subjects\n'}
Calling absorb with line type:  MinorClause(line_label='PLURAL', priority=1, word='plural', attribute_name='plural', is_list=False, is_cum=False, special_pattern='', plural='plural_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*plural[_\\*:]*')
derive_clause_dict for SUBTYPE_OF: Subtype of: Component
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   Component

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
derive_clause_dict for BASED_ON: based on: LiterateDataModel
Using handlers:  ParseNameList()
ParseNameList returning:  [ClassReference(content='LiterateDataModel', _type='ClassReference')]
adding name value. based on -. [ClassReference(content='LiterateDataModel', _type='ClassReference')]
thedict[based on] = [ClassReference(content='LiterateDataModel', _type='ClassReference')]
{'based on': [ClassReference(content='LiterateDataModel', _type='ClassReference')]}
Clause line dict is {'based on': [ClassReference(content='LiterateDataModel', _type='ClassReference')]}
Using ATT_NAME  based_on for based on
Adding value in ddforpart. based_on -. [ClassReference(content='LiterateDataModel', _type='ClassReference')]
Calling absorb with line type:  MinorClause(line_label='BASED_ON', priority=1, word='based on', attribute_name='based on', is_list=True, is_cum=True, special_pattern='', plural='based on', handlers=ParseNameList(), kw_pattern='[_\\*]*based\\s?on[_\\*:]*')
Full header:  - name (UpperCamel )

Full header:  - **parentSubject** - The parent subject, if any, under which this subject is nested _(optional Subject)_

Full header:  - **Classes** - The major classes related to this subject, in the order in which they should be presented _(ListOf Classes)_

Parsing annotation:  ***Issue***: define chapter, section, subsection as levels?
***DSL***: Generally, it is best to present the classes within a Subject in top down order...
* Each Class should be followed first by the classes that are dependent on it, and then
* By its subtype classes.
Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Issue', 'value': 'define chapter, section, subsection as levels?'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='issue', _type='Label'), 'content': OneLiner(content='define chapter, section, subsection as levels?')}
Full header:  - **childSubjects** - Any child subjects nested under this subject, in the order in which they should be presented _(ListOf Subjects)_

derive_clause_dict for INVERSE: inverse of: Subject.parentSubject.
Using handlers:  ParseAttributeReference()
adding name value. inverse -. {'_type': 'AttributeReference', 'class_name': ClassReference(content='Subject', _type='ClassReference'), 'attribute_name': AttributeName(content='parentSubject', _type='AttributeName', _html_id=None)}
thedict[inverse] = {'_type': 'AttributeReference', 'class_name': ClassReference(content='Subject', _type='ClassReference'), 'attribute_name': AttributeName(content='parentSubject', _type='AttributeName', _html_id=None)}
{'inverse': {'_type': 'AttributeReference', 'class_name': ClassReference(content='Subject', _type='ClassReference'), 'attribute_name': AttributeName(content='parentSubject', _type='AttributeName', _html_id=None)}}
Clause line dict is {'inverse': {'_type': 'AttributeReference', 'class_name': ClassReference(content='Subject', _type='ClassReference'), 'attribute_name': AttributeName(content='parentSubject', _type='AttributeName', _html_id=None)}}
Calling absorb with line type:  MinorClause(line_label='INVERSE', priority=1, word='inverse', attribute_name='inverse', is_list=False, is_cum=False, special_pattern='', plural='inverse_s', handlers=ParseAttributeReference(), kw_pattern='[_\\*]*inverse[_\\*:]*')
Full header:  _ **SubjectArea**  - A main topic or area of focus within the model, containing related subjects and classes

derive_clause_dict for PLURAL: Plural: SubjectAreas
Using handlers:  ParseTrivial()
adding name value. plural -.  SubjectAreas

thedict[plural] =  SubjectAreas

{'plural': ' SubjectAreas\n'}
Clause line dict is {'plural': ' SubjectAreas\n'}
Calling absorb with line type:  MinorClause(line_label='PLURAL', priority=1, word='plural', attribute_name='plural', is_list=False, is_cum=False, special_pattern='', plural='plural_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*plural[_\\*:]*')
derive_clause_dict for SUBTYPE_OF: Subtype of: Subject
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   Subject

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Subject', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Subject', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Subject', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Subject', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Subject', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Subject', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
derive_clause_dict for WHERE: Where: parentSubject is absent
Using handlers:  ParseTrivial()
adding name value. where -.  parentSubject is absent

thedict[where] =  parentSubject is absent

{'where': ' parentSubject is absent\n'}
Clause line dict is {'where': ' parentSubject is absent\n'}
Calling absorb with line type:  MinorClause(line_label='WHERE', priority=1, word='where', attribute_name='where', is_list=False, is_cum=False, special_pattern='', plural='where_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*where[_\\*:]*')
derive_clause_dict for BASED_ON: based on: Literate Model, XYZ
Using handlers:  ParseNameList()
ParseNameList returning:  [ClassReference(content='LiterateModel', _type='ClassReference'), ClassReference(content='Xyz', _type='ClassReference')]
adding name value. based on -. [ClassReference(content='LiterateModel', _type='ClassReference'), ClassReference(content='Xyz', _type='ClassReference')]
thedict[based on] = [ClassReference(content='LiterateModel', _type='ClassReference'), ClassReference(content='Xyz', _type='ClassReference')]
{'based on': [ClassReference(content='LiterateModel', _type='ClassReference'), ClassReference(content='Xyz', _type='ClassReference')]}
Clause line dict is {'based on': [ClassReference(content='LiterateModel', _type='ClassReference'), ClassReference(content='Xyz', _type='ClassReference')]}
Using ATT_NAME  based_on for based on
Adding value in ddforpart. based_on -. [ClassReference(content='LiterateModel', _type='ClassReference'), ClassReference(content='Xyz', _type='ClassReference')]
Calling absorb with line type:  MinorClause(line_label='BASED_ON', priority=1, word='based on', attribute_name='based on', is_list=True, is_cum=True, special_pattern='', plural='based on', handlers=ParseNameList(), kw_pattern='[_\\*]*based\\s?on[_\\*:]*')
Full header:  ### Classes

Full header:  _ **Class** - A key entity or object type in the model, often corresponding to a real-world concept

derive_clause_dict for PLURAL: Plural: Classes
Using handlers:  ParseTrivial()
adding name value. plural -.  Classes

thedict[plural] =  Classes

{'plural': ' Classes\n'}
Clause line dict is {'plural': ' Classes\n'}
Calling absorb with line type:  MinorClause(line_label='PLURAL', priority=1, word='plural', attribute_name='plural', is_list=False, is_cum=False, special_pattern='', plural='plural_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*plural[_\\*:]*')
derive_clause_dict for SUBTYPE_OF: Subtype of: Component
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   Component

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
derive_clause_dict for CONSTRAINT: ***Constraint***: Within each Class, attribute names must be unique.
Using handlers:  ParseTrivial()
adding name value. one_liner -.  Within each Class, attribute names must be unique.

thedict[one_liner] = {'_type': 'OneLiner', 'content': ' Within each Class, attribute names must be unique.\n'}
{'one_liner': {'_type': 'OneLiner', 'content': ' Within each Class, attribute names must be unique.\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' Within each Class, attribute names must be unique.\n'}}
Calling absorb with line type:  MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*')
Dict for Formula {'_type': 'Constraint', 'one_liner': {'_type': 'OneLiner', 'content': ' Within each Class, attribute names must be unique.\n'}}
. Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ CONSTRAINT: ***Constraint***: Within each Class, attribute names must be unique.

DerivedDict for Part:  Constraint
{'_type': 'Constraint', 'one_liner': {'_type': 'OneLiner', 'content': ' Within each Class, attribute names must be unique.\n'}}
Full header:  - **pluralForm** - the normal English plural form of the name of the Class (UpperCamel)

Parsing annotation:  Note: When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.')}
derive_clause_dict for DEFAULT: ***Default***: the regular plural, formed by adding "s" or "es".
Using handlers:  ParseTrivial()
adding name value. one_liner -.  the regular plural, formed by adding "s" or "es".

thedict[one_liner] = {'_type': 'OneLiner', 'content': ' the regular plural, formed by adding "s" or "es".\n'}
{'one_liner': {'_type': 'OneLiner', 'content': ' the regular plural, formed by adding "s" or "es".\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' the regular plural, formed by adding "s" or "es".\n'}}
Calling absorb with line type:  MajorClause(line_label='DEFAULT', priority=1, class_started='Default', word='Default', attribute_name='one_liner', is_list=False, is_cum=False, special_pattern='', plural='one_liner_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*Default[_\\*:]*')
Dict for Formula {'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': ' the regular plural, formed by adding "s" or "es".\n'}}
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: ***Default***: the regular plural, formed by adding "s" or "es".

DerivedDict for Part:  Default
{'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': ' the regular plural, formed by adding "s" or "es".\n'}}
Full header:  - **basedOn** - the Class or Classes on which this class is dependent (SetOf Class).

Parsing annotation:  Note: that basedOn and dependentOf are being used synonymousle in this metamodel.
ToDo - fix that
Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='that basedOn and dependentOf are being used synonymousle in this metamodel.')}
Full header:  - **supertypes** - The parent class(es) from which this class inherits attributes (ListOf Classes)

Full header:  - **subtypings** - the criteria, or dimensions, by which the class can be divided into subtypes (list of Subtypings).

Parsing annotation:  Example: in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Example', 'value': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='example', _type='Label'), 'content': OneLiner(content='in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).')}
Full header:  - **subtypes** - Any subtypes or specializations of this class based on it‚Äôs subtypings. (ListOf Classes)

Parsing annotation:  Example: For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Example', 'value': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='example', _type='Label'), 'content': OneLiner(content='For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.')}
Full header:  - **attributes** - The attributes or properties of the class, in the order in which they should be presented _(ListOf Attributes)_

Full header:  - **attributeSections** - additional attributes or properties of the class, grouped for clarity and elaboration.  _(ListOf AttributeSections)_

Full header:  - **constraints** - Any constraints, rules, or validations specific to this class _(ListOf Constraints)_

Parsing annotation:  Note: Constraints may be expressed on either the Class or the Attribute. Always?
Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.
Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'Constraints may be expressed on either the Class or the Attribute. Always?'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='Constraints may be expressed on either the Class or the Attribute. Always?')}
Full header:  - **methods** - Any behaviors or operations associated with this class _(ListOf Methods)_

Full header:  __  ***Implied Attributes***

Full header:  - **dependents** - the Classes which are basedOn this Class (optional SetOf Classes).

derive_clause_dict for INVERSE: ***Inverse of***: Class.basedOn
Using handlers:  ParseAttributeReference()
adding name value. inverse -. {'_type': 'AttributeReference', 'class_name': ClassReference(content='Class', _type='ClassReference'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName', _html_id=None)}
thedict[inverse] = {'_type': 'AttributeReference', 'class_name': ClassReference(content='Class', _type='ClassReference'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName', _html_id=None)}
{'inverse': {'_type': 'AttributeReference', 'class_name': ClassReference(content='Class', _type='ClassReference'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName', _html_id=None)}}
Clause line dict is {'inverse': {'_type': 'AttributeReference', 'class_name': ClassReference(content='Class', _type='ClassReference'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName', _html_id=None)}}
Calling absorb with line type:  MinorClause(line_label='INVERSE', priority=1, word='inverse', attribute_name='inverse', is_list=False, is_cum=False, special_pattern='', plural='inverse_s', handlers=ParseAttributeReference(), kw_pattern='[_\\*]*inverse[_\\*:]*')
Full header:  - UniqueKeys - (optional Set of UniqueKeys).

derive_clause_dict for INVERSE: ***Inverse of***:UniqueKey.basedOn
Using handlers:  ParseAttributeReference()
adding name value. inverse -. {'_type': 'AttributeReference', 'class_name': ClassReference(content='UniqueKey', _type='ClassReference'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName', _html_id=None)}
thedict[inverse] = {'_type': 'AttributeReference', 'class_name': ClassReference(content='UniqueKey', _type='ClassReference'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName', _html_id=None)}
{'inverse': {'_type': 'AttributeReference', 'class_name': ClassReference(content='UniqueKey', _type='ClassReference'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName', _html_id=None)}}
Clause line dict is {'inverse': {'_type': 'AttributeReference', 'class_name': ClassReference(content='UniqueKey', _type='ClassReference'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName', _html_id=None)}}
Calling absorb with line type:  MinorClause(line_label='INVERSE', priority=1, word='inverse', attribute_name='inverse', is_list=False, is_cum=False, special_pattern='', plural='inverse_s', handlers=ParseAttributeReference(), kw_pattern='[_\\*]*inverse[_\\*:]*')
Full header:  _ **Subtyping** - a way in which subtypes of a Class may be classified (Subtype of Component).

derive_clause_dict for BASED_ON: ***based on:*** Class
Using handlers:  ParseNameList()
ParseNameList returning:  [ClassReference(content='Class', _type='ClassReference')]
adding name value. based on -. [ClassReference(content='Class', _type='ClassReference')]
thedict[based on] = [ClassReference(content='Class', _type='ClassReference')]
{'based on': [ClassReference(content='Class', _type='ClassReference')]}
Clause line dict is {'based on': [ClassReference(content='Class', _type='ClassReference')]}
Using ATT_NAME  based_on for based on
Adding value in ddforpart. based_on -. [ClassReference(content='Class', _type='ClassReference')]
Calling absorb with line type:  MinorClause(line_label='BASED_ON', priority=1, word='based on', attribute_name='based on', is_list=True, is_cum=True, special_pattern='', plural='based on', handlers=ParseNameList(), kw_pattern='[_\\*]*based\\s?on[_\\*:]*')
Full header:  - **name** (LowerCamel).
Usually ByThis or ByThat
Full header:  - **is exclusive** (Boolean).

derive_clause_dict for DEFAULT: Default: true
Using handlers:  ParseTrivial()
adding name value. one_liner -.  true

thedict[one_liner] = {'_type': 'OneLiner', 'content': ' true\n'}
{'one_liner': {'_type': 'OneLiner', 'content': ' true\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' true\n'}}
Calling absorb with line type:  MajorClause(line_label='DEFAULT', priority=1, class_started='Default', word='Default', attribute_name='one_liner', is_list=False, is_cum=False, special_pattern='', plural='one_liner_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*Default[_\\*:]*')
Dict for Formula {'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': ' true\n'}}
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: Default: true

DerivedDict for Part:  Default
{'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': ' true\n'}}
Full header:  - **is exhaustive** (Boolean).

derive_clause_dict for DEFAULT: Default: true
Using handlers:  ParseTrivial()
adding name value. one_liner -.  true

thedict[one_liner] = {'_type': 'OneLiner', 'content': ' true\n'}
{'one_liner': {'_type': 'OneLiner', 'content': ' true\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' true\n'}}
Calling absorb with line type:  MajorClause(line_label='DEFAULT', priority=1, class_started='Default', word='Default', attribute_name='one_liner', is_list=False, is_cum=False, special_pattern='', plural='one_liner_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*Default[_\\*:]*')
Dict for Formula {'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': ' true\n'}}
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: Default: true

DerivedDict for Part:  Default
{'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': ' true\n'}}
Full header:  - **classes** (List of Classes).

Parsing annotation:  Note: every class can have an unnamed subtyping.
Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.
Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'every class can have an unnamed subtyping.'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='every class can have an unnamed subtyping.')}
derive_clause_dict for SUBTYPE_OF: Subtype of: Class
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   Class

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Class', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Class', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Class', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Class', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Class', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Class', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
Full header:  _ **Reference Type** - A class that is presumed to be used as a reference, rather than a value

derive_clause_dict for SUBTYPE_OF: Subtype of: Class
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   Class

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Class', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Class', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Class', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Class', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Class', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Class', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
Full header:  ValueType:  **CodeType**   - A data type or enumeration used in the model

raw name = CodeType, deep = None
Full header:  - isCaptive - the code type was implied by use in an attribute and is only used for that attribute (Boolean)

Full header:  ValueType:  **Code Value** - A possible value for an enumerated data class

raw name = Code Value, deep = None
derive_clause_dict for BASED_ON: based on: CodeType
Using handlers:  ParseNameList()
ParseNameList returning:  [ClassReference(content='CodeType', _type='ClassReference')]
adding name value. based on -. [ClassReference(content='CodeType', _type='ClassReference')]
thedict[based on] = [ClassReference(content='CodeType', _type='ClassReference')]
{'based on': [ClassReference(content='CodeType', _type='ClassReference')]}
Clause line dict is {'based on': [ClassReference(content='CodeType', _type='ClassReference')]}
Using ATT_NAME  based_on for based on
Adding value in ddforpart. based_on -. [ClassReference(content='CodeType', _type='ClassReference')]
Calling absorb with line type:  MinorClause(line_label='BASED_ON', priority=1, word='based on', attribute_name='based on', is_list=True, is_cum=True, special_pattern='', plural='based on', handlers=ParseNameList(), kw_pattern='[_\\*]*based\\s?on[_\\*:]*')
Full header:  - **code** - A short code or abbreviationi for the value _(NameString)_

Full header:  - **description** - an explanation of what the code means (*RichText*)

Parsing annotation:  Note: Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:
* List the code values as a bulletted list inside the description of the attribute in the form
‚Äò**code**: description‚Äô
* A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.
Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content="Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:")}
Full header:  _ **Key** - a list of attributes of a class

derive_clause_dict for SUBTYPE_OF: Subtype of: Component
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   Component

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
derive_clause_dict for BASED_ON: basedOn: Class
Using handlers:  ParseNameList()
ParseNameList returning:  [ClassReference(content='Class', _type='ClassReference')]
adding name value. based on -. [ClassReference(content='Class', _type='ClassReference')]
thedict[based on] = [ClassReference(content='Class', _type='ClassReference')]
{'based on': [ClassReference(content='Class', _type='ClassReference')]}
Clause line dict is {'based on': [ClassReference(content='Class', _type='ClassReference')]}
Using ATT_NAME  based_on for based on
Adding value in ddforpart. based_on -. [ClassReference(content='Class', _type='ClassReference')]
Calling absorb with line type:  MinorClause(line_label='BASED_ON', priority=1, word='based on', attribute_name='based on', is_list=True, is_cum=True, special_pattern='', plural='based on', handlers=ParseNameList(), kw_pattern='[_\\*]*based\\s?on[_\\*:]*')
Full header:  - keyAttributes - the attributes of the base Class. (List of Attributes ).

derive_clause_dict for CONSTRAINT: Constraint: each attribute must be a direct or inherited of the base class.
Using handlers:  ParseTrivial()
adding name value. one_liner -.  each attribute must be a direct or inherited of the base class.

thedict[one_liner] = {'_type': 'OneLiner', 'content': ' each attribute must be a direct or inherited of the base class.\n'}
{'one_liner': {'_type': 'OneLiner', 'content': ' each attribute must be a direct or inherited of the base class.\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' each attribute must be a direct or inherited of the base class.\n'}}
Calling absorb with line type:  MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*')
Dict for Formula {'_type': 'Constraint', 'one_liner': {'_type': 'OneLiner', 'content': ' each attribute must be a direct or inherited of the base class.\n'}}
. Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ CONSTRAINT: Constraint: each attribute must be a direct or inherited of the base class.

DerivedDict for Part:  Constraint
{'_type': 'Constraint', 'one_liner': {'_type': 'OneLiner', 'content': ' each attribute must be a direct or inherited of the base class.\n'}}
derive_clause_dict for CONSTRAINT: Constraint: no repetitions allowed in keyAttributes> üëç **Issue**: introduce PureLists?
Using handlers:  ParseTrivial()
adding name value. one_liner -.  no repetitions allowed in keyAttributes
> üëç **Issue**: introduce PureLists?
thedict[one_liner] = {'_type': 'OneLiner', 'content': ' no repetitions allowed in keyAttributes\n> üëç **Issue**: introduce PureLists?'}
{'one_liner': {'_type': 'OneLiner', 'content': ' no repetitions allowed in keyAttributes\n> üëç **Issue**: introduce PureLists?'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' no repetitions allowed in keyAttributes\n> üëç **Issue**: introduce PureLists?'}}
Calling absorb with line type:  MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*')
Dict for Formula {'_type': 'Constraint', 'one_liner': {'_type': 'OneLiner', 'content': ' no repetitions allowed in keyAttributes\n> üëç **Issue**: introduce PureLists?'}}
Parsing annotation:  Issue: need ascending descending to support index keys or ordering keys.

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Issue', 'value': 'need ascending descending to support index keys or ordering keys.'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='issue', _type='Label'), 'content': OneLiner(content='need ascending descending to support index keys or ordering keys.')}
. Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ CONSTRAINT: Constraint: no repetitions allowed in keyAttributes> üëç **Issue**: introduce PureLists?
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ ISSUE: Issue: need ascending descending to support index keys or ordering keys.

DerivedDict for Part:  Constraint
{'_type': 'Constraint', 'one_liner': {'_type': 'OneLiner', 'content': ' no repetitions allowed in keyAttributes\n> üëç **Issue**: introduce PureLists?'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': {'_type': 'Label', 'content': 'issue'}, 'content': {'_type': 'OneLiner', 'content': 'need ascending descending to support index keys or ordering keys.'}}]}
Full header:  _ **UniqueKey** - a list of attributes on which instances of the base class may be keyed.

derive_clause_dict for SUBTYPE_OF: Subtype of: Key
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   Key

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Key', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Key', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Key', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Key', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Key', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Key', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
Parsing annotation:  Note: order unimportant for Unique Keys.

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'order unimportant for Unique Keys.'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='order unimportant for Unique Keys.')}
Full header:  ## Attributes

Full header:  _ **Attribute Section** - a group of attributes for a class that merit a shared explanation.

derive_clause_dict for SUBTYPE_OF: ***SubtypeOf***: Component.
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   Component.

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
derive_clause_dict for BASED_ON: ***Based on***: Class
Using handlers:  ParseNameList()
ParseNameList returning:  [ClassReference(content='Class', _type='ClassReference')]
adding name value. based on -. [ClassReference(content='Class', _type='ClassReference')]
thedict[based on] = [ClassReference(content='Class', _type='ClassReference')]
{'based on': [ClassReference(content='Class', _type='ClassReference')]}
Clause line dict is {'based on': [ClassReference(content='Class', _type='ClassReference')]}
Using ATT_NAME  based_on for based on
Adding value in ddforpart. based_on -. [ClassReference(content='Class', _type='ClassReference')]
Calling absorb with line type:  MinorClause(line_label='BASED_ON', priority=1, word='based on', attribute_name='based on', is_list=True, is_cum=True, special_pattern='', plural='based on', handlers=ParseNameList(), kw_pattern='[_\\*]*based\\s?on[_\\*:]*')
Full header:  -	isOptional - whether the attributes in this section, taken together, are optional. (Boolean)

Full header:  _ **Attribute**  - A property or characteristic of a class

derive_clause_dict for PLURAL: Plural: Attributes
Using handlers:  ParseTrivial()
adding name value. plural -.  Attributes

thedict[plural] =  Attributes

{'plural': ' Attributes\n'}
Clause line dict is {'plural': ' Attributes\n'}
Calling absorb with line type:  MinorClause(line_label='PLURAL', priority=1, word='plural', attribute_name='plural', is_list=False, is_cum=False, special_pattern='', plural='plural_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*plural[_\\*:]*')
derive_clause_dict for SUBTYPE_OF: Subtype of: Component
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   Component

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
derive_clause_dict for BASED_ON: *Based on*: AttributeSection
Using handlers:  ParseNameList()
ParseNameList returning:  [ClassReference(content='AttributeSection', _type='ClassReference')]
adding name value. based on -. [ClassReference(content='AttributeSection', _type='ClassReference')]
thedict[based on] = [ClassReference(content='AttributeSection', _type='ClassReference')]
{'based on': [ClassReference(content='AttributeSection', _type='ClassReference')]}
Clause line dict is {'based on': [ClassReference(content='AttributeSection', _type='ClassReference')]}
Using ATT_NAME  based_on for based on
Adding value in ddforpart. based_on -. [ClassReference(content='AttributeSection', _type='ClassReference')]
Calling absorb with line type:  MinorClause(line_label='BASED_ON', priority=1, word='based on', attribute_name='based on', is_list=True, is_cum=True, special_pattern='', plural='based on', handlers=ParseNameList(), kw_pattern='[_\\*]*based\\s?on[_\\*:]*')
Full header:  - **name** - (Lower Camel).

derive_clause_dict for OVERRIDES: Overrides: CamelName
Using handlers:  ParseAttributeReference()
adding name value. overrides -. {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}
thedict[overrides] = {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}
{'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}
Clause line dict is {'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}
Calling absorb with line type:  MinorClause(line_label='OVERRIDES', priority=1, word='overrides', attribute_name='overrides', is_list=False, is_cum=False, special_pattern='', plural='overrides_s', handlers=ParseAttributeReference(), kw_pattern='[_\\*]*overrides[_\\*:]*')
Full header:  - **dataType** - The kind of object to which the attribute refers.  _(DataType)_
H
In the simplest cases, the data type will be a class. And the specifier is the just the name of that class.
Parsing annotation:  ***See***: the section below on Data Type Specifiers.

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'See', 'value': 'the section below on Data Type Specifiers.'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='see', _type='Label'), 'content': OneLiner(content='the section below on Data Type Specifiers.')}
Full header:  __ **Cardinalities**.

Full header:  - **isOptional** - Indicates whether the attribute must have a value for every instance of the class _(Boolean)_

derive_clause_dict for DEFAULT: ***Default:*** False
Using handlers:  ParseTrivial()
adding name value. one_liner -. *** False

thedict[one_liner] = {'_type': 'OneLiner', 'content': '*** False\n'}
{'one_liner': {'_type': 'OneLiner', 'content': '*** False\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': '*** False\n'}}
Calling absorb with line type:  MajorClause(line_label='DEFAULT', priority=1, class_started='Default', word='Default', attribute_name='one_liner', is_list=False, is_cum=False, special_pattern='', plural='one_liner_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*Default[_\\*:]*')
Dict for Formula {'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': '*** False\n'}}
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: ***Default:*** False

DerivedDict for Part:  Default
{'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': '*** False\n'}}
Full header:  - **cardinality** - The cardinality of the relationship represented by the attribute _(CardinalityCode)_

derive_clause_dict for DEFAULT: ***Default:***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.
Using handlers:  ParseTrivial()
adding name value. one_liner -. ***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.
For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.
thedict[one_liner] = {'_type': 'OneLiner', 'content': '***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'}
{'one_liner': {'_type': 'OneLiner', 'content': '***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': '***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'}}
Calling absorb with line type:  MajorClause(line_label='DEFAULT', priority=1, class_started='Default', word='Default', attribute_name='one_liner', is_list=False, is_cum=False, special_pattern='', plural='one_liner_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*Default[_\\*:]*')
Dict for Formula {'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': '***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'}}
Parsing annotation:  For example:

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'For example', 'value': ''}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='forExample', _type='Label'), 'content': OneLiner(content='')}
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: ***Default:***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.
_ _ ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.', extra_text=[])], extra_text=[])]
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ WILD: For example:

DerivedDict for Part:  Default
{'_type': 'Default', 'one_liner': {'_type': 'OneLiner', 'content': '***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': {'_type': 'Label', 'content': 'forExample'}, 'content': {'_type': 'OneLiner', 'content': ''}}]}
Full header:  - author (1:1 Author)

Inventing name for:  1:1 Author
Full header:  - books (optional N:M Set of Books)

Inventing name for:  N:M Set of Books
Parsing annotation:  ***Note***: how this works with optionality

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'how this works with optionality'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='how this works with optionality')}
Full header:  __  ***Inverse Attributes***

Full header:  - **isInvertible** - (Boolean)

derive_clause_dict for DERIVATION: ***Derivation***: true if the data type is a class or a simple collection of members of a class.
Using handlers:  ParseTrivial()
adding name value. one_liner -.  true if the data type is a class or a simple collection of members of a class.

thedict[one_liner] = {'_type': 'OneLiner', 'content': ' true if the data type is a class or a simple collection of members of a class.\n'}
{'one_liner': {'_type': 'OneLiner', 'content': ' true if the data type is a class or a simple collection of members of a class.\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' true if the data type is a class or a simple collection of members of a class.\n'}}
Calling absorb with line type:  MajorClause(line_label='DERIVATION', priority=1, class_started='Derivation', word='Derivation', attribute_name='one_liner', is_list=False, is_cum=False, special_pattern='', plural='one_liner_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*Derivation[_\\*:]*')
Dict for Formula {'_type': 'Derivation', 'one_liner': {'_type': 'OneLiner', 'content': ' true if the data type is a class or a simple collection of members of a class.\n'}}
. Derivation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DERIVATION: ***Derivation***: true if the data type is a class or a simple collection of members of a class.

DerivedDict for Part:  Derivation
{'_type': 'Derivation', 'one_liner': {'_type': 'OneLiner', 'content': ' true if the data type is a class or a simple collection of members of a class.\n'}}
Full header:  - **inverseClass** - the class which contains, or would contain the inverse attribute (optional Class)

derive_clause_dict for DERIVATION: ***Derivation***: from the data type. Null unless arrribute is invertible.
Using handlers:  ParseTrivial()
adding name value. one_liner -.  from the data type. Null unless arrribute is invertible.

thedict[one_liner] = {'_type': 'OneLiner', 'content': ' from the data type. Null unless arrribute is invertible.\n'}
{'one_liner': {'_type': 'OneLiner', 'content': ' from the data type. Null unless arrribute is invertible.\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' from the data type. Null unless arrribute is invertible.\n'}}
Calling absorb with line type:  MajorClause(line_label='DERIVATION', priority=1, class_started='Derivation', word='Derivation', attribute_name='one_liner', is_list=False, is_cum=False, special_pattern='', plural='one_liner_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*Derivation[_\\*:]*')
Dict for Formula {'_type': 'Derivation', 'one_liner': {'_type': 'OneLiner', 'content': ' from the data type. Null unless arrribute is invertible.\n'}}
. Derivation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DERIVATION: ***Derivation***: from the data type. Null unless arrribute is invertible.

DerivedDict for Part:  Derivation
{'_type': 'Derivation', 'one_liner': {'_type': 'OneLiner', 'content': ' from the data type. Null unless arrribute is invertible.\n'}}
Full header:  - **inverseAttribute** - (optional Attribute)

Full header:  - **inverseIsOptional** - (optional Attribute)

Full header:  __ ***Formulas***

Full header:  - **default** - The rule or formula for calculating the value, if no value is supplied
Now running to a second line with the parenthentical on yet a third line
(optional Derivation)
Parsing annotation:  Note: even when an Attribute has a default derivation, there‚Äôs no guarantee that every instance will have an assigned value. Example needed.
And let's see if the note can span extra lines, too
Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'even when an Attribute has a default derivation, there‚Äôs no guarantee that every instance will have an assigned value. Example needed.'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='even when an Attribute has a default derivation, there‚Äôs no guarantee that every instance will have an assigned value. Example needed.')}
Full header:  - **derivation** - For derived attributes, the rule or formula for calculating the value _(optional Derivation)_

Parsing annotation:  ***Issue***: on insert vs on access?

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Issue', 'value': 'on insert vs on access?'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='issue', _type='Label'), 'content': OneLiner(content='on insert vs on access?')}
Full header:  - **constraints** - Any validation rules specific to this attribute _(ListOf Constraints)_

Parsing annotation:  Note: from Class.constraints

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'from Class.constraints'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='note', _type='Label'), 'content': OneLiner(content='from Class.constraints')}
Full header:  __ Override Tracking

Full header:  - Overrides

Full header:  ValueType:   **Derivation**  - A rule or formula for deriving the value of an attribute

raw name = Derivation, deep = None
derive_clause_dict for PLURAL: Plural: Derivations
Using handlers:  ParseTrivial()
adding name value. plural -.  Derivations

thedict[plural] =  Derivations

{'plural': ' Derivations\n'}
Clause line dict is {'plural': ' Derivations\n'}
Calling absorb with line type:  MinorClause(line_label='PLURAL', priority=1, word='plural', attribute_name='plural', is_list=False, is_cum=False, special_pattern='', plural='plural_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*plural[_\\*:]*')
Full header:  - **statement** - An English language statement of the derivation rule _(RichText)_

Full header:  - **expression** - The formal expression of the derivation in a programming language _(CodeExpression)_

Full header:  ValueType:    **Constraint**  - A rule, condition, or validation that must be satisfied by the model

raw name = Constraint, deep = None
derive_clause_dict for PLURAL: Plural: Constraints
Using handlers:  ParseTrivial()
adding name value. plural -.  Constraints

thedict[plural] =  Constraints

{'plural': ' Constraints\n'}
Clause line dict is {'plural': ' Constraints\n'}
Calling absorb with line type:  MinorClause(line_label='PLURAL', priority=1, word='plural', attribute_name='plural', is_list=False, is_cum=False, special_pattern='', plural='plural_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*plural[_\\*:]*')
derive_clause_dict for SUBTYPE_OF: Subtype of: Component
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   Component

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
Full header:  - **statement** - An English language statement of the constraint _(RichText)_

Full header:  - **expression** - The formal expression of the constraint in a programming language (e.g., OCL _(CodeExpression)_

Inventing name for:  e.g., OCL _(CodeExpression
Full header:  - **severity** -  (Code)

Full header:  ValueType:  **Message** - (Template)

raw name = Message, deep = None
Full header:  ValueType:   **Class Constraint**

raw name = Class Constraint, deep = None
derive_clause_dict for SUBTYPE_OF: **Subtype of**: Constraint
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   Constraint

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Constraint', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Constraint', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Constraint', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Constraint', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Constraint', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Constraint', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
derive_clause_dict for BASED_ON: ***Based on***: Class.
Using handlers:  ParseNameList()
ParseNameList returning:  [ClassReference(content='Class', _type='ClassReference')]
adding name value. based on -. [ClassReference(content='Class', _type='ClassReference')]
thedict[based on] = [ClassReference(content='Class', _type='ClassReference')]
{'based on': [ClassReference(content='Class', _type='ClassReference')]}
Clause line dict is {'based on': [ClassReference(content='Class', _type='ClassReference')]}
Using ATT_NAME  based_on for based on
Adding value in ddforpart. based_on -. [ClassReference(content='Class', _type='ClassReference')]
Calling absorb with line type:  MinorClause(line_label='BASED_ON', priority=1, word='based on', attribute_name='based on', is_list=True, is_cum=True, special_pattern='', plural='based on', handlers=ParseNameList(), kw_pattern='[_\\*]*based\\s?on[_\\*:]*')
Full header:  ValueType:   **Attribute Constraint**

raw name = Attribute Constraint, deep = None
derive_clause_dict for SUBTYPE_OF: ***Subtype of***: Constraint
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   Constraint

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Constraint', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Constraint', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Constraint', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Constraint', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Constraint', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Constraint', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
derive_clause_dict for BASED_ON: ***Based on***: Attribute
Using handlers:  ParseNameList()
ParseNameList returning:  [ClassReference(content='Attribute', _type='ClassReference')]
adding name value. based on -. [ClassReference(content='Attribute', _type='ClassReference')]
thedict[based on] = [ClassReference(content='Attribute', _type='ClassReference')]
{'based on': [ClassReference(content='Attribute', _type='ClassReference')]}
Clause line dict is {'based on': [ClassReference(content='Attribute', _type='ClassReference')]}
Using ATT_NAME  based_on for based on
Adding value in ddforpart. based_on -. [ClassReference(content='Attribute', _type='ClassReference')]
Calling absorb with line type:  MinorClause(line_label='BASED_ON', priority=1, word='based on', attribute_name='based on', is_list=True, is_cum=True, special_pattern='', plural='based on', handlers=ParseNameList(), kw_pattern='[_\\*]*based\\s?on[_\\*:]*')
Full header:  ValueType:   **CodeExpression**

raw name = CodeExpression, deep = None
Full header:  - **Language** - the programming language (Code)

Full header:  - **Expression** (String)

Full header:  ## Methods

Full header:  _ **Method**  - A behavior or operation associated with a class

derive_clause_dict for PLURAL: Plural: Methods
Using handlers:  ParseTrivial()
adding name value. plural -.  Methods

thedict[plural] =  Methods

{'plural': ' Methods\n'}
Clause line dict is {'plural': ' Methods\n'}
Calling absorb with line type:  MinorClause(line_label='PLURAL', priority=1, word='plural', attribute_name='plural', is_list=False, is_cum=False, special_pattern='', plural='plural_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*plural[_\\*:]*')
derive_clause_dict for SUBTYPE_OF: Subtype of: Component
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   Component

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
Full header:  - **parameters** - The input parameters of the method _(ListOf Parameters)_

Full header:  - **returnType** - The data type of the value returned by the method _(DataType )_

Full header:  _ **Parameter**
An input to a method
derive_clause_dict for PLURAL: Plural: Parameters
Using handlers:  ParseTrivial()
adding name value. plural -.  Parameters

thedict[plural] =  Parameters

{'plural': ' Parameters\n'}
Clause line dict is {'plural': ' Parameters\n'}
Calling absorb with line type:  MinorClause(line_label='PLURAL', priority=1, word='plural', attribute_name='plural', is_list=False, is_cum=False, special_pattern='', plural='plural_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*plural[_\\*:]*')
derive_clause_dict for SUBTYPE_OF: Subtype of: Component
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   Component

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='Component', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
Full header:  - **type** - The data type of the parameter _(DataType )_

Full header:  - **cardinality** - The cardinality of the parameter (e.g., optional, required) _(AttributeCardinality)_

Inventing name for:  e.g., optional, required
Full header:  ## Data Types

Full header:  ValueType: **Data Type**

raw name = Data Type, deep = None
Full header:  ValueType:   **Simple Data Type**
***SubtpeOf***: DataType
raw name = Simple Data Type
SubtpeOf DataType, deep = None
Full header:  - **coreClass** - (Class)

Full header:  ValueType:   **Complex Data Type**

raw name = Complex Data Type, deep = None
Full header:  - **aggregation** (Aggregating Operator)

Full header:  - **aggregatedTypes** (List of DataTypes)

Full header:  ValueType:   **Aggregating Operator**

raw name = Aggregating Operator, deep = None
Full header:  - **Name**- (Code)

Full header:  - **arity** - (Integer)

Full header:  - **spelling** - (Template)

Full header:  ## Low level Data Types

Full header:  ValueType: Emoji

raw name = Emoji, deep = None
Full header:  ValueType: String

raw name = String, deep = None
Full header:  ValueType: **CamelName**

raw name = CamelName, deep = None
derive_clause_dict for SUBTYPE_OF: ***Subtype of***: String
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   String

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
Full header:  - value: the string (String)

derive_clause_dict for CONSTRAINT: üö´ ***Constraint***: Must follow the camel case naming convention and not be empty.
Using handlers:  ParseTrivial()
adding name value. one_liner -.  Must follow the camel case naming convention and not be empty.

thedict[one_liner] = {'_type': 'OneLiner', 'content': ' Must follow the camel case naming convention and not be empty.\n'}
{'one_liner': {'_type': 'OneLiner', 'content': ' Must follow the camel case naming convention and not be empty.\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' Must follow the camel case naming convention and not be empty.\n'}}
Calling absorb with line type:  MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*')
Dict for Formula {'_type': 'Constraint', 'one_liner': {'_type': 'OneLiner', 'content': ' Must follow the camel case naming convention and not be empty.\n'}}
Parsing annotation:  Example:  "firstName", "orderDate", "customerID"

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Example', 'value': '"firstName", "orderDate", "customerID"'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='example', _type='Label'), 'content': OneLiner(content='"firstName", "orderDate", "customerID"')}
Parsing annotation:  *ModelingNote:* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'ModelingNote', 'value': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='modelingNote', _type='Label'), 'content': OneLiner(content='* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.')}
. Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ CONSTRAINT: üö´ ***Constraint***: Must follow the camel case naming convention and not be empty.
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ EXAMPLE: Example:  "firstName", "orderDate", "customerID"
_ _ _ ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='> üìù ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.', extra_text=[])], extra_text=[])]
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ WILD: *ModelingNote:* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.

DerivedDict for Part:  Constraint
{'_type': 'Constraint', 'one_liner': {'_type': 'OneLiner', 'content': ' Must follow the camel case naming convention and not be empty.\n'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': {'_type': 'Label', 'content': 'example'}, 'content': {'_type': 'OneLiner', 'content': '"firstName", "orderDate", "customerID"'}, 'elaboration': [{'_type': 'Paragraph', 'content': '> üìù ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': {'_type': 'Label', 'content': 'modelingNote'}, 'content': {'_type': 'OneLiner', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}}]}
Full header:  ValueType:  **UpperCamel**- a CamelName that begins with a capital letter

raw name = UpperCamel, deep = None
derive_clause_dict for SUBTYPE_OF: **Subtype of**: CamelName
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   CamelName

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='CamelName', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='CamelName', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='CamelName', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='CamelName', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='CamelName', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='CamelName', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
derive_clause_dict for WHERE: **Where**: content begins with an upper case letter.
Using handlers:  ParseTrivial()
adding name value. where -.  content begins with an upper case letter.

thedict[where] =  content begins with an upper case letter.

{'where': ' content begins with an upper case letter.\n'}
Clause line dict is {'where': ' content begins with an upper case letter.\n'}
Calling absorb with line type:  MinorClause(line_label='WHERE', priority=1, word='where', attribute_name='where', is_list=False, is_cum=False, special_pattern='', plural='where_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*where[_\\*:]*')
Parsing annotation:  Example:_ "Customer", "ProductCategory", "PaymentMethod"

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Example', 'value': '_ "Customer", "ProductCategory", "PaymentMethod"'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='example', _type='Label'), 'content': OneLiner(content='_ "Customer", "ProductCategory", "PaymentMethod"')}
Full header:  ValueType:   **LowerCamel** - a CamelName that begins with a lower case letter

raw name = LowerCamel, deep = None
derive_clause_dict for SUBTYPE_OF: **Subtype of**: CamelName
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   CamelName

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='CamelName', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='CamelName', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='CamelName', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='CamelName', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='CamelName', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='CamelName', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
derive_clause_dict for WHERE: **Where**: content begins with a lower case letter.
Using handlers:  ParseTrivial()
adding name value. where -.  content begins with a lower case letter.

thedict[where] =  content begins with a lower case letter.

{'where': ' content begins with a lower case letter.\n'}
Clause line dict is {'where': ' content begins with a lower case letter.\n'}
Calling absorb with line type:  MinorClause(line_label='WHERE', priority=1, word='where', attribute_name='where', is_list=False, is_cum=False, special_pattern='', plural='where_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*where[_\\*:]*')
Parsing annotation:  Example:  "firstName", "orderTotal", "shippingAddress"

Returning parsed from ParseAnnotaion {'line_type': 'labeled_value', 'emoji': '', 'label': 'Example', 'value': '"firstName", "orderTotal", "shippingAddress"'}
emojis are:  []
Final annoation dict is:  {'emoji': '', 'label': Label(content='example', _type='Label'), 'content': OneLiner(content='"firstName", "orderTotal", "shippingAddress"')}
Full header:  ValueType:   **Qualified Camel** - an expression consisting of Camel Names separated by periods

raw name = Qualified Camel, deep = None
derive_clause_dict for SUBTYPE_OF: ***Subtype of***: String
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   String

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
derive_clause_dict for CONSTRAINT: ***Constraint***: content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.
Using handlers:  ParseTrivial()
adding name value. one_liner -.  content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.

thedict[one_liner] = {'_type': 'OneLiner', 'content': ' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n'}
{'one_liner': {'_type': 'OneLiner', 'content': ' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n'}}
Calling absorb with line type:  MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*')
Dict for Formula {'_type': 'Constraint', 'one_liner': {'_type': 'OneLiner', 'content': ' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n'}}
. Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ CONSTRAINT: ***Constraint***: content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.

DerivedDict for Part:  Constraint
{'_type': 'Constraint', 'one_liner': {'_type': 'OneLiner', 'content': ' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n'}}
Full header:  _ ValueType: **RichText** - A string with markup for block level formatting.

derive_clause_dict for SUBTYPE_OF: ***SubtypeOf***: String
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   String

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='String', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
Full header:  - **value** - the string content (string)

Full header:  - **format** - the rich text coding language used (Code)

Full header:  ValueType:  **OneLiner**   - String with markup for line level formatting.

raw name = OneLiner, deep = None
derive_clause_dict for SUBTYPE_OF: ***SubtypeOf***: RichText
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   RichText

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='RichText', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='RichText', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='RichText', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='RichText', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='RichText', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='RichText', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
Full header:  - **value** - the string content (string)

derive_clause_dict for CONSTRAINT: ***Constraint***: must not containa line break or new line character
Using handlers:  ParseTrivial()
adding name value. one_liner -.  must not containa line break or new line character

thedict[one_liner] = {'_type': 'OneLiner', 'content': ' must not containa line break or new line character\n'}
{'one_liner': {'_type': 'OneLiner', 'content': ' must not containa line break or new line character\n'}}
Clause line dict is {'one_liner': {'_type': 'OneLiner', 'content': ' must not containa line break or new line character\n'}}
Calling absorb with line type:  MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*')
Dict for Formula {'_type': 'Constraint', 'one_liner': {'_type': 'OneLiner', 'content': ' must not containa line break or new line character\n'}}
derive_clause_dict for MESSAGE: Message: A line can't span two lines
Using handlers:  ParseTrivial()
adding name value. message -.  A line can't span two lines

thedict[message] =  A line can't span two lines

{'message': " A line can't span two lines\n"}
Clause line dict is {'message': " A line can't span two lines\n"}
Calling absorb with line type:  MinorClause(line_label='MESSAGE', priority=1, word='message', attribute_name='message', is_list=False, is_cum=False, special_pattern='', plural='message_s', handlers=ParseTrivial(), kw_pattern='[_\\*]*message[_\\*:]*')
. Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ CONSTRAINT: ***Constraint***: must not containa line break or new line character
_ _ MESSAGE: Message: A line can't span two lines

DerivedDict for Part:  Constraint
{'_type': 'Constraint', 'one_liner': {'_type': 'OneLiner', 'content': ' must not containa line break or new line character\n'}, 'message': " A line can't span two lines\n"}
Full header:  ValueType:  **PrimitiveType**  - A basic, built-in data type

raw name = PrimitiveType, deep = None
Full header:  ValueType: **String**

raw name = String, deep = None
derive_clause_dict for SUBTYPE_OF: SubtypeOf: PrimitiveType
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   PrimitiveType

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
Full header:  ValueType: **Integer**

raw name = Integer, deep = None
derive_clause_dict for SUBTYPE_OF: SubtypeOf: PrimitiveType
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   PrimitiveType

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
Full header:  ValueType: **Decimal**

raw name = Decimal, deep = None
derive_clause_dict for SUBTYPE_OF: SubtypeOf: PrimitiveType
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   PrimitiveType

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
Full header:  ValueType: **Boolean**

raw name = Boolean, deep = None
derive_clause_dict for SUBTYPE_OF: SubtypeOf: PrimitiveType
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   PrimitiveType

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
Full header:  ValueType: **Date**

raw name = Date, deep = None
derive_clause_dict for SUBTYPE_OF: SubtypeOf: PrimitiveType
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   PrimitiveType

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
Full header:  ValueType: **Time**

raw name = Time, deep = None
derive_clause_dict for SUBTYPE_OF: SubtypeOf: PrimitiveType
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   PrimitiveType

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
Full header:  ValueType: **DateTime**

raw name = DateTime, deep = None
derive_clause_dict for SUBTYPE_OF: SubtypeOf: PrimitiveType
Using handlers:  ParseSubtypeOf()
parsing subtypeOfs:   PrimitiveType

SubtypeOf result is  [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
adding name value. subtype of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
thedict[subtype of] = [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
{'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Clause line dict is {'subtype of': [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]}
Using ATT_NAME  subtype_of for subtype of
Adding value in ddforpart. subtype_of -. [{'_type': 'SubtypeBy', 'class_name': ClassReference(content='PrimitiveType', _type='ClassReference'), 'subtyping_name': SubtypingName(content='subtypes', _type='SubtypingName')}]
Calling absorb with line type:  MinorClause(line_label='SUBTYPE_OF', priority=1, word='subtype of', attribute_name='subtype of', is_list=True, is_cum=True, special_pattern='', plural='subtype of', handlers=ParseSubtypeOf(), kw_pattern='[_\\*]*subtype\\s?of[_\\*:]*')
Full header:  ### Annotation Types Used

Full header:  ### Annotation types as CSV

Full header:  ## Appendices - various sidebars to include
Insert More Sidebars.md
Insert Overrides.md
insert LDM Intro.md
Insert OCL.md
Insert Camel Case.md
Full header:  - minor component

Full header:  - embellishment

Full header:  - words and phrases


Phase: .. full dict saved  in ldm/ldm_models/Literate/Literate_results/Literate_PD_02.dict.yaml

Phase: Creating model with from_typed_dict() => to_typed_dict() => ldm/ldm_models/Literate/Literate_results/Literate_PD_03.model.yaml
Calling LiterateModel.from_typed_dict ...
In AttSection post-init for For Machinery, is_optional = None
backfilling attributes for  Component
	backfilled  normalName
	backfilled  name
	backfilled  qualifiedName
	backfilled  abbreviatedName
	backfilled  oneLiner
	backfilled  elaboration
	backfilled  Attribute: isEmbellishment
backfilling attributes for  AnnotationType
	backfilled  emoji
	backfilled  emojiName
	backfilled  emojiUnicode
	backfilled  label
	backfilled  plural
	backfilled  purpose
In AttSection post-init for For Machinery, is_optional = None
backfilling attributes for  Annotation
	backfilled  annotationType
	backfilled  label
	backfilled  emoji
	backfilled  content
	backfilled  Attribute: isEmbellishment
In AttSection post-init for Modeling Configuration, is_optional = None
backfilling attributes for  LiterateDataModel
	backfilled  name
	backfilled  allSubjects
	backfilled  allClasses
	backfilled  Attribute: annotationTypes
	backfilled  Attribute: preferredCodingLanguage
	backfilled  Attribute: alternateCodingLanguages
	backfilled  Attribute: preferredTemplateLanguage
	backfilled  Attribute: alternateTemplateLanguages
	backfilled  Attribute: aiFunctions
backfilling attributes for  Subject
	backfilled  name
	backfilled  parentSubject
	backfilled  classes
	backfilled  childSubjects
In AttSection post-init for Implied Attributes, is_optional = None
backfilling attributes for  Class
	backfilled  pluralForm
	backfilled  basedOn
	backfilled  supertypes
	backfilled  subtypings
	backfilled  subtypes
	backfilled  attributes
	backfilled  attributeSections
	backfilled  constraints
	backfilled  methods
	backfilled  Attribute: dependents
	backfilled  Attribute: uniqueKeys
backfilling attributes for  Subtyping
	backfilled  name
	backfilled  isExclusive
	backfilled  isExhaustive
	backfilled  classes
backfilling attributes for  CodeType
	backfilled  isCaptive
backfilling attributes for  CodeValue
	backfilled  code
	backfilled  description
backfilling attributes for  Key
	backfilled  keyAttributes
backfilling attributes for  AttributeSection
	backfilled  isOptional
In AttSection post-init for Cardinalities, is_optional = None
In AttSection post-init for Inverse Attributes, is_optional = None
In AttSection post-init for Formulas, is_optional = None
In AttSection post-init for Override Tracking, is_optional = None
backfilling attributes for  Attribute
	backfilled  name
	backfilled  dataType
	backfilled  Attribute: isOptional
	backfilled  Attribute: cardinality
	backfilled  Attribute: author
	backfilled  Attribute: books
	backfilled  Attribute: isInvertible
	backfilled  Attribute: inverseClass
	backfilled  Attribute: inverseAttribute
	backfilled  Attribute: inverseIsOptional
	backfilled  Attribute: default
	backfilled  Attribute: derivation
	backfilled  Attribute: constraints
	backfilled  Attribute: overrides
backfilling attributes for  Derivation
	backfilled  statement
	backfilled  expression
backfilling attributes for  Constraint
	backfilled  statement
	backfilled  expression
	backfilled  severity
backfilling attributes for  CodeExpression
	backfilled  language
	backfilled  expression
backfilling attributes for  Method
	backfilled  parameters
	backfilled  returnType
backfilling attributes for  ParameterAnInputToAMethod
	backfilled  type
	backfilled  cardinality
backfilling attributes for  SimpleDataTypeSubtpeOfDataType
	backfilled  coreClass
backfilling attributes for  ComplexDataType
	backfilled  aggregation
	backfilled  aggregatedTypes
backfilling attributes for  AggregatingOperator
	backfilled  name
	backfilled  arity
	backfilled  spelling
backfilling attributes for  CamelName
	backfilled  valueTheString
backfilling attributes for  ValueTypeRichText
	backfilled  value
	backfilled  format
backfilling attributes for  OneLiner
	backfilled  value

Phase: have py  model from dict

Phase: Creating model_dict from model => ldm/ldm_models/Literate/Literate_results/Literate_PD_03.model.yaml

Phase: Validating model tp ldm/ldm_models/Literate/Literate_results/Literate_PD_04.v_model.yaml
All classes names (singular and plural are: 
Calcing all_class names  for  Literatemodel: Literate Data Model
Calcing all_classes for  Literatemodel: Literate Data Model
- locally, there are 0 classes for Literatemodel: Literate Data Model
Calcing all_classes for  Subjectb: Preliminaries
- locally, there are 3 classes for Subjectb: Preliminaries
- allclasses for Subjectb: Preliminaries contains 3; locally just 3
Calcing all_classes for  Subjectb: The Model and its Subjects
- locally, there are 3 classes for Subjectb: The Model and its Subjects
Calcing all_classes for  Subjectc: Classes
- locally, there are 7 classes for Subjectc: Classes
- allclasses for Subjectc: Classes contains 7; locally just 7
- allclasses for Subjectb: The Model and its Subjects contains 10; locally just 3
Calcing all_classes for  Subjectb: Attributes
- locally, there are 8 classes for Subjectb: Attributes
- allclasses for Subjectb: Attributes contains 8; locally just 8
Calcing all_classes for  Subjectb: Methods
- locally, there are 2 classes for Subjectb: Methods
- allclasses for Subjectb: Methods contains 2; locally just 2
Calcing all_classes for  Subjectb: Data Types
- locally, there are 4 classes for Subjectb: Data Types
- allclasses for Subjectb: Data Types contains 4; locally just 4
Calcing all_classes for  Subjectb: Low level Data Types
- locally, there are 16 classes for Subjectb: Low level Data Types
Calcing all_classes for  Subjectc: Annotation Types Used
- locally, there are 0 classes for Subjectc: Annotation Types Used
- allclasses for Subjectc: Annotation Types Used contains 0; locally just 0
Calcing all_classes for  Subjectc: Annotation types as CSV
- locally, there are 0 classes for Subjectc: Annotation types as CSV
- allclasses for Subjectc: Annotation types as CSV contains 0; locally just 0
- allclasses for Subjectb: Low level Data Types contains 16; locally just 16
Calcing all_classes for  Subjectb: Appendices
- locally, there are 0 classes for Subjectb: Appendices
- allclasses for Subjectb: Appendices contains 0; locally just 0
- allclasses for Literatemodel: Literate Data Model contains 43; locally just 0
	"AggregatingOperator",
	"AggregatingOperators",
	"Annotation",
	"AnnotationType",
	"AnnotationTypes",
	"Annotations",
	"Attribute",
	"AttributeConstraint",
	"AttributeConstraints",
	"AttributeSection",
	"AttributeSections",
	"Attributes",
	"Boolean",
	"Booleans",
	"CamelName",
	"CamelNames",
	"Class",
	"ClassConstraint",
	"ClassConstraints",
	"Classes",
	"CodeExpression",
	"CodeExpressions",
	"CodeType",
	"CodeTypes",
	"CodeValue",
	"CodeValues",
	"ComplexDataType",
	"ComplexDataTypes",
	"Component",
	"Components",
	"Constraint",
	"Constraints",
	"DataType",
	"DataTypes",
	"Date",
	"DateTime",
	"DateTimes",
	"Dates",
	"Decimal",
	"Decimals",
	"Derivation",
	"Derivations",
	"Emoji",
	"Emojis",
	"Integer",
	"Integers",
	"Key",
	"Keys",
	"LiterateDataModel",
	"LiterateDataModels",
	"LowerCamel",
	"LowerCamels",
	"Message",
	"Messages",
	"Method",
	"Methods",
	"OneLiner",
	"OneLiners",
	"ParameterAnInputToAMethod",
	"Parameters",
	"PrimitiveType",
	"PrimitiveTypes",
	"QualifiedCamel",
	"QualifiedCamels",
	"ReferenceType",
	"ReferenceTypes",
	"SimpleDataTypeSubtpeOfDataType",
	"SimpleDataTypeSubtpeOfDataTypes",
	"String",
	"Strings",
	"Subject",
	"SubjectArea",
	"SubjectAreas",
	"Subjects",
	"Subtyping",
	"Subtypings",
	"Time",
	"Times",
	"UniqueKey",
	"UniqueKeys",
	"UpperCamel",
	"UpperCamels",
	"ValueTypeRichText",
	"ValueTypeRichTexts",
Attributes Index = 

Class:  Component
	 normalName
	 name
	 qualifiedName
	 abbreviatedName
	 oneLiner
	 elaboration
Class:  AnnotationType
	 emoji
	 emojiName
	 emojiUnicode
	 label
	 plural
	 purpose
Class:  Annotation
	 annotationType
	 label
	 emoji
	 content
Class:  LiterateDataModel
	 name
	 allSubjects
	 allClasses
Class:  Subject
	 name
	 parentSubject
	 classes
	 childSubjects
Class:  Class
	 pluralForm
	 basedOn
	 supertypes
	 subtypings
	 subtypes
	 attributes
	 attributeSections
	 constraints
	 methods
Class:  Subtyping
	 name
	 isExclusive
	 isExhaustive
	 classes
Class:  CodeType
	 isCaptive
Class:  CodeValue
	 code
	 description
Class:  Key
	 keyAttributes
Class:  AttributeSection
	 isOptional
Class:  Attribute
	 name
	 dataType
Class:  Derivation
	 statement
	 expression
Class:  Constraint
	 statement
	 expression
	 severity
Class:  CodeExpression
	 language
	 expression
Class:  Method
	 parameters
	 returnType
Class:  ParameterAnInputToAMethod
	 type
	 cardinality
Class:  SimpleDataTypeSubtpeOfDataType
	 coreClass
Class:  ComplexDataType
	 aggregation
	 aggregatedTypes
Class:  AggregatingOperator
	 name
	 arity
	 spelling
Class:  CamelName
	 valueTheString
Class:  ValueTypeRichText
	 value
	 format
Class:  OneLiner
	 value
finding value types...
CALC MROS - yields...
0  classes in final model
Calc Dependents
b is  LiterateDataModel
AnnotationType is based on LiterateDataModel
b is  Component
Annotation is based on Component
b is  LiterateDataModel
Subject is based on LiterateDataModel
b is  LiterateModel
SubjectArea is based on LiterateModel
b is  Xyz
SubjectArea is based on Xyz
b is  Class
Subtyping is based on Class
b is  CodeType
CodeValue is based on CodeType
b is  Class
Key is based on Class
b is  Class
AttributeSection is based on Class
b is  AttributeSection
Attribute is based on AttributeSection
b is  Class
ClassConstraint is based on Class
b is  Attribute
AttributeConstraint is based on Attribute
Dependents of  LiterateDataModel  are  ['AnnotationType', 'Subject']
Dependents of  Component  are  ['Annotation']
Dependents of  LiterateModel  are  ['SubjectArea']
Class not found
Dependents of  Xyz  are  ['SubjectArea']
Class not found
Dependents of  Class  are  ['Subtyping', 'Key', 'AttributeSection', 'ClassConstraint']
Dependents of  CodeType  are  ['CodeValue']
Dependents of  AttributeSection  are  ['Attribute']
Dependents of  Attribute  are  ['AttributeConstraint']
Class: LiterateDataModel is subtype of Component via subtypes
Class: Subject is subtype of Component via subtypes
Class: SubjectArea is subtype of Subject via subtypes
Class: Class is subtype of Component via subtypes
Class: ReferenceType is subtype of Class via subtypes
Class: Key is subtype of Component via subtypes
Class: UniqueKey is subtype of Key via subtypes
Class: AttributeSection is subtype of Component via subtypes
Class: Attribute is subtype of Component via subtypes
Valuetype: Constraint is subtype of Component via subtypes
Valuetype: ClassConstraint is subtype of Constraint via subtypes
Valuetype: AttributeConstraint is subtype of Constraint via subtypes
Class: Method is subtype of Component via subtypes
Class: ParameterAnInputToAMethod is subtype of Component via subtypes
Valuetype: CamelName is subtype of String via subtypes
Valuetype: UpperCamel is subtype of CamelName via subtypes
Valuetype: LowerCamel is subtype of CamelName via subtypes
Valuetype: QualifiedCamel is subtype of String via subtypes
Class: ValueTypeRichText is subtype of String via subtypes
Valuetype: OneLiner is subtype of RichText via subtypes
Valuetype: String is subtype of PrimitiveType via subtypes
Valuetype: Integer is subtype of PrimitiveType via subtypes
Valuetype: Decimal is subtype of PrimitiveType via subtypes
Valuetype: Boolean is subtype of PrimitiveType via subtypes
Valuetype: Date is subtype of PrimitiveType via subtypes
Valuetype: Time is subtype of PrimitiveType via subtypes
Valuetype: DateTime is subtype of PrimitiveType via subtypes
All Subtypings
Component  => 
	subtypes: ['LiterateDataModel', 'Subject', 'Class', 'Key', 'AttributeSection', 'Attribute', 'Constraint', 'Method', 'ParameterAnInputToAMethod']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Subtyping object is  Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='LiterateDataModel', _type='ClassReference'), ClassReference(content='Subject', _type='ClassReference'), ClassReference(content='Class', _type='ClassReference'), ClassReference(content='Key', _type='ClassReference'), ClassReference(content='AttributeSection', _type='ClassReference'), ClassReference(content='Attribute', _type='ClassReference'), ClassReference(content='Constraint', _type='ClassReference'), ClassReference(content='Method', _type='ClassReference'), ClassReference(content='ParameterAnInputToAMethod', _type='ClassReference')])
Subject  => 
	subtypes: ['SubjectArea']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Subtyping object is  Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='SubjectArea', _type='ClassReference')])
Class  => 
	subtypes: ['ReferenceType']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Subtyping object is  Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='ReferenceType', _type='ClassReference')])
Key  => 
	subtypes: ['UniqueKey']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Subtyping object is  Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='UniqueKey', _type='ClassReference')])
Constraint  => 
	subtypes: ['ClassConstraint', 'AttributeConstraint']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Subtyping object is  Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='ClassConstraint', _type='ClassReference'), ClassReference(content='AttributeConstraint', _type='ClassReference')])
String  => 
	subtypes: ['CamelName', 'QualifiedCamel', 'ValueTypeRichText']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Subtyping object is  Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='CamelName', _type='ClassReference'), ClassReference(content='QualifiedCamel', _type='ClassReference'), ClassReference(content='ValueTypeRichText', _type='ClassReference')])
CamelName  => 
	subtypes: ['UpperCamel', 'LowerCamel']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Subtyping object is  Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='UpperCamel', _type='ClassReference'), ClassReference(content='LowerCamel', _type='ClassReference')])
RichText  => 
	subtypes: ['OneLiner']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Subtyping object is  Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='OneLiner', _type='ClassReference')])
No place to put subtypings for:  RichText
PrimitiveType  => 
	subtypes: ['String', 'Integer', 'Decimal', 'Boolean', 'Date', 'Time', 'DateTime']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Subtyping object is  Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(content='String', _type='ClassReference'), ClassReference(content='Integer', _type='ClassReference'), ClassReference(content='Decimal', _type='ClassReference'), ClassReference(content='Boolean', _type='ClassReference'), ClassReference(content='Date', _type='ClassReference'), ClassReference(content='Time', _type='ClassReference'), ClassReference(content='DateTime', _type='ClassReference')])
All classes names (singular and plural are: 
	"AggregatingOperator",
	"AggregatingOperators",
	"Annotation",
	"AnnotationType",
	"AnnotationTypes",
	"Annotations",
	"Attribute",
	"AttributeConstraint",
	"AttributeConstraints",
	"AttributeSection",
	"AttributeSections",
	"Attributes",
	"Boolean",
	"Booleans",
	"CamelName",
	"CamelNames",
	"Class",
	"ClassConstraint",
	"ClassConstraints",
	"Classes",
	"CodeExpression",
	"CodeExpressions",
	"CodeType",
	"CodeTypes",
	"CodeValue",
	"CodeValues",
	"ComplexDataType",
	"ComplexDataTypes",
	"Component",
	"Components",
	"Constraint",
	"Constraints",
	"DataType",
	"DataTypes",
	"Date",
	"DateTime",
	"DateTimes",
	"Dates",
	"Decimal",
	"Decimals",
	"Derivation",
	"Derivations",
	"Emoji",
	"Emojis",
	"Integer",
	"Integers",
	"Key",
	"Keys",
	"LiterateDataModel",
	"LiterateDataModels",
	"LowerCamel",
	"LowerCamels",
	"Message",
	"Messages",
	"Method",
	"Methods",
	"OneLiner",
	"OneLiners",
	"ParameterAnInputToAMethod",
	"Parameters",
	"PrimitiveType",
	"PrimitiveTypes",
	"QualifiedCamel",
	"QualifiedCamels",
	"ReferenceType",
	"ReferenceTypes",
	"SimpleDataTypeSubtpeOfDataType",
	"SimpleDataTypeSubtpeOfDataTypes",
	"String",
	"Strings",
	"Subject",
	"SubjectArea",
	"SubjectAreas",
	"Subjects",
	"Subtyping",
	"Subtypings",
	"Time",
	"Times",
	"UniqueKey",
	"UniqueKeys",
	"UpperCamel",
	"UpperCamels",
	"ValueTypeRichText",
	"ValueTypeRichTexts",
Attributes Index = 

Class:  Component
	 normalName
	 name
	 qualifiedName
	 abbreviatedName
	 oneLiner
	 elaboration
Class:  AnnotationType
	 emoji
	 emojiName
	 emojiUnicode
	 label
	 plural
	 purpose
Class:  Annotation
	 annotationType
	 label
	 emoji
	 content
Class:  LiterateDataModel
	 name
	 allSubjects
	 allClasses
Class:  Subject
	 name
	 parentSubject
	 classes
	 childSubjects
Class:  Class
	 pluralForm
	 basedOn
	 supertypes
	 subtypings
	 subtypes
	 attributes
	 attributeSections
	 constraints
	 methods
Class:  Subtyping
	 name
	 isExclusive
	 isExhaustive
	 classes
Class:  CodeType
	 isCaptive
Class:  CodeValue
	 code
	 description
Class:  Key
	 keyAttributes
Class:  AttributeSection
	 isOptional
Class:  Attribute
	 name
	 dataType
Class:  Derivation
	 statement
	 expression
Class:  Constraint
	 statement
	 expression
	 severity
Class:  CodeExpression
	 language
	 expression
Class:  Method
	 parameters
	 returnType
Class:  ParameterAnInputToAMethod
	 type
	 cardinality
Class:  SimpleDataTypeSubtpeOfDataType
	 coreClass
Class:  ComplexDataType
	 aggregation
	 aggregatedTypes
Class:  AggregatingOperator
	 name
	 arity
	 spelling
Class:  CamelName
	 valueTheString
Class:  ValueTypeRichText
	 value
	 format
Class:  OneLiner
	 value
finding value types...
CALC MROS - yields...
0  classes in final model
Validating LiterateModel
in calc attribute, attname is  AttributeName(content='normalName', _type='AttributeName', _html_id='Component__normalName')
calc attribute override; mro for  Class: Component  is  []
Considering Component.normalName for inversion... 
	dtc =  optional  String (O_O)
	dt  =   String  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = String
	Singular for String is String
	SKIPPING Component.normalName, a  String. core type String is a value type
in calc attribute, attname is  AttributeName(content='name', _type='AttributeName', _html_id='Component__name')
calc attribute override; mro for  Class: Component  is  []
Considering Component.name for inversion... 
	dtc =  optional  CamelName (O_O)
	dt  =   CamelName  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = CamelName
	Singular for CamelName is CamelName
	SKIPPING Component.name, a  CamelName. core type CamelName is a value type
in calc attribute, attname is  AttributeName(content='qualifiedName', _type='AttributeName', _html_id='Component__qualifiedName')
calc attribute override; mro for  Class: Component  is  []
Considering Component.qualifiedName for inversion... 
	dtc =  optional  QualifiedCamel (O_O)
	dt  =   QualifiedCamel  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = QualifiedCamel
	Singular for QualifiedCamel is QualifiedCamel
	SKIPPING Component.qualifiedName, a  QualifiedCamel. core type QualifiedCamel is a value type
in calc attribute, attname is  AttributeName(content='abbreviatedName', _type='AttributeName', _html_id='Component__abbreviatedName')
calc attribute override; mro for  Class: Component  is  []
Considering Component.abbreviatedName for inversion... 
	dtc =  optional  CamelName (O_O)
	dt  =   CamelName  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = CamelName
	Singular for CamelName is CamelName
	SKIPPING Component.abbreviatedName, a  CamelName. core type CamelName is a value type
in calc attribute, attname is  AttributeName(content='oneLiner', _type='AttributeName', _html_id='Component__oneLiner')
calc attribute override; mro for  Class: Component  is  []
Considering Component.oneLiner for inversion... 
	dtc =  optional  OneLiner (O_O)
	dt  =   OneLiner  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = OneLiner
	Singular for OneLiner is OneLiner
	SKIPPING Component.oneLiner, a  OneLiner. core type OneLiner is a value type
in calc attribute, attname is  AttributeName(content='elaboration', _type='AttributeName', _html_id='Component__elaboration')
calc attribute override; mro for  Class: Component  is  []
Considering Component.elaboration for inversion... 
	dtc =  optional  RichText (O_O)
	dt  =   RichText  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = RichText
	SKIPPING No such class as  RichText
	!!! Base type error for  RichText  in dt   RichText
ClassReference(content='LiterateDataModel', _type='ClassReference')
AttNam =  baseLiterateDataModel
dt =  value LiterateDataModel
dtc =  optional value LiterateDataModel (M_1)
Creating basedon attribute:  Attribute(one_liner=OneLiner(content='A link back to the LiterateDataModel on which this AnnotationType depends.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='baseLiterateDataModel', _type='AttributeName', _html_id='AnnotationType__baseLiterateDataModel'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='LiterateDataModel', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
In AttSection post-init for Implied Attributes for Annotation Type, is_optional = None
Creating section for Class: AnnotationType: Attributesection: Implied Attributes for Annotation Type
in calc attribute, attname is  AttributeName(content='emoji', _type='AttributeName', _html_id='AnnotationType__emoji')
calc attribute override; mro for  Class: AnnotationType  is  []
Considering AnnotationType.emoji for inversion... 
	dtc =  optional  Emoji (O_O)
	dt  =   Emoji  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Emoji
	Singular for Emoji is Emoji
	SKIPPING AnnotationType.emoji, a  Emoji. core type Emoji is a value type
in calc attribute, attname is  AttributeName(content='emojiName', _type='AttributeName', _html_id='AnnotationType__emojiName')
calc attribute override; mro for  Class: AnnotationType  is  []
Considering AnnotationType.emojiName for inversion... 
	dtc =  optional  String (O_O)
	dt  =   String  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = String
	Singular for String is String
	SKIPPING AnnotationType.emojiName, a  String. core type String is a value type
in calc attribute, attname is  AttributeName(content='emojiUnicode', _type='AttributeName', _html_id='AnnotationType__emojiUnicode')
calc attribute override; mro for  Class: AnnotationType  is  []
Considering AnnotationType.emojiUnicode for inversion... 
	dtc =  optional  String (O_O)
	dt  =   String  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = String
	Singular for String is String
	SKIPPING AnnotationType.emojiUnicode, a  String. core type String is a value type
in calc attribute, attname is  AttributeName(content='label', _type='AttributeName', _html_id='AnnotationType__label')
calc attribute override; mro for  Class: AnnotationType  is  []
Considering AnnotationType.label for inversion... 
	dtc =  optional  LowerCamel (O_O)
	dt  =   LowerCamel  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = LowerCamel
	Singular for LowerCamel is LowerCamel
	SKIPPING AnnotationType.label, a  LowerCamel. core type LowerCamel is a value type
in calc attribute, attname is  AttributeName(content='plural', _type='AttributeName', _html_id='AnnotationType__plural')
calc attribute override; mro for  Class: AnnotationType  is  []
Considering AnnotationType.plural for inversion... 
	dtc =  optional  UpperCamel (O_O)
	dt  =   UpperCamel  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = UpperCamel
	Singular for UpperCamel is UpperCamel
	SKIPPING AnnotationType.plural, a  UpperCamel. core type UpperCamel is a value type
in calc attribute, attname is  AttributeName(content='purpose', _type='AttributeName', _html_id='AnnotationType__purpose')
calc attribute override; mro for  Class: AnnotationType  is  []
Considering AnnotationType.purpose for inversion... 
	dtc =  optional  OneLiner (O_O)
	dt  =   OneLiner  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = OneLiner
	Singular for OneLiner is OneLiner
	SKIPPING AnnotationType.purpose, a  OneLiner. core type OneLiner is a value type
ClassReference(content='Component', _type='ClassReference')
AttNam =  baseComponent
dt =  value Component
dtc =  optional value Component (M_1)
Creating basedon attribute:  Attribute(one_liner=OneLiner(content='A link back to the Component on which this Annotation depends.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='baseComponent', _type='AttributeName', _html_id='Annotation__baseComponent'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Component', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
In AttSection post-init for Implied Attributes for Annotation, is_optional = None
Creating section for Class: Annotation: Attributesection: Implied Attributes for Annotation
in calc attribute, attname is  AttributeName(content='annotationType', _type='AttributeName', _html_id='Annotation__annotationType')
calc attribute override; mro for  Class: Annotation  is  []
Considering Annotation.annotationType for inversion... 
	dtc =  optional  AnnotationType (O_O)
	dt  =   AnnotationType  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = AnnotationType
	Singular for AnnotationType is AnnotationType
	Inverting Annotation.annotationType, a  AnnotationType. core type AnnotationType not a value type
	Invrse AttNam =  inverseOfAnnotationType
	Inverse dt =  value Annotation
	Inverse dtc =  optional value Annotation (M_1)
	Creating inverse attribute:  Attribute(one_liner=OneLiner(content='Inverse attribute for Annotation.annotationType from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='inverseOfAnnotationType', _type='AttributeName', _html_id='AnnotationType__inverseOfAnnotationType'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Annotation', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
In AttSection post-init for Implied Attributes for Annotation Type, is_optional = None
Creating section for Class: AnnotationType: Attributesection: Implied Attributes for Annotation Type
in calc attribute, attname is  AttributeName(content='label', _type='AttributeName', _html_id='Annotation__label')
calc attribute override; mro for  Class: Annotation  is  []
Considering Annotation.label for inversion... 
	dtc =  optional  CamelName (O_O)
	dt  =   CamelName  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = CamelName
	Singular for CamelName is CamelName
	SKIPPING Annotation.label, a  CamelName. core type CamelName is a value type
in calc attribute, attname is  AttributeName(content='emoji', _type='AttributeName', _html_id='Annotation__emoji')
calc attribute override; mro for  Class: Annotation  is  []
Considering Annotation.emoji for inversion... 
	dtc =  optional  Emoji (O_O)
	dt  =   Emoji  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Emoji
	Singular for Emoji is Emoji
	SKIPPING Annotation.emoji, a  Emoji. core type Emoji is a value type
in calc attribute, attname is  AttributeName(content='content', _type='AttributeName', _html_id='Annotation__content')
calc attribute override; mro for  Class: Annotation  is  []
Considering Annotation.content for inversion... 
	dtc =  optional  RichText (O_O)
	dt  =   RichText  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = RichText
	SKIPPING No such class as  RichText
	!!! Base type error for  RichText  in dt   RichText
in calc attribute, attname is  AttributeName(content='name', _type='AttributeName', _html_id='LiterateDataModel__name')
calc attribute override; mro for  Class: LiterateDataModel  is  ['Component']
Found override for LiterateDataModel.name in Component
Attribute name =  name
.. and as AName:  AttributeName(content='name', _type='AttributeName', _html_id=None)
Considering LiterateDataModel.name for inversion... 
	dtc =  optional  UpperCamel (O_O)
	dt  =   UpperCamel  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = UpperCamel
	Singular for UpperCamel is UpperCamel
	SKIPPING LiterateDataModel.name, a  UpperCamel. core type UpperCamel is a value type
in calc attribute, attname is  AttributeName(content='allSubjects', _type='AttributeName', _html_id='LiterateDataModel__allSubjects')
calc attribute override; mro for  Class: LiterateDataModel  is  ['Component']
Considering LiterateDataModel.allSubjects for inversion... 
	dtc =  optional List of  Classes (O_O)
	dt  =  List of  Classes  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Classes
	Singular for Classes is Class
	Inverting LiterateDataModel.allSubjects, a List of  Classes. core type Class not a value type
	Invrse AttNam =  inverseOfAllSubjects
	Inverse dt =  value LiterateDataModel
	Inverse dtc =  optional value LiterateDataModel (M_1)
	Creating inverse attribute:  Attribute(one_liner=OneLiner(content='Inverse attribute for LiterateDataModel.allSubjects from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='inverseOfAllSubjects', _type='AttributeName', _html_id='Class__inverseOfAllSubjects'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='LiterateDataModel', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
In AttSection post-init for Implied Attributes for Class, is_optional = None
Creating section for Class: Class: Attributesection: Implied Attributes for Class
in calc attribute, attname is  AttributeName(content='allClasses', _type='AttributeName', _html_id='LiterateDataModel__allClasses')
calc attribute override; mro for  Class: LiterateDataModel  is  ['Component']
Considering LiterateDataModel.allClasses for inversion... 
	dtc =  optional List of  Classes (O_O)
	dt  =  List of  Classes  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Classes
	Singular for Classes is Class
	Inverting LiterateDataModel.allClasses, a List of  Classes. core type Class not a value type
	Invrse AttNam =  inverseOfAllClasses
	Inverse dt =  value LiterateDataModel
	Inverse dtc =  optional value LiterateDataModel (M_1)
	Creating inverse attribute:  Attribute(one_liner=OneLiner(content='Inverse attribute for LiterateDataModel.allClasses from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='inverseOfAllClasses', _type='AttributeName', _html_id='Class__inverseOfAllClasses'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='LiterateDataModel', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Found section named:  Implied Attributes for Class
	!!! Base type error for  CodingLanguage  in dt   CodingLanguage
	!!! Base type error for  CodingLanguages  in dt  List of  CodingLanguages
	!!! Base type error for  TemplateLanguage  in dt   TemplateLanguage
	!!! Base type error for  TemplateLanguages  in dt  List of  TemplateLanguages
ClassReference(content='LiterateDataModel', _type='ClassReference')
AttNam =  baseLiterateDataModel
dt =  value LiterateDataModel
dtc =  optional value LiterateDataModel (M_1)
Creating basedon attribute:  Attribute(one_liner=OneLiner(content='A link back to the LiterateDataModel on which this Subject depends.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='baseLiterateDataModel', _type='AttributeName', _html_id='Subject__baseLiterateDataModel'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='LiterateDataModel', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
In AttSection post-init for Implied Attributes for Subject, is_optional = None
Creating section for Class: Subject: Attributesection: Implied Attributes for Subject
in calc attribute, attname is  AttributeName(content='name', _type='AttributeName', _html_id='Subject__name')
calc attribute override; mro for  Class: Subject  is  ['Component']
Found override for Subject.name in Component
Attribute name =  name
.. and as AName:  AttributeName(content='name', _type='AttributeName', _html_id=None)
Considering Subject.name for inversion... 
	dtc =  optional  UpperCamel (O_O)
	dt  =   UpperCamel  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = UpperCamel
	Singular for UpperCamel is UpperCamel
	SKIPPING Subject.name, a  UpperCamel. core type UpperCamel is a value type
in calc attribute, attname is  AttributeName(content='parentSubject', _type='AttributeName', _html_id='Subject__parentSubject')
calc attribute override; mro for  Class: Subject  is  ['Component']
Considering Subject.parentSubject for inversion... 
	dtc =  optional  Subject (O_O)
	dt  =   Subject  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Subject
	Singular for Subject is Subject
	Inverting Subject.parentSubject, a  Subject. core type Subject not a value type
	Invrse AttNam =  inverseOfParentSubject
	Inverse dt =  value Subject
	Inverse dtc =  optional value Subject (M_1)
	Creating inverse attribute:  Attribute(one_liner=OneLiner(content='Inverse attribute for Subject.parentSubject from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='inverseOfParentSubject', _type='AttributeName', _html_id='Subject__inverseOfParentSubject'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Subject', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Found section named:  Implied Attributes for Subject
in calc attribute, attname is  AttributeName(content='classes', _type='AttributeName', _html_id='Subject__classes')
calc attribute override; mro for  Class: Subject  is  ['Component']
Considering Subject.classes for inversion... 
	dtc =  optional List of  Classes (O_O)
	dt  =  List of  Classes  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Classes
	Singular for Classes is Class
	Inverting Subject.classes, a List of  Classes. core type Class not a value type
	Invrse AttNam =  inverseOfClasses
	Inverse dt =  value Subject
	Inverse dtc =  optional value Subject (M_1)
	Creating inverse attribute:  Attribute(one_liner=OneLiner(content='Inverse attribute for Subject.classes from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='inverseOfClasses', _type='AttributeName', _html_id='Class__inverseOfClasses'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Subject', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Found section named:  Implied Attributes for Class
in calc attribute, attname is  AttributeName(content='childSubjects', _type='AttributeName', _html_id='Subject__childSubjects')
calc attribute override; mro for  Class: Subject  is  ['Component']
Considering Subject.childSubjects for inversion... 
	Skipping: already has inverse
	dtc =  optional List of  Subjects (O_O)
	dt  =  List of  Subjects  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Subjects
	Singular for Subjects is Subject
	Inverting Subject.childSubjects, a List of  Subjects. core type Subject not a value type
	Invrse AttNam =  inverseOfChildSubjects
	Inverse dt =  value Subject
	Inverse dtc =  optional value Subject (M_1)
	Creating inverse attribute:  Attribute(one_liner=OneLiner(content='Inverse attribute for Subject.childSubjects from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='inverseOfChildSubjects', _type='AttributeName', _html_id='Subject__inverseOfChildSubjects'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Subject', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Found section named:  Implied Attributes for Subject
ClassReference(content='LiterateModel', _type='ClassReference')
AttNam =  baseLiterateModel
dt =  value LiterateModel
dtc =  optional value LiterateModel (M_1)
Creating basedon attribute:  Attribute(one_liner=OneLiner(content='A link back to the LiterateModel on which this SubjectArea depends.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='baseLiterateModel', _type='AttributeName', _html_id='SubjectArea__baseLiterateModel'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='LiterateModel', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
In AttSection post-init for Implied Attributes for Subject Area, is_optional = None
Creating section for Class: SubjectArea: Attributesection: Implied Attributes for Subject Area
ClassReference(content='Xyz', _type='ClassReference')
AttNam =  baseXyz
dt =  value Xyz
dtc =  optional value Xyz (M_1)
Creating basedon attribute:  Attribute(one_liner=OneLiner(content='A link back to the Xyz on which this SubjectArea depends.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='baseXyz', _type='AttributeName', _html_id='SubjectArea__baseXyz'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Xyz', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
In AttSection post-init for Implied Attributes for Subject Area, is_optional = None
Creating section for Class: SubjectArea: Attributesection: Implied Attributes for Subject Area
	!!! Base type error for  LiterateModel  in dt  value LiterateModel
	!!! Base type error for  Xyz  in dt  value Xyz
in calc attribute, attname is  AttributeName(content='pluralForm', _type='AttributeName', _html_id='Class__pluralForm')
calc attribute override; mro for  Class: Class  is  ['Component']
Considering Class.pluralForm for inversion... 
	dtc =  optional  UpperCamel (O_O)
	dt  =   UpperCamel  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = UpperCamel
	Singular for UpperCamel is UpperCamel
	SKIPPING Class.pluralForm, a  UpperCamel. core type UpperCamel is a value type
in calc attribute, attname is  AttributeName(content='basedOn', _type='AttributeName', _html_id='Class__basedOn')
calc attribute override; mro for  Class: Class  is  ['Component']
Considering Class.basedOn for inversion... 
	dtc =  optional Set of  Class (O_O)
	dt  =  Set of  Class  --  <class 'Literate_01.SetDataType'>
	typename of dt is: SetDataType
	Target type0 = Class
	Singular for Class is Class
	Inverting Class.basedOn, a Set of  Class. core type Class not a value type
	Invrse AttNam =  inverseOfBasedOn
	Inverse dt =  value Class
	Inverse dtc =  optional value Class (M_1)
	Creating inverse attribute:  Attribute(one_liner=OneLiner(content='Inverse attribute for Class.basedOn from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='inverseOfBasedOn', _type='AttributeName', _html_id='Class__inverseOfBasedOn'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Class', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Found section named:  Implied Attributes for Class
in calc attribute, attname is  AttributeName(content='supertypes', _type='AttributeName', _html_id='Class__supertypes')
calc attribute override; mro for  Class: Class  is  ['Component']
Considering Class.supertypes for inversion... 
	dtc =  optional  Es (O_O)
	dt  =   Es  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Es
	SKIPPING No such class as  Es
in calc attribute, attname is  AttributeName(content='subtypings', _type='AttributeName', _html_id='Class__subtypings')
calc attribute override; mro for  Class: Class  is  ['Component']
Considering Class.subtypings for inversion... 
	dtc =  optional List of  Subtypings (O_O)
	dt  =  List of  Subtypings  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Subtypings
	Singular for Subtypings is Subtyping
	Inverting Class.subtypings, a List of  Subtypings. core type Subtyping not a value type
	Invrse AttNam =  inverseOfSubtypings
	Inverse dt =  value Class
	Inverse dtc =  optional value Class (M_1)
	Creating inverse attribute:  Attribute(one_liner=OneLiner(content='Inverse attribute for Class.subtypings from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='inverseOfSubtypings', _type='AttributeName', _html_id='Subtyping__inverseOfSubtypings'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Class', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
In AttSection post-init for Implied Attributes for Subtyping, is_optional = None
Creating section for Class: Subtyping: Attributesection: Implied Attributes for Subtyping
in calc attribute, attname is  AttributeName(content='subtypes', _type='AttributeName', _html_id='Class__subtypes')
calc attribute override; mro for  Class: Class  is  ['Component']
Considering Class.subtypes for inversion... 
	dtc =  optional List of  Classes (O_O)
	dt  =  List of  Classes  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Classes
	Singular for Classes is Class
	Inverting Class.subtypes, a List of  Classes. core type Class not a value type
	Invrse AttNam =  inverseOfSubtypes
	Inverse dt =  value Class
	Inverse dtc =  optional value Class (M_1)
	Creating inverse attribute:  Attribute(one_liner=OneLiner(content='Inverse attribute for Class.subtypes from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='inverseOfSubtypes', _type='AttributeName', _html_id='Class__inverseOfSubtypes'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Class', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Found section named:  Implied Attributes for Class
in calc attribute, attname is  AttributeName(content='attributes', _type='AttributeName', _html_id='Class__attributes')
calc attribute override; mro for  Class: Class  is  ['Component']
Considering Class.attributes for inversion... 
	dtc =  optional List of  Attributes (O_O)
	dt  =  List of  Attributes  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Attributes
	Singular for Attributes is Attribute
	Inverting Class.attributes, a List of  Attributes. core type Attribute not a value type
	Invrse AttNam =  inverseOfAttributes
	Inverse dt =  value Class
	Inverse dtc =  optional value Class (M_1)
	Creating inverse attribute:  Attribute(one_liner=OneLiner(content='Inverse attribute for Class.attributes from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='inverseOfAttributes', _type='AttributeName', _html_id='Attribute__inverseOfAttributes'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Class', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
In AttSection post-init for Implied Attributes for Attribute, is_optional = None
Creating section for Class: Attribute: Attributesection: Implied Attributes for Attribute
in calc attribute, attname is  AttributeName(content='attributeSections', _type='AttributeName', _html_id='Class__attributeSections')
calc attribute override; mro for  Class: Class  is  ['Component']
Considering Class.attributeSections for inversion... 
	dtc =  optional List of  AttributeSections (O_O)
	dt  =  List of  AttributeSections  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = AttributeSections
	Singular for AttributeSections is AttributeSection
	Inverting Class.attributeSections, a List of  AttributeSections. core type AttributeSection not a value type
	Invrse AttNam =  inverseOfAttributeSections
	Inverse dt =  value Class
	Inverse dtc =  optional value Class (M_1)
	Creating inverse attribute:  Attribute(one_liner=OneLiner(content='Inverse attribute for Class.attributeSections from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='inverseOfAttributeSections', _type='AttributeName', _html_id='AttributeSection__inverseOfAttributeSections'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Class', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
In AttSection post-init for Implied Attributes for Attribute Section, is_optional = None
Creating section for Class: AttributeSection: Attributesection: Implied Attributes for Attribute Section
in calc attribute, attname is  AttributeName(content='constraints', _type='AttributeName', _html_id='Class__constraints')
calc attribute override; mro for  Class: Class  is  ['Component']
Considering Class.constraints for inversion... 
	dtc =  optional List of  Constraints (O_O)
	dt  =  List of  Constraints  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Constraints
	Singular for Constraints is Constraint
	SKIPPING Class.constraints, a List of  Constraints. core type Constraint is a value type
in calc attribute, attname is  AttributeName(content='methods', _type='AttributeName', _html_id='Class__methods')
calc attribute override; mro for  Class: Class  is  ['Component']
Considering Class.methods for inversion... 
	dtc =  optional List of  Methods (O_O)
	dt  =  List of  Methods  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Methods
	Singular for Methods is Method
	Inverting Class.methods, a List of  Methods. core type Method not a value type
	Invrse AttNam =  inverseOfMethods
	Inverse dt =  value Class
	Inverse dtc =  optional value Class (M_1)
	Creating inverse attribute:  Attribute(one_liner=OneLiner(content='Inverse attribute for Class.methods from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='inverseOfMethods', _type='AttributeName', _html_id='Method__inverseOfMethods'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Class', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
In AttSection post-init for Implied Attributes for Method, is_optional = None
Creating section for Class: Method: Attributesection: Implied Attributes for Method
	!!! Base type error for  Es  in dt   Es
ClassReference(content='Class', _type='ClassReference')
AttNam =  baseClass
dt =  value Class
dtc =  optional value Class (M_1)
Creating basedon attribute:  Attribute(one_liner=OneLiner(content='A link back to the Class on which this Subtyping depends.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='baseClass', _type='AttributeName', _html_id='Subtyping__baseClass'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Class', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Found section named:  Implied Attributes for Subtyping
in calc attribute, attname is  AttributeName(content='name', _type='AttributeName', _html_id='Subtyping__name')
calc attribute override; mro for  Class: Subtyping  is  []
Considering Subtyping.name for inversion... 
	dtc =  optional  LowerCamel (O_O)
	dt  =   LowerCamel  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = LowerCamel
	Singular for LowerCamel is LowerCamel
	SKIPPING Subtyping.name, a  LowerCamel. core type LowerCamel is a value type
in calc attribute, attname is  AttributeName(content='isExclusive', _type='AttributeName', _html_id='Subtyping__isExclusive')
calc attribute override; mro for  Class: Subtyping  is  []
Considering Subtyping.isExclusive for inversion... 
	dtc =  optional  Boolean (O_O)
	dt  =   Boolean  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Boolean
	Singular for Boolean is Boolean
	SKIPPING Subtyping.isExclusive, a  Boolean. core type Boolean is a value type
in calc attribute, attname is  AttributeName(content='isExhaustive', _type='AttributeName', _html_id='Subtyping__isExhaustive')
calc attribute override; mro for  Class: Subtyping  is  []
Considering Subtyping.isExhaustive for inversion... 
	dtc =  optional  Boolean (O_O)
	dt  =   Boolean  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Boolean
	Singular for Boolean is Boolean
	SKIPPING Subtyping.isExhaustive, a  Boolean. core type Boolean is a value type
in calc attribute, attname is  AttributeName(content='classes', _type='AttributeName', _html_id='Subtyping__classes')
calc attribute override; mro for  Class: Subtyping  is  []
Considering Subtyping.classes for inversion... 
	dtc =  optional List of  Classes (O_O)
	dt  =  List of  Classes  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Classes
	Singular for Classes is Class
	Inverting Subtyping.classes, a List of  Classes. core type Class not a value type
	Invrse AttNam =  inverseOfClasses
	Inverse dt =  value Subtyping
	Inverse dtc =  optional value Subtyping (M_1)
	Creating inverse attribute:  Attribute(one_liner=OneLiner(content='Inverse attribute for Subtyping.classes from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='inverseOfClasses', _type='AttributeName', _html_id='Class__inverseOfClasses'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Subtyping', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Found section named:  Implied Attributes for Class
in calc attribute, attname is  AttributeName(content='isCaptive', _type='AttributeName', _html_id='CodeType__isCaptive')
calc attribute override; mro for  Valuetype: CodeType  is  []
Considering CodeType.isCaptive for inversion... 
	dtc =  optional  Boolean (O_O)
	dt  =   Boolean  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Boolean
	Singular for Boolean is Boolean
	SKIPPING CodeType.isCaptive, a  Boolean. core type Boolean is a value type
ClassReference(content='CodeType', _type='ClassReference')
AttNam =  baseCodeType
dt =  value CodeType
dtc =  optional value CodeType (M_1)
Creating basedon attribute:  Attribute(one_liner=OneLiner(content='A link back to the CodeType on which this CodeValue depends.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='baseCodeType', _type='AttributeName', _html_id='CodeValue__baseCodeType'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='CodeType', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
In AttSection post-init for Implied Attributes for Code Value, is_optional = None
Creating section for Valuetype: CodeValue: Attributesection: Implied Attributes for Code Value
in calc attribute, attname is  AttributeName(content='code', _type='AttributeName', _html_id='CodeValue__code')
calc attribute override; mro for  Valuetype: CodeValue  is  []
Considering CodeValue.code for inversion... 
	dtc =  optional  NameString (O_O)
	dt  =   NameString  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = NameString
	SKIPPING No such class as  NameString
in calc attribute, attname is  AttributeName(content='description', _type='AttributeName', _html_id='CodeValue__description')
calc attribute override; mro for  Valuetype: CodeValue  is  []
Considering CodeValue.description for inversion... 
	dtc =  optional  RichText (O_O)
	dt  =   RichText  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = RichText
	SKIPPING No such class as  RichText
	!!! Base type error for  NameString  in dt   NameString
	!!! Base type error for  RichText  in dt   RichText
ClassReference(content='Class', _type='ClassReference')
AttNam =  baseClass
dt =  value Class
dtc =  optional value Class (M_1)
Creating basedon attribute:  Attribute(one_liner=OneLiner(content='A link back to the Class on which this Key depends.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='baseClass', _type='AttributeName', _html_id='Key__baseClass'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Class', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
In AttSection post-init for Implied Attributes for Key, is_optional = None
Creating section for Class: Key: Attributesection: Implied Attributes for Key
in calc attribute, attname is  AttributeName(content='keyAttributes', _type='AttributeName', _html_id='Key__keyAttributes')
calc attribute override; mro for  Class: Key  is  ['Component']
Considering Key.keyAttributes for inversion... 
	dtc =  optional List of  Attributes (O_O)
	dt  =  List of  Attributes  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Attributes
	Singular for Attributes is Attribute
	Inverting Key.keyAttributes, a List of  Attributes. core type Attribute not a value type
	Invrse AttNam =  inverseOfKeyAttributes
	Inverse dt =  value Key
	Inverse dtc =  optional value Key (M_1)
	Creating inverse attribute:  Attribute(one_liner=OneLiner(content='Inverse attribute for Key.keyAttributes from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='inverseOfKeyAttributes', _type='AttributeName', _html_id='Attribute__inverseOfKeyAttributes'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Key', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Found section named:  Implied Attributes for Attribute
ClassReference(content='Class', _type='ClassReference')
AttNam =  baseClass
dt =  value Class
dtc =  optional value Class (M_1)
Creating basedon attribute:  Attribute(one_liner=OneLiner(content='A link back to the Class on which this AttributeSection depends.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='baseClass', _type='AttributeName', _html_id='AttributeSection__baseClass'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Class', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
In AttSection post-init for Implied Attributes for Attribute Section, is_optional = None
Creating section for Class: AttributeSection: Attributesection: Implied Attributes for Attribute Section
in calc attribute, attname is  AttributeName(content='isOptional', _type='AttributeName', _html_id='AttributeSection__isOptional')
calc attribute override; mro for  Class: AttributeSection  is  ['Component']
Considering AttributeSection.isOptional for inversion... 
	dtc =  optional  Boolean (O_O)
	dt  =   Boolean  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Boolean
	Singular for Boolean is Boolean
	SKIPPING AttributeSection.isOptional, a  Boolean. core type Boolean is a value type
ClassReference(content='AttributeSection', _type='ClassReference')
AttNam =  baseAttributeSection
dt =  value AttributeSection
dtc =  optional value AttributeSection (M_1)
Creating basedon attribute:  Attribute(one_liner=OneLiner(content='A link back to the AttributeSection on which this Attribute depends.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='baseAttributeSection', _type='AttributeName', _html_id='Attribute__baseAttributeSection'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='AttributeSection', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Found section named:  Implied Attributes for Attribute
in calc attribute, attname is  AttributeName(content='name', _type='AttributeName', _html_id='Attribute__name')
calc attribute override; mro for  Class: Attribute  is  ['Component']
Found override for Attribute.name in Component
Attribute name =  name
.. and as AName:  AttributeName(content='name', _type='AttributeName', _html_id=None)
Considering Attribute.name for inversion... 
	dtc =  optional  LowerCamel (O_O)
	dt  =   LowerCamel  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = LowerCamel
	Singular for LowerCamel is LowerCamel
	SKIPPING Attribute.name, a  LowerCamel. core type LowerCamel is a value type
in calc attribute, attname is  AttributeName(content='dataType', _type='AttributeName', _html_id='Attribute__dataType')
calc attribute override; mro for  Class: Attribute  is  ['Component']
Considering Attribute.dataType for inversion... 
	dtc =  optional  DataType (O_O)
	dt  =   DataType  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = DataType
	Singular for DataType is DataType
	SKIPPING Attribute.dataType, a  DataType. core type DataType is a value type
	!!! Base type error for  CardinalityCode  in dt   CardinalityCode
	!!! Base type error for  InventedName  in dt  value InventedName
	!!! Base type error for  InventedName  in dt  value InventedName
in calc attribute, attname is  AttributeName(content='statement', _type='AttributeName', _html_id='Derivation__statement')
calc attribute override; mro for  Valuetype: Derivation  is  []
Considering Derivation.statement for inversion... 
	dtc =  optional  RichText (O_O)
	dt  =   RichText  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = RichText
	SKIPPING No such class as  RichText
in calc attribute, attname is  AttributeName(content='expression', _type='AttributeName', _html_id='Derivation__expression')
calc attribute override; mro for  Valuetype: Derivation  is  []
Considering Derivation.expression for inversion... 
	dtc =  optional  CodeExpression (O_O)
	dt  =   CodeExpression  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = CodeExpression
	Singular for CodeExpression is CodeExpression
	SKIPPING Derivation.expression, a  CodeExpression. core type CodeExpression is a value type
	!!! Base type error for  RichText  in dt   RichText
in calc attribute, attname is  AttributeName(content='statement', _type='AttributeName', _html_id='Constraint__statement')
calc attribute override; mro for  Valuetype: Constraint  is  ['Component']
Considering Constraint.statement for inversion... 
	dtc =  optional  RichText (O_O)
	dt  =   RichText  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = RichText
	SKIPPING No such class as  RichText
in calc attribute, attname is  AttributeName(content='expression', _type='AttributeName', _html_id='Constraint__expression')
calc attribute override; mro for  Valuetype: Constraint  is  ['Component']
Considering Constraint.expression for inversion... 
	dtc =  optional value InventedName (O_O)
	dt  =  value InventedName  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = InventedName
	SKIPPING No such class as  InventedName
in calc attribute, attname is  AttributeName(content='severity', _type='AttributeName', _html_id='Constraint__severity')
calc attribute override; mro for  Valuetype: Constraint  is  ['Component']
Considering Constraint.severity for inversion... 
	dtc =  optional  Code (O_O)
	dt  =   Code  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Code
	SKIPPING No such class as  Code
	!!! Base type error for  RichText  in dt   RichText
	!!! Base type error for  InventedName  in dt  value InventedName
	!!! Base type error for  Code  in dt   Code
ClassReference(content='Class', _type='ClassReference')
AttNam =  baseClass
dt =  value Class
dtc =  optional value Class (M_1)
Creating basedon attribute:  Attribute(one_liner=OneLiner(content='A link back to the Class on which this ClassConstraint depends.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='baseClass', _type='AttributeName', _html_id='ClassConstraint__baseClass'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Class', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
In AttSection post-init for Implied Attributes for Class Constraint, is_optional = None
Creating section for Valuetype: ClassConstraint: Attributesection: Implied Attributes for Class Constraint
ClassReference(content='Attribute', _type='ClassReference')
AttNam =  baseAttribute
dt =  value Attribute
dtc =  optional value Attribute (M_1)
Creating basedon attribute:  Attribute(one_liner=OneLiner(content='A link back to the Attribute on which this AttributeConstraint depends.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='baseAttribute', _type='AttributeName', _html_id='AttributeConstraint__baseAttribute'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Attribute', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
In AttSection post-init for Implied Attributes for Attribute Constraint, is_optional = None
Creating section for Valuetype: AttributeConstraint: Attributesection: Implied Attributes for Attribute Constraint
in calc attribute, attname is  AttributeName(content='language', _type='AttributeName', _html_id='CodeExpression__language')
calc attribute override; mro for  Valuetype: CodeExpression  is  []
Considering CodeExpression.language for inversion... 
	dtc =  optional  Code (O_O)
	dt  =   Code  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Code
	SKIPPING No such class as  Code
in calc attribute, attname is  AttributeName(content='expression', _type='AttributeName', _html_id='CodeExpression__expression')
calc attribute override; mro for  Valuetype: CodeExpression  is  []
Considering CodeExpression.expression for inversion... 
	dtc =  optional  String (O_O)
	dt  =   String  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = String
	Singular for String is String
	SKIPPING CodeExpression.expression, a  String. core type String is a value type
	!!! Base type error for  Code  in dt   Code
in calc attribute, attname is  AttributeName(content='parameters', _type='AttributeName', _html_id='Method__parameters')
calc attribute override; mro for  Class: Method  is  ['Component']
Considering Method.parameters for inversion... 
	dtc =  optional List of  Parameters (O_O)
	dt  =  List of  Parameters  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Parameters
	Singular for Parameters is ParameterAnInputToAMethod
	Inverting Method.parameters, a List of  Parameters. core type ParameterAnInputToAMethod not a value type
	Invrse AttNam =  inverseOfParameters
	Inverse dt =  value Method
	Inverse dtc =  optional value Method (M_1)
	Creating inverse attribute:  Attribute(one_liner=OneLiner(content='Inverse attribute for Method.parameters from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='inverseOfParameters', _type='AttributeName', _html_id='ParameterAnInputToAMethod__inverseOfParameters'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='Method', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
In AttSection post-init for Implied Attributes for Parameter An Input To A Method, is_optional = None
Creating section for Class: ParameterAnInputToAMethod: Attributesection: Implied Attributes for Parameter An Input To A Method
in calc attribute, attname is  AttributeName(content='returnType', _type='AttributeName', _html_id='Method__returnType')
calc attribute override; mro for  Class: Method  is  ['Component']
Considering Method.returnType for inversion... 
	dtc =  optional  DataType (O_O)
	dt  =   DataType  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = DataType
	Singular for DataType is DataType
	SKIPPING Method.returnType, a  DataType. core type DataType is a value type
in calc attribute, attname is  AttributeName(content='type', _type='AttributeName', _html_id='ParameterAnInputToAMethod__type')
calc attribute override; mro for  Class: ParameterAnInputToAMethod  is  ['Component']
Considering ParameterAnInputToAMethod.type for inversion... 
	dtc =  optional  DataType (O_O)
	dt  =   DataType  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = DataType
	Singular for DataType is DataType
	SKIPPING ParameterAnInputToAMethod.type, a  DataType. core type DataType is a value type
in calc attribute, attname is  AttributeName(content='cardinality', _type='AttributeName', _html_id='ParameterAnInputToAMethod__cardinality')
calc attribute override; mro for  Class: ParameterAnInputToAMethod  is  ['Component']
Considering ParameterAnInputToAMethod.cardinality for inversion... 
	dtc =  optional value InventedName (O_O)
	dt  =  value InventedName  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = InventedName
	SKIPPING No such class as  InventedName
	!!! Base type error for  InventedName  in dt  value InventedName
in calc attribute, attname is  AttributeName(content='coreClass', _type='AttributeName', _html_id='SimpleDataTypeSubtpeOfDataType__coreClass')
calc attribute override; mro for  Valuetype: SimpleDataTypeSubtpeOfDataType  is  []
Considering SimpleDataTypeSubtpeOfDataType.coreClass for inversion... 
	dtc =  optional  Class (O_O)
	dt  =   Class  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Class
	Singular for Class is Class
	Inverting SimpleDataTypeSubtpeOfDataType.coreClass, a  Class. core type Class not a value type
	Invrse AttNam =  inverseOfCoreClass
	Inverse dt =  value SimpleDataTypeSubtpeOfDataType
	Inverse dtc =  optional value SimpleDataTypeSubtpeOfDataType (M_1)
	Creating inverse attribute:  Attribute(one_liner=OneLiner(content='Inverse attribute for SimpleDataTypeSubtpeOfDataType.coreClass from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(content='inverseOfCoreClass', _type='AttributeName', _html_id='Class__inverseOfCoreClass'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(class_name=ClassReference(content='SimpleDataTypeSubtpeOfDataType', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Found section named:  Implied Attributes for Class
in calc attribute, attname is  AttributeName(content='aggregation', _type='AttributeName', _html_id='ComplexDataType__aggregation')
calc attribute override; mro for  Valuetype: ComplexDataType  is  []
Considering ComplexDataType.aggregation for inversion... 
	dtc =  optional  AggregatingOperator (O_O)
	dt  =   AggregatingOperator  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = AggregatingOperator
	Singular for AggregatingOperator is AggregatingOperator
	SKIPPING ComplexDataType.aggregation, a  AggregatingOperator. core type AggregatingOperator is a value type
in calc attribute, attname is  AttributeName(content='aggregatedTypes', _type='AttributeName', _html_id='ComplexDataType__aggregatedTypes')
calc attribute override; mro for  Valuetype: ComplexDataType  is  []
Considering ComplexDataType.aggregatedTypes for inversion... 
	dtc =  optional List of  DataTypes (O_O)
	dt  =  List of  DataTypes  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = DataTypes
	Singular for DataTypes is DataType
	SKIPPING ComplexDataType.aggregatedTypes, a List of  DataTypes. core type DataType is a value type
in calc attribute, attname is  AttributeName(content='name', _type='AttributeName', _html_id='AggregatingOperator__name')
calc attribute override; mro for  Valuetype: AggregatingOperator  is  []
Considering AggregatingOperator.name for inversion... 
	dtc =  optional  Code (O_O)
	dt  =   Code  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Code
	SKIPPING No such class as  Code
in calc attribute, attname is  AttributeName(content='arity', _type='AttributeName', _html_id='AggregatingOperator__arity')
calc attribute override; mro for  Valuetype: AggregatingOperator  is  []
Considering AggregatingOperator.arity for inversion... 
	dtc =  optional  Integer (O_O)
	dt  =   Integer  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Integer
	Singular for Integer is Integer
	SKIPPING AggregatingOperator.arity, a  Integer. core type Integer is a value type
in calc attribute, attname is  AttributeName(content='spelling', _type='AttributeName', _html_id='AggregatingOperator__spelling')
calc attribute override; mro for  Valuetype: AggregatingOperator  is  []
Considering AggregatingOperator.spelling for inversion... 
	dtc =  optional  Template (O_O)
	dt  =   Template  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Template
	SKIPPING No such class as  Template
	!!! Base type error for  Code  in dt   Code
	!!! Base type error for  Template  in dt   Template
in calc attribute, attname is  AttributeName(content='valueTheString', _type='AttributeName', _html_id='CamelName__valueTheString')
calc attribute override; mro for  Valuetype: CamelName  is  ['String', 'PrimitiveType']
Considering CamelName.valueTheString for inversion... 
	dtc =  optional  String (O_O)
	dt  =   String  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = String
	Singular for String is String
	SKIPPING CamelName.valueTheString, a  String. core type String is a value type
in calc attribute, attname is  AttributeName(content='value', _type='AttributeName', _html_id='ValueTypeRichText__value')
calc attribute override; mro for  Class: ValueTypeRichText  is  ['String', 'PrimitiveType']
Considering ValueTypeRichText.value for inversion... 
	dtc =  optional  String (O_O)
	dt  =   String  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = String
	Singular for String is String
	SKIPPING ValueTypeRichText.value, a  String. core type String is a value type
in calc attribute, attname is  AttributeName(content='format', _type='AttributeName', _html_id='ValueTypeRichText__format')
calc attribute override; mro for  Class: ValueTypeRichText  is  ['String', 'PrimitiveType']
Considering ValueTypeRichText.format for inversion... 
	dtc =  optional  Code (O_O)
	dt  =   Code  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Code
	SKIPPING No such class as  Code
	!!! Base type error for  Code  in dt   Code
in calc attribute, attname is  AttributeName(content='value', _type='AttributeName', _html_id='OneLiner__value')
calc attribute override; mro for  Valuetype: OneLiner  is  []
Considering OneLiner.value for inversion... 
	dtc =  optional  String (O_O)
	dt  =   String  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = String
	Singular for String is String
	SKIPPING OneLiner.value, a  String. core type String is a value type
Call to Validating references...
Before validating:  0  classes in model
Validating references
Validation class refs for  Component with att =  based_on  -  []
Validation class refs for  Component with att =  dependents  -  [ClassReference(content='Annotation', _type='ClassReference')]
Validation class refs for  AnnotationType with att =  based_on  -  [ClassReference(content='LiterateDataModel', _type='ClassReference')]
Validation class refs for  AnnotationType with att =  dependents  -  []
Validation class refs for  Annotation with att =  based_on  -  [ClassReference(content='Component', _type='ClassReference')]
Validation class refs for  Annotation with att =  dependents  -  []
Validation class refs for  LiterateDataModel with att =  based_on  -  []
Validation class refs for  LiterateDataModel with att =  dependents  -  [ClassReference(content='AnnotationType', _type='ClassReference'), ClassReference(content='Subject', _type='ClassReference')]
Validation class refs for  Subject with att =  based_on  -  [ClassReference(content='LiterateDataModel', _type='ClassReference')]
Validation class refs for  Subject with att =  dependents  -  []
Validation class refs for  SubjectArea with att =  based_on  -  [ClassReference(content='LiterateModel', _type='ClassReference'), ClassReference(content='Xyz', _type='ClassReference')]
Validation class refs for  SubjectArea with att =  dependents  -  []
Validation class refs for  Class with att =  based_on  -  []
Validation class refs for  Class with att =  dependents  -  [ClassReference(content='Subtyping', _type='ClassReference'), ClassReference(content='Key', _type='ClassReference'), ClassReference(content='AttributeSection', _type='ClassReference'), ClassReference(content='ClassConstraint', _type='ClassReference')]
Validation class refs for  Subtyping with att =  based_on  -  [ClassReference(content='Class', _type='ClassReference')]
Validation class refs for  Subtyping with att =  dependents  -  []
Validation class refs for  ReferenceType with att =  based_on  -  []
Validation class refs for  ReferenceType with att =  dependents  -  []
Validation class refs for  CodeType with att =  based_on  -  []
Validation class refs for  CodeType with att =  dependents  -  [ClassReference(content='CodeValue', _type='ClassReference')]
Validation class refs for  CodeValue with att =  based_on  -  [ClassReference(content='CodeType', _type='ClassReference')]
Validation class refs for  CodeValue with att =  dependents  -  []
Validation class refs for  Key with att =  based_on  -  [ClassReference(content='Class', _type='ClassReference')]
Validation class refs for  Key with att =  dependents  -  []
Validation class refs for  UniqueKey with att =  based_on  -  []
Validation class refs for  UniqueKey with att =  dependents  -  []
Validation class refs for  AttributeSection with att =  based_on  -  [ClassReference(content='Class', _type='ClassReference')]
Validation class refs for  AttributeSection with att =  dependents  -  [ClassReference(content='Attribute', _type='ClassReference')]
Validation class refs for  Attribute with att =  based_on  -  [ClassReference(content='AttributeSection', _type='ClassReference')]
Validation class refs for  Attribute with att =  dependents  -  [ClassReference(content='AttributeConstraint', _type='ClassReference')]
Validation class refs for  Derivation with att =  based_on  -  []
Validation class refs for  Derivation with att =  dependents  -  []
Validation class refs for  Constraint with att =  based_on  -  []
Validation class refs for  Constraint with att =  dependents  -  []
Validation class refs for  Message with att =  based_on  -  []
Validation class refs for  Message with att =  dependents  -  []
Validation class refs for  ClassConstraint with att =  based_on  -  [ClassReference(content='Class', _type='ClassReference')]
Validation class refs for  ClassConstraint with att =  dependents  -  []
Validation class refs for  AttributeConstraint with att =  based_on  -  [ClassReference(content='Attribute', _type='ClassReference')]
Validation class refs for  AttributeConstraint with att =  dependents  -  []
Validation class refs for  CodeExpression with att =  based_on  -  []
Validation class refs for  CodeExpression with att =  dependents  -  []
Validation class refs for  Method with att =  based_on  -  []
Validation class refs for  Method with att =  dependents  -  []
Validation class refs for  ParameterAnInputToAMethod with att =  based_on  -  []
Validation class refs for  ParameterAnInputToAMethod with att =  dependents  -  []
Validation class refs for  DataType with att =  based_on  -  []
Validation class refs for  DataType with att =  dependents  -  []
Validation class refs for  SimpleDataTypeSubtpeOfDataType with att =  based_on  -  []
Validation class refs for  SimpleDataTypeSubtpeOfDataType with att =  dependents  -  []
Validation class refs for  ComplexDataType with att =  based_on  -  []
Validation class refs for  ComplexDataType with att =  dependents  -  []
Validation class refs for  AggregatingOperator with att =  based_on  -  []
Validation class refs for  AggregatingOperator with att =  dependents  -  []
Validation class refs for  Emoji with att =  based_on  -  []
Validation class refs for  Emoji with att =  dependents  -  []
Validation class refs for  String with att =  based_on  -  []
Validation class refs for  String with att =  dependents  -  []
Validation class refs for  CamelName with att =  based_on  -  []
Validation class refs for  CamelName with att =  dependents  -  []
Validation class refs for  UpperCamel with att =  based_on  -  []
Validation class refs for  UpperCamel with att =  dependents  -  []
Validation class refs for  LowerCamel with att =  based_on  -  []
Validation class refs for  LowerCamel with att =  dependents  -  []
Validation class refs for  QualifiedCamel with att =  based_on  -  []
Validation class refs for  QualifiedCamel with att =  dependents  -  []
Validation class refs for  ValueTypeRichText with att =  based_on  -  []
Validation class refs for  ValueTypeRichText with att =  dependents  -  []
Validation class refs for  OneLiner with att =  based_on  -  []
Validation class refs for  OneLiner with att =  dependents  -  []
Validation class refs for  PrimitiveType with att =  based_on  -  []
Validation class refs for  PrimitiveType with att =  dependents  -  []
Validation class refs for  String with att =  based_on  -  []
Validation class refs for  String with att =  dependents  -  []
Validation class refs for  Integer with att =  based_on  -  []
Validation class refs for  Integer with att =  dependents  -  []
Validation class refs for  Decimal with att =  based_on  -  []
Validation class refs for  Decimal with att =  dependents  -  []
Validation class refs for  Boolean with att =  based_on  -  []
Validation class refs for  Boolean with att =  dependents  -  []
Validation class refs for  Date with att =  based_on  -  []
Validation class refs for  Date with att =  dependents  -  []
Validation class refs for  Time with att =  based_on  -  []
Validation class refs for  Time with att =  dependents  -  []
Validation class refs for  DateTime with att =  based_on  -  []
Validation class refs for  DateTime with att =  dependents  -  []
After validating:  0  classes in model
Validation diagnostics: 67
- Warning (Style) on Attribute named oneLiner: oneLiner is too long. (116 chars).
- Error (InvalidBaseType) on BaseDataType named : RichText is not a class name - or plural
- Warning (Style) on Attribute named isEmbellishment: oneLiner is too long. (91 chars).
- Warning (Style) on Class named AnnotationType: oneLiner is too long. (96 chars).
- Warning (Style) on AttributeSection named Implied Attributes for Annotation Type: name is too long. (38 chars).
- Error (InvalidBaseType) on BaseDataType named : RichText is not a class name - or plural
- Warning (Style) on Attribute named isEmbellishment: oneLiner is too long. (92 chars).
- Warning (Style) on AttributeSection named Implied Attributes for Annotation: name is too long. (33 chars).
- Warning (Style) on Class named LiterateDataModel: oneLiner is too long. (112 chars).
- Error (MissingValue) on Constraint named : Missing value for required field: 'ocl'
- Error (MissingValue) on Constraint named : Missing value for required field: 'ocl'
- Error (InvalidBaseType) on BaseDataType named : CodingLanguage is not a class name - or plural
- Error (InvalidBaseType) on ListDataType named : CodingLanguages is not a class name - or plural
- Error (InvalidBaseType) on BaseDataType named : TemplateLanguage is not a class name - or plural
- Error (InvalidBaseType) on ListDataType named : TemplateLanguages is not a class name - or plural
- Bug (MissingValue) on Class named LiterateDataModel: Required field 'presumed_plural' is missing
- Warning (Style) on Attribute named classes: oneLiner is too long. (91 chars).
- Warning (Style) on Attribute named childSubjects: oneLiner is too long. (94 chars).
- Bug (MissingValue) on Class named Subject: Required field 'presumed_plural' is missing
- Warning (Style) on AttributeSection named Implied Attributes for Subject Area: name is too long. (35 chars).
- Error (InvalidBaseType) on BaseDataType named : LiterateModel is not a class name - or plural
- Warning (Style) on AttributeSection named Implied Attributes for Subject Area: name is too long. (35 chars).
- Error (InvalidBaseType) on BaseDataType named : Xyz is not a class name - or plural
- Bug (MissingValue) on Class named SubjectArea: Required field 'presumed_plural' is missing
- Error (MissingValue) on Constraint named : Missing value for required field: 'ocl'
- Error (InvalidBaseType) on BaseDataType named : Es is not a class name - or plural
- Warning (Style) on Attribute named attributes: oneLiner is too long. (91 chars).
- Bug (MissingValue) on Class named Class: Required field 'presumed_plural' is missing
- Warning (Style) on AttributeSection named Implied Attributes for Subtyping: name is too long. (32 chars).
- Error (InvalidBaseType) on BaseDataType named : NameString is not a class name - or plural
- Error (InvalidBaseType) on BaseDataType named : RichText is not a class name - or plural
- Warning (Style) on AttributeSection named Implied Attributes for Code Value: name is too long. (33 chars).
- Error (MissingValue) on Constraint named : Missing value for required field: 'ocl'
- Error (MissingValue) on Constraint named : Missing value for required field: 'ocl'
- Warning (Style) on AttributeSection named Implied Attributes for Attribute Section: name is too long. (40 chars).
- Warning (Style) on AttributeSection named Implied Attributes for Attribute Section: name is too long. (40 chars).
- Error (InvalidBaseType) on BaseDataType named : CardinalityCode is not a class name - or plural
- Warning (Style) on Default named : Formula one_liner is too long (220 chars)
- Error (InvalidBaseType) on BaseDataType named : InventedName is not a class name - or plural
- Error (InvalidBaseType) on BaseDataType named : InventedName is not a class name - or plural
- Warning (Style) on Attribute named default: oneLiner is too long. (143 chars).
- Bug (MissingValue) on Attribute named overrides: Required field 'data_type_clause' is missing
- Warning (Style) on AttributeSection named Implied Attributes for Attribute: name is too long. (32 chars).
- Bug (MissingValue) on Class named Attribute: Required field 'presumed_plural' is missing
- Error (InvalidBaseType) on BaseDataType named : RichText is not a class name - or plural
- Bug (MissingValue) on ValueType named Derivation: Required field 'presumed_plural' is missing
- Error (InvalidBaseType) on BaseDataType named : RichText is not a class name - or plural
- Error (InvalidBaseType) on BaseDataType named : InventedName is not a class name - or plural
- Error (InvalidBaseType) on BaseDataType named : Code is not a class name - or plural
- Bug (MissingValue) on ValueType named Constraint: Required field 'presumed_plural' is missing
- Warning (Style) on AttributeSection named Implied Attributes for Class Constraint: name is too long. (39 chars).
- Warning (Style) on AttributeSection named Implied Attributes for Attribute Constraint: name is too long. (43 chars).
- Error (InvalidBaseType) on BaseDataType named : Code is not a class name - or plural
- Bug (MissingValue) on Class named Method: Required field 'presumed_plural' is missing
- Error (InvalidBaseType) on BaseDataType named : InventedName is not a class name - or plural
- Warning (Style) on AttributeSection named Implied Attributes for Parameter An Input To A Method: name is too long. (53 chars).
- Bug (MissingValue) on Class named ParameterAnInputToAMethod: Required field 'presumed_plural' is missing
- Error (InvalidBaseType) on BaseDataType named : Code is not a class name - or plural
- Error (InvalidBaseType) on BaseDataType named : Template is not a class name - or plural
- Error (MissingValue) on Constraint named : Missing value for required field: 'ocl'
- Warning (Style) on Constraint named : Formula one_liner is too long (129 chars)
- Error (MissingValue) on Constraint named : Missing value for required field: 'ocl'
- Error (InvalidBaseType) on BaseDataType named : Code is not a class name - or plural
- Error (MissingValue) on Constraint named : Missing value for required field: 'ocl'
- Warning (Style) on SubjectB named Appendices: oneLiner is too long. (126 chars).
- Error (InvalidClassReference) on Class named SubjectArea: Invalid reference to 'LiterateModel' in based_on
- Error (InvalidClassReference) on Class named SubjectArea: Invalid reference to 'Xyz' in based_on
..Created dict for validated model: ldm/ldm_models/Literate/Literate_results/Literate_PD_04.v_model.yaml

Phase: counting diagnostics
{'Warning - Attribute - Style- checkOneLinerLength': 7, 'Error - BaseDataType - InvalidBaseType- checkClassReference': 21, 'Warning - Class - Style- checkOneLinerLength': 2, 'Warning - AttributeSection - Style- NoConstraintName': 12, 'Error - Constraint - MissingValue- NoConstraintName': 8, 'Error - ListDataType - InvalidBaseType- checkClassReference': 2, 'Bug - Class - MissingValue- NoConstraintName': 7, 'Warning - Default - Style- NoConstraintName': 1, 'Bug - Attribute - MissingValue- NoConstraintName': 1, 'Bug - ValueType - MissingValue- NoConstraintName': 2, 'Warning - Constraint - Style- NoConstraintName': 1, 'Warning - SubjectB - Style- checkOneLinerLength': 1, 'Error - Class - InvalidClassReference- checkListedClassReference': 2}
7 	 Warning - Attribute - Style- checkOneLinerLength
21 	 Error - BaseDataType - InvalidBaseType- checkClassReference
2 	 Warning - Class - Style- checkOneLinerLength
12 	 Warning - AttributeSection - Style- NoConstraintName
8 	 Error - Constraint - MissingValue- NoConstraintName
2 	 Error - ListDataType - InvalidBaseType- checkClassReference
7 	 Bug - Class - MissingValue- NoConstraintName
1 	 Warning - Default - Style- NoConstraintName
1 	 Bug - Attribute - MissingValue- NoConstraintName
2 	 Bug - ValueType - MissingValue- NoConstraintName
1 	 Warning - Constraint - Style- NoConstraintName
1 	 Warning - SubjectB - Style- checkOneLinerLength
2 	 Error - Class - InvalidClassReference- checkListedClassReference
pattern is ldm/ldm_models/Literate/Literate_results/*dict*.yaml
pattern is ldm/ldm_models/Literate/Literate_results/*model*.yaml
Dict names are:  ['Literate_PD_02.dict.yaml', 'Literate_PD_03.model.yaml', 'Literate_PD_04.v_model.yaml']
All combos are:
['Literate_PD_02.dict.yaml', 'Literate_PD_03.model.yaml']
['Literate_PD_03.model.yaml', 'Literate_PD_04.v_model.yaml']
Combo is: ['Literate_PD_02.dict.yaml', 'Literate_PD_03.model.yaml']
Including:  Literate_PD_02.dict.yaml
Including:  Literate_PD_03.model.yaml
Combo is: ['Literate_PD_03.model.yaml', 'Literate_PD_04.v_model.yaml']
Including:  Literate_PD_03.model.yaml
Including:  Literate_PD_04.v_model.yaml

Phase: Create extract for diagrams
Registered as_extract for object
Registered as_extract for LiterateModel
Registered as_extract for Class
Faculty class Extractors created
Faculty patches setup:
  Component.validate -> validate_component
  Component.as_html -> component_html
  LiterateModel.validate -> validate_literate_model
  LiterateModel.as_html -> literate_model_html
  LiterateModel.as_extract -> model_extract
  SubjectE.validate -> validate_subject_e
  SubjectE.as_html -> subject_html
  Class.validate -> validate_class
  Class.as_html -> class_html
  Class.as_extract -> class_extract
  AttributeSection.validate -> validate_attribute_section
  AttributeSection.as_html -> attribute_section_html
  Attribute.validate -> validate_attribute
  Attribute.as_html -> attribute_html
  Formula.validate -> validate_formula
  Formula.as_html -> formula_html
  Constraint.validate -> validate_constraint
  object.as_html -> any_html
  object.as_extract -> any_extract
  Paragraph.as_html -> paragraph_html
  OneLiner.as_html -> one_liner_html
  CodeBlock.as_html -> code_block_html
  str.as_html -> str_html
  list.as_html -> list_html
  Annotation.as_html -> annotation_html
  Emoji.as_html -> emoji_html
  Casing.as_html -> casing_html
  ClassName.as_html -> class_name_html
  ClassReference.as_html -> class_reference_html
  SubtypeBy.as_html -> subtype_by_html
  DataTypeClause.as_html -> dtc_html
  BaseDataType.as_html -> bdt_html
  ListDataType.as_html -> ldt_html
  SetDataType.as_html -> sdt_as_html
  MappingDataType.as_html -> mdt_html
  IsOptional.as_html -> is_optional_html
  AsValue.as_html -> as_value_html
  Diagnostic.as_html -> diagnostic_html
  Subtyping.as_html -> subtyping_html
  AttributeName.as_html -> attribute_name_html
  AttributeReference.as_html -> attribute_reference_html
Created Extractprs() =  <ldm.ldm_extractors.Extractors object at 0x000002ACC7EF5E80>
Patches are...
Function validate_component registered as validate for target Component
Function component_html registered as as_html for target Component
Function validate_literate_model registered as validate for target LiterateModel
Function literate_model_html registered as as_html for target LiterateModel
Function model_extract registered as as_extract for target LiterateModel
Function validate_subject_e registered as validate for target SubjectE
Function subject_html registered as as_html for target SubjectE
Function validate_class registered as validate for target Class
Function class_html registered as as_html for target Class
Function class_extract registered as as_extract for target Class
Function validate_attribute_section registered as validate for target AttributeSection
Function attribute_section_html registered as as_html for target AttributeSection
Function validate_attribute registered as validate for target Attribute
Function attribute_html registered as as_html for target Attribute
Function validate_formula registered as validate for target Formula
Function formula_html registered as as_html for target Formula
Function validate_constraint registered as validate for target Constraint
Function any_html registered as as_html for target object
Function any_extract registered as as_extract for target object
Function paragraph_html registered as as_html for target Paragraph
Function one_liner_html registered as as_html for target OneLiner
Function code_block_html registered as as_html for target CodeBlock
Function str_html registered as as_html for target str
Function list_html registered as as_html for target list
Function annotation_html registered as as_html for target Annotation
Function emoji_html registered as as_html for target Emoji
Function casing_html registered as as_html for target Casing
Function class_name_html registered as as_html for target ClassName
Function class_reference_html registered as as_html for target ClassReference
Function subtype_by_html registered as as_html for target SubtypeBy
Function dtc_html registered as as_html for target DataTypeClause
Function bdt_html registered as as_html for target BaseDataType
Function ldt_html registered as as_html for target ListDataType
Function sdt_as_html registered as as_html for target SetDataType
Function mdt_html registered as as_html for target MappingDataType
Function is_optional_html registered as as_html for target IsOptional
Function as_value_html registered as as_html for target AsValue
Function diagnostic_html registered as as_html for target Diagnostic
Function subtyping_html registered as as_html for target Subtyping
Function attribute_name_html registered as as_html for target AttributeName
Function attribute_reference_html registered as as_html for target AttributeReference
extracting  Class: Component
Base type names for  String are ['String']
extract skipping attribute - normalName - target type String is trivial
Base type names for  CamelName are ['CamelName']
extract skipping attribute - name - target type CamelName is trivial
Base type names for  QualifiedCamel are ['QualifiedCamel']
extract skipping attribute - qualifiedName - target type QualifiedCamel is trivial
Base type names for  CamelName are ['CamelName']
extract skipping attribute - abbreviatedName - target type CamelName is trivial
Base type names for  OneLiner are ['OneLiner']
extract skipping attribute - oneLiner - target type OneLiner is trivial
Base type names for  RichText are ['RichText']
extract skipping attribute - elaboration - target type RichText is not in all class names
Extract is  {'_type': 'Class', 'name': 'Component', 'edges': []}
extracting  Class: AnnotationType
Cardinality is 'M:1'
Base type names for  Emoji are ['Emoji']
extract skipping attribute - emoji - target type Emoji is trivial
Base type names for  String are ['String']
extract skipping attribute - emojiName - target type String is trivial
Base type names for  String are ['String']
extract skipping attribute - emojiUnicode - target type String is trivial
Base type names for  LowerCamel are ['LowerCamel']
extract skipping attribute - label - target type LowerCamel is trivial
Base type names for  UpperCamel are ['UpperCamel']
extract skipping attribute - plural - target type UpperCamel is trivial
Base type names for  OneLiner are ['OneLiner']
extract skipping attribute - purpose - target type OneLiner is trivial
Extract is  {'_type': 'Class', 'name': 'AnnotationType', 'edges': [{'relation': 'based_on', 'to': 'LiterateDataModel', 'cardinality': 'M:1'}]}
extracting  Class: Annotation
Cardinality is 'M:1'
Base type names for  AnnotationType are ['AnnotationType']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Base type names for  CamelName are ['CamelName']
extract skipping attribute - label - target type CamelName is trivial
Base type names for  Emoji are ['Emoji']
extract skipping attribute - emoji - target type Emoji is trivial
Base type names for  RichText are ['RichText']
extract skipping attribute - content - target type RichText is not in all class names
Extract is  {'_type': 'Class', 'name': 'Annotation', 'edges': [{'relation': 'based_on', 'to': 'Component', 'cardinality': 'M:1'}, {'relation': 'annotationType', 'to': 'AnnotationType', 'cardinality': 'O_O'}]}
extracting  Class: LiterateDataModel
Cardinality is '1:1'
Base type names for  UpperCamel are ['UpperCamel']
extract skipping attribute - name - target type UpperCamel is trivial
Base type names for List of  Classes are ['Classes']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Base type names for List of  Classes are ['Classes']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Extract is  {'_type': 'Class', 'name': 'LiterateDataModel', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'allSubjects', 'to': 'Classes', 'cardinality': 'O_O'}, {'relation': 'allClasses', 'to': 'Classes', 'cardinality': 'O_O'}]}
extracting  Class: Subject
Cardinality is '1:1'
Cardinality is 'M:1'
Base type names for  UpperCamel are ['UpperCamel']
extract skipping attribute - name - target type UpperCamel is trivial
Base type names for  Subject are ['Subject']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Base type names for List of  Classes are ['Classes']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Base type names for List of  Subjects are ['Subjects']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Extract is  {'_type': 'Class', 'name': 'Subject', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'LiterateDataModel', 'cardinality': 'M:1'}, {'relation': 'parentSubject', 'to': 'Subject', 'cardinality': 'O_O'}, {'relation': 'classes', 'to': 'Classes', 'cardinality': 'O_O'}, {'relation': 'childSubjects', 'to': 'Subjects', 'cardinality': 'O_O'}]}
extracting  Class: SubjectArea
Cardinality is '1:1'
Cardinality is 'M:1'
Cardinality is 'M:1'
Extract is  {'_type': 'Class', 'name': 'SubjectArea', 'edges': [{'relation': 'subtype_of', 'to': 'Subject', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'LiterateModel', 'cardinality': 'M:1'}, {'relation': 'based_on', 'to': 'Xyz', 'cardinality': 'M:1'}]}
extracting  Class: Class
Cardinality is '1:1'
Base type names for  UpperCamel are ['UpperCamel']
extract skipping attribute - pluralForm - target type UpperCamel is trivial
Base type names for Set of  Class are ['Class']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Base type names for  Es are ['Es']
extract skipping attribute - supertypes - target type Es is not in all class names
Base type names for List of  Subtypings are ['Subtypings']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Base type names for List of  Classes are ['Classes']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Base type names for List of  Attributes are ['Attributes']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Base type names for List of  AttributeSections are ['AttributeSections']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Base type names for List of  Constraints are ['Constraints']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Base type names for List of  Methods are ['Methods']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Extract is  {'_type': 'Class', 'name': 'Class_', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'basedOn', 'to': 'Class_', 'cardinality': 'O_O'}, {'relation': 'subtypings', 'to': 'Subtypings', 'cardinality': 'O_O'}, {'relation': 'subtypes', 'to': 'Classes', 'cardinality': 'O_O'}, {'relation': 'attributes', 'to': 'Attributes', 'cardinality': 'O_O'}, {'relation': 'attributeSections', 'to': 'AttributeSections', 'cardinality': 'O_O'}, {'relation': 'constraints', 'to': 'Constraints', 'cardinality': 'O_O'}, {'relation': 'methods', 'to': 'Methods', 'cardinality': 'O_O'}]}
extracting  Class: Subtyping
Cardinality is 'M:1'
Base type names for  LowerCamel are ['LowerCamel']
extract skipping attribute - name - target type LowerCamel is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isExclusive - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isExhaustive - target type Boolean is trivial
Base type names for List of  Classes are ['Classes']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Extract is  {'_type': 'Class', 'name': 'Subtyping', 'edges': [{'relation': 'based_on', 'to': 'Class_', 'cardinality': 'M:1'}, {'relation': 'classes', 'to': 'Classes', 'cardinality': 'O_O'}]}
extracting  Class: ReferenceType
Cardinality is '1:1'
Extract is  {'_type': 'Class', 'name': 'ReferenceType', 'edges': [{'relation': 'subtype_of', 'to': 'Class_', 'cardinality': '1:1'}]}
extracting  Valuetype: CodeType
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isCaptive - target type Boolean is trivial
Extract is  {'_type': 'ValueType', 'name': 'CodeType', 'edges': []}
extracting  Valuetype: CodeValue
Cardinality is 'M:1'
Base type names for  NameString are ['NameString']
extract skipping attribute - code - target type NameString is not in all class names
Base type names for  RichText are ['RichText']
extract skipping attribute - description - target type RichText is not in all class names
Extract is  {'_type': 'ValueType', 'name': 'CodeValue', 'edges': [{'relation': 'based_on', 'to': 'CodeType', 'cardinality': 'M:1'}]}
extracting  Class: Key
Cardinality is '1:1'
Cardinality is 'M:1'
Base type names for List of  Attributes are ['Attributes']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Extract is  {'_type': 'Class', 'name': 'Key', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'Class_', 'cardinality': 'M:1'}, {'relation': 'keyAttributes', 'to': 'Attributes', 'cardinality': 'O_O'}]}
extracting  Class: UniqueKey
Cardinality is '1:1'
Extract is  {'_type': 'Class', 'name': 'UniqueKey', 'edges': [{'relation': 'subtype_of', 'to': 'Key', 'cardinality': '1:1'}]}
extracting  Class: AttributeSection
Cardinality is '1:1'
Cardinality is 'M:1'
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isOptional - target type Boolean is trivial
Extract is  {'_type': 'Class', 'name': 'AttributeSection', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'Class_', 'cardinality': 'M:1'}]}
extracting  Class: Attribute
Cardinality is '1:1'
Cardinality is 'M:1'
Base type names for  LowerCamel are ['LowerCamel']
extract skipping attribute - name - target type LowerCamel is trivial
Base type names for  DataType are ['DataType']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Extract is  {'_type': 'Class', 'name': 'Attribute', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'AttributeSection', 'cardinality': 'M:1'}, {'relation': 'dataType', 'to': 'DataType', 'cardinality': 'O_O'}]}
extracting  Valuetype: Derivation
Base type names for  RichText are ['RichText']
extract skipping attribute - statement - target type RichText is not in all class names
Base type names for  CodeExpression are ['CodeExpression']
extract skipping attribute - expression - target type CodeExpression is trivial
Extract is  {'_type': 'ValueType', 'name': 'Derivation', 'edges': []}
extracting  Valuetype: Constraint
Cardinality is '1:1'
Base type names for  RichText are ['RichText']
extract skipping attribute - statement - target type RichText is not in all class names
Base type names for value InventedName are ['InventedName']
extract skipping attribute - expression - target type InventedName is not in all class names
Base type names for  Code are ['Code']
extract skipping attribute - severity - target type Code is not in all class names
Extract is  {'_type': 'ValueType', 'name': 'Constraint', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}]}
Extract skipping trivial class (by adhoc list) Message
extracting  Valuetype: ClassConstraint
Cardinality is '1:1'
Cardinality is 'M:1'
Extract is  {'_type': 'ValueType', 'name': 'ClassConstraint', 'edges': [{'relation': 'subtype_of', 'to': 'Constraint', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'Class_', 'cardinality': 'M:1'}]}
extracting  Valuetype: AttributeConstraint
Cardinality is '1:1'
Cardinality is 'M:1'
Extract is  {'_type': 'ValueType', 'name': 'AttributeConstraint', 'edges': [{'relation': 'subtype_of', 'to': 'Constraint', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'Attribute', 'cardinality': 'M:1'}]}
Extract skipping trivial class (by adhoc list) CodeExpression
extracting  Class: Method
Cardinality is '1:1'
Base type names for List of  Parameters are ['Parameters']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Base type names for  DataType are ['DataType']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Extract is  {'_type': 'Class', 'name': 'Method', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'parameters', 'to': 'Parameters', 'cardinality': 'O_O'}, {'relation': 'returnType', 'to': 'DataType', 'cardinality': 'O_O'}]}
extracting  Class: ParameterAnInputToAMethod
Cardinality is '1:1'
Base type names for  DataType are ['DataType']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Base type names for value InventedName are ['InventedName']
extract skipping attribute - cardinality - target type InventedName is not in all class names
Extract is  {'_type': 'Class', 'name': 'ParameterAnInputToAMethod', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'type', 'to': 'DataType', 'cardinality': 'O_O'}]}
extracting  Valuetype: DataType
Extract is  {'_type': 'ValueType', 'name': 'DataType', 'edges': []}
Extract skipping trivial class (by adhoc list) SimpleDataTypeSubtpeOfDataType
extracting  Valuetype: ComplexDataType
Base type names for  AggregatingOperator are ['AggregatingOperator']
extract skipping attribute - aggregation - target type AggregatingOperator is trivial
Base type names for List of  DataTypes are ['DataTypes']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Extract is  {'_type': 'ValueType', 'name': 'ComplexDataType', 'edges': [{'relation': 'aggregatedTypes', 'to': 'DataTypes', 'cardinality': 'O_O'}]}
Extract skipping trivial class (by adhoc list) AggregatingOperator
Extract skipping trivial class (by adhoc list) Emoji
Extract skipping trivial class (by adhoc list) String
Extract skipping trivial class (by adhoc list) CamelName
Extract skipping trivial class (by adhoc list) UpperCamel
Extract skipping trivial class (by adhoc list) LowerCamel
Extract skipping trivial class (by adhoc list) QualifiedCamel
Extract skipping trivial class (by adhoc list) ValueTypeRichText
Extract skipping trivial class (by adhoc list) OneLiner
Extract skipping trivial class (by adhoc list) PrimitiveType
Extract skipping trivial class (by adhoc list) String
Extract skipping trivial class (by adhoc list) Integer
Extract skipping trivial class (by adhoc list) Decimal
Extract skipping trivial class (by adhoc list) Boolean
Extract skipping trivial class (by adhoc list) Date
Extract skipping trivial class (by adhoc list) Time
Extract skipping trivial class (by adhoc list) DateTime
And the extract is....
{'_type': 'LiterateModel', 'name': 'Literate Data Model', 'classes': [{'_type': 'Class', 'name': 'Component', 'edges': []}, {'_type': 'Class', 'name': 'AnnotationType', 'edges': [{'relation': 'based_on', 'to': 'LiterateDataModel', 'cardinality': 'M:1'}]}, {'_type': 'Class', 'name': 'Annotation', 'edges': [{'relation': 'based_on', 'to': 'Component', 'cardinality': 'M:1'}, {'relation': 'annotationType', 'to': 'AnnotationType', 'cardinality': 'O_O'}]}, {'_type': 'Class', 'name': 'LiterateDataModel', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'allSubjects', 'to': 'Classes', 'cardinality': 'O_O'}, {'relation': 'allClasses', 'to': 'Classes', 'cardinality': 'O_O'}]}, {'_type': 'Class', 'name': 'Subject', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'LiterateDataModel', 'cardinality': 'M:1'}, {'relation': 'parentSubject', 'to': 'Subject', 'cardinality': 'O_O'}, {'relation': 'classes', 'to': 'Classes', 'cardinality': 'O_O'}, {'relation': 'childSubjects', 'to': 'Subjects', 'cardinality': 'O_O'}]}, {'_type': 'Class', 'name': 'SubjectArea', 'edges': [{'relation': 'subtype_of', 'to': 'Subject', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'LiterateModel', 'cardinality': 'M:1'}, {'relation': 'based_on', 'to': 'Xyz', 'cardinality': 'M:1'}]}, {'_type': 'Class', 'name': 'Class_', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'basedOn', 'to': 'Class_', 'cardinality': 'O_O'}, {'relation': 'subtypings', 'to': 'Subtypings', 'cardinality': 'O_O'}, {'relation': 'subtypes', 'to': 'Classes', 'cardinality': 'O_O'}, {'relation': 'attributes', 'to': 'Attributes', 'cardinality': 'O_O'}, {'relation': 'attributeSections', 'to': 'AttributeSections', 'cardinality': 'O_O'}, {'relation': 'constraints', 'to': 'Constraints', 'cardinality': 'O_O'}, {'relation': 'methods', 'to': 'Methods', 'cardinality': 'O_O'}]}, {'_type': 'Class', 'name': 'Subtyping', 'edges': [{'relation': 'based_on', 'to': 'Class_', 'cardinality': 'M:1'}, {'relation': 'classes', 'to': 'Classes', 'cardinality': 'O_O'}]}, {'_type': 'Class', 'name': 'ReferenceType', 'edges': [{'relation': 'subtype_of', 'to': 'Class_', 'cardinality': '1:1'}]}, {'_type': 'ValueType', 'name': 'CodeType', 'edges': []}, {'_type': 'ValueType', 'name': 'CodeValue', 'edges': [{'relation': 'based_on', 'to': 'CodeType', 'cardinality': 'M:1'}]}, {'_type': 'Class', 'name': 'Key', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'Class_', 'cardinality': 'M:1'}, {'relation': 'keyAttributes', 'to': 'Attributes', 'cardinality': 'O_O'}]}, {'_type': 'Class', 'name': 'UniqueKey', 'edges': [{'relation': 'subtype_of', 'to': 'Key', 'cardinality': '1:1'}]}, {'_type': 'Class', 'name': 'AttributeSection', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'Class_', 'cardinality': 'M:1'}]}, {'_type': 'Class', 'name': 'Attribute', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'AttributeSection', 'cardinality': 'M:1'}, {'relation': 'dataType', 'to': 'DataType', 'cardinality': 'O_O'}]}, {'_type': 'ValueType', 'name': 'Derivation', 'edges': []}, {'_type': 'ValueType', 'name': 'Constraint', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}]}, {'_type': 'ValueType', 'name': 'ClassConstraint', 'edges': [{'relation': 'subtype_of', 'to': 'Constraint', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'Class_', 'cardinality': 'M:1'}]}, {'_type': 'ValueType', 'name': 'AttributeConstraint', 'edges': [{'relation': 'subtype_of', 'to': 'Constraint', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'Attribute', 'cardinality': 'M:1'}]}, {'_type': 'Class', 'name': 'Method', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'parameters', 'to': 'Parameters', 'cardinality': 'O_O'}, {'relation': 'returnType', 'to': 'DataType', 'cardinality': 'O_O'}]}, {'_type': 'Class', 'name': 'ParameterAnInputToAMethod', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'type', 'to': 'DataType', 'cardinality': 'O_O'}]}, {'_type': 'ValueType', 'name': 'DataType', 'edges': []}, {'_type': 'ValueType', 'name': 'ComplexDataType', 'edges': [{'relation': 'aggregatedTypes', 'to': 'DataTypes', 'cardinality': 'O_O'}]}]}

Phase: Validating to JSON Schema
Schema path is:  ldm/ldm_models/Literate/Literate_results/LiterateMeta/LiterateMetaModel_01_PD_schema.yaml
Object  path is:  ldm/ldm_models/Literate/Literate_results/Literate_PD_04.v_model.yaml
113  validation errors found!
Error at path: ['subjects', 0, 'classes', 0, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 3, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 4, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 5, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 1, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 1, 'attribute_sections', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 1, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 1, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 1, 'attributes', 3, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 1, 'attributes', 4, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 1, 'attributes', 5, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 2, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 2, 'attribute_sections', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 2, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 2, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 2, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 2, 'attributes', 3, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 0, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 0, 'attribute_sections', 0, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 0, 'attribute_sections', 0, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 0, 'attribute_sections', 0, 'attributes', 3, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 0, 'attribute_sections', 0, 'attributes', 4, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 0, 'attribute_sections', 0, 'attributes', 5, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 0, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 0, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 1, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 1, 'attribute_sections', 0, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 1, 'attribute_sections', 0, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 1, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 1, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 1, 'attributes', 3, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 2, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 2, 'attribute_sections', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attribute_sections', 0, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attribute_sections', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attribute_sections', 1, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attribute_sections', 1, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attribute_sections', 1, 'attributes', 3, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attribute_sections', 1, 'attributes', 4, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attribute_sections', 1, 'attributes', 5, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attribute_sections', 1, 'attributes', 6, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attributes', 3, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attributes', 4, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attributes', 5, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attributes', 6, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attributes', 7, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attributes', 8, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 1, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 1, 'attribute_sections', 0, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 1, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 1, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 1, 'attributes', 3, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 3, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 4, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 4, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 4, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 5, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 5, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 0, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 0, 'attribute_sections', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 0, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 0, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 0, 'attributes', 3, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 1, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 1, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 1, 'attributes', 3, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 2, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 2, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 2, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 4, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 4, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 4, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 2, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 2, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 3, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 3, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 3, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 5, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 6, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 7, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 7, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 3, 'classes', 0, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 3, 'classes', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 3, 'classes', 0, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 3, 'classes', 1, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 3, 'classes', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 3, 'classes', 1, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 4, 'classes', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 4, 'classes', 2, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 4, 'classes', 2, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 4, 'classes', 3, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 4, 'classes', 3, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 4, 'classes', 3, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 5, 'classes', 2, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 5, 'classes', 6, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 5, 'classes', 6, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 5, 'classes', 7, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

113  validation errors found!

Phase: Skipping Render to Markdown

Phase: Creating HTML using the Faculty
HTMLing Model Literate Data Model
Doing html for 0 classes and 7 subjects
HTMLing subject Literate Data Model
	Doing html for 0 classes and 7 subjects
HTMLing subject Preliminaries
	Doing html for 3 classes and 0 subjects
HTMLing class Component
for attribute  subtypes  class_names_clause handed:  [ClassReference(content='LiterateDataModel', _type='ClassReference'), ClassReference(content='Subject', _type='ClassReference'), ClassReference(content='Class', _type='ClassReference'), ClassReference(content='Key', _type='ClassReference'), ClassReference(content='AttributeSection', _type='ClassReference'), ClassReference(content='Attribute', _type='ClassReference'), ClassReference(content='Constraint', _type='ClassReference'), ClassReference(content='Method', _type='ClassReference'), ClassReference(content='ParameterAnInputToAMethod', _type='ClassReference')]
class_names are:  ['LiterateDataModel', 'Subject', 'Class', 'Key', 'AttributeSection', 'Attribute', 'Constraint', 'Method', 'ParameterAnInputToAMethod']
class_anchors are:  [FluentTag(<a class="base_class" href="#LiterateDataModel">LiterateDataModel</a>), FluentTag(<a class="base_class" href="#Subject">Subject</a>), FluentTag(<a class="base_class" href="#Class">Class</a>), FluentTag(<a class="base_class" href="#Key">Key</a>), FluentTag(<a class="base_class" href="#AttributeSection">AttributeSection</a>), FluentTag(<a class="base_class" href="#Attribute">Attribute</a>), FluentTag(<a class="base_class" href="#Constraint">Constraint</a>), FluentTag(<a class="base_class" href="#Method">Method</a>), FluentTag(<a class="base_class" href="#ParameterAnInputToAMethod">ParameterAnInputToAMethod</a>)]
Showing 11 of 23 classes
HTMLing class AnnotationType
Showing 3 of 23 classes
HTMLing class Annotation
Showing 3 of 23 classes
HTMLing subject The Model and its Subjects
	Doing html for 3 classes and 1 subjects
HTMLing class LiterateDataModel
Showing 4 of 23 classes
HTMLing class Subject
for attribute  subtypes  class_names_clause handed:  [ClassReference(content='SubjectArea', _type='ClassReference')]
class_names are:  ['SubjectArea']
class_anchors are:  [FluentTag(<a class="base_class" href="#SubjectArea">SubjectArea</a>)]
Showing 4 of 23 classes
HTMLing class SubjectArea
Showing 2 of 23 classes
HTMLing subject Classes
	Doing html for 7 classes and 0 subjects
HTMLing class Class
for attribute  subtypes  class_names_clause handed:  [ClassReference(content='ReferenceType', _type='ClassReference')]
class_names are:  ['ReferenceType']
class_anchors are:  [FluentTag(<a class="base_class" href="#ReferenceType">ReferenceType</a>)]
Showing 7 of 23 classes
HTMLing class Subtyping
Showing 2 of 23 classes
HTMLing class ReferenceType
Showing 2 of 23 classes
HTMLing class CodeType
Showing 2 of 23 classes
HTMLing class CodeValue
Showing 2 of 23 classes
HTMLing class Key
for attribute  subtypes  class_names_clause handed:  [ClassReference(content='UniqueKey', _type='ClassReference')]
class_names are:  ['UniqueKey']
class_anchors are:  [FluentTag(<a class="base_class" href="#UniqueKey">UniqueKey</a>)]
Showing 4 of 23 classes
HTMLing class UniqueKey
Showing 2 of 23 classes
HTMLing subject Attributes
	Doing html for 8 classes and 0 subjects
HTMLing class AttributeSection
Showing 4 of 23 classes
HTMLing class Attribute
Showing 5 of 23 classes
HTMLing class Derivation
Focal points not contained in nodes - skipping diagram
HTMLing class Constraint
for attribute  subtypes  class_names_clause handed:  [ClassReference(content='ClassConstraint', _type='ClassReference'), ClassReference(content='AttributeConstraint', _type='ClassReference')]
class_names are:  ['ClassConstraint', 'AttributeConstraint']
class_anchors are:  [FluentTag(<a class="base_class" href="#ClassConstraint">ClassConstraint</a>), FluentTag(<a class="base_class" href="#AttributeConstraint">AttributeConstraint</a>)]
Showing 4 of 23 classes
HTMLing class Message
HTMLing class ClassConstraint
Showing 3 of 23 classes
HTMLing class AttributeConstraint
Showing 3 of 23 classes
HTMLing class CodeExpression
HTMLing subject Methods
	Doing html for 2 classes and 0 subjects
HTMLing class Method
Showing 3 of 23 classes
HTMLing class ParameterAnInputToAMethod
Showing 3 of 23 classes
HTMLing subject Data Types
	Doing html for 4 classes and 0 subjects
HTMLing class DataType
Showing 4 of 23 classes
HTMLing class SimpleDataTypeSubtpeOfDataType
HTMLing class ComplexDataType
Showing 1 of 23 classes
HTMLing class AggregatingOperator
HTMLing subject Low level Data Types
	Doing html for 16 classes and 2 subjects
HTMLing class Emoji
HTMLing class String
HTMLing class CamelName
for attribute  subtypes  class_names_clause handed:  [ClassReference(content='UpperCamel', _type='ClassReference'), ClassReference(content='LowerCamel', _type='ClassReference')]
class_names are:  ['UpperCamel', 'LowerCamel']
class_anchors are:  [FluentTag(<a class="base_class" href="#UpperCamel">UpperCamel</a>), FluentTag(<a class="base_class" href="#LowerCamel">LowerCamel</a>)]
HTMLing class UpperCamel
HTMLing class LowerCamel
HTMLing class QualifiedCamel
HTMLing class ValueTypeRichText
HTMLing class OneLiner
HTMLing class PrimitiveType
for attribute  subtypes  class_names_clause handed:  [ClassReference(content='String', _type='ClassReference'), ClassReference(content='Integer', _type='ClassReference'), ClassReference(content='Decimal', _type='ClassReference'), ClassReference(content='Boolean', _type='ClassReference'), ClassReference(content='Date', _type='ClassReference'), ClassReference(content='Time', _type='ClassReference'), ClassReference(content='DateTime', _type='ClassReference')]
class_names are:  ['String', 'Integer', 'Decimal', 'Boolean', 'Date', 'Time', 'DateTime']
class_anchors are:  [FluentTag(<a class="base_class" href="#String">String</a>), FluentTag(<a class="base_class" href="#Integer">Integer</a>), FluentTag(<a class="base_class" href="#Decimal">Decimal</a>), FluentTag(<a class="base_class" href="#Boolean">Boolean</a>), FluentTag(<a class="base_class" href="#Date">Date</a>), FluentTag(<a class="base_class" href="#Time">Time</a>), FluentTag(<a class="base_class" href="#DateTime">DateTime</a>)]
HTMLing class String
for attribute  subtypes  class_names_clause handed:  [ClassReference(content='CamelName', _type='ClassReference'), ClassReference(content='QualifiedCamel', _type='ClassReference'), ClassReference(content='ValueTypeRichText', _type='ClassReference')]
class_names are:  ['CamelName', 'QualifiedCamel', 'ValueTypeRichText']
class_anchors are:  [FluentTag(<a class="base_class" href="#CamelName">CamelName</a>), FluentTag(<a class="base_class" href="#QualifiedCamel">QualifiedCamel</a>), FluentTag(<a class="base_class" href="#ValueTypeRichText">ValueTypeRichText</a>)]
HTMLing class Integer
HTMLing class Decimal
HTMLing class Boolean
HTMLing class Date
HTMLing class Time
HTMLing class DateTime
HTMLing subject Annotation Types Used
	Doing html for 0 classes and 0 subjects
creating png in C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\assets\plant_img1.png
PUML png file saved to: C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\assets\plant_img1.png
PUML svg file saved to: C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\assets\plant_img1.svg
HTMLing subject Annotation types as CSV
	Doing html for 0 classes and 0 subjects
HTMLing subject Appendices
	Doing html for 0 classes and 0 subjects
Body classes are None
Saved styled dictionary to ldm/ldm_models/Literate/Literate_results/Literate_PD_07_as.html
Body classes are ['reviewing']
Saved styled dictionary (for review) to ldm/ldm_models/Literate/Literate_results/Literate_PD_07_as.review.html

Phase: Saving HTML for PDF 
Body classes are None
Saved styled dictionary to ldm/ldm_models/Literate/Literate_results/Literate_PD_08_as_pdf.html
Body classes are ['reviewing']
Saved styled dictionary (for review) to ldm/ldm_models/Literate/Literate_results/Literate_PD_08_as_pdf.review.html

Phase: Creating PDF from html and css - using Prince
