
Phase: Creating schema and survey of Literate_01
Generate schema...

Phase: Parsing model: ldm/ldm_models/Literate/Literate.md
PARSING ldm/ldm_models/Literate/Literate.md

Phase: Deriving dict from parse => {yaml_dict_file}
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: ***Default***: name -  how do you say name in english?
_ _ OCL: ocl: x.name == y

. Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ CONSTRAINT: constraint: the abbreviated name should be shorter than the actual name
_ _ OCL: ocl: len(abbreviatedName) < len(name)
_ _ SEVERITY: severity: Warning
_ _ MESSAGE: message:  Why have an abbreviation longer than the name?
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ NOTE: Note: Does this annotation find it's way to the Constraint? YES! It's fixed!

. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: üîÑ ***Default***: false
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ NOTE: ‚ÑπÔ∏è ***Note***: This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.

. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: Default: based on label

. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: Default: from annotationType

. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: Default: from annotation type

. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: üîÑ ***Default***: false
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ NOTE: ‚ÑπÔ∏è ***Note***: This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.

. Derivation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DERIVATION: Derivation: gathering s.allSubjects over s in subjectAreas

. Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ CONSTRAINT: ***Constraint***: Subject names must be unique across the model.

. Derivation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DERIVATION: Derivation: gathering s.allClasses over s in allSubjects.

. Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ CONSTRAINT: ***Constraint***: Class names must be unique across the model.

. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: Default: OCL

. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: Default: Handlebars

. Derivation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DERIVATION: Derivation: ['aiEnglishPlural()']

. Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ CONSTRAINT: ***Constraint***: Within each Class, attribute names must be unique.

. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: ***Default***: the regular plural, formed by adding "s" or "es".

. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: Default: true

. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: Default: true

. Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ CONSTRAINT: Constraint: each attribute must be a direct or inherited of the base class.

. Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ CONSTRAINT: Constraint: no repetitions allowed in keyAttributes> üëç **Issue**: introduce PureLists?
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ ISSUE: Issue: need ascending descending to support index keys or ordering keys.

. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: ***Default:*** False

. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: ***Default:***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.
_ _ ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.', extra_text=[])], extra_text=[])]
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ WILD: For example:

Inventing name for:  1:1 Author
Inventing name for:  N:M Set of Books
. Derivation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DERIVATION: ***Derivation***: true if the data type is a class or a simple collection of members of a class.

. Derivation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DERIVATION: ***Derivation***: from the data type. Null unless arrribute is invertible.

Inventing name for:  e.g., OCL _(CodeExpression
Inventing name for:  e.g., optional, required
. Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ CONSTRAINT: üö´ ***Constraint***: Must follow the camel case naming convention and not be empty.
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ EXAMPLE: Example:  "firstName", "orderDate", "customerID"
_ _ _ ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='> üìù ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.', extra_text=[])], extra_text=[])]
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ WILD: *ModelingNote:* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.

. Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ CONSTRAINT: ***Constraint***: content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.

. Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ CONSTRAINT: ***Constraint***: must not containa line break or new line character
_ _ MESSAGE: Message: A line can't span two lines


Phase: .. full dict saved  in ldm/ldm_models/Literate/Literate_results/Literate_PD_02.dict.yaml

Phase: Creating model with from_typed_dict() => to_typed_dict() => ldm/ldm_models/Literate/Literate_results/Literate_PD_03.model.yaml
Calling LiterateModel.from_typed_dict ...
In AttSection post-init for For Machinery, is_optional = None
In AttSection post-init for For Machinery, is_optional = None
In AttSection post-init for Modeling Configuration, is_optional = None
In AttSection post-init for Implied Attributes, is_optional = None
In AttSection post-init for Cardinalities, is_optional = None
In AttSection post-init for Inverse Attributes, is_optional = None
In AttSection post-init for Formulas, is_optional = None
In AttSection post-init for Override Tracking, is_optional = None

Phase: have py  model from dict

Phase: Creating model_dict from model => ldm/ldm_models/Literate/Literate_results/Literate_PD_03.model.yaml

Phase: Testing containers

Phase: Validating model tp ldm/ldm_models/Literate/Literate_results/Literate_PD_04.v_model.yaml
All classes names (singular and plural are: 
Calcing all_class names  for  Literatemodel: Literate Data Model
	"AggregatingOperator",
	"AggregatingOperators",
	"Annotation",
	"AnnotationType",
	"AnnotationTypes",
	"Annotations",
	"Attribute",
	"AttributeConstraint",
	"AttributeConstraints",
	"AttributeSection",
	"AttributeSections",
	"Attributes",
	"Boolean",
	"Booleans",
	"CamelName",
	"CamelNames",
	"Class",
	"ClassConstraint",
	"ClassConstraints",
	"Classes",
	"CodeExpression",
	"CodeExpressions",
	"CodeType",
	"CodeTypes",
	"CodeValue",
	"CodeValues",
	"ComplexDataType",
	"ComplexDataTypes",
	"Component",
	"Components",
	"Constraint",
	"Constraints",
	"DataType",
	"DataTypes",
	"Date",
	"DateTime",
	"DateTimes",
	"Dates",
	"Decimal",
	"Decimals",
	"Derivation",
	"Derivations",
	"Emoji",
	"Emojis",
	"Integer",
	"Integers",
	"Key",
	"Keys",
	"LiterateDataModel",
	"LiterateDataModels",
	"LowerCamel",
	"LowerCamels",
	"Message",
	"Messages",
	"Method",
	"Methods",
	"OneLiner",
	"OneLiners",
	"ParameterAnInputToAMethod",
	"Parameters",
	"PrimitiveType",
	"PrimitiveTypes",
	"QualifiedCamel",
	"QualifiedCamels",
	"ReferenceType",
	"ReferenceTypes",
	"SimpleDataTypeSubtpeOfDataType",
	"SimpleDataTypeSubtpeOfDataTypes",
	"String",
	"Strings",
	"Subject",
	"SubjectArea",
	"SubjectAreas",
	"Subjects",
	"Subtyping",
	"Subtypings",
	"Time",
	"Times",
	"UniqueKey",
	"UniqueKeys",
	"UpperCamel",
	"UpperCamels",
	"ValueTypeRichText",
	"ValueTypeRichTexts",
0  classes in final model
Calc Dependents
Dependents of  LiterateDataModel  are  ['AnnotationType', 'Subject']
Dependents of  Component  are  ['Annotation']
Dependents of  LiterateModel  are  ['SubjectArea']
Base Class LiterateModel not found when deriving dependents
Dependents of  Xyz  are  ['SubjectArea']
Base Class Xyz not found when deriving dependents
Dependents of  Class  are  ['Subtyping', 'Key', 'AttributeSection', 'ClassConstraint']
Dependents of  CodeType  are  ['CodeValue']
Dependents of  AttributeSection  are  ['Attribute']
Dependents of  Attribute  are  ['AttributeConstraint']
Class: LiterateDataModel is subtype of Component via subtypes
Class: Subject is subtype of Component via subtypes
Class: SubjectArea is subtype of Subject via subtypes
Class: Class is subtype of Component via subtypes
Class: ReferenceType is subtype of Class via subtypes
Class: Key is subtype of Component via subtypes
Class: UniqueKey is subtype of Key via subtypes
Class: AttributeSection is subtype of Component via subtypes
Class: Attribute is subtype of Component via subtypes
Valuetype: Constraint is subtype of Component via subtypes
Valuetype: ClassConstraint is subtype of Constraint via subtypes
Valuetype: AttributeConstraint is subtype of Constraint via subtypes
Class: Method is subtype of Component via subtypes
Class: ParameterAnInputToAMethod is subtype of Component via subtypes
Valuetype: CamelName is subtype of String via subtypes
Valuetype: UpperCamel is subtype of CamelName via subtypes
Valuetype: LowerCamel is subtype of CamelName via subtypes
Valuetype: QualifiedCamel is subtype of String via subtypes
Class: ValueTypeRichText is subtype of String via subtypes
Valuetype: OneLiner is subtype of RichText via subtypes
Valuetype: String is subtype of PrimitiveType via subtypes
Valuetype: Integer is subtype of PrimitiveType via subtypes
Valuetype: Decimal is subtype of PrimitiveType via subtypes
Valuetype: Boolean is subtype of PrimitiveType via subtypes
Valuetype: Date is subtype of PrimitiveType via subtypes
Valuetype: Time is subtype of PrimitiveType via subtypes
Valuetype: DateTime is subtype of PrimitiveType via subtypes
All Subtypings
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
No place to put subtypings for:  RichText
Invalid boolean value for IsExclusive:  - should be in:
	   ['Exclusive']
	or ['non Exclusive', 'nonexclusive']
Invalid boolean value for IsExhaustive:  - should be in:
	   ['exhaustive']
	or ['nonExhaustive']
All classes names (singular and plural are: 
	"AggregatingOperator",
	"AggregatingOperators",
	"Annotation",
	"AnnotationType",
	"AnnotationTypes",
	"Annotations",
	"Attribute",
	"AttributeConstraint",
	"AttributeConstraints",
	"AttributeSection",
	"AttributeSections",
	"Attributes",
	"Boolean",
	"Booleans",
	"CamelName",
	"CamelNames",
	"Class",
	"ClassConstraint",
	"ClassConstraints",
	"Classes",
	"CodeExpression",
	"CodeExpressions",
	"CodeType",
	"CodeTypes",
	"CodeValue",
	"CodeValues",
	"ComplexDataType",
	"ComplexDataTypes",
	"Component",
	"Components",
	"Constraint",
	"Constraints",
	"DataType",
	"DataTypes",
	"Date",
	"DateTime",
	"DateTimes",
	"Dates",
	"Decimal",
	"Decimals",
	"Derivation",
	"Derivations",
	"Emoji",
	"Emojis",
	"Integer",
	"Integers",
	"Key",
	"Keys",
	"LiterateDataModel",
	"LiterateDataModels",
	"LowerCamel",
	"LowerCamels",
	"Message",
	"Messages",
	"Method",
	"Methods",
	"OneLiner",
	"OneLiners",
	"ParameterAnInputToAMethod",
	"Parameters",
	"PrimitiveType",
	"PrimitiveTypes",
	"QualifiedCamel",
	"QualifiedCamels",
	"ReferenceType",
	"ReferenceTypes",
	"SimpleDataTypeSubtpeOfDataType",
	"SimpleDataTypeSubtpeOfDataTypes",
	"String",
	"Strings",
	"Subject",
	"SubjectArea",
	"SubjectAreas",
	"Subjects",
	"Subtyping",
	"Subtypings",
	"Time",
	"Times",
	"UniqueKey",
	"UniqueKeys",
	"UpperCamel",
	"UpperCamels",
	"ValueTypeRichText",
	"ValueTypeRichTexts",
0  classes in final model
Validating LiterateModel
in calc attribute, attname is  normalName
the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Component  is  []
Considering Component.normalName for inversion... 
	dtc =  optional  String (O_O)
	dt  =   String  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = String
	Singular for String is String
	SKIPPING Component.normalName, a  String. core type String is a value type
in calc attribute, attname is  name
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Component  is  []
Considering Component.name for inversion... 
	dtc =  optional  CamelName (O_O)
	dt  =   CamelName  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = CamelName
	Singular for CamelName is CamelName
	SKIPPING Component.name, a  CamelName. core type CamelName is a value type
in calc attribute, attname is  qualifiedName
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Component  is  []
Considering Component.qualifiedName for inversion... 
	dtc =  optional  QualifiedCamel (O_O)
	dt  =   QualifiedCamel  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = QualifiedCamel
	Singular for QualifiedCamel is QualifiedCamel
	SKIPPING Component.qualifiedName, a  QualifiedCamel. core type QualifiedCamel is a value type
in calc attribute, attname is  abbreviatedName
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Component  is  []
Considering Component.abbreviatedName for inversion... 
	dtc =  optional  CamelName (O_O)
	dt  =   CamelName  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = CamelName
	Singular for CamelName is CamelName
	SKIPPING Component.abbreviatedName, a  CamelName. core type CamelName is a value type
in calc attribute, attname is  oneLiner
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Component  is  []
Considering Component.oneLiner for inversion... 
	dtc =  optional  OneLiner (O_O)
	dt  =   OneLiner  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = OneLiner
	Singular for OneLiner is OneLiner
	SKIPPING Component.oneLiner, a  OneLiner. core type OneLiner is a value type
in calc attribute, attname is  elaboration
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Component  is  []
Considering Component.elaboration for inversion... 
	dtc =  optional  RichText (O_O)
	dt  =   RichText  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = RichText
	SKIPPING inverse for..  No such class as  RichText
validating datatype:   String
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:   CamelName
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:   QualifiedCamel
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:   CamelName
type of datatype is  <class 'Literate_01.BaseDataType'>
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Default'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Constraint'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
validating datatype:   OneLiner
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:   RichText
type of datatype is  <class 'Literate_01.BaseDataType'>
	!!! Base type error for  RichText  in dt   RichText
validating datatype:   Boolean
type of datatype is  <class 'Literate_01.BaseDataType'>
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Default'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
Adding implied attribute:  Attribute: baseLiterateDataModel  in  Class: AnnotationType
In AttSection post-init for Implied Attributes for Annotation Type, is_optional = None
Creating section for Class: AnnotationType: Attributesection: Implied Attributes for Annotation Type
Setting container of <AttributeSection>:Implied Attributes for Annotation Type to <Class>:AnnotationType
Setting container of <Attribute>:emoji to <Class>:AnnotationType
Setting container of <DataTypeClause>:[optional  Emoji (O_O)] to <Attribute>:emoji
Setting container of <BaseDataType>:[ Emoji] to <DataTypeClause>:[optional  Emoji (O_O)]
Setting container of <ClassReference>:Emoji to <BaseDataType>:[ Emoji]
Setting container of <AttributeName>:emoji to <Attribute>:emoji
Setting container of <Attribute>:emojiName to <Class>:AnnotationType
Setting container of <DataTypeClause>:[optional  String (O_O)] to <Attribute>:emojiName
Setting container of <BaseDataType>:[ String] to <DataTypeClause>:[optional  String (O_O)]
Setting container of <ClassReference>:String to <BaseDataType>:[ String]
Setting container of <AttributeName>:emojiName to <Attribute>:emojiName
Setting container of <Attribute>:emojiUnicode to <Class>:AnnotationType
Setting container of <DataTypeClause>:[optional  String (O_O)] to <Attribute>:emojiUnicode
Setting container of <BaseDataType>:[ String] to <DataTypeClause>:[optional  String (O_O)]
Setting container of <ClassReference>:String to <BaseDataType>:[ String]
Setting container of <AttributeName>:emojiUnicode to <Attribute>:emojiUnicode
Setting container of <Attribute>:label to <Class>:AnnotationType
Setting container of <DataTypeClause>:[optional  LowerCamel (O_O)] to <Attribute>:label
Setting container of <BaseDataType>:[ LowerCamel] to <DataTypeClause>:[optional  LowerCamel (O_O)]
Setting container of <ClassReference>:LowerCamel to <BaseDataType>:[ LowerCamel]
Setting container of <AttributeName>:label to <Attribute>:label
Setting container of <Attribute>:plural to <Class>:AnnotationType
Setting container of <DataTypeClause>:[optional  UpperCamel (O_O)] to <Attribute>:plural
Setting container of <BaseDataType>:[ UpperCamel] to <DataTypeClause>:[optional  UpperCamel (O_O)]
Setting container of <ClassReference>:UpperCamel to <BaseDataType>:[ UpperCamel]
Setting container of <AttributeName>:plural to <Attribute>:plural
Setting container of <Attribute>:purpose to <Class>:AnnotationType
Setting container of <DataTypeClause>:[optional  OneLiner (O_O)] to <Attribute>:purpose
Setting container of <BaseDataType>:[ OneLiner] to <DataTypeClause>:[optional  OneLiner (O_O)]
Setting container of <ClassReference>:OneLiner to <BaseDataType>:[ OneLiner]
Setting container of <AttributeName>:purpose to <Attribute>:purpose
Setting container of <ClassReference>:LiterateDataModel to <Class>:AnnotationType
Setting container of <Attribute>:baseLiterateDataModel to <AttributeSection>:Implied Attributes for Annotation Type
Setting container of <DataTypeClause>:[optional value LiterateDataModel (M_1)] to <Attribute>:baseLiterateDataModel
Setting container of <BaseDataType>:[value LiterateDataModel] to <DataTypeClause>:[optional value LiterateDataModel (M_1)]
Setting container of <ClassReference>:LiterateDataModel to <BaseDataType>:[value LiterateDataModel]
Setting container of <AttributeName>:baseLiterateDataModel to <Attribute>:baseLiterateDataModel
Added implied attribute:  Attribute: baseLiterateDataModel  in  Class: AnnotationType
... Containees of section are:  ['<Attribute>:baseLiterateDataModel']
... Containees of att are:  ['<DataTypeClause>:[optional value LiterateDataModel (M_1)]', '<AttributeName>:baseLiterateDataModel']
... Chain from name is:  <AttributeName>:baseLiterateDataModel -> <Attribute>:baseLiterateDataModel -> <AttributeSection>:Implied Attributes for Annotation Type -> <Class>:AnnotationType -> <SubjectB>:Preliminaries -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:baseLiterateDataModel -> <AttributeSection>:Implied Attributes for Annotation Type -> <Class>:AnnotationType -> <SubjectB>:Preliminaries -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Annotation Type -> <Class>:AnnotationType -> <SubjectB>:Preliminaries -> <LiterateModel>:Literate Data Model
<Attribute>:baseLiterateDataModel contains <DataTypeClause>:[optional value LiterateDataModel (M_1)]
	<DataTypeClause>:[optional value LiterateDataModel (M_1)] contains <BaseDataType>:[value LiterateDataModel]
		<BaseDataType>:[value LiterateDataModel] contains <ClassReference>:LiterateDataModel
<Attribute>:baseLiterateDataModel contains <AttributeName>:baseLiterateDataModel
in calc attribute, attname is  emoji
the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: AnnotationType  is  []
Considering AnnotationType.emoji for inversion... 
	dtc =  optional  Emoji (O_O)
	dt  =   Emoji  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Emoji
	Singular for Emoji is Emoji
	SKIPPING AnnotationType.emoji, a  Emoji. core type Emoji is a value type
in calc attribute, attname is  emojiName
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: AnnotationType  is  []
Considering AnnotationType.emojiName for inversion... 
	dtc =  optional  String (O_O)
	dt  =   String  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = String
	Singular for String is String
	SKIPPING AnnotationType.emojiName, a  String. core type String is a value type
in calc attribute, attname is  emojiUnicode
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: AnnotationType  is  []
Considering AnnotationType.emojiUnicode for inversion... 
	dtc =  optional  String (O_O)
	dt  =   String  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = String
	Singular for String is String
	SKIPPING AnnotationType.emojiUnicode, a  String. core type String is a value type
in calc attribute, attname is  label
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: AnnotationType  is  []
Considering AnnotationType.label for inversion... 
	dtc =  optional  LowerCamel (O_O)
	dt  =   LowerCamel  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = LowerCamel
	Singular for LowerCamel is LowerCamel
	SKIPPING AnnotationType.label, a  LowerCamel. core type LowerCamel is a value type
in calc attribute, attname is  plural
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: AnnotationType  is  []
Considering AnnotationType.plural for inversion... 
	dtc =  optional  UpperCamel (O_O)
	dt  =   UpperCamel  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = UpperCamel
	Singular for UpperCamel is UpperCamel
	SKIPPING AnnotationType.plural, a  UpperCamel. core type UpperCamel is a value type
in calc attribute, attname is  purpose
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: AnnotationType  is  []
Considering AnnotationType.purpose for inversion... 
	dtc =  optional  OneLiner (O_O)
	dt  =   OneLiner  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = OneLiner
	Singular for OneLiner is OneLiner
	SKIPPING AnnotationType.purpose, a  OneLiner. core type OneLiner is a value type
validating datatype:   Emoji
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:   String
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:   String
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:   LowerCamel
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:   UpperCamel
type of datatype is  <class 'Literate_01.BaseDataType'>
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Default'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
validating datatype:   OneLiner
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:  value LiterateDataModel
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
Adding implied attribute:  Attribute: baseComponent  in  Class: Annotation
In AttSection post-init for Implied Attributes for Annotation, is_optional = None
Creating section for Class: Annotation: Attributesection: Implied Attributes for Annotation
Setting container of <AttributeSection>:For Machinery to <Class>:Annotation
Setting container of <Attribute>:isEmbellishment to <AttributeSection>:For Machinery
Setting container of <DataTypeClause>:[optional  Boolean (O_O)] to <Attribute>:isEmbellishment
Setting container of <BaseDataType>:[ Boolean] to <DataTypeClause>:[optional  Boolean (O_O)]
Setting container of <ClassReference>:Boolean to <BaseDataType>:[ Boolean]
Setting container of <AttributeName>:isEmbellishment to <Attribute>:isEmbellishment
Setting container of <AttributeSection>:Implied Attributes for Annotation to <Class>:Annotation
Setting container of <Attribute>:annotationType to <Class>:Annotation
Setting container of <DataTypeClause>:[optional  AnnotationType (O_O)] to <Attribute>:annotationType
Setting container of <BaseDataType>:[ AnnotationType] to <DataTypeClause>:[optional  AnnotationType (O_O)]
Setting container of <ClassReference>:AnnotationType to <BaseDataType>:[ AnnotationType]
Setting container of <AttributeName>:annotationType to <Attribute>:annotationType
Setting container of <Attribute>:label to <Class>:Annotation
Setting container of <DataTypeClause>:[optional  CamelName (O_O)] to <Attribute>:label
Setting container of <BaseDataType>:[ CamelName] to <DataTypeClause>:[optional  CamelName (O_O)]
Setting container of <ClassReference>:CamelName to <BaseDataType>:[ CamelName]
Setting container of <AttributeName>:label to <Attribute>:label
Setting container of <Attribute>:emoji to <Class>:Annotation
Setting container of <DataTypeClause>:[optional  Emoji (O_O)] to <Attribute>:emoji
Setting container of <BaseDataType>:[ Emoji] to <DataTypeClause>:[optional  Emoji (O_O)]
Setting container of <ClassReference>:Emoji to <BaseDataType>:[ Emoji]
Setting container of <AttributeName>:emoji to <Attribute>:emoji
Setting container of <Attribute>:content to <Class>:Annotation
Setting container of <DataTypeClause>:[optional  RichText (O_O)] to <Attribute>:content
Setting container of <BaseDataType>:[ RichText] to <DataTypeClause>:[optional  RichText (O_O)]
Setting container of <ClassReference>:RichText to <BaseDataType>:[ RichText]
Setting container of <AttributeName>:content to <Attribute>:content
Setting container of <ClassReference>:Component to <Class>:Annotation
Setting container of <Attribute>:baseComponent to <AttributeSection>:Implied Attributes for Annotation
Setting container of <DataTypeClause>:[optional value Component (M_1)] to <Attribute>:baseComponent
Setting container of <BaseDataType>:[value Component] to <DataTypeClause>:[optional value Component (M_1)]
Setting container of <ClassReference>:Component to <BaseDataType>:[value Component]
Setting container of <AttributeName>:baseComponent to <Attribute>:baseComponent
Added implied attribute:  Attribute: baseComponent  in  Class: Annotation
... Containees of section are:  ['<Attribute>:baseComponent']
... Containees of att are:  ['<DataTypeClause>:[optional value Component (M_1)]', '<AttributeName>:baseComponent']
... Chain from name is:  <AttributeName>:baseComponent -> <Attribute>:baseComponent -> <AttributeSection>:Implied Attributes for Annotation -> <Class>:Annotation -> <SubjectB>:Preliminaries -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:baseComponent -> <AttributeSection>:Implied Attributes for Annotation -> <Class>:Annotation -> <SubjectB>:Preliminaries -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Annotation -> <Class>:Annotation -> <SubjectB>:Preliminaries -> <LiterateModel>:Literate Data Model
<Attribute>:baseComponent contains <DataTypeClause>:[optional value Component (M_1)]
	<DataTypeClause>:[optional value Component (M_1)] contains <BaseDataType>:[value Component]
		<BaseDataType>:[value Component] contains <ClassReference>:Component
<Attribute>:baseComponent contains <AttributeName>:baseComponent
in calc attribute, attname is  annotationType
the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Annotation  is  []
Considering Annotation.annotationType for inversion... 
	dtc =  optional  AnnotationType (O_O)
	dt  =   AnnotationType  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = AnnotationType
	Singular for AnnotationType is AnnotationType
	Inverting Annotation.annotationType, a  AnnotationType. core type AnnotationType not a value type
	Invrse AttNam =  inverseOfAnnotationType
	Inverse dt =  value Annotation
	Inverse dtc =  optional value Annotation (M_1)
	Creating inverse attribute:  Attribute(container=None, one_liner=OneLiner(content='Inverse attribute for Annotation.annotationType from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(container=None, content='inverseOfAnnotationType', _type='AttributeName'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(container=None, data_type=BaseDataType(container=None, class_name=ClassReference(container=None, content='Annotation', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Adding implied attribute:  Attribute: inverseOfAnnotationType  in  Class: AnnotationType
In AttSection post-init for Implied Attributes for Annotation Type, is_optional = None
Creating section for Class: AnnotationType: Attributesection: Implied Attributes for Annotation Type
Setting container of <AttributeSection>:Implied Attributes for Annotation Type to <Class>:AnnotationType
Setting container of <Attribute>:baseLiterateDataModel to <AttributeSection>:Implied Attributes for Annotation Type
Setting container of <DataTypeClause>:[optional value LiterateDataModel (M_1)] to <Attribute>:baseLiterateDataModel
Setting container of <BaseDataType>:[value LiterateDataModel] to <DataTypeClause>:[optional value LiterateDataModel (M_1)]
Setting container of <ClassReference>:LiterateDataModel to <BaseDataType>:[value LiterateDataModel]
Setting container of <AttributeName>:baseLiterateDataModel to <Attribute>:baseLiterateDataModel
Setting container of <AttributeSection>:Implied Attributes for Annotation Type to <Class>:AnnotationType
Setting container of <Attribute>:emoji to <Class>:AnnotationType
Setting container of <DataTypeClause>:[optional  Emoji (O_O)] to <Attribute>:emoji
Setting container of <BaseDataType>:[ Emoji] to <DataTypeClause>:[optional  Emoji (O_O)]
Setting container of <ClassReference>:Emoji to <BaseDataType>:[ Emoji]
Setting container of <AttributeName>:emoji to <Attribute>:emoji
Setting container of <Attribute>:emojiName to <Class>:AnnotationType
Setting container of <DataTypeClause>:[optional  String (O_O)] to <Attribute>:emojiName
Setting container of <BaseDataType>:[ String] to <DataTypeClause>:[optional  String (O_O)]
Setting container of <ClassReference>:String to <BaseDataType>:[ String]
Setting container of <AttributeName>:emojiName to <Attribute>:emojiName
Setting container of <Attribute>:emojiUnicode to <Class>:AnnotationType
Setting container of <DataTypeClause>:[optional  String (O_O)] to <Attribute>:emojiUnicode
Setting container of <BaseDataType>:[ String] to <DataTypeClause>:[optional  String (O_O)]
Setting container of <ClassReference>:String to <BaseDataType>:[ String]
Setting container of <AttributeName>:emojiUnicode to <Attribute>:emojiUnicode
Setting container of <Attribute>:label to <Class>:AnnotationType
Setting container of <DataTypeClause>:[optional  LowerCamel (O_O)] to <Attribute>:label
Setting container of <BaseDataType>:[ LowerCamel] to <DataTypeClause>:[optional  LowerCamel (O_O)]
Setting container of <ClassReference>:LowerCamel to <BaseDataType>:[ LowerCamel]
Setting container of <AttributeName>:label to <Attribute>:label
Setting container of <Attribute>:plural to <Class>:AnnotationType
Setting container of <DataTypeClause>:[optional  UpperCamel (O_O)] to <Attribute>:plural
Setting container of <BaseDataType>:[ UpperCamel] to <DataTypeClause>:[optional  UpperCamel (O_O)]
Setting container of <ClassReference>:UpperCamel to <BaseDataType>:[ UpperCamel]
Setting container of <AttributeName>:plural to <Attribute>:plural
Setting container of <Attribute>:purpose to <Class>:AnnotationType
Setting container of <DataTypeClause>:[optional  OneLiner (O_O)] to <Attribute>:purpose
Setting container of <BaseDataType>:[ OneLiner] to <DataTypeClause>:[optional  OneLiner (O_O)]
Setting container of <ClassReference>:OneLiner to <BaseDataType>:[ OneLiner]
Setting container of <AttributeName>:purpose to <Attribute>:purpose
Setting container of <ClassReference>:LiterateDataModel to <Class>:AnnotationType
Setting container of <Attribute>:inverseOfAnnotationType to <AttributeSection>:Implied Attributes for Annotation Type
Setting container of <DataTypeClause>:[optional value Annotation (M_1)] to <Attribute>:inverseOfAnnotationType
Setting container of <BaseDataType>:[value Annotation] to <DataTypeClause>:[optional value Annotation (M_1)]
Setting container of <ClassReference>:Annotation to <BaseDataType>:[value Annotation]
Setting container of <AttributeName>:inverseOfAnnotationType to <Attribute>:inverseOfAnnotationType
Added implied attribute:  Attribute: inverseOfAnnotationType  in  Class: AnnotationType
... Containees of section are:  ['<Attribute>:inverseOfAnnotationType']
... Containees of att are:  ['<DataTypeClause>:[optional value Annotation (M_1)]', '<AttributeName>:inverseOfAnnotationType']
... Chain from name is:  <AttributeName>:inverseOfAnnotationType -> <Attribute>:inverseOfAnnotationType -> <AttributeSection>:Implied Attributes for Annotation Type -> <Class>:AnnotationType -> <SubjectB>:Preliminaries -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:inverseOfAnnotationType -> <AttributeSection>:Implied Attributes for Annotation Type -> <Class>:AnnotationType -> <SubjectB>:Preliminaries -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Annotation Type -> <Class>:AnnotationType -> <SubjectB>:Preliminaries -> <LiterateModel>:Literate Data Model
<Attribute>:inverseOfAnnotationType contains <DataTypeClause>:[optional value Annotation (M_1)]
	<DataTypeClause>:[optional value Annotation (M_1)] contains <BaseDataType>:[value Annotation]
		<BaseDataType>:[value Annotation] contains <ClassReference>:Annotation
<Attribute>:inverseOfAnnotationType contains <AttributeName>:inverseOfAnnotationType
in calc attribute, attname is  label
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Annotation  is  []
Considering Annotation.label for inversion... 
	dtc =  optional  CamelName (O_O)
	dt  =   CamelName  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = CamelName
	Singular for CamelName is CamelName
	SKIPPING Annotation.label, a  CamelName. core type CamelName is a value type
in calc attribute, attname is  emoji
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Annotation  is  []
Considering Annotation.emoji for inversion... 
	dtc =  optional  Emoji (O_O)
	dt  =   Emoji  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Emoji
	Singular for Emoji is Emoji
	SKIPPING Annotation.emoji, a  Emoji. core type Emoji is a value type
in calc attribute, attname is  content
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Annotation  is  []
Considering Annotation.content for inversion... 
	dtc =  optional  RichText (O_O)
	dt  =   RichText  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = RichText
	SKIPPING inverse for..  No such class as  RichText
validating datatype:   AnnotationType
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:   CamelName
type of datatype is  <class 'Literate_01.BaseDataType'>
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Default'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
validating datatype:   Emoji
type of datatype is  <class 'Literate_01.BaseDataType'>
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Default'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
validating datatype:   RichText
type of datatype is  <class 'Literate_01.BaseDataType'>
	!!! Base type error for  RichText  in dt   RichText
validating datatype:   Boolean
type of datatype is  <class 'Literate_01.BaseDataType'>
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Default'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
validating datatype:  value Component
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
in calc attribute, attname is  name
the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
MRO for LiterateDataModel =>  ['Component']
calc attribute override; mro for  Class: LiterateDataModel  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Found override for LiterateDataModel.name in Component
Attribute name =  name
.. and as AName:  AttributeName(container=None, content='name', _type='AttributeName')
Considering LiterateDataModel.name for inversion... 
	dtc =  optional  UpperCamel (O_O)
	dt  =   UpperCamel  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = UpperCamel
	Singular for UpperCamel is UpperCamel
	SKIPPING LiterateDataModel.name, a  UpperCamel. core type UpperCamel is a value type
in calc attribute, attname is  allSubjects
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: LiterateDataModel  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering LiterateDataModel.allSubjects for inversion... 
	dtc =  optional List of  Classes (O_O)
	dt  =  List of  Classes  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Classes
	Singular for Classes is Class
	Inverting LiterateDataModel.allSubjects, a List of  Classes. core type Class not a value type
	Invrse AttNam =  inverseOfAllSubjects
	Inverse dt =  value LiterateDataModel
	Inverse dtc =  optional value LiterateDataModel (M_1)
	Creating inverse attribute:  Attribute(container=None, one_liner=OneLiner(content='Inverse attribute for LiterateDataModel.allSubjects from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(container=None, content='inverseOfAllSubjects', _type='AttributeName'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(container=None, data_type=BaseDataType(container=None, class_name=ClassReference(container=None, content='LiterateDataModel', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Adding implied attribute:  Attribute: inverseOfAllSubjects  in  Class: Class
In AttSection post-init for Implied Attributes for Class, is_optional = None
Creating section for Class: Class: Attributesection: Implied Attributes for Class
Setting container of <AttributeSection>:Implied Attributes to <Class>:Class
Setting container of <Attribute>:dependents to <AttributeSection>:Implied Attributes
Setting container of <DataTypeClause>:[optional Set of  Classes (O_O)] to <Attribute>:dependents
Setting container of <SetDataType>:[Set of  Classes] to <DataTypeClause>:[optional Set of  Classes (O_O)]
Setting container of <BaseDataType>:[ Classes] to <SetDataType>:[Set of  Classes]
Setting container of <ClassReference>:Classes to <BaseDataType>:[ Classes]
Setting container of <AttributeName>:dependents to <Attribute>:dependents
Setting container of <AttributeReference>:[Class.basedOn] to <Attribute>:dependents
Setting container of <ClassReference>:Class to <AttributeReference>:[Class.basedOn]
Setting container of <AttributeName>:basedOn to <AttributeReference>:[Class.basedOn]
Setting container of <Attribute>:uniqueKeys to <AttributeSection>:Implied Attributes
Setting container of <DataTypeClause>:[optional Set of  UniqueKeys (O_O)] to <Attribute>:uniqueKeys
Setting container of <SetDataType>:[Set of  UniqueKeys] to <DataTypeClause>:[optional Set of  UniqueKeys (O_O)]
Setting container of <BaseDataType>:[ UniqueKeys] to <SetDataType>:[Set of  UniqueKeys]
Setting container of <ClassReference>:UniqueKeys to <BaseDataType>:[ UniqueKeys]
Setting container of <AttributeName>:uniqueKeys to <Attribute>:uniqueKeys
Setting container of <AttributeReference>:[UniqueKey.basedOn] to <Attribute>:uniqueKeys
Setting container of <ClassReference>:UniqueKey to <AttributeReference>:[UniqueKey.basedOn]
Setting container of <AttributeName>:basedOn to <AttributeReference>:[UniqueKey.basedOn]
Setting container of <AttributeSection>:Implied Attributes for Class to <Class>:Class
Setting container of <Attribute>:pluralForm to <Class>:Class
Setting container of <DataTypeClause>:[optional  UpperCamel (O_O)] to <Attribute>:pluralForm
Setting container of <BaseDataType>:[ UpperCamel] to <DataTypeClause>:[optional  UpperCamel (O_O)]
Setting container of <ClassReference>:UpperCamel to <BaseDataType>:[ UpperCamel]
Setting container of <AttributeName>:pluralForm to <Attribute>:pluralForm
Setting container of <Attribute>:basedOn to <Class>:Class
Setting container of <DataTypeClause>:[optional Set of  Class (O_O)] to <Attribute>:basedOn
Setting container of <SetDataType>:[Set of  Class] to <DataTypeClause>:[optional Set of  Class (O_O)]
Setting container of <BaseDataType>:[ Class] to <SetDataType>:[Set of  Class]
Setting container of <ClassReference>:Class to <BaseDataType>:[ Class]
Setting container of <AttributeName>:basedOn to <Attribute>:basedOn
Setting container of <Attribute>:supertypes to <Class>:Class
Setting container of <DataTypeClause>:[optional  Es (O_O)] to <Attribute>:supertypes
Setting container of <BaseDataType>:[ Es] to <DataTypeClause>:[optional  Es (O_O)]
Setting container of <ClassReference>:Es to <BaseDataType>:[ Es]
Setting container of <AttributeName>:supertypes to <Attribute>:supertypes
Setting container of <Attribute>:subtypings to <Class>:Class
Setting container of <DataTypeClause>:[optional List of  Subtypings (O_O)] to <Attribute>:subtypings
Setting container of <ListDataType>:[List of  Subtypings] to <DataTypeClause>:[optional List of  Subtypings (O_O)]
Setting container of <BaseDataType>:[ Subtypings] to <ListDataType>:[List of  Subtypings]
Setting container of <ClassReference>:Subtypings to <BaseDataType>:[ Subtypings]
Setting container of <AttributeName>:subtypings to <Attribute>:subtypings
Setting container of <Attribute>:subtypes to <Class>:Class
Setting container of <DataTypeClause>:[optional List of  Classes (O_O)] to <Attribute>:subtypes
Setting container of <ListDataType>:[List of  Classes] to <DataTypeClause>:[optional List of  Classes (O_O)]
Setting container of <BaseDataType>:[ Classes] to <ListDataType>:[List of  Classes]
Setting container of <ClassReference>:Classes to <BaseDataType>:[ Classes]
Setting container of <AttributeName>:subtypes to <Attribute>:subtypes
Setting container of <Attribute>:attributes to <Class>:Class
Setting container of <DataTypeClause>:[optional List of  Attributes (O_O)] to <Attribute>:attributes
Setting container of <ListDataType>:[List of  Attributes] to <DataTypeClause>:[optional List of  Attributes (O_O)]
Setting container of <BaseDataType>:[ Attributes] to <ListDataType>:[List of  Attributes]
Setting container of <ClassReference>:Attributes to <BaseDataType>:[ Attributes]
Setting container of <AttributeName>:attributes to <Attribute>:attributes
Setting container of <Attribute>:attributeSections to <Class>:Class
Setting container of <DataTypeClause>:[optional List of  AttributeSections (O_O)] to <Attribute>:attributeSections
Setting container of <ListDataType>:[List of  AttributeSections] to <DataTypeClause>:[optional List of  AttributeSections (O_O)]
Setting container of <BaseDataType>:[ AttributeSections] to <ListDataType>:[List of  AttributeSections]
Setting container of <ClassReference>:AttributeSections to <BaseDataType>:[ AttributeSections]
Setting container of <AttributeName>:attributeSections to <Attribute>:attributeSections
Setting container of <Attribute>:constraints to <Class>:Class
Setting container of <DataTypeClause>:[optional List of  Constraints (O_O)] to <Attribute>:constraints
Setting container of <ListDataType>:[List of  Constraints] to <DataTypeClause>:[optional List of  Constraints (O_O)]
Setting container of <BaseDataType>:[ Constraints] to <ListDataType>:[List of  Constraints]
Setting container of <ClassReference>:Constraints to <BaseDataType>:[ Constraints]
Setting container of <AttributeName>:constraints to <Attribute>:constraints
Setting container of <Attribute>:methods to <Class>:Class
Setting container of <DataTypeClause>:[optional List of  Methods (O_O)] to <Attribute>:methods
Setting container of <ListDataType>:[List of  Methods] to <DataTypeClause>:[optional List of  Methods (O_O)]
Setting container of <BaseDataType>:[ Methods] to <ListDataType>:[List of  Methods]
Setting container of <ClassReference>:Methods to <BaseDataType>:[ Methods]
Setting container of <AttributeName>:methods to <Attribute>:methods
Setting container of <Constraint>:[Constraint(container=Class(container=SubjectC(container=SubjectB(container=LiterateModel(container=None, one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='#', name=SubjectName(content='Literate Data Model', _type='SubjectName'), parenthetical=None, abbreviation=None, classes=[], subjects=[SubjectB(container=..., one_liner=OneLiner(content='the basic structure of the model'), elaboration=[Paragraph(content='In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'), Paragraph(content='We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n')], annotations=[], diagnostics=[Diagnostic(object_name='AnnotationType', object_type='Class', category='Style', message='oneLiner is too long. (96 chars).', severity='Warning', constraint_name='checkOneLinerLength')], is_embellishment=False, prefix='##', name=SubjectName(content='Preliminaries', _type='SubjectName'), parenthetical=None, abbreviation=None, classes=[Class(container=..., one_liner=OneLiner(content='An element or building block of the literate data model'), elaboration=[], annotations=[], diagnostics=[Diagnostic(object_name='oneLiner', object_type='Attribute', category='Style', message='oneLiner is too long. (116 chars).', severity='Warning', constraint_name='checkOneLinerLength')], is_embellishment=False, prefix='Class', name=ClassName(content='Component', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Components', presumed_plural='Components', subtype_of=[], subtypings=[Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(container=None, content='LiterateDataModel', _type='ClassReference'), ClassReference(container=None, content='Subject', _type='ClassReference'), ClassReference(container=None, content='Class', _type='ClassReference'), ClassReference(container=None, content='Key', _type='ClassReference'), ClassReference(container=None, content='AttributeSection', _type='ClassReference'), ClassReference(container=None, content='Attribute', _type='ClassReference'), ClassReference(container=None, content='Constraint', _type='ClassReference'), ClassReference(container=None, content='Method', _type='ClassReference'), ClassReference(container=None, content='ParameterAnInputToAMethod', _type='ClassReference')])], subtypes=[], based_on=[], dependents=[ClassReference(container=None, content='Annotation', _type='ClassReference')], is_value_type=False, where=None, constraints=[], attributes=[Attribute(container=..., one_liner=OneLiner(content='the name of the component, not in camel case'), elaboration=[], annotations=[Annotation(label=Label(content='warning', _type='Label'), content=OneLiner(content='This is a warning with emoji'), emoji=Emoji(content='‚ö†Ô∏è', _type='Emoji', as_entered='‚ö†Ô∏è'), elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='normalName', _type='AttributeName'), parenthetical='*String*', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='String', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='The name of the component'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='name', _type='AttributeName'), parenthetical='CamelName', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='CamelName', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='qualifiedName', _type='AttributeName'), parenthetical='*QualifiedCamel*', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='QualifiedCamel', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content="a short form of the component's name, used for cross references and improved readability."), elaboration=[], annotations=[Annotation(label=Label(content='example', _type='Label'), content=OneLiner(content='"LDM" is the short form of "Literate Data Model".'), emoji=Emoji(content='üî£', _type='Emoji', as_entered='üî£'), elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='abbreviatedName', _type='AttributeName'), parenthetical='*CamelName*', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='CamelName', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' name -  how do you say name in english?\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=' x.name == y\n'), constraints=[Constraint(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' the abbreviated name should be shorter than the actual name\n'), elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content="Does this annotation find it's way to the Constraint? YES! It's fixed!"), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, ocl=' len(abbreviatedName) < len(name)\n', message='  Why have an abbreviation longer than the name?\n', severity=' Warning\n')]), Attribute(container=..., one_liner=OneLiner(content='A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='oneLiner', _type='AttributeName'), parenthetical='OneLiner', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='OneLiner', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='A more detailed explanation or discussion of the component _'), elaboration=[], annotations=[], diagnostics=[Diagnostic(object_name='', object_type='BaseDataType', category='InvalidBaseType', message='RichText is not a class name - or plural', severity='Error', constraint_name='checkClassReference')], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='elaboration', _type='AttributeName'), parenthetical='RichText', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='RichText', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=AttributeSection(container=..., one_liner=OneLiner(content='mechanical attributes'), elaboration=[], annotations=[], diagnostics=[Diagnostic(object_name='isEmbellishment', object_type='Attribute', category='Style', message='oneLiner is too long. (91 chars).', severity='Warning', constraint_name='checkOneLinerLength')], is_embellishment=False, prefix='__', name=AttributeSectionName(content='For Machinery', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[...]), one_liner=OneLiner(content='Indicates whether this component is an embellishment added during post-parsing processing _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='isEmbellishment', _type='AttributeName'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Boolean', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' false\n'), elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, ocl=''), constraints=[]), Attribute(container=AttributeSection(container=..., one_liner=OneLiner(content='mechanical attributes'), elaboration=[], annotations=[], diagnostics=[Diagnostic(object_name='isEmbellishment', object_type='Attribute', category='Style', message='oneLiner is too long. (91 chars).', severity='Warning', constraint_name='checkOneLinerLength')], is_embellishment=False, prefix='__', name=AttributeSectionName(content='For Machinery', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[...]), one_liner=OneLiner(content='Indicates whether this component is an embellishment added during post-parsing processing _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='isEmbellishment', _type='AttributeName'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Boolean', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' false\n'), elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, ocl=''), constraints=[])], attribute_sections=[AttributeSection(container=..., one_liner=OneLiner(content='mechanical attributes'), elaboration=[], annotations=[], diagnostics=[Diagnostic(object_name='isEmbellishment', object_type='Attribute', category='Style', message='oneLiner is too long. (91 chars).', severity='Warning', constraint_name='checkOneLinerLength')], is_embellishment=False, prefix='__', name=AttributeSectionName(content='For Machinery', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[Attribute(container=..., one_liner=OneLiner(content='Indicates whether this component is an embellishment added during post-parsing processing _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='isEmbellishment', _type='AttributeName'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Boolean', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' false\n'), elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, ocl=''), constraints=[])])]), Class(container=..., one_liner=OneLiner(content='a kind of note, or aside, used to call attention to additional information about some Component.'), elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'), emoji=Emoji(content='üóâ', _type='Emoji', as_entered='üóâ'), elaboration=[])], diagnostics=[Diagnostic(object_name='Implied Attributes for Annotation Type', object_type='AttributeSection', category='Style', message='name is too long. (38 chars).', severity='Warning', constraint_name='NoConstraintName')], is_embellishment=False, prefix='Class', name=ClassName(content='AnnotationType', _type='ClassName'), parenthetical=None, abbreviation=None, plural='AnnotationTypes', presumed_plural='AnnotationTypes', subtype_of=[], subtypings=[], subtypes=[], based_on=[ClassReference(container=..., content='LiterateDataModel', _type='ClassReference')], dependents=[], is_value_type=False, where=None, constraints=[], attributes=[Attribute(container=..., one_liner=OneLiner(content='an emoji'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='emoji', _type='AttributeName'), parenthetical='Emoji', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Emoji', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='an emoji'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='emojiName', _type='AttributeName'), parenthetical='String', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='String', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='the Unicode for the emoji'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='emojiUnicode', _type='AttributeName'), parenthetical='String', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='String', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='A short label to indicate the purpose of the annotation _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='label', _type='AttributeName'), parenthetical='LowerCamel', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='LowerCamel', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='the plural form of the label'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='plural', _type='AttributeName'), parenthetical='*UpperCamel*', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='UpperCamel', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' based on label\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[]), Attribute(container=..., one_liner=OneLiner(content='the intended reason for the annotation.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='purpose', _type='AttributeName'), parenthetical='OneLiner', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='OneLiner', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])], attribute_sections=[AttributeSection(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeSectionName(content='Implied Attributes for Annotation Type', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[Attribute(container=..., one_liner=OneLiner(content='A link back to the LiterateDataModel on which this AnnotationType depends.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(container=..., content='baseLiterateDataModel', _type='AttributeName'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='LiterateDataModel', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])]), AttributeSection(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeSectionName(content='Implied Attributes for Annotation Type', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[Attribute(container=..., one_liner=OneLiner(content='Inverse attribute for Annotation.annotationType from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(container=..., content='inverseOfAnnotationType', _type='AttributeName'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Annotation', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=AttributeReference(container=None, class_name=ClassReference(container=None, content='Annotation', _type='ClassReference'), attribute_name=AttributeName(container=None, content='annotationType', _type='AttributeName')), inverse_of=None, derivation=None, default=None, constraints=[])])]), Class(container=..., one_liner=OneLiner(content='A note or comment associated with a model element'), elaboration=[], annotations=[], diagnostics=[Diagnostic(object_name='Implied Attributes for Annotation', object_type='AttributeSection', category='Style', message='name is too long. (33 chars).', severity='Warning', constraint_name='NoConstraintName')], is_embellishment=False, prefix='Class', name=ClassName(content='Annotation', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Annotations', presumed_plural='Annotations', subtype_of=[], subtypings=[], subtypes=[], based_on=[ClassReference(container=BaseDataType(container=DataTypeClause(container=Attribute(container=AttributeSection(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeSectionName(content='Implied Attributes for Annotation', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[...]), one_liner=OneLiner(content='A link back to the Component on which this Annotation depends.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(container=..., content='baseComponent', _type='AttributeName'), parenthetical=None, abbreviation=None, data_type_clause=..., overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), data_type=..., is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), class_name=..., as_value_type=AsValue(content=False, _type='AsValue')), content='Component', _type='ClassReference')], dependents=[], is_value_type=False, where=None, constraints=[], attributes=[Attribute(container=..., one_liner=None, elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'), emoji=Emoji(content='üóâ', _type='Emoji', as_entered='üóâ'), elaboration=[]), Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='Should be a Value  Type'), emoji=Emoji(content='üóâ', _type='Emoji', as_entered='üóâ'), elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='annotationType', _type='AttributeName'), parenthetical='optional Annotation Type', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='AnnotationType', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=AttributeReference(container=None, class_name=ClassReference(container=None, content='AnnotationType', _type='ClassReference'), attribute_name=AttributeName(container=Attribute(container=AttributeSection(container=Class(container=..., one_liner=OneLiner(content='a kind of note, or aside, used to call attention to additional information about some Component.'), elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'), emoji=Emoji(content='üóâ', _type='Emoji', as_entered='üóâ'), elaboration=[])], diagnostics=[Diagnostic(object_name='Implied Attributes for Annotation Type', object_type='AttributeSection', category='Style', message='name is too long. (38 chars).', severity='Warning', constraint_name='NoConstraintName')], is_embellishment=False, prefix='Class', name=ClassName(content='AnnotationType', _type='ClassName'), parenthetical=None, abbreviation=None, plural='AnnotationTypes', presumed_plural='AnnotationTypes', subtype_of=[], subtypings=[], subtypes=[], based_on=[ClassReference(container=..., content='LiterateDataModel', _type='ClassReference')], dependents=[], is_value_type=False, where=None, constraints=[], attributes=[Attribute(container=..., one_liner=OneLiner(content='an emoji'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='emoji', _type='AttributeName'), parenthetical='Emoji', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Emoji', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='an emoji'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='emojiName', _type='AttributeName'), parenthetical='String', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='String', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='the Unicode for the emoji'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='emojiUnicode', _type='AttributeName'), parenthetical='String', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='String', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='A short label to indicate the purpose of the annotation _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='label', _type='AttributeName'), parenthetical='LowerCamel', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='LowerCamel', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='the plural form of the label'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='plural', _type='AttributeName'), parenthetical='*UpperCamel*', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='UpperCamel', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' based on label\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[]), Attribute(container=..., one_liner=OneLiner(content='the intended reason for the annotation.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='purpose', _type='AttributeName'), parenthetical='OneLiner', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='OneLiner', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])], attribute_sections=[AttributeSection(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeSectionName(content='Implied Attributes for Annotation Type', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[Attribute(container=..., one_liner=OneLiner(content='A link back to the LiterateDataModel on which this AnnotationType depends.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(container=..., content='baseLiterateDataModel', _type='AttributeName'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='LiterateDataModel', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])]), ...]), one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeSectionName(content='Implied Attributes for Annotation Type', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[...]), one_liner=OneLiner(content='Inverse attribute for Annotation.annotationType from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=..., parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Annotation', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=AttributeReference(container=None, class_name=ClassReference(container=None, content='Annotation', _type='ClassReference'), attribute_name=AttributeName(container=None, content='annotationType', _type='AttributeName')), inverse_of=None, derivation=None, default=None, constraints=[]), content='inverseOfAnnotationType', _type='AttributeName')), inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='A short label to indicate the purpose of the annotation _'), elaboration=[Paragraph(content='But any short label is valid.\n')], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='label', _type='AttributeName'), parenthetical='CamelName', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='CamelName', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' from annotationType\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[]), Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='emoji', _type='AttributeName'), parenthetical='optional Emoji', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Emoji', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' from annotation type\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[]), Attribute(container=..., one_liner=OneLiner(content='The content or body of the annotation'), elaboration=[], annotations=[], diagnostics=[Diagnostic(object_name='', object_type='BaseDataType', category='InvalidBaseType', message='RichText is not a class name - or plural', severity='Error', constraint_name='checkClassReference')], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='content', _type='AttributeName'), parenthetical='*RichText*', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='RichText', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])], attribute_sections=[AttributeSection(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[Diagnostic(object_name='isEmbellishment', object_type='Attribute', category='Style', message='oneLiner is too long. (92 chars).', severity='Warning', constraint_name='checkOneLinerLength')], is_embellishment=False, prefix='__', name=AttributeSectionName(content='For Machinery', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[Attribute(container=..., one_liner=OneLiner(content='Indicates whether this annotation is an embellishment added during post-parsing processing _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='isEmbellishment', _type='AttributeName'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Boolean', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' false\n'), elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, ocl=''), constraints=[])]), AttributeSection(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeSectionName(content='Implied Attributes for Annotation', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[Attribute(container=..., one_liner=OneLiner(content='A link back to the Component on which this Annotation depends.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(container=..., content='baseComponent', _type='AttributeName'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Component', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])])])], subjects=[]), ..., SubjectB(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='##', name=SubjectName(content='Attributes', _type='SubjectName'), parenthetical=None, abbreviation=None, classes=[Class(container=..., one_liner=OneLiner(content='a group of attributes for a class that merit a shared explanation.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='AttributeSection', _type='ClassName'), parenthetical=None, abbreviation=None, plural='AttributeSections', presumed_plural='AttributeSections', subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='Component', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[ClassReference(container=..., content='Class', _type='ClassReference')], dependents=[ClassReference(container=None, content='Attribute', _type='ClassReference')], is_value_type=False, where=None, constraints=[], attributes=[Attribute(container=..., one_liner=OneLiner(content='whether the attributes in this section, taken together, are optional.'), elaboration=[Paragraph(content='If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n')], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='isOptional', _type='AttributeName'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Boolean', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])], attribute_sections=[]), Class(container=..., one_liner=OneLiner(content='A property or characteristic of a class'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='Attribute', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Attributes', presumed_plural=None, subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='Component', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[ClassReference(container=..., content='AttributeSection', _type='ClassReference')], dependents=[ClassReference(container=None, content='AttributeConstraint', _type='ClassReference')], is_value_type=False, where=None, constraints=[], attributes=[Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='name', _type='AttributeName'), parenthetical='Lower Camel', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='LowerCamel', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='The kind of object to which the attribute refers.  _'), elaboration=[Paragraph(content='But,\n \n+ * List of Editions\n \n+ * Set of Edition\n \n+ * ... and more complicated cases.\n')], annotations=[Annotation(label=Label(content='see', _type='Label'), content=OneLiner(content='the section below on Data Type Specifiers.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='dataType', _type='AttributeName'), parenthetical='DataType', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='DataType', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])], attribute_sections=[AttributeSection(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='__', name=AttributeSectionName(content='Cardinalities', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[Attribute(container=..., one_liner=OneLiner(content='Indicates whether the attribute must have a value for every instance of the class _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='isOptional', _type='AttributeName'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Boolean', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content='*** False\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[]), Attribute(container=..., one_liner=OneLiner(content='The cardinality of the relationship represented by the attribute _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='cardinality', _type='AttributeName'), parenthetical='CardinalityCode', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='CardinalityCode', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), elaboration=[Paragraph(content='***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n')], annotations=[Annotation(label=Label(content='forExample', _type='Label'), content=OneLiner(content=''), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, ocl=''), constraints=[]), Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='author', _type='AttributeName'), parenthetical='1:1 Author', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='InventedName', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=None, elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='how this works with optionality'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='books', _type='AttributeName'), parenthetical='optional N:M Set of Books', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='InventedName', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])]), AttributeSection(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='__', name=AttributeSectionName(content='Inverse Attributes', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='isInvertible', _type='AttributeName'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Boolean', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=Derivation(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' true if the data type is a class or a simple collection of members of a class.\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='the class which contains, or would contain the inverse attribute'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='inverseClass', _type='AttributeName'), parenthetical='optional Class', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Class', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=Derivation(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' from the data type. Null unless arrribute is invertible.\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), default=None, constraints=[]), Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='inverseAttribute', _type='AttributeName'), parenthetical='optional Attribute', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Attribute', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='inverseIsOptional', _type='AttributeName'), parenthetical='optional Attribute', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Attribute', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])]), AttributeSection(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='__', name=AttributeSectionName(content='Formulas', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[Attribute(container=..., one_liner=OneLiner(content='The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'), elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='even when an Attribute has a default derivation, there‚Äôs no guarantee that every instance will have an assigned value. Example needed.'), emoji=None, elaboration=[Paragraph(content="Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"), Paragraph(content='Last paragraph here\n')])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='default', _type='AttributeName'), parenthetical='optional Derivation', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Derivation', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='For derived attributes, the rule or formula for calculating the value _'), elaboration=[], annotations=[Annotation(label=Label(content='issue', _type='Label'), content=OneLiner(content='on insert vs on access?'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='derivation', _type='AttributeName'), parenthetical='optional Derivation', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Derivation', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='Any validation rules specific to this attribute _'), elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='from Class.constraints'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='constraints', _type='AttributeName'), parenthetical='ListOf Constraints', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=ListDataType(container=..., element_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Constraints', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])]), AttributeSection(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='__', name=AttributeSectionName(content='Override Tracking', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='overrides', _type='AttributeName'), parenthetical=None, abbreviation=None, data_type_clause=None, overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])])]), ValueType(container=..., one_liner=OneLiner(content='A rule or formula for deriving the value of an attribute'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='Derivation', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Derivations', presumed_plural=None, subtype_of=[], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[Attribute(container=..., one_liner=OneLiner(content='An English language statement of the derivation rule _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='statement', _type='AttributeName'), parenthetical='RichText', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='RichText', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='The formal expression of the derivation in a programming language _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='expression', _type='AttributeName'), parenthetical='CodeExpression', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='CodeExpression', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])], attribute_sections=[]), ValueType(container=..., one_liner=OneLiner(content='A rule, condition, or validation that must be satisfied by the model'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='Constraint', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Constraints', presumed_plural=None, subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='Component', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(container=None, content='ClassConstraint', _type='ClassReference'), ClassReference(container=None, content='AttributeConstraint', _type='ClassReference')])], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[Attribute(container=..., one_liner=OneLiner(content='An English language statement of the constraint _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='statement', _type='AttributeName'), parenthetical='RichText', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='RichText', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='The formal expression of the constraint in a programming language'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='expression', _type='AttributeName'), parenthetical='e.g., OCL _(CodeExpression', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='InventedName', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=None, elaboration=[CodeBlock(content='```codes\nWarning, nothing fatal; just a caution\nError, serious. Fix now\n```')], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='severity', _type='AttributeName'), parenthetical='Code', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Code', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])], attribute_sections=[]), ValueType(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='ClassConstraint', _type='ClassName'), parenthetical=None, abbreviation=None, plural='ClassConstraints', presumed_plural='ClassConstraints', subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='Constraint', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[ClassReference(container=..., content='Class', _type='ClassReference')], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), ValueType(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='AttributeConstraint', _type='ClassName'), parenthetical=None, abbreviation=None, plural='AttributeConstraints', presumed_plural='AttributeConstraints', subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='Constraint', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[ClassReference(container=..., content='Attribute', _type='ClassReference')], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[])], subjects=[]), SubjectB(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='##', name=SubjectName(content='Methods', _type='SubjectName'), parenthetical=None, abbreviation=None, classes=[Class(container=..., one_liner=OneLiner(content='A behavior or operation associated with a class'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='Method', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Methods', presumed_plural=None, subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='Component', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=False, where=None, constraints=[], attributes=[Attribute(container=..., one_liner=OneLiner(content='The input parameters of the method _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='parameters', _type='AttributeName'), parenthetical='ListOf Parameters', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=ListDataType(container=..., element_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Parameters', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='The data type of the value returned by the method _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='returnType', _type='AttributeName'), parenthetical='DataType', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='DataType', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])], attribute_sections=[]), Class(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='ParameterAnInputToAMethod', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Parameters', presumed_plural=None, subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='Component', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=False, where=None, constraints=[], attributes=[Attribute(container=..., one_liner=OneLiner(content='The data type of the parameter _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='type', _type='AttributeName'), parenthetical='DataType', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='DataType', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='The cardinality of the parameter'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='cardinality', _type='AttributeName'), parenthetical='e.g., optional, required', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='InventedName', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])], attribute_sections=[])], subjects=[]), SubjectB(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='##', name=SubjectName(content='Trivial Data Types', _type='SubjectName'), parenthetical=None, abbreviation=None, classes=[ValueType(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='Message', _type='ClassName'), parenthetical='Template', abbreviation=None, plural='Messages', presumed_plural='Messages', subtype_of=[], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), ValueType(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='CodeExpression', _type='ClassName'), parenthetical=None, abbreviation=None, plural='CodeExpressions', presumed_plural='CodeExpressions', subtype_of=[], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[Attribute(container=..., one_liner=OneLiner(content='the programming language'), elaboration=[CodeBlock(content='``` code\nOCL, Object Constraint Language\nJava, Java\n```')], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='language', _type='AttributeName'), parenthetical='Code', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Code', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='expression', _type='AttributeName'), parenthetical='String', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='String', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])], attribute_sections=[]), ValueType(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='DataType', _type='ClassName'), parenthetical=None, abbreviation=None, plural='DataTypes', presumed_plural='DataTypes', subtype_of=[], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), ValueType(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='SimpleDataTypeSubtpeOfDataType', _type='ClassName'), parenthetical=None, abbreviation=None, plural='SimpleDataTypeSubtpeOfDataTypes', presumed_plural='SimpleDataTypeSubtpeOfDataTypes', subtype_of=[], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='coreClass', _type='AttributeName'), parenthetical='Class', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Class', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])], attribute_sections=[]), ValueType(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='ComplexDataType', _type='ClassName'), parenthetical=None, abbreviation=None, plural='ComplexDataTypes', presumed_plural='ComplexDataTypes', subtype_of=[], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='aggregation', _type='AttributeName'), parenthetical='Aggregating Operator', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='AggregatingOperator', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='aggregatedTypes', _type='AttributeName'), parenthetical='List of DataTypes', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=ListDataType(container=..., element_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='DataTypes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])], attribute_sections=[]), ValueType(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='AggregatingOperator', _type='ClassName'), parenthetical=None, abbreviation=None, plural='AggregatingOperators', presumed_plural='AggregatingOperators', subtype_of=[], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[Attribute(container=..., one_liner=None, elaboration=[CodeBlock(content='``` code\nSetOf\nListOf\nMapping\n```')], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='name', _type='AttributeName'), parenthetical='Code', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Code', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='arity', _type='AttributeName'), parenthetical='Integer', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Integer', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='spelling', _type='AttributeName'), parenthetical='Template', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Template', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])], attribute_sections=[])], subjects=[]), SubjectB(container=..., one_liner=None, elaboration=[Paragraph(content='insert Camel Case.md\n')], annotations=[], diagnostics=[], is_embellishment=False, prefix='##', name=SubjectName(content='Trivial Low level Data Types', _type='SubjectName'), parenthetical=None, abbreviation=None, classes=[ValueType(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='Emoji', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Emojis', presumed_plural='Emojis', subtype_of=[], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), ValueType(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='String', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Strings', presumed_plural='Strings', subtype_of=[], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), ValueType(container=..., one_liner=None, elaboration=[Paragraph(content='A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n')], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='CamelName', _type='ClassName'), parenthetical=None, abbreviation=None, plural='CamelNames', presumed_plural='CamelNames', subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='String', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(container=None, content='UpperCamel', _type='ClassReference'), ClassReference(container=None, content='LowerCamel', _type='ClassReference')])], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='valueTheString', _type='AttributeName'), parenthetical='String', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='String', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[Constraint(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' Must follow the camel case naming convention and not be empty.\n'), elaboration=[], annotations=[Annotation(label=Label(content='example', _type='Label'), content=OneLiner(content='"firstName", "orderDate", "customerID"'), emoji=None, elaboration=[Paragraph(content='> üìù ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n')]), Annotation(label=Label(content='modelingNote', _type='Label'), content=OneLiner(content='* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, ocl='', message='', severity=None)])], attribute_sections=[]), ValueType(container=..., one_liner=OneLiner(content='a CamelName that begins with a capital letter'), elaboration=[], annotations=[Annotation(label=Label(content='example', _type='Label'), content=OneLiner(content='_ "Customer", "ProductCategory", "PaymentMethod"'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='UpperCamel', _type='ClassName'), parenthetical=None, abbreviation=None, plural='UpperCamels', presumed_plural='UpperCamels', subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='CamelName', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=' content begins with an upper case letter.\n', constraints=[], attributes=[], attribute_sections=[]), ValueType(container=..., one_liner=OneLiner(content='a CamelName that begins with a lower case letter'), elaboration=[], annotations=[Annotation(label=Label(content='example', _type='Label'), content=OneLiner(content='"firstName", "orderTotal", "shippingAddress"'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='LowerCamel', _type='ClassName'), parenthetical=None, abbreviation=None, plural='LowerCamels', presumed_plural='LowerCamels', subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='CamelName', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=' content begins with a lower case letter.\n', constraints=[], attributes=[], attribute_sections=[]), ValueType(container=..., one_liner=OneLiner(content='an expression consisting of Camel Names separated by periods'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='QualifiedCamel', _type='ClassName'), parenthetical=None, abbreviation=None, plural='QualifiedCamels', presumed_plural='QualifiedCamels', subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='String', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[Constraint(container=..., one_liner=OneLiner(content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl='', message='', severity=None)], attributes=[], attribute_sections=[]), Class(container=..., one_liner=OneLiner(content='A string with markup for block level formatting.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='ValueTypeRichText', _type='ClassName'), parenthetical=None, abbreviation=None, plural='ValueTypeRichTexts', presumed_plural='ValueTypeRichTexts', subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='String', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=False, where=None, constraints=[], attributes=[Attribute(container=..., one_liner=OneLiner(content='the string content'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='value', _type='AttributeName'), parenthetical='string', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='String', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='the rich text coding language used'), elaboration=[CodeBlock(content='```code\nHTML\nMarkDown\n```')], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='format', _type='AttributeName'), parenthetical='Code', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Code', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])], attribute_sections=[]), ValueType(container=..., one_liner=OneLiner(content='String with markup for line level formatting.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='OneLiner', _type='ClassName'), parenthetical=None, abbreviation=None, plural='OneLiners', presumed_plural='OneLiners', subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='RichText', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[Attribute(container=..., one_liner=OneLiner(content='the string content'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='value', _type='AttributeName'), parenthetical='string', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='String', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[Constraint(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' must not containa line break or new line character\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl='', message=" A line can't span two lines\n", severity=None)])], attribute_sections=[]), ValueType(container=..., one_liner=OneLiner(content='A basic, built-in data type'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='PrimitiveType', _type='ClassName'), parenthetical=None, abbreviation=None, plural='PrimitiveTypes', presumed_plural='PrimitiveTypes', subtype_of=[], subtypings=[Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(container=None, content='String', _type='ClassReference'), ClassReference(container=None, content='Integer', _type='ClassReference'), ClassReference(container=None, content='Decimal', _type='ClassReference'), ClassReference(container=None, content='Boolean', _type='ClassReference'), ClassReference(container=None, content='Date', _type='ClassReference'), ClassReference(container=None, content='Time', _type='ClassReference'), ClassReference(container=None, content='DateTime', _type='ClassReference')])], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), ValueType(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='String', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Strings', presumed_plural='Strings', subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='PrimitiveType', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(container=None, content='CamelName', _type='ClassReference'), ClassReference(container=None, content='QualifiedCamel', _type='ClassReference'), ClassReference(container=None, content='ValueTypeRichText', _type='ClassReference')])], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), ValueType(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='Integer', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Integers', presumed_plural='Integers', subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='PrimitiveType', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), ValueType(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='Decimal', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Decimals', presumed_plural='Decimals', subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='PrimitiveType', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), ValueType(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='Boolean', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Booleans', presumed_plural='Booleans', subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='PrimitiveType', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), ValueType(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='Date', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Dates', presumed_plural='Dates', subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='PrimitiveType', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), ValueType(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='Time', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Times', presumed_plural='Times', subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='PrimitiveType', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[]), ValueType(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='DateTime', _type='ClassName'), parenthetical=None, abbreviation=None, plural='DateTimes', presumed_plural='DateTimes', subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='PrimitiveType', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[], attribute_sections=[])], subjects=[SubjectC(container=..., one_liner=None, elaboration=[Paragraph(content='These are the recognized Annotation Types for the LDM model.\n'), Paragraph(content='And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.\n'), CodeBlock(content='```puml\n@startjson\n\n[\n{\n"label": "Error",\n"emoji": "‚ùå",\n"emojiName": "cross_mark",\n"emojiUnicode": "U+274C",\n"purpose": "Indicates a critical error or failure in the model."\n},\n{\n"label": "Warning",\n"emoji": "‚ö†Ô∏è",\n"emojiName": "warning",\n"emojiUnicode": "U+26A0",\n"purpose": "Indicates a potential issue or warning in the model."\n},\n{\n"label": "Note",\n"emoji": "üìò",\n"emojiName": "blue_book",\n"emojiUnicode": "U+1F4D8",\n"purpose": "Provides additional context, explanations, or clarifications for the annotated element."\n},\n{\n"label": "Issue",\n"emoji": "‚ö†Ô∏è",\n"emojiName": "warning",\n"emojiUnicode": "U+26A0",\n"purpose": "Highlights a potential issue or error that needs to be addressed or resolved."\n},\n{\n"label": "Question",\n"emoji": "‚ùì",\n"emojiName": "question",\n"emojiUnicode": "U+2753",\n"purpose": "Raises a question or seeks further clarification about the annotated element."\n},\n{\n"label": "Suggestion",\n"emoji": "üí°",\n"emojiName": "bulb",\n"emojiUnicode": "U+1F4A1",\n"purpose": "Provides a suggestion or recommendation for improving the model or the annotated element."\n},\n{\n"label": "Info",\n"emoji": "‚ÑπÔ∏è",\n"emojiName": "information_source",\n"emojiUnicode": "U+2139",\n"purpose": "Offers relevant information, facts, or details about the annotated element."\n},\n{\n"label": "Todo",\n"emoji": "üìå",\n"emojiName": "pushpin",\n"emojiUnicode": "U+1F4CC",\n"purpose": "Indicates a pending task, action item, or future work related to the annotated element."\n},\n{\n"label": "Reference",\n"emoji": "üåê",\n"emojiName": "globe_with_meridians",\n"emojiUnicode": "U+1F310",\n"purpose": "Provides a reference or link to an external resource or documentation."\n},\n{\n"label": "See",\n"emoji": "üîç",\n"emojiName": "mag",\n"emojiUnicode": "U+1F50D",\n"purpose": "Indicates a cross-reference to another relevant element within the model."\n}\n]\n@endjson\n\n```')], annotations=[], diagnostics=[], is_embellishment=False, prefix='###', name=SubjectName(content='Annotation Types Used', _type='SubjectName'), parenthetical=None, abbreviation=None, classes=[], subjects=[]), SubjectC(container=..., one_liner=None, elaboration=[CodeBlock(content='``` csv\nlabel,emoji,emojiName,emojiUnicode,purpose\nError,‚ùå,cross_mark,U+274C,Indicates a critical error or failure in the model.\nWarning,‚ö†Ô∏è,warning,U+26A0,Indicates a potential issue or warning in the model.\nNote,üìò,blue_book,U+1F4D8,"Provides additional context, explanations, or clarifications for the annotated element."\nIssue,‚ö†Ô∏è,warning,U+26A0,Highlights a potential issue or error that needs to be addressed or resolved.\nQuestion,‚ùì,question,U+2753,Raises a question or seeks further clarification about the annotated element.\nSuggestion,üí°,bulb,U+1F4A1,Provides a suggestion or recommendation for improving the model or the annotated element.\nInfo,‚ÑπÔ∏è,information_source,U+2139,"Offers relevant information, facts, or details about the annotated element."\nTodo,üìå,pushpin,U+1F4CC,"Indicates a pending task, action item, or future work related to the annotated element."\nReference,üåê,globe_with_meridians,U+1F310,Provides a reference or link to an external resource or documentation.\nSee,üîç,mag,U+1F50D,Indicates a cross-reference to another relevant element within the model.\n\n```')], annotations=[], diagnostics=[], is_embellishment=False, prefix='###', name=SubjectName(content='Annotation types as CSV', _type='SubjectName'), parenthetical=None, abbreviation=None, classes=[], subjects=[])]), SubjectB(container=..., one_liner=OneLiner(content='various sidebars to include\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md'), elaboration=[Paragraph(content='== content to add\n')], annotations=[], diagnostics=[], is_embellishment=False, prefix='##', name=SubjectName(content='Appendices', _type='SubjectName'), parenthetical=None, abbreviation=None, classes=[], subjects=[])]), one_liner=None, elaboration=[], annotations=[], diagnostics=[Diagnostic(object_name='LiterateDataModel', object_type='Class', category='Style', message='oneLiner is too long. (112 chars).', severity='Warning', constraint_name='checkOneLinerLength')], is_embellishment=False, prefix='##', name=SubjectName(content='The Model and its Subjects', _type='SubjectName'), parenthetical=None, abbreviation=None, classes=[Class(container=..., one_liner=OneLiner(content="A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='LiterateDataModel', _type='ClassName'), parenthetical=None, abbreviation='LDM', plural='LiterateDataModels', presumed_plural=None, subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='Component', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[ClassReference(container=None, content='AnnotationType', _type='ClassReference'), ClassReference(container=None, content='Subject', _type='ClassReference')], is_value_type=False, where=None, constraints=[], attributes=[Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='name', _type='AttributeName'), parenthetical='UpperCamel', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='UpperCamel', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=AttributeReference(container=None, class_name=ClassReference(container=None, content='Component', _type='ClassReference'), attribute_name=AttributeName(container=None, content='name', _type='AttributeName')), inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='list of all classes in the model, as ordered in the\ndefinition of the model.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='allSubjects', _type='AttributeName'), parenthetical='List of Classes', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=ListDataType(container=..., element_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Classes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=Derivation(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' gathering s.allSubjects over s in subjectAreas\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), default=None, constraints=[Constraint(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' Subject names must be unique across the model.\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl='', message='', severity=None)]), Attribute(container=..., one_liner=OneLiner(content='list of all classes in the model, as ordered in the definition of the model.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='allClasses', _type='AttributeName'), parenthetical='List of Classes', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=ListDataType(container=..., element_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Classes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=Derivation(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' gathering s.allClasses over s in allSubjects.\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), default=None, constraints=[Constraint(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' Class names must be unique across the model.\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl='', message='', severity=None)])], attribute_sections=[AttributeSection(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='__', name=AttributeSectionName(content='Modeling Configuration', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='annotationTypes', _type='AttributeName'), parenthetical='List of AnnotationTypes', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=ListDataType(container=..., element_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='AnnotationTypes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='the recommended lanquage  for expressing derivation, defaults, and constraints'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='preferredCodingLanguage', _type='AttributeName'), parenthetical='Coding Language', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='CodingLanguage', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' OCL\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[]), Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='alternateCodingLanguages', _type='AttributeName'), parenthetical='optional List of Coding Languages', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=ListDataType(container=..., element_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='CodingLanguages', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='the recommended lanquage  for expressing derivation, defaults, and constraints'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='preferredTemplateLanguage', _type='AttributeName'), parenthetical='Template Language', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='TemplateLanguage', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' Handlebars\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[]), Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='alternateTemplateLanguages', _type='AttributeName'), parenthetical='optional List of Template Languages', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=ListDataType(container=..., element_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='TemplateLanguages', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='A list of functions that require sophisticated AI-powered implementation *'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='aiFunctions', _type='AttributeName'), parenthetical='List of String', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=ListDataType(container=..., element_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='String', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=Derivation(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=" ['aiEnglishPlural()']\n"), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), default=None, constraints=[])])]), Class(container=..., one_liner=OneLiner(content='A specific topic or theme within the model'), elaboration=[Paragraph(content='Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it‚Äôs just expository.\n')], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='Subject', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Subjects', presumed_plural=None, subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='Component', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(container=None, content='SubjectArea', _type='ClassReference')])], subtypes=[], based_on=[ClassReference(container=..., content='LiterateDataModel', _type='ClassReference')], dependents=[], is_value_type=False, where=None, constraints=[], attributes=[Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='name', _type='AttributeName'), parenthetical='UpperCamel', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='UpperCamel', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='The parent subject, if any, under which this subject is nested _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='parentSubject', _type='AttributeName'), parenthetical='optional Subject', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Subject', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='The major classes related to this subject, in the order in which they should be presented _'), elaboration=[], annotations=[Annotation(label=Label(content='issue', _type='Label'), content=OneLiner(content='define chapter, section, subsection as levels?'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='classes', _type='AttributeName'), parenthetical='ListOf Classes', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=ListDataType(container=..., element_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Classes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='Any child subjects nested under this subject, in the order in which they should be presented _'), elaboration=[Paragraph(content='***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n')], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='childSubjects', _type='AttributeName'), parenthetical='ListOf Subjects', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=ListDataType(container=..., element_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Subjects', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=AttributeReference(container=..., class_name=ClassReference(container=..., content='Subject', _type='ClassReference'), attribute_name=AttributeName(container=..., content='parentSubject', _type='AttributeName')), inverse_of=None, derivation=None, default=None, constraints=[])], attribute_sections=[]), Class(container=..., one_liner=OneLiner(content='A main topic or area of focus within the model, containing related subjects and classes'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='SubjectArea', _type='ClassName'), parenthetical=None, abbreviation=None, plural='SubjectAreas', presumed_plural=None, subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='Subject', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[ClassReference(container=..., content='LiterateModel', _type='ClassReference'), ClassReference(container=..., content='Xyz', _type='ClassReference')], dependents=[], is_value_type=False, where=' parentSubject is absent\n', constraints=[], attributes=[], attribute_sections=[])], subjects=[...]), one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='###', name=SubjectName(content='Classes', _type='SubjectName'), parenthetical=None, abbreviation=None, classes=[..., Class(container=..., one_liner=OneLiner(content='a way in which subtypes of a Class may be classified'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='Subtyping', _type='ClassName'), parenthetical='Subtype of Component', abbreviation=None, plural='Subtypings', presumed_plural='Subtypings', subtype_of=[], subtypings=[], subtypes=[], based_on=[ClassReference(container=..., content='Class', _type='ClassReference')], dependents=[], is_value_type=False, where=None, constraints=[], attributes=[Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='name', _type='AttributeName'), parenthetical='LowerCamel', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='LowerCamel', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='isExclusive', _type='AttributeName'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Boolean', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' true\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[]), Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='isExhaustive', _type='AttributeName'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Boolean', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' true\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[]), Attribute(container=..., one_liner=None, elaboration=[Paragraph(content='***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n')], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='every class can have an unnamed subtyping.'), emoji=None, elaboration=[Paragraph(content='ValueType - A class that is presumed to be used a value, rather than a reference\n')])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='classes', _type='AttributeName'), parenthetical='List of Classes', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=ListDataType(container=..., element_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Classes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])], attribute_sections=[]), Class(container=..., one_liner=OneLiner(content='A class that is presumed to be used as a reference, rather than a value'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='ReferenceType', _type='ClassName'), parenthetical=None, abbreviation=None, plural='ReferenceTypes', presumed_plural='ReferenceTypes', subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='Class', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=False, where=None, constraints=[], attributes=[], attribute_sections=[]), ValueType(container=..., one_liner=OneLiner(content='A data type or enumeration used in the model'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='CodeType', _type='ClassName'), parenthetical=None, abbreviation=None, plural='CodeTypes', presumed_plural='CodeTypes', subtype_of=[], subtypings=[], subtypes=[], based_on=[], dependents=[ClassReference(container=None, content='CodeValue', _type='ClassReference')], is_value_type=True, where=None, constraints=[], attributes=[Attribute(container=..., one_liner=OneLiner(content='the code type was implied by use in an attribute and is only used for that attribute'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='isCaptive', _type='AttributeName'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Boolean', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])], attribute_sections=[]), ValueType(container=..., one_liner=OneLiner(content='A possible value for an enumerated data class'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Value Type', name=ClassName(content='CodeValue', _type='ClassName'), parenthetical=None, abbreviation=None, plural='CodeValues', presumed_plural='CodeValues', subtype_of=[], subtypings=[], subtypes=[], based_on=[ClassReference(container=..., content='CodeType', _type='ClassReference')], dependents=[], is_value_type=True, where=None, constraints=[], attributes=[Attribute(container=..., one_liner=OneLiner(content='A short code or abbreviationi for the value _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='code', _type='AttributeName'), parenthetical='NameString', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='NameString', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='an explanation of what the code means'), elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content="Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='description', _type='AttributeName'), parenthetical='*RichText*', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='RichText', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])], attribute_sections=[]), Class(container=..., one_liner=OneLiner(content='a list of attributes of a class'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='Key', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Keys', presumed_plural='Keys', subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='Component', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(container=None, content='UniqueKey', _type='ClassReference')])], subtypes=[], based_on=[ClassReference(container=..., content='Class', _type='ClassReference')], dependents=[], is_value_type=False, where=None, constraints=[], attributes=[Attribute(container=..., one_liner=OneLiner(content='the attributes of the base Class.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='keyAttributes', _type='AttributeName'), parenthetical='List of Attributes', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=ListDataType(container=..., element_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Attributes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[Constraint(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' each attribute must be a direct or inherited of the base class.\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl='', message='', severity=None), Constraint(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' no repetitions allowed in keyAttributes\n> üëç **Issue**: introduce PureLists?'), elaboration=[], annotations=[Annotation(label=Label(content='issue', _type='Label'), content=OneLiner(content='need ascending descending to support index keys or ordering keys.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, ocl='', message='', severity=None)])], attribute_sections=[]), Class(container=..., one_liner=OneLiner(content='a list of attributes on which instances of the base class may be keyed.'), elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='order unimportant for Unique Keys.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='UniqueKey', _type='ClassName'), parenthetical=None, abbreviation=None, plural='UniqueKeys', presumed_plural='UniqueKeys', subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='Key', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[], subtypes=[], based_on=[], dependents=[], is_value_type=False, where=None, constraints=[], attributes=[], attribute_sections=[])], subjects=[]), one_liner=OneLiner(content='A key entity or object type in the model, often corresponding to a real-world concept'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='Class', name=ClassName(content='Class', _type='ClassName'), parenthetical=None, abbreviation=None, plural='Classes', presumed_plural=None, subtype_of=[SubtypeBy(class_name=ClassReference(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), content='Component', _type='ClassReference'), subtyping_name=SubtypingName(content='subtypes', _type='SubtypingName'))], subtypings=[Subtyping(name=SubtypingName(content='subtypes', _type='SubtypingName'), is_exclusive=IsExclusive(content=True, _type='IsExclusive'), is_exhaustive=IsExclusive(content=False, _type='IsExclusive'), subtypes=[ClassReference(container=None, content='ReferenceType', _type='ClassReference')])], subtypes=[], based_on=[], dependents=[ClassReference(container=None, content='Subtyping', _type='ClassReference'), ClassReference(container=None, content='Key', _type='ClassReference'), ClassReference(container=None, content='AttributeSection', _type='ClassReference'), ClassReference(container=None, content='ClassConstraint', _type='ClassReference')], is_value_type=False, where=None, constraints=[...], attributes=[Attribute(container=..., one_liner=OneLiner(content='the normal English plural form of the name of the Class'), elaboration=[Paragraph(content='Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n')], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.'), emoji=None, elaboration=[Paragraph(content='The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n')])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='pluralForm', _type='AttributeName'), parenthetical='UpperCamel', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='UpperCamel', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(container=FieldInfo(annotation=Union[Container, NoneType], required=False, default=None, kw_only=True), one_liner=OneLiner(content=' the regular plural, formed by adding "s" or "es".\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl=''), constraints=[]), Attribute(container=..., one_liner=OneLiner(content='the Class or Classes on which this class is dependent'), elaboration=[Paragraph(content='This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n')], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='that basedOn and dependentOf are being used synonymousle in this metamodel.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='basedOn', _type='AttributeName'), parenthetical='SetOf Class', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=SetDataType(container=..., element_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Class', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='The parent class'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='supertypes', _type='AttributeName'), parenthetical='es', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Es', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='the criteria, or dimensions, by which the class can be divided into subtypes'), elaboration=[], annotations=[Annotation(label=Label(content='example', _type='Label'), content=OneLiner(content='in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='subtypings', _type='AttributeName'), parenthetical='list of Subtypings', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=ListDataType(container=..., element_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Subtypings', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='Any subtypes or specializations of this class based on it‚Äôs subtypings.'), elaboration=[], annotations=[Annotation(label=Label(content='example', _type='Label'), content=OneLiner(content='For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='subtypes', _type='AttributeName'), parenthetical='ListOf Classes', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=ListDataType(container=..., element_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Classes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='The attributes or properties of the class, in the order in which they should be presented _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='attributes', _type='AttributeName'), parenthetical='ListOf Attributes', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=ListDataType(container=..., element_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Attributes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='additional attributes or properties of the class, grouped for clarity and elaboration.  _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='attributeSections', _type='AttributeName'), parenthetical='ListOf AttributeSections', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=ListDataType(container=..., element_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='AttributeSections', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='Any constraints, rules, or validations specific to this class _'), elaboration=[], annotations=[Annotation(label=Label(content='note', _type='Label'), content=OneLiner(content='Constraints may be expressed on either the Class or the Attribute. Always?'), emoji=None, elaboration=[])], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='constraints', _type='AttributeName'), parenthetical='ListOf Constraints', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=ListDataType(container=..., element_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Constraints', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=OneLiner(content='Any behaviors or operations associated with this class _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='methods', _type='AttributeName'), parenthetical='ListOf Methods', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=ListDataType(container=..., element_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Methods', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])], attribute_sections=[AttributeSection(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='__', name=AttributeSectionName(content='Implied Attributes', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[Attribute(container=..., one_liner=OneLiner(content='the Classes which are basedOn this Class'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='dependents', _type='AttributeName'), parenthetical='optional SetOf Classes', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=SetDataType(container=..., element_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='Classes', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=AttributeReference(container=..., class_name=ClassReference(container=..., content='Class', _type='ClassReference'), attribute_name=AttributeName(container=..., content='basedOn', _type='AttributeName')), inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix='-', name=AttributeName(container=..., content='uniqueKeys', _type='AttributeName'), parenthetical='optional Set of UniqueKeys', abbreviation=None, data_type_clause=DataTypeClause(container=..., data_type=SetDataType(container=..., element_type=BaseDataType(container=..., class_name=ClassReference(container=..., content='UniqueKeys', _type='ClassReference'), as_value_type=AsValue(content=True, _type='AsValue'))), is_optional_lit=IsOptional(content=True, _type='IsOptional'), cardinality=<Cardinality.ONE_ONE: 'O_O'>), overrides=None, inverse=AttributeReference(container=..., class_name=ClassReference(container=..., content='UniqueKey', _type='ClassReference'), attribute_name=AttributeName(container=..., content='basedOn', _type='AttributeName')), inverse_of=None, derivation=None, default=None, constraints=[])]), AttributeSection(container=..., one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeSectionName(content='Implied Attributes for Class', _type='AttributeSectionName'), parenthetical=None, abbreviation=None, is_optional=IsOptional(content=False, _type='IsOptional'), attributes=[])]), one_liner=OneLiner(content=' Within each Class, attribute names must be unique.\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, ocl='', message='', severity=None)] to <Class>:Class
Setting container of <Attribute>:inverseOfAllSubjects to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value LiterateDataModel (M_1)] to <Attribute>:inverseOfAllSubjects
Setting container of <BaseDataType>:[value LiterateDataModel] to <DataTypeClause>:[optional value LiterateDataModel (M_1)]
Setting container of <ClassReference>:LiterateDataModel to <BaseDataType>:[value LiterateDataModel]
Setting container of <AttributeName>:inverseOfAllSubjects to <Attribute>:inverseOfAllSubjects
Added implied attribute:  Attribute: inverseOfAllSubjects  in  Class: Class
... Containees of section are:  ['<Attribute>:inverseOfAllSubjects']
... Containees of att are:  ['<DataTypeClause>:[optional value LiterateDataModel (M_1)]', '<AttributeName>:inverseOfAllSubjects']
... Chain from name is:  <AttributeName>:inverseOfAllSubjects -> <Attribute>:inverseOfAllSubjects -> <AttributeSection>:Implied Attributes for Class -> <Class>:Class -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:inverseOfAllSubjects -> <AttributeSection>:Implied Attributes for Class -> <Class>:Class -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Class -> <Class>:Class -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
<Attribute>:inverseOfAllSubjects contains <DataTypeClause>:[optional value LiterateDataModel (M_1)]
	<DataTypeClause>:[optional value LiterateDataModel (M_1)] contains <BaseDataType>:[value LiterateDataModel]
		<BaseDataType>:[value LiterateDataModel] contains <ClassReference>:LiterateDataModel
<Attribute>:inverseOfAllSubjects contains <AttributeName>:inverseOfAllSubjects
in calc attribute, attname is  allClasses
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: LiterateDataModel  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering LiterateDataModel.allClasses for inversion... 
	dtc =  optional List of  Classes (O_O)
	dt  =  List of  Classes  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Classes
	Singular for Classes is Class
	Inverting LiterateDataModel.allClasses, a List of  Classes. core type Class not a value type
	Invrse AttNam =  inverseOfAllClasses
	Inverse dt =  value LiterateDataModel
	Inverse dtc =  optional value LiterateDataModel (M_1)
	Creating inverse attribute:  Attribute(container=None, one_liner=OneLiner(content='Inverse attribute for LiterateDataModel.allClasses from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(container=None, content='inverseOfAllClasses', _type='AttributeName'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(container=None, data_type=BaseDataType(container=None, class_name=ClassReference(container=None, content='LiterateDataModel', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Adding implied attribute:  Attribute: inverseOfAllClasses  in  Class: Class
Found section named:  Implied Attributes for Class
Setting container of <Attribute>:inverseOfAllSubjects to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value LiterateDataModel (M_1)] to <Attribute>:inverseOfAllSubjects
Setting container of <BaseDataType>:[value LiterateDataModel] to <DataTypeClause>:[optional value LiterateDataModel (M_1)]
Setting container of <ClassReference>:LiterateDataModel to <BaseDataType>:[value LiterateDataModel]
Setting container of <AttributeName>:inverseOfAllSubjects to <Attribute>:inverseOfAllSubjects
Setting container of <AttributeReference>:[LiterateDataModel.allSubjects] to <Attribute>:inverseOfAllSubjects
Setting container of <ClassReference>:LiterateDataModel to <AttributeReference>:[LiterateDataModel.allSubjects]
Setting container of <AttributeName>:allSubjects to <AttributeReference>:[LiterateDataModel.allSubjects]
Setting container of <Attribute>:inverseOfAllClasses to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value LiterateDataModel (M_1)] to <Attribute>:inverseOfAllClasses
Setting container of <BaseDataType>:[value LiterateDataModel] to <DataTypeClause>:[optional value LiterateDataModel (M_1)]
Setting container of <ClassReference>:LiterateDataModel to <BaseDataType>:[value LiterateDataModel]
Setting container of <AttributeName>:inverseOfAllClasses to <Attribute>:inverseOfAllClasses
Added implied attribute:  Attribute: inverseOfAllClasses  in  Class: Class
... Containees of section are:  ['<Attribute>:inverseOfAllSubjects', '<Attribute>:inverseOfAllClasses']
... Containees of att are:  ['<DataTypeClause>:[optional value LiterateDataModel (M_1)]', '<AttributeName>:inverseOfAllClasses']
... Chain from name is:  <AttributeName>:inverseOfAllClasses -> <Attribute>:inverseOfAllClasses -> <AttributeSection>:Implied Attributes for Class -> <Class>:Class -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:inverseOfAllClasses -> <AttributeSection>:Implied Attributes for Class -> <Class>:Class -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Class -> <Class>:Class -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
<Attribute>:inverseOfAllClasses contains <DataTypeClause>:[optional value LiterateDataModel (M_1)]
	<DataTypeClause>:[optional value LiterateDataModel (M_1)] contains <BaseDataType>:[value LiterateDataModel]
		<BaseDataType>:[value LiterateDataModel] contains <ClassReference>:LiterateDataModel
<Attribute>:inverseOfAllClasses contains <AttributeName>:inverseOfAllClasses
validating datatype:   UpperCamel
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:  List of  Classes
type of datatype is  <class 'Literate_01.ListDataType'>
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Derivation'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Constraint'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Constraint'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
validating datatype:  List of  Classes
type of datatype is  <class 'Literate_01.ListDataType'>
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Derivation'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Constraint'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Constraint'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
validating datatype:  List of  AnnotationTypes
type of datatype is  <class 'Literate_01.ListDataType'>
validating datatype:   CodingLanguage
type of datatype is  <class 'Literate_01.BaseDataType'>
	!!! Base type error for  CodingLanguage  in dt   CodingLanguage
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Default'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
validating datatype:  List of  CodingLanguages
type of datatype is  <class 'Literate_01.ListDataType'>
	!!! Base type error for  CodingLanguages  in dt  List of  CodingLanguages
validating datatype:   TemplateLanguage
type of datatype is  <class 'Literate_01.BaseDataType'>
	!!! Base type error for  TemplateLanguage  in dt   TemplateLanguage
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Default'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
validating datatype:  List of  TemplateLanguages
type of datatype is  <class 'Literate_01.ListDataType'>
	!!! Base type error for  TemplateLanguages  in dt  List of  TemplateLanguages
validating datatype:  List of  String
type of datatype is  <class 'Literate_01.ListDataType'>
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Derivation'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
Adding implied attribute:  Attribute: baseLiterateDataModel  in  Class: Subject
In AttSection post-init for Implied Attributes for Subject, is_optional = None
Creating section for Class: Subject: Attributesection: Implied Attributes for Subject
Setting container of <AttributeSection>:Implied Attributes for Subject to <Class>:Subject
Setting container of <Attribute>:name to <Class>:Subject
Setting container of <DataTypeClause>:[optional  UpperCamel (O_O)] to <Attribute>:name
Setting container of <BaseDataType>:[ UpperCamel] to <DataTypeClause>:[optional  UpperCamel (O_O)]
Setting container of <ClassReference>:UpperCamel to <BaseDataType>:[ UpperCamel]
Setting container of <AttributeName>:name to <Attribute>:name
Setting container of <Attribute>:parentSubject to <Class>:Subject
Setting container of <DataTypeClause>:[optional  Subject (O_O)] to <Attribute>:parentSubject
Setting container of <BaseDataType>:[ Subject] to <DataTypeClause>:[optional  Subject (O_O)]
Setting container of <ClassReference>:Subject to <BaseDataType>:[ Subject]
Setting container of <AttributeName>:parentSubject to <Attribute>:parentSubject
Setting container of <Attribute>:classes to <Class>:Subject
Setting container of <DataTypeClause>:[optional List of  Classes (O_O)] to <Attribute>:classes
Setting container of <ListDataType>:[List of  Classes] to <DataTypeClause>:[optional List of  Classes (O_O)]
Setting container of <BaseDataType>:[ Classes] to <ListDataType>:[List of  Classes]
Setting container of <ClassReference>:Classes to <BaseDataType>:[ Classes]
Setting container of <AttributeName>:classes to <Attribute>:classes
Setting container of <Attribute>:childSubjects to <Class>:Subject
Setting container of <DataTypeClause>:[optional List of  Subjects (O_O)] to <Attribute>:childSubjects
Setting container of <ListDataType>:[List of  Subjects] to <DataTypeClause>:[optional List of  Subjects (O_O)]
Setting container of <BaseDataType>:[ Subjects] to <ListDataType>:[List of  Subjects]
Setting container of <ClassReference>:Subjects to <BaseDataType>:[ Subjects]
Setting container of <AttributeName>:childSubjects to <Attribute>:childSubjects
Setting container of <AttributeReference>:[Subject.parentSubject] to <Attribute>:childSubjects
Setting container of <ClassReference>:Subject to <AttributeReference>:[Subject.parentSubject]
Setting container of <AttributeName>:parentSubject to <AttributeReference>:[Subject.parentSubject]
Setting container of <ClassReference>:LiterateDataModel to <Class>:Subject
Setting container of <Attribute>:baseLiterateDataModel to <AttributeSection>:Implied Attributes for Subject
Setting container of <DataTypeClause>:[optional value LiterateDataModel (M_1)] to <Attribute>:baseLiterateDataModel
Setting container of <BaseDataType>:[value LiterateDataModel] to <DataTypeClause>:[optional value LiterateDataModel (M_1)]
Setting container of <ClassReference>:LiterateDataModel to <BaseDataType>:[value LiterateDataModel]
Setting container of <AttributeName>:baseLiterateDataModel to <Attribute>:baseLiterateDataModel
Added implied attribute:  Attribute: baseLiterateDataModel  in  Class: Subject
... Containees of section are:  ['<Attribute>:baseLiterateDataModel']
... Containees of att are:  ['<DataTypeClause>:[optional value LiterateDataModel (M_1)]', '<AttributeName>:baseLiterateDataModel']
... Chain from name is:  <AttributeName>:baseLiterateDataModel -> <Attribute>:baseLiterateDataModel -> <AttributeSection>:Implied Attributes for Subject -> <Class>:Subject -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:baseLiterateDataModel -> <AttributeSection>:Implied Attributes for Subject -> <Class>:Subject -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Subject -> <Class>:Subject -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
<Attribute>:baseLiterateDataModel contains <DataTypeClause>:[optional value LiterateDataModel (M_1)]
	<DataTypeClause>:[optional value LiterateDataModel (M_1)] contains <BaseDataType>:[value LiterateDataModel]
		<BaseDataType>:[value LiterateDataModel] contains <ClassReference>:LiterateDataModel
<Attribute>:baseLiterateDataModel contains <AttributeName>:baseLiterateDataModel
in calc attribute, attname is  name
the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
MRO for Subject =>  ['Component']
calc attribute override; mro for  Class: Subject  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Found override for Subject.name in Component
Attribute name =  name
.. and as AName:  AttributeName(container=None, content='name', _type='AttributeName')
Considering Subject.name for inversion... 
	dtc =  optional  UpperCamel (O_O)
	dt  =   UpperCamel  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = UpperCamel
	Singular for UpperCamel is UpperCamel
	SKIPPING Subject.name, a  UpperCamel. core type UpperCamel is a value type
in calc attribute, attname is  parentSubject
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Subject  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering Subject.parentSubject for inversion... 
	dtc =  optional  Subject (O_O)
	dt  =   Subject  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Subject
	Singular for Subject is Subject
	Inverting Subject.parentSubject, a  Subject. core type Subject not a value type
	Invrse AttNam =  inverseOfParentSubject
	Inverse dt =  value Subject
	Inverse dtc =  optional value Subject (M_1)
	Creating inverse attribute:  Attribute(container=None, one_liner=OneLiner(content='Inverse attribute for Subject.parentSubject from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(container=None, content='inverseOfParentSubject', _type='AttributeName'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(container=None, data_type=BaseDataType(container=None, class_name=ClassReference(container=None, content='Subject', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Adding implied attribute:  Attribute: inverseOfParentSubject  in  Class: Subject
Found section named:  Implied Attributes for Subject
Setting container of <Attribute>:baseLiterateDataModel to <AttributeSection>:Implied Attributes for Subject
Setting container of <DataTypeClause>:[optional value LiterateDataModel (M_1)] to <Attribute>:baseLiterateDataModel
Setting container of <BaseDataType>:[value LiterateDataModel] to <DataTypeClause>:[optional value LiterateDataModel (M_1)]
Setting container of <ClassReference>:LiterateDataModel to <BaseDataType>:[value LiterateDataModel]
Setting container of <AttributeName>:baseLiterateDataModel to <Attribute>:baseLiterateDataModel
Setting container of <Attribute>:inverseOfParentSubject to <AttributeSection>:Implied Attributes for Subject
Setting container of <DataTypeClause>:[optional value Subject (M_1)] to <Attribute>:inverseOfParentSubject
Setting container of <BaseDataType>:[value Subject] to <DataTypeClause>:[optional value Subject (M_1)]
Setting container of <ClassReference>:Subject to <BaseDataType>:[value Subject]
Setting container of <AttributeName>:inverseOfParentSubject to <Attribute>:inverseOfParentSubject
Added implied attribute:  Attribute: inverseOfParentSubject  in  Class: Subject
... Containees of section are:  ['<Attribute>:baseLiterateDataModel', '<Attribute>:inverseOfParentSubject']
... Containees of att are:  ['<DataTypeClause>:[optional value Subject (M_1)]', '<AttributeName>:inverseOfParentSubject']
... Chain from name is:  <AttributeName>:inverseOfParentSubject -> <Attribute>:inverseOfParentSubject -> <AttributeSection>:Implied Attributes for Subject -> <Class>:Subject -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:inverseOfParentSubject -> <AttributeSection>:Implied Attributes for Subject -> <Class>:Subject -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Subject -> <Class>:Subject -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
<Attribute>:inverseOfParentSubject contains <DataTypeClause>:[optional value Subject (M_1)]
	<DataTypeClause>:[optional value Subject (M_1)] contains <BaseDataType>:[value Subject]
		<BaseDataType>:[value Subject] contains <ClassReference>:Subject
<Attribute>:inverseOfParentSubject contains <AttributeName>:inverseOfParentSubject
in calc attribute, attname is  classes
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Subject  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering Subject.classes for inversion... 
	dtc =  optional List of  Classes (O_O)
	dt  =  List of  Classes  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Classes
	Singular for Classes is Class
	Inverting Subject.classes, a List of  Classes. core type Class not a value type
	Invrse AttNam =  inverseOfClasses
	Inverse dt =  value Subject
	Inverse dtc =  optional value Subject (M_1)
	Creating inverse attribute:  Attribute(container=None, one_liner=OneLiner(content='Inverse attribute for Subject.classes from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(container=None, content='inverseOfClasses', _type='AttributeName'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(container=None, data_type=BaseDataType(container=None, class_name=ClassReference(container=None, content='Subject', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Adding implied attribute:  Attribute: inverseOfClasses  in  Class: Class
Found section named:  Implied Attributes for Class
Setting container of <Attribute>:inverseOfAllSubjects to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value LiterateDataModel (M_1)] to <Attribute>:inverseOfAllSubjects
Setting container of <BaseDataType>:[value LiterateDataModel] to <DataTypeClause>:[optional value LiterateDataModel (M_1)]
Setting container of <ClassReference>:LiterateDataModel to <BaseDataType>:[value LiterateDataModel]
Setting container of <AttributeName>:inverseOfAllSubjects to <Attribute>:inverseOfAllSubjects
Setting container of <AttributeReference>:[LiterateDataModel.allSubjects] to <Attribute>:inverseOfAllSubjects
Setting container of <ClassReference>:LiterateDataModel to <AttributeReference>:[LiterateDataModel.allSubjects]
Setting container of <AttributeName>:allSubjects to <AttributeReference>:[LiterateDataModel.allSubjects]
Setting container of <Attribute>:inverseOfAllClasses to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value LiterateDataModel (M_1)] to <Attribute>:inverseOfAllClasses
Setting container of <BaseDataType>:[value LiterateDataModel] to <DataTypeClause>:[optional value LiterateDataModel (M_1)]
Setting container of <ClassReference>:LiterateDataModel to <BaseDataType>:[value LiterateDataModel]
Setting container of <AttributeName>:inverseOfAllClasses to <Attribute>:inverseOfAllClasses
Setting container of <AttributeReference>:[LiterateDataModel.allClasses] to <Attribute>:inverseOfAllClasses
Setting container of <ClassReference>:LiterateDataModel to <AttributeReference>:[LiterateDataModel.allClasses]
Setting container of <AttributeName>:allClasses to <AttributeReference>:[LiterateDataModel.allClasses]
Setting container of <Attribute>:inverseOfClasses to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value Subject (M_1)] to <Attribute>:inverseOfClasses
Setting container of <BaseDataType>:[value Subject] to <DataTypeClause>:[optional value Subject (M_1)]
Setting container of <ClassReference>:Subject to <BaseDataType>:[value Subject]
Setting container of <AttributeName>:inverseOfClasses to <Attribute>:inverseOfClasses
Added implied attribute:  Attribute: inverseOfClasses  in  Class: Class
... Containees of section are:  ['<Attribute>:inverseOfAllSubjects', '<Attribute>:inverseOfAllClasses', '<Attribute>:inverseOfClasses']
... Containees of att are:  ['<DataTypeClause>:[optional value Subject (M_1)]', '<AttributeName>:inverseOfClasses']
... Chain from name is:  <AttributeName>:inverseOfClasses -> <Attribute>:inverseOfClasses -> <AttributeSection>:Implied Attributes for Class -> <Class>:Class -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:inverseOfClasses -> <AttributeSection>:Implied Attributes for Class -> <Class>:Class -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Class -> <Class>:Class -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
<Attribute>:inverseOfClasses contains <DataTypeClause>:[optional value Subject (M_1)]
	<DataTypeClause>:[optional value Subject (M_1)] contains <BaseDataType>:[value Subject]
		<BaseDataType>:[value Subject] contains <ClassReference>:Subject
<Attribute>:inverseOfClasses contains <AttributeName>:inverseOfClasses
in calc attribute, attname is  childSubjects
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Subject  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering Subject.childSubjects for inversion... 
	Skipping: already has inverse
	dtc =  optional List of  Subjects (O_O)
	dt  =  List of  Subjects  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Subjects
	Singular for Subjects is Subject
	Inverting Subject.childSubjects, a List of  Subjects. core type Subject not a value type
	Invrse AttNam =  inverseOfChildSubjects
	Inverse dt =  value Subject
	Inverse dtc =  optional value Subject (M_1)
	Creating inverse attribute:  Attribute(container=None, one_liner=OneLiner(content='Inverse attribute for Subject.childSubjects from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(container=None, content='inverseOfChildSubjects', _type='AttributeName'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(container=None, data_type=BaseDataType(container=None, class_name=ClassReference(container=None, content='Subject', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Adding implied attribute:  Attribute: inverseOfChildSubjects  in  Class: Subject
Found section named:  Implied Attributes for Subject
Setting container of <Attribute>:baseLiterateDataModel to <AttributeSection>:Implied Attributes for Subject
Setting container of <DataTypeClause>:[optional value LiterateDataModel (M_1)] to <Attribute>:baseLiterateDataModel
Setting container of <BaseDataType>:[value LiterateDataModel] to <DataTypeClause>:[optional value LiterateDataModel (M_1)]
Setting container of <ClassReference>:LiterateDataModel to <BaseDataType>:[value LiterateDataModel]
Setting container of <AttributeName>:baseLiterateDataModel to <Attribute>:baseLiterateDataModel
Setting container of <Attribute>:inverseOfParentSubject to <AttributeSection>:Implied Attributes for Subject
Setting container of <DataTypeClause>:[optional value Subject (M_1)] to <Attribute>:inverseOfParentSubject
Setting container of <BaseDataType>:[value Subject] to <DataTypeClause>:[optional value Subject (M_1)]
Setting container of <ClassReference>:Subject to <BaseDataType>:[value Subject]
Setting container of <AttributeName>:inverseOfParentSubject to <Attribute>:inverseOfParentSubject
Setting container of <AttributeReference>:[Subject.parentSubject] to <Attribute>:inverseOfParentSubject
Setting container of <ClassReference>:Subject to <AttributeReference>:[Subject.parentSubject]
Setting container of <AttributeName>:parentSubject to <AttributeReference>:[Subject.parentSubject]
Setting container of <Attribute>:inverseOfChildSubjects to <AttributeSection>:Implied Attributes for Subject
Setting container of <DataTypeClause>:[optional value Subject (M_1)] to <Attribute>:inverseOfChildSubjects
Setting container of <BaseDataType>:[value Subject] to <DataTypeClause>:[optional value Subject (M_1)]
Setting container of <ClassReference>:Subject to <BaseDataType>:[value Subject]
Setting container of <AttributeName>:inverseOfChildSubjects to <Attribute>:inverseOfChildSubjects
Added implied attribute:  Attribute: inverseOfChildSubjects  in  Class: Subject
... Containees of section are:  ['<Attribute>:baseLiterateDataModel', '<Attribute>:inverseOfParentSubject', '<Attribute>:inverseOfChildSubjects']
... Containees of att are:  ['<DataTypeClause>:[optional value Subject (M_1)]', '<AttributeName>:inverseOfChildSubjects']
... Chain from name is:  <AttributeName>:inverseOfChildSubjects -> <Attribute>:inverseOfChildSubjects -> <AttributeSection>:Implied Attributes for Subject -> <Class>:Subject -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:inverseOfChildSubjects -> <AttributeSection>:Implied Attributes for Subject -> <Class>:Subject -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Subject -> <Class>:Subject -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
<Attribute>:inverseOfChildSubjects contains <DataTypeClause>:[optional value Subject (M_1)]
	<DataTypeClause>:[optional value Subject (M_1)] contains <BaseDataType>:[value Subject]
		<BaseDataType>:[value Subject] contains <ClassReference>:Subject
<Attribute>:inverseOfChildSubjects contains <AttributeName>:inverseOfChildSubjects
validating datatype:   UpperCamel
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:   Subject
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:  List of  Classes
type of datatype is  <class 'Literate_01.ListDataType'>
validating datatype:  List of  Subjects
type of datatype is  <class 'Literate_01.ListDataType'>
validating datatype:  value LiterateDataModel
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
validating datatype:  value Subject
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
validating datatype:  value Subject
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
Adding implied attribute:  Attribute: baseLiterateModel  in  Class: SubjectArea
In AttSection post-init for Implied Attributes for Subject Area, is_optional = None
Creating section for Class: SubjectArea: Attributesection: Implied Attributes for Subject Area
Setting container of <AttributeSection>:Implied Attributes for Subject Area to <Class>:SubjectArea
Setting container of <ClassReference>:LiterateModel to <Class>:SubjectArea
Setting container of <ClassReference>:Xyz to <Class>:SubjectArea
Setting container of <Attribute>:baseLiterateModel to <AttributeSection>:Implied Attributes for Subject Area
Setting container of <DataTypeClause>:[optional value LiterateModel (M_1)] to <Attribute>:baseLiterateModel
Setting container of <BaseDataType>:[value LiterateModel] to <DataTypeClause>:[optional value LiterateModel (M_1)]
Setting container of <ClassReference>:LiterateModel to <BaseDataType>:[value LiterateModel]
Setting container of <AttributeName>:baseLiterateModel to <Attribute>:baseLiterateModel
Added implied attribute:  Attribute: baseLiterateModel  in  Class: SubjectArea
... Containees of section are:  ['<Attribute>:baseLiterateModel']
... Containees of att are:  ['<DataTypeClause>:[optional value LiterateModel (M_1)]', '<AttributeName>:baseLiterateModel']
... Chain from name is:  <AttributeName>:baseLiterateModel -> <Attribute>:baseLiterateModel -> <AttributeSection>:Implied Attributes for Subject Area -> <Class>:SubjectArea -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:baseLiterateModel -> <AttributeSection>:Implied Attributes for Subject Area -> <Class>:SubjectArea -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Subject Area -> <Class>:SubjectArea -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
<Attribute>:baseLiterateModel contains <DataTypeClause>:[optional value LiterateModel (M_1)]
	<DataTypeClause>:[optional value LiterateModel (M_1)] contains <BaseDataType>:[value LiterateModel]
		<BaseDataType>:[value LiterateModel] contains <ClassReference>:LiterateModel
<Attribute>:baseLiterateModel contains <AttributeName>:baseLiterateModel
Adding implied attribute:  Attribute: baseXyz  in  Class: SubjectArea
In AttSection post-init for Implied Attributes for Subject Area, is_optional = None
Creating section for Class: SubjectArea: Attributesection: Implied Attributes for Subject Area
Setting container of <AttributeSection>:Implied Attributes for Subject Area to <Class>:SubjectArea
Setting container of <Attribute>:baseLiterateModel to <AttributeSection>:Implied Attributes for Subject Area
Setting container of <DataTypeClause>:[optional value LiterateModel (M_1)] to <Attribute>:baseLiterateModel
Setting container of <BaseDataType>:[value LiterateModel] to <DataTypeClause>:[optional value LiterateModel (M_1)]
Setting container of <ClassReference>:LiterateModel to <BaseDataType>:[value LiterateModel]
Setting container of <AttributeName>:baseLiterateModel to <Attribute>:baseLiterateModel
Setting container of <AttributeSection>:Implied Attributes for Subject Area to <Class>:SubjectArea
Setting container of <ClassReference>:LiterateModel to <Class>:SubjectArea
Setting container of <ClassReference>:Xyz to <Class>:SubjectArea
Setting container of <Attribute>:baseXyz to <AttributeSection>:Implied Attributes for Subject Area
Setting container of <DataTypeClause>:[optional value Xyz (M_1)] to <Attribute>:baseXyz
Setting container of <BaseDataType>:[value Xyz] to <DataTypeClause>:[optional value Xyz (M_1)]
Setting container of <ClassReference>:Xyz to <BaseDataType>:[value Xyz]
Setting container of <AttributeName>:baseXyz to <Attribute>:baseXyz
Added implied attribute:  Attribute: baseXyz  in  Class: SubjectArea
... Containees of section are:  ['<Attribute>:baseXyz']
... Containees of att are:  ['<DataTypeClause>:[optional value Xyz (M_1)]', '<AttributeName>:baseXyz']
... Chain from name is:  <AttributeName>:baseXyz -> <Attribute>:baseXyz -> <AttributeSection>:Implied Attributes for Subject Area -> <Class>:SubjectArea -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:baseXyz -> <AttributeSection>:Implied Attributes for Subject Area -> <Class>:SubjectArea -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Subject Area -> <Class>:SubjectArea -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
<Attribute>:baseXyz contains <DataTypeClause>:[optional value Xyz (M_1)]
	<DataTypeClause>:[optional value Xyz (M_1)] contains <BaseDataType>:[value Xyz]
		<BaseDataType>:[value Xyz] contains <ClassReference>:Xyz
<Attribute>:baseXyz contains <AttributeName>:baseXyz
validating datatype:  value LiterateModel
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
	!!! Base type error for  LiterateModel  in dt  value LiterateModel
validating datatype:  value Xyz
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
	!!! Base type error for  Xyz  in dt  value Xyz
in calc attribute, attname is  pluralForm
the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
MRO for Class =>  ['Component']
calc attribute override; mro for  Class: Class  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering Class.pluralForm for inversion... 
	dtc =  optional  UpperCamel (O_O)
	dt  =   UpperCamel  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = UpperCamel
	Singular for UpperCamel is UpperCamel
	SKIPPING Class.pluralForm, a  UpperCamel. core type UpperCamel is a value type
in calc attribute, attname is  basedOn
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Class  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering Class.basedOn for inversion... 
	dtc =  optional Set of  Class (O_O)
	dt  =  Set of  Class  --  <class 'Literate_01.SetDataType'>
	typename of dt is: SetDataType
	Target type0 = Class
	Singular for Class is Class
	Inverting Class.basedOn, a Set of  Class. core type Class not a value type
	Invrse AttNam =  inverseOfBasedOn
	Inverse dt =  value Class
	Inverse dtc =  optional value Class (M_1)
	Creating inverse attribute:  Attribute(container=None, one_liner=OneLiner(content='Inverse attribute for Class.basedOn from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(container=None, content='inverseOfBasedOn', _type='AttributeName'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(container=None, data_type=BaseDataType(container=None, class_name=ClassReference(container=None, content='Class', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Adding implied attribute:  Attribute: inverseOfBasedOn  in  Class: Class
Found section named:  Implied Attributes for Class
Setting container of <Attribute>:inverseOfAllSubjects to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value LiterateDataModel (M_1)] to <Attribute>:inverseOfAllSubjects
Setting container of <BaseDataType>:[value LiterateDataModel] to <DataTypeClause>:[optional value LiterateDataModel (M_1)]
Setting container of <ClassReference>:LiterateDataModel to <BaseDataType>:[value LiterateDataModel]
Setting container of <AttributeName>:inverseOfAllSubjects to <Attribute>:inverseOfAllSubjects
Setting container of <AttributeReference>:[LiterateDataModel.allSubjects] to <Attribute>:inverseOfAllSubjects
Setting container of <ClassReference>:LiterateDataModel to <AttributeReference>:[LiterateDataModel.allSubjects]
Setting container of <AttributeName>:allSubjects to <AttributeReference>:[LiterateDataModel.allSubjects]
Setting container of <Attribute>:inverseOfAllClasses to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value LiterateDataModel (M_1)] to <Attribute>:inverseOfAllClasses
Setting container of <BaseDataType>:[value LiterateDataModel] to <DataTypeClause>:[optional value LiterateDataModel (M_1)]
Setting container of <ClassReference>:LiterateDataModel to <BaseDataType>:[value LiterateDataModel]
Setting container of <AttributeName>:inverseOfAllClasses to <Attribute>:inverseOfAllClasses
Setting container of <AttributeReference>:[LiterateDataModel.allClasses] to <Attribute>:inverseOfAllClasses
Setting container of <ClassReference>:LiterateDataModel to <AttributeReference>:[LiterateDataModel.allClasses]
Setting container of <AttributeName>:allClasses to <AttributeReference>:[LiterateDataModel.allClasses]
Setting container of <Attribute>:inverseOfClasses to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value Subject (M_1)] to <Attribute>:inverseOfClasses
Setting container of <BaseDataType>:[value Subject] to <DataTypeClause>:[optional value Subject (M_1)]
Setting container of <ClassReference>:Subject to <BaseDataType>:[value Subject]
Setting container of <AttributeName>:inverseOfClasses to <Attribute>:inverseOfClasses
Setting container of <AttributeReference>:[Subject.classes] to <Attribute>:inverseOfClasses
Setting container of <ClassReference>:Subject to <AttributeReference>:[Subject.classes]
Setting container of <AttributeName>:classes to <AttributeReference>:[Subject.classes]
Setting container of <Attribute>:inverseOfBasedOn to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value Class (M_1)] to <Attribute>:inverseOfBasedOn
Setting container of <BaseDataType>:[value Class] to <DataTypeClause>:[optional value Class (M_1)]
Setting container of <ClassReference>:Class to <BaseDataType>:[value Class]
Setting container of <AttributeName>:inverseOfBasedOn to <Attribute>:inverseOfBasedOn
Added implied attribute:  Attribute: inverseOfBasedOn  in  Class: Class
... Containees of section are:  ['<Attribute>:inverseOfAllSubjects', '<Attribute>:inverseOfAllClasses', '<Attribute>:inverseOfClasses', '<Attribute>:inverseOfBasedOn']
... Containees of att are:  ['<DataTypeClause>:[optional value Class (M_1)]', '<AttributeName>:inverseOfBasedOn']
... Chain from name is:  <AttributeName>:inverseOfBasedOn -> <Attribute>:inverseOfBasedOn -> <AttributeSection>:Implied Attributes for Class -> <Class>:Class -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:inverseOfBasedOn -> <AttributeSection>:Implied Attributes for Class -> <Class>:Class -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Class -> <Class>:Class -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
<Attribute>:inverseOfBasedOn contains <DataTypeClause>:[optional value Class (M_1)]
	<DataTypeClause>:[optional value Class (M_1)] contains <BaseDataType>:[value Class]
		<BaseDataType>:[value Class] contains <ClassReference>:Class
<Attribute>:inverseOfBasedOn contains <AttributeName>:inverseOfBasedOn
in calc attribute, attname is  supertypes
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Class  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering Class.supertypes for inversion... 
	dtc =  optional  Es (O_O)
	dt  =   Es  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Es
	SKIPPING inverse for..  No such class as  Es
in calc attribute, attname is  subtypings
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Class  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering Class.subtypings for inversion... 
	dtc =  optional List of  Subtypings (O_O)
	dt  =  List of  Subtypings  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Subtypings
	Singular for Subtypings is Subtyping
	Inverting Class.subtypings, a List of  Subtypings. core type Subtyping not a value type
	Invrse AttNam =  inverseOfSubtypings
	Inverse dt =  value Class
	Inverse dtc =  optional value Class (M_1)
	Creating inverse attribute:  Attribute(container=None, one_liner=OneLiner(content='Inverse attribute for Class.subtypings from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(container=None, content='inverseOfSubtypings', _type='AttributeName'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(container=None, data_type=BaseDataType(container=None, class_name=ClassReference(container=None, content='Class', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Adding implied attribute:  Attribute: inverseOfSubtypings  in  Class: Subtyping
In AttSection post-init for Implied Attributes for Subtyping, is_optional = None
Creating section for Class: Subtyping: Attributesection: Implied Attributes for Subtyping
Setting container of <AttributeSection>:Implied Attributes for Subtyping to <Class>:Subtyping
Setting container of <Attribute>:name to <Class>:Subtyping
Setting container of <DataTypeClause>:[optional  LowerCamel (O_O)] to <Attribute>:name
Setting container of <BaseDataType>:[ LowerCamel] to <DataTypeClause>:[optional  LowerCamel (O_O)]
Setting container of <ClassReference>:LowerCamel to <BaseDataType>:[ LowerCamel]
Setting container of <AttributeName>:name to <Attribute>:name
Setting container of <Attribute>:isExclusive to <Class>:Subtyping
Setting container of <DataTypeClause>:[optional  Boolean (O_O)] to <Attribute>:isExclusive
Setting container of <BaseDataType>:[ Boolean] to <DataTypeClause>:[optional  Boolean (O_O)]
Setting container of <ClassReference>:Boolean to <BaseDataType>:[ Boolean]
Setting container of <AttributeName>:isExclusive to <Attribute>:isExclusive
Setting container of <Attribute>:isExhaustive to <Class>:Subtyping
Setting container of <DataTypeClause>:[optional  Boolean (O_O)] to <Attribute>:isExhaustive
Setting container of <BaseDataType>:[ Boolean] to <DataTypeClause>:[optional  Boolean (O_O)]
Setting container of <ClassReference>:Boolean to <BaseDataType>:[ Boolean]
Setting container of <AttributeName>:isExhaustive to <Attribute>:isExhaustive
Setting container of <Attribute>:classes to <Class>:Subtyping
Setting container of <DataTypeClause>:[optional List of  Classes (O_O)] to <Attribute>:classes
Setting container of <ListDataType>:[List of  Classes] to <DataTypeClause>:[optional List of  Classes (O_O)]
Setting container of <BaseDataType>:[ Classes] to <ListDataType>:[List of  Classes]
Setting container of <ClassReference>:Classes to <BaseDataType>:[ Classes]
Setting container of <AttributeName>:classes to <Attribute>:classes
Setting container of <ClassReference>:Class to <Class>:Subtyping
Setting container of <Attribute>:inverseOfSubtypings to <AttributeSection>:Implied Attributes for Subtyping
Setting container of <DataTypeClause>:[optional value Class (M_1)] to <Attribute>:inverseOfSubtypings
Setting container of <BaseDataType>:[value Class] to <DataTypeClause>:[optional value Class (M_1)]
Setting container of <ClassReference>:Class to <BaseDataType>:[value Class]
Setting container of <AttributeName>:inverseOfSubtypings to <Attribute>:inverseOfSubtypings
Added implied attribute:  Attribute: inverseOfSubtypings  in  Class: Subtyping
... Containees of section are:  ['<Attribute>:inverseOfSubtypings']
... Containees of att are:  ['<DataTypeClause>:[optional value Class (M_1)]', '<AttributeName>:inverseOfSubtypings']
... Chain from name is:  <AttributeName>:inverseOfSubtypings -> <Attribute>:inverseOfSubtypings -> <AttributeSection>:Implied Attributes for Subtyping -> <Class>:Subtyping -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:inverseOfSubtypings -> <AttributeSection>:Implied Attributes for Subtyping -> <Class>:Subtyping -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Subtyping -> <Class>:Subtyping -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
<Attribute>:inverseOfSubtypings contains <DataTypeClause>:[optional value Class (M_1)]
	<DataTypeClause>:[optional value Class (M_1)] contains <BaseDataType>:[value Class]
		<BaseDataType>:[value Class] contains <ClassReference>:Class
<Attribute>:inverseOfSubtypings contains <AttributeName>:inverseOfSubtypings
in calc attribute, attname is  subtypes
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Class  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering Class.subtypes for inversion... 
	dtc =  optional List of  Classes (O_O)
	dt  =  List of  Classes  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Classes
	Singular for Classes is Class
	Inverting Class.subtypes, a List of  Classes. core type Class not a value type
	Invrse AttNam =  inverseOfSubtypes
	Inverse dt =  value Class
	Inverse dtc =  optional value Class (M_1)
	Creating inverse attribute:  Attribute(container=None, one_liner=OneLiner(content='Inverse attribute for Class.subtypes from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(container=None, content='inverseOfSubtypes', _type='AttributeName'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(container=None, data_type=BaseDataType(container=None, class_name=ClassReference(container=None, content='Class', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Adding implied attribute:  Attribute: inverseOfSubtypes  in  Class: Class
Found section named:  Implied Attributes for Class
Setting container of <Attribute>:inverseOfAllSubjects to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value LiterateDataModel (M_1)] to <Attribute>:inverseOfAllSubjects
Setting container of <BaseDataType>:[value LiterateDataModel] to <DataTypeClause>:[optional value LiterateDataModel (M_1)]
Setting container of <ClassReference>:LiterateDataModel to <BaseDataType>:[value LiterateDataModel]
Setting container of <AttributeName>:inverseOfAllSubjects to <Attribute>:inverseOfAllSubjects
Setting container of <AttributeReference>:[LiterateDataModel.allSubjects] to <Attribute>:inverseOfAllSubjects
Setting container of <ClassReference>:LiterateDataModel to <AttributeReference>:[LiterateDataModel.allSubjects]
Setting container of <AttributeName>:allSubjects to <AttributeReference>:[LiterateDataModel.allSubjects]
Setting container of <Attribute>:inverseOfAllClasses to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value LiterateDataModel (M_1)] to <Attribute>:inverseOfAllClasses
Setting container of <BaseDataType>:[value LiterateDataModel] to <DataTypeClause>:[optional value LiterateDataModel (M_1)]
Setting container of <ClassReference>:LiterateDataModel to <BaseDataType>:[value LiterateDataModel]
Setting container of <AttributeName>:inverseOfAllClasses to <Attribute>:inverseOfAllClasses
Setting container of <AttributeReference>:[LiterateDataModel.allClasses] to <Attribute>:inverseOfAllClasses
Setting container of <ClassReference>:LiterateDataModel to <AttributeReference>:[LiterateDataModel.allClasses]
Setting container of <AttributeName>:allClasses to <AttributeReference>:[LiterateDataModel.allClasses]
Setting container of <Attribute>:inverseOfClasses to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value Subject (M_1)] to <Attribute>:inverseOfClasses
Setting container of <BaseDataType>:[value Subject] to <DataTypeClause>:[optional value Subject (M_1)]
Setting container of <ClassReference>:Subject to <BaseDataType>:[value Subject]
Setting container of <AttributeName>:inverseOfClasses to <Attribute>:inverseOfClasses
Setting container of <AttributeReference>:[Subject.classes] to <Attribute>:inverseOfClasses
Setting container of <ClassReference>:Subject to <AttributeReference>:[Subject.classes]
Setting container of <AttributeName>:classes to <AttributeReference>:[Subject.classes]
Setting container of <Attribute>:inverseOfBasedOn to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value Class (M_1)] to <Attribute>:inverseOfBasedOn
Setting container of <BaseDataType>:[value Class] to <DataTypeClause>:[optional value Class (M_1)]
Setting container of <ClassReference>:Class to <BaseDataType>:[value Class]
Setting container of <AttributeName>:inverseOfBasedOn to <Attribute>:inverseOfBasedOn
Setting container of <AttributeReference>:[Class.basedOn] to <Attribute>:inverseOfBasedOn
Setting container of <ClassReference>:Class to <AttributeReference>:[Class.basedOn]
Setting container of <AttributeName>:basedOn to <AttributeReference>:[Class.basedOn]
Setting container of <Attribute>:inverseOfSubtypes to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value Class (M_1)] to <Attribute>:inverseOfSubtypes
Setting container of <BaseDataType>:[value Class] to <DataTypeClause>:[optional value Class (M_1)]
Setting container of <ClassReference>:Class to <BaseDataType>:[value Class]
Setting container of <AttributeName>:inverseOfSubtypes to <Attribute>:inverseOfSubtypes
Added implied attribute:  Attribute: inverseOfSubtypes  in  Class: Class
... Containees of section are:  ['<Attribute>:inverseOfAllSubjects', '<Attribute>:inverseOfAllClasses', '<Attribute>:inverseOfClasses', '<Attribute>:inverseOfBasedOn', '<Attribute>:inverseOfSubtypes']
... Containees of att are:  ['<DataTypeClause>:[optional value Class (M_1)]', '<AttributeName>:inverseOfSubtypes']
... Chain from name is:  <AttributeName>:inverseOfSubtypes -> <Attribute>:inverseOfSubtypes -> <AttributeSection>:Implied Attributes for Class -> <Class>:Class -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:inverseOfSubtypes -> <AttributeSection>:Implied Attributes for Class -> <Class>:Class -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Class -> <Class>:Class -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
<Attribute>:inverseOfSubtypes contains <DataTypeClause>:[optional value Class (M_1)]
	<DataTypeClause>:[optional value Class (M_1)] contains <BaseDataType>:[value Class]
		<BaseDataType>:[value Class] contains <ClassReference>:Class
<Attribute>:inverseOfSubtypes contains <AttributeName>:inverseOfSubtypes
in calc attribute, attname is  attributes
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Class  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering Class.attributes for inversion... 
	dtc =  optional List of  Attributes (O_O)
	dt  =  List of  Attributes  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Attributes
	Singular for Attributes is Attribute
	Inverting Class.attributes, a List of  Attributes. core type Attribute not a value type
	Invrse AttNam =  inverseOfAttributes
	Inverse dt =  value Class
	Inverse dtc =  optional value Class (M_1)
	Creating inverse attribute:  Attribute(container=None, one_liner=OneLiner(content='Inverse attribute for Class.attributes from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(container=None, content='inverseOfAttributes', _type='AttributeName'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(container=None, data_type=BaseDataType(container=None, class_name=ClassReference(container=None, content='Class', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Adding implied attribute:  Attribute: inverseOfAttributes  in  Class: Attribute
In AttSection post-init for Implied Attributes for Attribute, is_optional = None
Creating section for Class: Attribute: Attributesection: Implied Attributes for Attribute
Setting container of <AttributeSection>:Cardinalities to <Class>:Attribute
Setting container of <Attribute>:isOptional to <AttributeSection>:Cardinalities
Setting container of <DataTypeClause>:[optional  Boolean (O_O)] to <Attribute>:isOptional
Setting container of <BaseDataType>:[ Boolean] to <DataTypeClause>:[optional  Boolean (O_O)]
Setting container of <ClassReference>:Boolean to <BaseDataType>:[ Boolean]
Setting container of <AttributeName>:isOptional to <Attribute>:isOptional
Setting container of <Attribute>:cardinality to <AttributeSection>:Cardinalities
Setting container of <DataTypeClause>:[optional  CardinalityCode (O_O)] to <Attribute>:cardinality
Setting container of <BaseDataType>:[ CardinalityCode] to <DataTypeClause>:[optional  CardinalityCode (O_O)]
Setting container of <ClassReference>:CardinalityCode to <BaseDataType>:[ CardinalityCode]
Setting container of <AttributeName>:cardinality to <Attribute>:cardinality
Setting container of <Attribute>:author to <AttributeSection>:Cardinalities
Setting container of <DataTypeClause>:[optional value InventedName (O_O)] to <Attribute>:author
Setting container of <BaseDataType>:[value InventedName] to <DataTypeClause>:[optional value InventedName (O_O)]
Setting container of <ClassReference>:InventedName to <BaseDataType>:[value InventedName]
Setting container of <AttributeName>:author to <Attribute>:author
Setting container of <Attribute>:books to <AttributeSection>:Cardinalities
Setting container of <DataTypeClause>:[optional value InventedName (O_O)] to <Attribute>:books
Setting container of <BaseDataType>:[value InventedName] to <DataTypeClause>:[optional value InventedName (O_O)]
Setting container of <ClassReference>:InventedName to <BaseDataType>:[value InventedName]
Setting container of <AttributeName>:books to <Attribute>:books
Setting container of <AttributeSection>:Inverse Attributes to <Class>:Attribute
Setting container of <Attribute>:isInvertible to <AttributeSection>:Inverse Attributes
Setting container of <DataTypeClause>:[optional  Boolean (O_O)] to <Attribute>:isInvertible
Setting container of <BaseDataType>:[ Boolean] to <DataTypeClause>:[optional  Boolean (O_O)]
Setting container of <ClassReference>:Boolean to <BaseDataType>:[ Boolean]
Setting container of <AttributeName>:isInvertible to <Attribute>:isInvertible
Setting container of <Attribute>:inverseClass to <AttributeSection>:Inverse Attributes
Setting container of <DataTypeClause>:[optional  Class (O_O)] to <Attribute>:inverseClass
Setting container of <BaseDataType>:[ Class] to <DataTypeClause>:[optional  Class (O_O)]
Setting container of <ClassReference>:Class to <BaseDataType>:[ Class]
Setting container of <AttributeName>:inverseClass to <Attribute>:inverseClass
Setting container of <Attribute>:inverseAttribute to <AttributeSection>:Inverse Attributes
Setting container of <DataTypeClause>:[optional  Attribute (O_O)] to <Attribute>:inverseAttribute
Setting container of <BaseDataType>:[ Attribute] to <DataTypeClause>:[optional  Attribute (O_O)]
Setting container of <ClassReference>:Attribute to <BaseDataType>:[ Attribute]
Setting container of <AttributeName>:inverseAttribute to <Attribute>:inverseAttribute
Setting container of <Attribute>:inverseIsOptional to <AttributeSection>:Inverse Attributes
Setting container of <DataTypeClause>:[optional  Attribute (O_O)] to <Attribute>:inverseIsOptional
Setting container of <BaseDataType>:[ Attribute] to <DataTypeClause>:[optional  Attribute (O_O)]
Setting container of <ClassReference>:Attribute to <BaseDataType>:[ Attribute]
Setting container of <AttributeName>:inverseIsOptional to <Attribute>:inverseIsOptional
Setting container of <AttributeSection>:Formulas to <Class>:Attribute
Setting container of <Attribute>:default to <AttributeSection>:Formulas
Setting container of <DataTypeClause>:[optional  Derivation (O_O)] to <Attribute>:default
Setting container of <BaseDataType>:[ Derivation] to <DataTypeClause>:[optional  Derivation (O_O)]
Setting container of <ClassReference>:Derivation to <BaseDataType>:[ Derivation]
Setting container of <AttributeName>:default to <Attribute>:default
Setting container of <Attribute>:derivation to <AttributeSection>:Formulas
Setting container of <DataTypeClause>:[optional  Derivation (O_O)] to <Attribute>:derivation
Setting container of <BaseDataType>:[ Derivation] to <DataTypeClause>:[optional  Derivation (O_O)]
Setting container of <ClassReference>:Derivation to <BaseDataType>:[ Derivation]
Setting container of <AttributeName>:derivation to <Attribute>:derivation
Setting container of <Attribute>:constraints to <AttributeSection>:Formulas
Setting container of <DataTypeClause>:[optional List of  Constraints (O_O)] to <Attribute>:constraints
Setting container of <ListDataType>:[List of  Constraints] to <DataTypeClause>:[optional List of  Constraints (O_O)]
Setting container of <BaseDataType>:[ Constraints] to <ListDataType>:[List of  Constraints]
Setting container of <ClassReference>:Constraints to <BaseDataType>:[ Constraints]
Setting container of <AttributeName>:constraints to <Attribute>:constraints
Setting container of <AttributeSection>:Override Tracking to <Class>:Attribute
Setting container of <Attribute>:overrides to <AttributeSection>:Override Tracking
Setting container of <AttributeName>:overrides to <Attribute>:overrides
Setting container of <AttributeSection>:Implied Attributes for Attribute to <Class>:Attribute
Setting container of <Attribute>:name to <Class>:Attribute
Setting container of <DataTypeClause>:[optional  LowerCamel (O_O)] to <Attribute>:name
Setting container of <BaseDataType>:[ LowerCamel] to <DataTypeClause>:[optional  LowerCamel (O_O)]
Setting container of <ClassReference>:LowerCamel to <BaseDataType>:[ LowerCamel]
Setting container of <AttributeName>:name to <Attribute>:name
Setting container of <Attribute>:dataType to <Class>:Attribute
Setting container of <DataTypeClause>:[optional  DataType (O_O)] to <Attribute>:dataType
Setting container of <BaseDataType>:[ DataType] to <DataTypeClause>:[optional  DataType (O_O)]
Setting container of <ClassReference>:DataType to <BaseDataType>:[ DataType]
Setting container of <AttributeName>:dataType to <Attribute>:dataType
Setting container of <ClassReference>:AttributeSection to <Class>:Attribute
Setting container of <Attribute>:inverseOfAttributes to <AttributeSection>:Implied Attributes for Attribute
Setting container of <DataTypeClause>:[optional value Class (M_1)] to <Attribute>:inverseOfAttributes
Setting container of <BaseDataType>:[value Class] to <DataTypeClause>:[optional value Class (M_1)]
Setting container of <ClassReference>:Class to <BaseDataType>:[value Class]
Setting container of <AttributeName>:inverseOfAttributes to <Attribute>:inverseOfAttributes
Added implied attribute:  Attribute: inverseOfAttributes  in  Class: Attribute
... Containees of section are:  ['<Attribute>:inverseOfAttributes']
... Containees of att are:  ['<DataTypeClause>:[optional value Class (M_1)]', '<AttributeName>:inverseOfAttributes']
... Chain from name is:  <AttributeName>:inverseOfAttributes -> <Attribute>:inverseOfAttributes -> <AttributeSection>:Implied Attributes for Attribute -> <Class>:Attribute -> <SubjectB>:Attributes -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:inverseOfAttributes -> <AttributeSection>:Implied Attributes for Attribute -> <Class>:Attribute -> <SubjectB>:Attributes -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Attribute -> <Class>:Attribute -> <SubjectB>:Attributes -> <LiterateModel>:Literate Data Model
<Attribute>:inverseOfAttributes contains <DataTypeClause>:[optional value Class (M_1)]
	<DataTypeClause>:[optional value Class (M_1)] contains <BaseDataType>:[value Class]
		<BaseDataType>:[value Class] contains <ClassReference>:Class
<Attribute>:inverseOfAttributes contains <AttributeName>:inverseOfAttributes
in calc attribute, attname is  attributeSections
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Class  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering Class.attributeSections for inversion... 
	dtc =  optional List of  AttributeSections (O_O)
	dt  =  List of  AttributeSections  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = AttributeSections
	Singular for AttributeSections is AttributeSection
	Inverting Class.attributeSections, a List of  AttributeSections. core type AttributeSection not a value type
	Invrse AttNam =  inverseOfAttributeSections
	Inverse dt =  value Class
	Inverse dtc =  optional value Class (M_1)
	Creating inverse attribute:  Attribute(container=None, one_liner=OneLiner(content='Inverse attribute for Class.attributeSections from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(container=None, content='inverseOfAttributeSections', _type='AttributeName'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(container=None, data_type=BaseDataType(container=None, class_name=ClassReference(container=None, content='Class', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Adding implied attribute:  Attribute: inverseOfAttributeSections  in  Class: AttributeSection
In AttSection post-init for Implied Attributes for Attribute Section, is_optional = None
Creating section for Class: AttributeSection: Attributesection: Implied Attributes for Attribute Section
Setting container of <AttributeSection>:Implied Attributes for Attribute Section to <Class>:AttributeSection
Setting container of <Attribute>:isOptional to <Class>:AttributeSection
Setting container of <DataTypeClause>:[optional  Boolean (O_O)] to <Attribute>:isOptional
Setting container of <BaseDataType>:[ Boolean] to <DataTypeClause>:[optional  Boolean (O_O)]
Setting container of <ClassReference>:Boolean to <BaseDataType>:[ Boolean]
Setting container of <AttributeName>:isOptional to <Attribute>:isOptional
Setting container of <ClassReference>:Class to <Class>:AttributeSection
Setting container of <Attribute>:inverseOfAttributeSections to <AttributeSection>:Implied Attributes for Attribute Section
Setting container of <DataTypeClause>:[optional value Class (M_1)] to <Attribute>:inverseOfAttributeSections
Setting container of <BaseDataType>:[value Class] to <DataTypeClause>:[optional value Class (M_1)]
Setting container of <ClassReference>:Class to <BaseDataType>:[value Class]
Setting container of <AttributeName>:inverseOfAttributeSections to <Attribute>:inverseOfAttributeSections
Added implied attribute:  Attribute: inverseOfAttributeSections  in  Class: AttributeSection
... Containees of section are:  ['<Attribute>:inverseOfAttributeSections']
... Containees of att are:  ['<DataTypeClause>:[optional value Class (M_1)]', '<AttributeName>:inverseOfAttributeSections']
... Chain from name is:  <AttributeName>:inverseOfAttributeSections -> <Attribute>:inverseOfAttributeSections -> <AttributeSection>:Implied Attributes for Attribute Section -> <Class>:AttributeSection -> <SubjectB>:Attributes -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:inverseOfAttributeSections -> <AttributeSection>:Implied Attributes for Attribute Section -> <Class>:AttributeSection -> <SubjectB>:Attributes -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Attribute Section -> <Class>:AttributeSection -> <SubjectB>:Attributes -> <LiterateModel>:Literate Data Model
<Attribute>:inverseOfAttributeSections contains <DataTypeClause>:[optional value Class (M_1)]
	<DataTypeClause>:[optional value Class (M_1)] contains <BaseDataType>:[value Class]
		<BaseDataType>:[value Class] contains <ClassReference>:Class
<Attribute>:inverseOfAttributeSections contains <AttributeName>:inverseOfAttributeSections
in calc attribute, attname is  constraints
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Class  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering Class.constraints for inversion... 
	dtc =  optional List of  Constraints (O_O)
	dt  =  List of  Constraints  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Constraints
	Singular for Constraints is Constraint
	SKIPPING Class.constraints, a List of  Constraints. core type Constraint is a value type
in calc attribute, attname is  methods
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Class  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering Class.methods for inversion... 
	dtc =  optional List of  Methods (O_O)
	dt  =  List of  Methods  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Methods
	Singular for Methods is Method
	Inverting Class.methods, a List of  Methods. core type Method not a value type
	Invrse AttNam =  inverseOfMethods
	Inverse dt =  value Class
	Inverse dtc =  optional value Class (M_1)
	Creating inverse attribute:  Attribute(container=None, one_liner=OneLiner(content='Inverse attribute for Class.methods from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(container=None, content='inverseOfMethods', _type='AttributeName'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(container=None, data_type=BaseDataType(container=None, class_name=ClassReference(container=None, content='Class', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Adding implied attribute:  Attribute: inverseOfMethods  in  Class: Method
In AttSection post-init for Implied Attributes for Method, is_optional = None
Creating section for Class: Method: Attributesection: Implied Attributes for Method
Setting container of <AttributeSection>:Implied Attributes for Method to <Class>:Method
Setting container of <Attribute>:parameters to <Class>:Method
Setting container of <DataTypeClause>:[optional List of  Parameters (O_O)] to <Attribute>:parameters
Setting container of <ListDataType>:[List of  Parameters] to <DataTypeClause>:[optional List of  Parameters (O_O)]
Setting container of <BaseDataType>:[ Parameters] to <ListDataType>:[List of  Parameters]
Setting container of <ClassReference>:Parameters to <BaseDataType>:[ Parameters]
Setting container of <AttributeName>:parameters to <Attribute>:parameters
Setting container of <Attribute>:returnType to <Class>:Method
Setting container of <DataTypeClause>:[optional  DataType (O_O)] to <Attribute>:returnType
Setting container of <BaseDataType>:[ DataType] to <DataTypeClause>:[optional  DataType (O_O)]
Setting container of <ClassReference>:DataType to <BaseDataType>:[ DataType]
Setting container of <AttributeName>:returnType to <Attribute>:returnType
Setting container of <Attribute>:inverseOfMethods to <AttributeSection>:Implied Attributes for Method
Setting container of <DataTypeClause>:[optional value Class (M_1)] to <Attribute>:inverseOfMethods
Setting container of <BaseDataType>:[value Class] to <DataTypeClause>:[optional value Class (M_1)]
Setting container of <ClassReference>:Class to <BaseDataType>:[value Class]
Setting container of <AttributeName>:inverseOfMethods to <Attribute>:inverseOfMethods
Added implied attribute:  Attribute: inverseOfMethods  in  Class: Method
... Containees of section are:  ['<Attribute>:inverseOfMethods']
... Containees of att are:  ['<DataTypeClause>:[optional value Class (M_1)]', '<AttributeName>:inverseOfMethods']
... Chain from name is:  <AttributeName>:inverseOfMethods -> <Attribute>:inverseOfMethods -> <AttributeSection>:Implied Attributes for Method -> <Class>:Method -> <SubjectB>:Methods -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:inverseOfMethods -> <AttributeSection>:Implied Attributes for Method -> <Class>:Method -> <SubjectB>:Methods -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Method -> <Class>:Method -> <SubjectB>:Methods -> <LiterateModel>:Literate Data Model
<Attribute>:inverseOfMethods contains <DataTypeClause>:[optional value Class (M_1)]
	<DataTypeClause>:[optional value Class (M_1)] contains <BaseDataType>:[value Class]
		<BaseDataType>:[value Class] contains <ClassReference>:Class
<Attribute>:inverseOfMethods contains <AttributeName>:inverseOfMethods
validating datatype:   UpperCamel
type of datatype is  <class 'Literate_01.BaseDataType'>
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Default'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
validating datatype:  Set of  Class
type of datatype is  <class 'Literate_01.SetDataType'>
validating datatype:   Es
type of datatype is  <class 'Literate_01.BaseDataType'>
	!!! Base type error for  Es  in dt   Es
validating datatype:  List of  Subtypings
type of datatype is  <class 'Literate_01.ListDataType'>
validating datatype:  List of  Classes
type of datatype is  <class 'Literate_01.ListDataType'>
validating datatype:  List of  Attributes
type of datatype is  <class 'Literate_01.ListDataType'>
validating datatype:  List of  AttributeSections
type of datatype is  <class 'Literate_01.ListDataType'>
validating datatype:  List of  Constraints
type of datatype is  <class 'Literate_01.ListDataType'>
validating datatype:  List of  Methods
type of datatype is  <class 'Literate_01.ListDataType'>
validating datatype:  Set of  Classes
type of datatype is  <class 'Literate_01.SetDataType'>
validating datatype:  Set of  UniqueKeys
type of datatype is  <class 'Literate_01.SetDataType'>
validating datatype:  value LiterateDataModel
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
validating datatype:  value LiterateDataModel
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
validating datatype:  value Subject
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
validating datatype:  value Class
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
validating datatype:  value Class
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
Adding implied attribute:  Attribute: baseClass  in  Class: Subtyping
Found section named:  Implied Attributes for Subtyping
Setting container of <Attribute>:inverseOfSubtypings to <AttributeSection>:Implied Attributes for Subtyping
Setting container of <DataTypeClause>:[optional value Class (M_1)] to <Attribute>:inverseOfSubtypings
Setting container of <BaseDataType>:[value Class] to <DataTypeClause>:[optional value Class (M_1)]
Setting container of <ClassReference>:Class to <BaseDataType>:[value Class]
Setting container of <AttributeName>:inverseOfSubtypings to <Attribute>:inverseOfSubtypings
Setting container of <AttributeReference>:[Class.subtypings] to <Attribute>:inverseOfSubtypings
Setting container of <ClassReference>:Class to <AttributeReference>:[Class.subtypings]
Setting container of <AttributeName>:subtypings to <AttributeReference>:[Class.subtypings]
Setting container of <Attribute>:baseClass to <AttributeSection>:Implied Attributes for Subtyping
Setting container of <DataTypeClause>:[optional value Class (M_1)] to <Attribute>:baseClass
Setting container of <BaseDataType>:[value Class] to <DataTypeClause>:[optional value Class (M_1)]
Setting container of <ClassReference>:Class to <BaseDataType>:[value Class]
Setting container of <AttributeName>:baseClass to <Attribute>:baseClass
Added implied attribute:  Attribute: baseClass  in  Class: Subtyping
... Containees of section are:  ['<Attribute>:inverseOfSubtypings', '<Attribute>:baseClass']
... Containees of att are:  ['<DataTypeClause>:[optional value Class (M_1)]', '<AttributeName>:baseClass']
... Chain from name is:  <AttributeName>:baseClass -> <Attribute>:baseClass -> <AttributeSection>:Implied Attributes for Subtyping -> <Class>:Subtyping -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:baseClass -> <AttributeSection>:Implied Attributes for Subtyping -> <Class>:Subtyping -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Subtyping -> <Class>:Subtyping -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
<Attribute>:baseClass contains <DataTypeClause>:[optional value Class (M_1)]
	<DataTypeClause>:[optional value Class (M_1)] contains <BaseDataType>:[value Class]
		<BaseDataType>:[value Class] contains <ClassReference>:Class
<Attribute>:baseClass contains <AttributeName>:baseClass
in calc attribute, attname is  name
the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Subtyping  is  []
Considering Subtyping.name for inversion... 
	dtc =  optional  LowerCamel (O_O)
	dt  =   LowerCamel  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = LowerCamel
	Singular for LowerCamel is LowerCamel
	SKIPPING Subtyping.name, a  LowerCamel. core type LowerCamel is a value type
in calc attribute, attname is  isExclusive
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Subtyping  is  []
Considering Subtyping.isExclusive for inversion... 
	dtc =  optional  Boolean (O_O)
	dt  =   Boolean  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Boolean
	Singular for Boolean is Boolean
	SKIPPING Subtyping.isExclusive, a  Boolean. core type Boolean is a value type
in calc attribute, attname is  isExhaustive
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Subtyping  is  []
Considering Subtyping.isExhaustive for inversion... 
	dtc =  optional  Boolean (O_O)
	dt  =   Boolean  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Boolean
	Singular for Boolean is Boolean
	SKIPPING Subtyping.isExhaustive, a  Boolean. core type Boolean is a value type
in calc attribute, attname is  classes
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Subtyping  is  []
Considering Subtyping.classes for inversion... 
	dtc =  optional List of  Classes (O_O)
	dt  =  List of  Classes  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Classes
	Singular for Classes is Class
	Inverting Subtyping.classes, a List of  Classes. core type Class not a value type
	Invrse AttNam =  inverseOfClasses
	Inverse dt =  value Subtyping
	Inverse dtc =  optional value Subtyping (M_1)
	Creating inverse attribute:  Attribute(container=None, one_liner=OneLiner(content='Inverse attribute for Subtyping.classes from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(container=None, content='inverseOfClasses', _type='AttributeName'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(container=None, data_type=BaseDataType(container=None, class_name=ClassReference(container=None, content='Subtyping', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Adding implied attribute:  Attribute: inverseOfClasses  in  Class: Class
Found section named:  Implied Attributes for Class
Setting container of <Attribute>:inverseOfAllSubjects to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value LiterateDataModel (M_1)] to <Attribute>:inverseOfAllSubjects
Setting container of <BaseDataType>:[value LiterateDataModel] to <DataTypeClause>:[optional value LiterateDataModel (M_1)]
Setting container of <ClassReference>:LiterateDataModel to <BaseDataType>:[value LiterateDataModel]
Setting container of <AttributeName>:inverseOfAllSubjects to <Attribute>:inverseOfAllSubjects
Setting container of <AttributeReference>:[LiterateDataModel.allSubjects] to <Attribute>:inverseOfAllSubjects
Setting container of <ClassReference>:LiterateDataModel to <AttributeReference>:[LiterateDataModel.allSubjects]
Setting container of <AttributeName>:allSubjects to <AttributeReference>:[LiterateDataModel.allSubjects]
Setting container of <Attribute>:inverseOfAllClasses to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value LiterateDataModel (M_1)] to <Attribute>:inverseOfAllClasses
Setting container of <BaseDataType>:[value LiterateDataModel] to <DataTypeClause>:[optional value LiterateDataModel (M_1)]
Setting container of <ClassReference>:LiterateDataModel to <BaseDataType>:[value LiterateDataModel]
Setting container of <AttributeName>:inverseOfAllClasses to <Attribute>:inverseOfAllClasses
Setting container of <AttributeReference>:[LiterateDataModel.allClasses] to <Attribute>:inverseOfAllClasses
Setting container of <ClassReference>:LiterateDataModel to <AttributeReference>:[LiterateDataModel.allClasses]
Setting container of <AttributeName>:allClasses to <AttributeReference>:[LiterateDataModel.allClasses]
Setting container of <Attribute>:inverseOfClasses to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value Subject (M_1)] to <Attribute>:inverseOfClasses
Setting container of <BaseDataType>:[value Subject] to <DataTypeClause>:[optional value Subject (M_1)]
Setting container of <ClassReference>:Subject to <BaseDataType>:[value Subject]
Setting container of <AttributeName>:inverseOfClasses to <Attribute>:inverseOfClasses
Setting container of <AttributeReference>:[Subject.classes] to <Attribute>:inverseOfClasses
Setting container of <ClassReference>:Subject to <AttributeReference>:[Subject.classes]
Setting container of <AttributeName>:classes to <AttributeReference>:[Subject.classes]
Setting container of <Attribute>:inverseOfBasedOn to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value Class (M_1)] to <Attribute>:inverseOfBasedOn
Setting container of <BaseDataType>:[value Class] to <DataTypeClause>:[optional value Class (M_1)]
Setting container of <ClassReference>:Class to <BaseDataType>:[value Class]
Setting container of <AttributeName>:inverseOfBasedOn to <Attribute>:inverseOfBasedOn
Setting container of <AttributeReference>:[Class.basedOn] to <Attribute>:inverseOfBasedOn
Setting container of <ClassReference>:Class to <AttributeReference>:[Class.basedOn]
Setting container of <AttributeName>:basedOn to <AttributeReference>:[Class.basedOn]
Setting container of <Attribute>:inverseOfSubtypes to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value Class (M_1)] to <Attribute>:inverseOfSubtypes
Setting container of <BaseDataType>:[value Class] to <DataTypeClause>:[optional value Class (M_1)]
Setting container of <ClassReference>:Class to <BaseDataType>:[value Class]
Setting container of <AttributeName>:inverseOfSubtypes to <Attribute>:inverseOfSubtypes
Setting container of <AttributeReference>:[Class.subtypes] to <Attribute>:inverseOfSubtypes
Setting container of <ClassReference>:Class to <AttributeReference>:[Class.subtypes]
Setting container of <AttributeName>:subtypes to <AttributeReference>:[Class.subtypes]
Setting container of <Attribute>:inverseOfClasses to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value Subtyping (M_1)] to <Attribute>:inverseOfClasses
Setting container of <BaseDataType>:[value Subtyping] to <DataTypeClause>:[optional value Subtyping (M_1)]
Setting container of <ClassReference>:Subtyping to <BaseDataType>:[value Subtyping]
Setting container of <AttributeName>:inverseOfClasses to <Attribute>:inverseOfClasses
Added implied attribute:  Attribute: inverseOfClasses  in  Class: Class
... Containees of section are:  ['<Attribute>:inverseOfAllSubjects', '<Attribute>:inverseOfAllClasses', '<Attribute>:inverseOfClasses', '<Attribute>:inverseOfBasedOn', '<Attribute>:inverseOfSubtypes', '<Attribute>:inverseOfClasses']
... Containees of att are:  ['<DataTypeClause>:[optional value Subtyping (M_1)]', '<AttributeName>:inverseOfClasses']
... Chain from name is:  <AttributeName>:inverseOfClasses -> <Attribute>:inverseOfClasses -> <AttributeSection>:Implied Attributes for Class -> <Class>:Class -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:inverseOfClasses -> <AttributeSection>:Implied Attributes for Class -> <Class>:Class -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Class -> <Class>:Class -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
<Attribute>:inverseOfClasses contains <DataTypeClause>:[optional value Subtyping (M_1)]
	<DataTypeClause>:[optional value Subtyping (M_1)] contains <BaseDataType>:[value Subtyping]
		<BaseDataType>:[value Subtyping] contains <ClassReference>:Subtyping
<Attribute>:inverseOfClasses contains <AttributeName>:inverseOfClasses
validating datatype:   LowerCamel
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:   Boolean
type of datatype is  <class 'Literate_01.BaseDataType'>
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Default'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
validating datatype:   Boolean
type of datatype is  <class 'Literate_01.BaseDataType'>
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Default'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
validating datatype:  List of  Classes
type of datatype is  <class 'Literate_01.ListDataType'>
validating datatype:  value Class
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
validating datatype:  value Class
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
in calc attribute, attname is  isCaptive
the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Valuetype: CodeType  is  []
Considering CodeType.isCaptive for inversion... 
	dtc =  optional  Boolean (O_O)
	dt  =   Boolean  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Boolean
	Singular for Boolean is Boolean
	SKIPPING CodeType.isCaptive, a  Boolean. core type Boolean is a value type
validating datatype:   Boolean
type of datatype is  <class 'Literate_01.BaseDataType'>
Adding implied attribute:  Attribute: baseCodeType  in  Valuetype: CodeValue
In AttSection post-init for Implied Attributes for Code Value, is_optional = None
Creating section for Valuetype: CodeValue: Attributesection: Implied Attributes for Code Value
Setting container of <AttributeSection>:Implied Attributes for Code Value to <ValueType>:CodeValue
Setting container of <Attribute>:code to <ValueType>:CodeValue
Setting container of <DataTypeClause>:[optional  NameString (O_O)] to <Attribute>:code
Setting container of <BaseDataType>:[ NameString] to <DataTypeClause>:[optional  NameString (O_O)]
Setting container of <ClassReference>:NameString to <BaseDataType>:[ NameString]
Setting container of <AttributeName>:code to <Attribute>:code
Setting container of <Attribute>:description to <ValueType>:CodeValue
Setting container of <DataTypeClause>:[optional  RichText (O_O)] to <Attribute>:description
Setting container of <BaseDataType>:[ RichText] to <DataTypeClause>:[optional  RichText (O_O)]
Setting container of <ClassReference>:RichText to <BaseDataType>:[ RichText]
Setting container of <AttributeName>:description to <Attribute>:description
Setting container of <ClassReference>:CodeType to <ValueType>:CodeValue
Setting container of <Attribute>:baseCodeType to <AttributeSection>:Implied Attributes for Code Value
Setting container of <DataTypeClause>:[optional value CodeType (M_1)] to <Attribute>:baseCodeType
Setting container of <BaseDataType>:[value CodeType] to <DataTypeClause>:[optional value CodeType (M_1)]
Setting container of <ClassReference>:CodeType to <BaseDataType>:[value CodeType]
Setting container of <AttributeName>:baseCodeType to <Attribute>:baseCodeType
Added implied attribute:  Attribute: baseCodeType  in  Valuetype: CodeValue
... Containees of section are:  ['<Attribute>:baseCodeType']
... Containees of att are:  ['<DataTypeClause>:[optional value CodeType (M_1)]', '<AttributeName>:baseCodeType']
... Chain from name is:  <AttributeName>:baseCodeType -> <Attribute>:baseCodeType -> <AttributeSection>:Implied Attributes for Code Value -> <ValueType>:CodeValue -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:baseCodeType -> <AttributeSection>:Implied Attributes for Code Value -> <ValueType>:CodeValue -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Code Value -> <ValueType>:CodeValue -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
<Attribute>:baseCodeType contains <DataTypeClause>:[optional value CodeType (M_1)]
	<DataTypeClause>:[optional value CodeType (M_1)] contains <BaseDataType>:[value CodeType]
		<BaseDataType>:[value CodeType] contains <ClassReference>:CodeType
<Attribute>:baseCodeType contains <AttributeName>:baseCodeType
in calc attribute, attname is  code
the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Valuetype: CodeValue  is  []
Considering CodeValue.code for inversion... 
	dtc =  optional  NameString (O_O)
	dt  =   NameString  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = NameString
	SKIPPING inverse for..  No such class as  NameString
in calc attribute, attname is  description
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Valuetype: CodeValue  is  []
Considering CodeValue.description for inversion... 
	dtc =  optional  RichText (O_O)
	dt  =   RichText  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = RichText
	SKIPPING inverse for..  No such class as  RichText
validating datatype:   NameString
type of datatype is  <class 'Literate_01.BaseDataType'>
	!!! Base type error for  NameString  in dt   NameString
validating datatype:   RichText
type of datatype is  <class 'Literate_01.BaseDataType'>
	!!! Base type error for  RichText  in dt   RichText
validating datatype:  value CodeType
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
Adding implied attribute:  Attribute: baseClass  in  Class: Key
In AttSection post-init for Implied Attributes for Key, is_optional = None
Creating section for Class: Key: Attributesection: Implied Attributes for Key
Setting container of <AttributeSection>:Implied Attributes for Key to <Class>:Key
Setting container of <Attribute>:keyAttributes to <Class>:Key
Setting container of <DataTypeClause>:[optional List of  Attributes (O_O)] to <Attribute>:keyAttributes
Setting container of <ListDataType>:[List of  Attributes] to <DataTypeClause>:[optional List of  Attributes (O_O)]
Setting container of <BaseDataType>:[ Attributes] to <ListDataType>:[List of  Attributes]
Setting container of <ClassReference>:Attributes to <BaseDataType>:[ Attributes]
Setting container of <AttributeName>:keyAttributes to <Attribute>:keyAttributes
Setting container of <ClassReference>:Class to <Class>:Key
Setting container of <Attribute>:baseClass to <AttributeSection>:Implied Attributes for Key
Setting container of <DataTypeClause>:[optional value Class (M_1)] to <Attribute>:baseClass
Setting container of <BaseDataType>:[value Class] to <DataTypeClause>:[optional value Class (M_1)]
Setting container of <ClassReference>:Class to <BaseDataType>:[value Class]
Setting container of <AttributeName>:baseClass to <Attribute>:baseClass
Added implied attribute:  Attribute: baseClass  in  Class: Key
... Containees of section are:  ['<Attribute>:baseClass']
... Containees of att are:  ['<DataTypeClause>:[optional value Class (M_1)]', '<AttributeName>:baseClass']
... Chain from name is:  <AttributeName>:baseClass -> <Attribute>:baseClass -> <AttributeSection>:Implied Attributes for Key -> <Class>:Key -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:baseClass -> <AttributeSection>:Implied Attributes for Key -> <Class>:Key -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Key -> <Class>:Key -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
<Attribute>:baseClass contains <DataTypeClause>:[optional value Class (M_1)]
	<DataTypeClause>:[optional value Class (M_1)] contains <BaseDataType>:[value Class]
		<BaseDataType>:[value Class] contains <ClassReference>:Class
<Attribute>:baseClass contains <AttributeName>:baseClass
in calc attribute, attname is  keyAttributes
the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
MRO for Key =>  ['Component']
calc attribute override; mro for  Class: Key  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering Key.keyAttributes for inversion... 
	dtc =  optional List of  Attributes (O_O)
	dt  =  List of  Attributes  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Attributes
	Singular for Attributes is Attribute
	Inverting Key.keyAttributes, a List of  Attributes. core type Attribute not a value type
	Invrse AttNam =  inverseOfKeyAttributes
	Inverse dt =  value Key
	Inverse dtc =  optional value Key (M_1)
	Creating inverse attribute:  Attribute(container=None, one_liner=OneLiner(content='Inverse attribute for Key.keyAttributes from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(container=None, content='inverseOfKeyAttributes', _type='AttributeName'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(container=None, data_type=BaseDataType(container=None, class_name=ClassReference(container=None, content='Key', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Adding implied attribute:  Attribute: inverseOfKeyAttributes  in  Class: Attribute
Found section named:  Implied Attributes for Attribute
Setting container of <Attribute>:inverseOfAttributes to <AttributeSection>:Implied Attributes for Attribute
Setting container of <DataTypeClause>:[optional value Class (M_1)] to <Attribute>:inverseOfAttributes
Setting container of <BaseDataType>:[value Class] to <DataTypeClause>:[optional value Class (M_1)]
Setting container of <ClassReference>:Class to <BaseDataType>:[value Class]
Setting container of <AttributeName>:inverseOfAttributes to <Attribute>:inverseOfAttributes
Setting container of <AttributeReference>:[Class.attributes] to <Attribute>:inverseOfAttributes
Setting container of <ClassReference>:Class to <AttributeReference>:[Class.attributes]
Setting container of <AttributeName>:attributes to <AttributeReference>:[Class.attributes]
Setting container of <Attribute>:inverseOfKeyAttributes to <AttributeSection>:Implied Attributes for Attribute
Setting container of <DataTypeClause>:[optional value Key (M_1)] to <Attribute>:inverseOfKeyAttributes
Setting container of <BaseDataType>:[value Key] to <DataTypeClause>:[optional value Key (M_1)]
Setting container of <ClassReference>:Key to <BaseDataType>:[value Key]
Setting container of <AttributeName>:inverseOfKeyAttributes to <Attribute>:inverseOfKeyAttributes
Added implied attribute:  Attribute: inverseOfKeyAttributes  in  Class: Attribute
... Containees of section are:  ['<Attribute>:inverseOfAttributes', '<Attribute>:inverseOfKeyAttributes']
... Containees of att are:  ['<DataTypeClause>:[optional value Key (M_1)]', '<AttributeName>:inverseOfKeyAttributes']
... Chain from name is:  <AttributeName>:inverseOfKeyAttributes -> <Attribute>:inverseOfKeyAttributes -> <AttributeSection>:Implied Attributes for Attribute -> <Class>:Attribute -> <SubjectB>:Attributes -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:inverseOfKeyAttributes -> <AttributeSection>:Implied Attributes for Attribute -> <Class>:Attribute -> <SubjectB>:Attributes -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Attribute -> <Class>:Attribute -> <SubjectB>:Attributes -> <LiterateModel>:Literate Data Model
<Attribute>:inverseOfKeyAttributes contains <DataTypeClause>:[optional value Key (M_1)]
	<DataTypeClause>:[optional value Key (M_1)] contains <BaseDataType>:[value Key]
		<BaseDataType>:[value Key] contains <ClassReference>:Key
<Attribute>:inverseOfKeyAttributes contains <AttributeName>:inverseOfKeyAttributes
validating datatype:  List of  Attributes
type of datatype is  <class 'Literate_01.ListDataType'>
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Constraint'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Constraint'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Constraint'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Constraint'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
validating datatype:  value Class
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
Adding implied attribute:  Attribute: baseClass  in  Class: AttributeSection
In AttSection post-init for Implied Attributes for Attribute Section, is_optional = None
Creating section for Class: AttributeSection: Attributesection: Implied Attributes for Attribute Section
Setting container of <AttributeSection>:Implied Attributes for Attribute Section to <Class>:AttributeSection
Setting container of <Attribute>:inverseOfAttributeSections to <AttributeSection>:Implied Attributes for Attribute Section
Setting container of <DataTypeClause>:[optional value Class (M_1)] to <Attribute>:inverseOfAttributeSections
Setting container of <BaseDataType>:[value Class] to <DataTypeClause>:[optional value Class (M_1)]
Setting container of <ClassReference>:Class to <BaseDataType>:[value Class]
Setting container of <AttributeName>:inverseOfAttributeSections to <Attribute>:inverseOfAttributeSections
Setting container of <AttributeReference>:[Class.attributeSections] to <Attribute>:inverseOfAttributeSections
Setting container of <ClassReference>:Class to <AttributeReference>:[Class.attributeSections]
Setting container of <AttributeName>:attributeSections to <AttributeReference>:[Class.attributeSections]
Setting container of <AttributeSection>:Implied Attributes for Attribute Section to <Class>:AttributeSection
Setting container of <Attribute>:isOptional to <Class>:AttributeSection
Setting container of <DataTypeClause>:[optional  Boolean (O_O)] to <Attribute>:isOptional
Setting container of <BaseDataType>:[ Boolean] to <DataTypeClause>:[optional  Boolean (O_O)]
Setting container of <ClassReference>:Boolean to <BaseDataType>:[ Boolean]
Setting container of <AttributeName>:isOptional to <Attribute>:isOptional
Setting container of <ClassReference>:Class to <Class>:AttributeSection
Setting container of <Attribute>:baseClass to <AttributeSection>:Implied Attributes for Attribute Section
Setting container of <DataTypeClause>:[optional value Class (M_1)] to <Attribute>:baseClass
Setting container of <BaseDataType>:[value Class] to <DataTypeClause>:[optional value Class (M_1)]
Setting container of <ClassReference>:Class to <BaseDataType>:[value Class]
Setting container of <AttributeName>:baseClass to <Attribute>:baseClass
Added implied attribute:  Attribute: baseClass  in  Class: AttributeSection
... Containees of section are:  ['<Attribute>:baseClass']
... Containees of att are:  ['<DataTypeClause>:[optional value Class (M_1)]', '<AttributeName>:baseClass']
... Chain from name is:  <AttributeName>:baseClass -> <Attribute>:baseClass -> <AttributeSection>:Implied Attributes for Attribute Section -> <Class>:AttributeSection -> <SubjectB>:Attributes -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:baseClass -> <AttributeSection>:Implied Attributes for Attribute Section -> <Class>:AttributeSection -> <SubjectB>:Attributes -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Attribute Section -> <Class>:AttributeSection -> <SubjectB>:Attributes -> <LiterateModel>:Literate Data Model
<Attribute>:baseClass contains <DataTypeClause>:[optional value Class (M_1)]
	<DataTypeClause>:[optional value Class (M_1)] contains <BaseDataType>:[value Class]
		<BaseDataType>:[value Class] contains <ClassReference>:Class
<Attribute>:baseClass contains <AttributeName>:baseClass
in calc attribute, attname is  isOptional
the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
MRO for AttributeSection =>  ['Component']
calc attribute override; mro for  Class: AttributeSection  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering AttributeSection.isOptional for inversion... 
	dtc =  optional  Boolean (O_O)
	dt  =   Boolean  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Boolean
	Singular for Boolean is Boolean
	SKIPPING AttributeSection.isOptional, a  Boolean. core type Boolean is a value type
validating datatype:   Boolean
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:  value Class
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
validating datatype:  value Class
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
Adding implied attribute:  Attribute: baseAttributeSection  in  Class: Attribute
Found section named:  Implied Attributes for Attribute
Setting container of <Attribute>:inverseOfAttributes to <AttributeSection>:Implied Attributes for Attribute
Setting container of <DataTypeClause>:[optional value Class (M_1)] to <Attribute>:inverseOfAttributes
Setting container of <BaseDataType>:[value Class] to <DataTypeClause>:[optional value Class (M_1)]
Setting container of <ClassReference>:Class to <BaseDataType>:[value Class]
Setting container of <AttributeName>:inverseOfAttributes to <Attribute>:inverseOfAttributes
Setting container of <AttributeReference>:[Class.attributes] to <Attribute>:inverseOfAttributes
Setting container of <ClassReference>:Class to <AttributeReference>:[Class.attributes]
Setting container of <AttributeName>:attributes to <AttributeReference>:[Class.attributes]
Setting container of <Attribute>:inverseOfKeyAttributes to <AttributeSection>:Implied Attributes for Attribute
Setting container of <DataTypeClause>:[optional value Key (M_1)] to <Attribute>:inverseOfKeyAttributes
Setting container of <BaseDataType>:[value Key] to <DataTypeClause>:[optional value Key (M_1)]
Setting container of <ClassReference>:Key to <BaseDataType>:[value Key]
Setting container of <AttributeName>:inverseOfKeyAttributes to <Attribute>:inverseOfKeyAttributes
Setting container of <AttributeReference>:[Key.keyAttributes] to <Attribute>:inverseOfKeyAttributes
Setting container of <ClassReference>:Key to <AttributeReference>:[Key.keyAttributes]
Setting container of <AttributeName>:keyAttributes to <AttributeReference>:[Key.keyAttributes]
Setting container of <Attribute>:baseAttributeSection to <AttributeSection>:Implied Attributes for Attribute
Setting container of <DataTypeClause>:[optional value AttributeSection (M_1)] to <Attribute>:baseAttributeSection
Setting container of <BaseDataType>:[value AttributeSection] to <DataTypeClause>:[optional value AttributeSection (M_1)]
Setting container of <ClassReference>:AttributeSection to <BaseDataType>:[value AttributeSection]
Setting container of <AttributeName>:baseAttributeSection to <Attribute>:baseAttributeSection
Added implied attribute:  Attribute: baseAttributeSection  in  Class: Attribute
... Containees of section are:  ['<Attribute>:inverseOfAttributes', '<Attribute>:inverseOfKeyAttributes', '<Attribute>:baseAttributeSection']
... Containees of att are:  ['<DataTypeClause>:[optional value AttributeSection (M_1)]', '<AttributeName>:baseAttributeSection']
... Chain from name is:  <AttributeName>:baseAttributeSection -> <Attribute>:baseAttributeSection -> <AttributeSection>:Implied Attributes for Attribute -> <Class>:Attribute -> <SubjectB>:Attributes -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:baseAttributeSection -> <AttributeSection>:Implied Attributes for Attribute -> <Class>:Attribute -> <SubjectB>:Attributes -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Attribute -> <Class>:Attribute -> <SubjectB>:Attributes -> <LiterateModel>:Literate Data Model
<Attribute>:baseAttributeSection contains <DataTypeClause>:[optional value AttributeSection (M_1)]
	<DataTypeClause>:[optional value AttributeSection (M_1)] contains <BaseDataType>:[value AttributeSection]
		<BaseDataType>:[value AttributeSection] contains <ClassReference>:AttributeSection
<Attribute>:baseAttributeSection contains <AttributeName>:baseAttributeSection
in calc attribute, attname is  name
the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
MRO for Attribute =>  ['Component']
calc attribute override; mro for  Class: Attribute  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Found override for Attribute.name in Component
Attribute name =  name
.. and as AName:  AttributeName(container=None, content='name', _type='AttributeName')
Considering Attribute.name for inversion... 
	dtc =  optional  LowerCamel (O_O)
	dt  =   LowerCamel  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = LowerCamel
	Singular for LowerCamel is LowerCamel
	SKIPPING Attribute.name, a  LowerCamel. core type LowerCamel is a value type
in calc attribute, attname is  dataType
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Attribute  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering Attribute.dataType for inversion... 
	dtc =  optional  DataType (O_O)
	dt  =   DataType  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = DataType
	Singular for DataType is DataType
	SKIPPING Attribute.dataType, a  DataType. core type DataType is a value type
validating datatype:   LowerCamel
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:   DataType
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:   Boolean
type of datatype is  <class 'Literate_01.BaseDataType'>
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Default'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
validating datatype:   CardinalityCode
type of datatype is  <class 'Literate_01.BaseDataType'>
	!!! Base type error for  CardinalityCode  in dt   CardinalityCode
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Default'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Default'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
validating datatype:  value InventedName
type of datatype is  <class 'Literate_01.BaseDataType'>
	!!! Base type error for  InventedName  in dt  value InventedName
validating datatype:  value InventedName
type of datatype is  <class 'Literate_01.BaseDataType'>
	!!! Base type error for  InventedName  in dt  value InventedName
validating datatype:   Boolean
type of datatype is  <class 'Literate_01.BaseDataType'>
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Derivation'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
validating datatype:   Class
type of datatype is  <class 'Literate_01.BaseDataType'>
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Derivation'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
validating datatype:   Attribute
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:   Attribute
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:   Derivation
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:   Derivation
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:  List of  Constraints
type of datatype is  <class 'Literate_01.ListDataType'>
validating datatype:  value Class
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
validating datatype:  value Key
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
validating datatype:  value AttributeSection
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
in calc attribute, attname is  statement
the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Valuetype: Derivation  is  []
Considering Derivation.statement for inversion... 
	dtc =  optional  RichText (O_O)
	dt  =   RichText  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = RichText
	SKIPPING inverse for..  No such class as  RichText
in calc attribute, attname is  expression
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Valuetype: Derivation  is  []
Considering Derivation.expression for inversion... 
	dtc =  optional  CodeExpression (O_O)
	dt  =   CodeExpression  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = CodeExpression
	Singular for CodeExpression is CodeExpression
	SKIPPING Derivation.expression, a  CodeExpression. core type CodeExpression is a value type
validating datatype:   RichText
type of datatype is  <class 'Literate_01.BaseDataType'>
	!!! Base type error for  RichText  in dt   RichText
validating datatype:   CodeExpression
type of datatype is  <class 'Literate_01.BaseDataType'>
in calc attribute, attname is  statement
the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
MRO for Constraint =>  ['Component']
calc attribute override; mro for  Valuetype: Constraint  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering Constraint.statement for inversion... 
	dtc =  optional  RichText (O_O)
	dt  =   RichText  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = RichText
	SKIPPING inverse for..  No such class as  RichText
in calc attribute, attname is  expression
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Valuetype: Constraint  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering Constraint.expression for inversion... 
	dtc =  optional value InventedName (O_O)
	dt  =  value InventedName  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = InventedName
	SKIPPING inverse for..  No such class as  InventedName
in calc attribute, attname is  severity
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Valuetype: Constraint  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering Constraint.severity for inversion... 
	dtc =  optional  Code (O_O)
	dt  =   Code  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Code
	SKIPPING inverse for..  No such class as  Code
validating datatype:   RichText
type of datatype is  <class 'Literate_01.BaseDataType'>
	!!! Base type error for  RichText  in dt   RichText
validating datatype:  value InventedName
type of datatype is  <class 'Literate_01.BaseDataType'>
	!!! Base type error for  InventedName  in dt  value InventedName
validating datatype:   Code
type of datatype is  <class 'Literate_01.BaseDataType'>
	!!! Base type error for  Code  in dt   Code
Adding implied attribute:  Attribute: baseClass  in  Valuetype: ClassConstraint
In AttSection post-init for Implied Attributes for Class Constraint, is_optional = None
Creating section for Valuetype: ClassConstraint: Attributesection: Implied Attributes for Class Constraint
Setting container of <AttributeSection>:Implied Attributes for Class Constraint to <ValueType>:ClassConstraint
Setting container of <ClassReference>:Class to <ValueType>:ClassConstraint
Setting container of <Attribute>:baseClass to <AttributeSection>:Implied Attributes for Class Constraint
Setting container of <DataTypeClause>:[optional value Class (M_1)] to <Attribute>:baseClass
Setting container of <BaseDataType>:[value Class] to <DataTypeClause>:[optional value Class (M_1)]
Setting container of <ClassReference>:Class to <BaseDataType>:[value Class]
Setting container of <AttributeName>:baseClass to <Attribute>:baseClass
Added implied attribute:  Attribute: baseClass  in  Valuetype: ClassConstraint
... Containees of section are:  ['<Attribute>:baseClass']
... Containees of att are:  ['<DataTypeClause>:[optional value Class (M_1)]', '<AttributeName>:baseClass']
... Chain from name is:  <AttributeName>:baseClass -> <Attribute>:baseClass -> <AttributeSection>:Implied Attributes for Class Constraint -> <ValueType>:ClassConstraint -> <SubjectB>:Attributes -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:baseClass -> <AttributeSection>:Implied Attributes for Class Constraint -> <ValueType>:ClassConstraint -> <SubjectB>:Attributes -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Class Constraint -> <ValueType>:ClassConstraint -> <SubjectB>:Attributes -> <LiterateModel>:Literate Data Model
<Attribute>:baseClass contains <DataTypeClause>:[optional value Class (M_1)]
	<DataTypeClause>:[optional value Class (M_1)] contains <BaseDataType>:[value Class]
		<BaseDataType>:[value Class] contains <ClassReference>:Class
<Attribute>:baseClass contains <AttributeName>:baseClass
validating datatype:  value Class
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
Adding implied attribute:  Attribute: baseAttribute  in  Valuetype: AttributeConstraint
In AttSection post-init for Implied Attributes for Attribute Constraint, is_optional = None
Creating section for Valuetype: AttributeConstraint: Attributesection: Implied Attributes for Attribute Constraint
Setting container of <AttributeSection>:Implied Attributes for Attribute Constraint to <ValueType>:AttributeConstraint
Setting container of <ClassReference>:Attribute to <ValueType>:AttributeConstraint
Setting container of <Attribute>:baseAttribute to <AttributeSection>:Implied Attributes for Attribute Constraint
Setting container of <DataTypeClause>:[optional value Attribute (M_1)] to <Attribute>:baseAttribute
Setting container of <BaseDataType>:[value Attribute] to <DataTypeClause>:[optional value Attribute (M_1)]
Setting container of <ClassReference>:Attribute to <BaseDataType>:[value Attribute]
Setting container of <AttributeName>:baseAttribute to <Attribute>:baseAttribute
Added implied attribute:  Attribute: baseAttribute  in  Valuetype: AttributeConstraint
... Containees of section are:  ['<Attribute>:baseAttribute']
... Containees of att are:  ['<DataTypeClause>:[optional value Attribute (M_1)]', '<AttributeName>:baseAttribute']
... Chain from name is:  <AttributeName>:baseAttribute -> <Attribute>:baseAttribute -> <AttributeSection>:Implied Attributes for Attribute Constraint -> <ValueType>:AttributeConstraint -> <SubjectB>:Attributes -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:baseAttribute -> <AttributeSection>:Implied Attributes for Attribute Constraint -> <ValueType>:AttributeConstraint -> <SubjectB>:Attributes -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Attribute Constraint -> <ValueType>:AttributeConstraint -> <SubjectB>:Attributes -> <LiterateModel>:Literate Data Model
<Attribute>:baseAttribute contains <DataTypeClause>:[optional value Attribute (M_1)]
	<DataTypeClause>:[optional value Attribute (M_1)] contains <BaseDataType>:[value Attribute]
		<BaseDataType>:[value Attribute] contains <ClassReference>:Attribute
<Attribute>:baseAttribute contains <AttributeName>:baseAttribute
validating datatype:  value Attribute
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
in calc attribute, attname is  parameters
the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
MRO for Method =>  ['Component']
calc attribute override; mro for  Class: Method  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering Method.parameters for inversion... 
	dtc =  optional List of  Parameters (O_O)
	dt  =  List of  Parameters  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = Parameters
	Singular for Parameters is ParameterAnInputToAMethod
	Inverting Method.parameters, a List of  Parameters. core type ParameterAnInputToAMethod not a value type
	Invrse AttNam =  inverseOfParameters
	Inverse dt =  value Method
	Inverse dtc =  optional value Method (M_1)
	Creating inverse attribute:  Attribute(container=None, one_liner=OneLiner(content='Inverse attribute for Method.parameters from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(container=None, content='inverseOfParameters', _type='AttributeName'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(container=None, data_type=BaseDataType(container=None, class_name=ClassReference(container=None, content='Method', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Adding implied attribute:  Attribute: inverseOfParameters  in  Class: ParameterAnInputToAMethod
In AttSection post-init for Implied Attributes for Parameter An Input To A Method, is_optional = None
Creating section for Class: ParameterAnInputToAMethod: Attributesection: Implied Attributes for Parameter An Input To A Method
Setting container of <AttributeSection>:Implied Attributes for Parameter An Input To A Method to <Class>:ParameterAnInputToAMethod
Setting container of <Attribute>:type to <Class>:ParameterAnInputToAMethod
Setting container of <DataTypeClause>:[optional  DataType (O_O)] to <Attribute>:type
Setting container of <BaseDataType>:[ DataType] to <DataTypeClause>:[optional  DataType (O_O)]
Setting container of <ClassReference>:DataType to <BaseDataType>:[ DataType]
Setting container of <AttributeName>:type to <Attribute>:type
Setting container of <Attribute>:cardinality to <Class>:ParameterAnInputToAMethod
Setting container of <DataTypeClause>:[optional value InventedName (O_O)] to <Attribute>:cardinality
Setting container of <BaseDataType>:[value InventedName] to <DataTypeClause>:[optional value InventedName (O_O)]
Setting container of <ClassReference>:InventedName to <BaseDataType>:[value InventedName]
Setting container of <AttributeName>:cardinality to <Attribute>:cardinality
Setting container of <Attribute>:inverseOfParameters to <AttributeSection>:Implied Attributes for Parameter An Input To A Method
Setting container of <DataTypeClause>:[optional value Method (M_1)] to <Attribute>:inverseOfParameters
Setting container of <BaseDataType>:[value Method] to <DataTypeClause>:[optional value Method (M_1)]
Setting container of <ClassReference>:Method to <BaseDataType>:[value Method]
Setting container of <AttributeName>:inverseOfParameters to <Attribute>:inverseOfParameters
Added implied attribute:  Attribute: inverseOfParameters  in  Class: ParameterAnInputToAMethod
... Containees of section are:  ['<Attribute>:inverseOfParameters']
... Containees of att are:  ['<DataTypeClause>:[optional value Method (M_1)]', '<AttributeName>:inverseOfParameters']
... Chain from name is:  <AttributeName>:inverseOfParameters -> <Attribute>:inverseOfParameters -> <AttributeSection>:Implied Attributes for Parameter An Input To A Method -> <Class>:ParameterAnInputToAMethod -> <SubjectB>:Methods -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:inverseOfParameters -> <AttributeSection>:Implied Attributes for Parameter An Input To A Method -> <Class>:ParameterAnInputToAMethod -> <SubjectB>:Methods -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Parameter An Input To A Method -> <Class>:ParameterAnInputToAMethod -> <SubjectB>:Methods -> <LiterateModel>:Literate Data Model
<Attribute>:inverseOfParameters contains <DataTypeClause>:[optional value Method (M_1)]
	<DataTypeClause>:[optional value Method (M_1)] contains <BaseDataType>:[value Method]
		<BaseDataType>:[value Method] contains <ClassReference>:Method
<Attribute>:inverseOfParameters contains <AttributeName>:inverseOfParameters
in calc attribute, attname is  returnType
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: Method  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering Method.returnType for inversion... 
	dtc =  optional  DataType (O_O)
	dt  =   DataType  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = DataType
	Singular for DataType is DataType
	SKIPPING Method.returnType, a  DataType. core type DataType is a value type
validating datatype:  List of  Parameters
type of datatype is  <class 'Literate_01.ListDataType'>
validating datatype:   DataType
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:  value Class
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
in calc attribute, attname is  type
the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
MRO for ParameterAnInputToAMethod =>  ['Component']
calc attribute override; mro for  Class: ParameterAnInputToAMethod  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering ParameterAnInputToAMethod.type for inversion... 
	dtc =  optional  DataType (O_O)
	dt  =   DataType  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = DataType
	Singular for DataType is DataType
	SKIPPING ParameterAnInputToAMethod.type, a  DataType. core type DataType is a value type
in calc attribute, attname is  cardinality
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: ParameterAnInputToAMethod  is  ['Component']
All attributes for Class: Component are:  dict_keys(['normalName', 'name', 'qualifiedName', 'abbreviatedName', 'oneLiner', 'elaboration', 'isEmbellishment'])
Considering ParameterAnInputToAMethod.cardinality for inversion... 
	dtc =  optional value InventedName (O_O)
	dt  =  value InventedName  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = InventedName
	SKIPPING inverse for..  No such class as  InventedName
validating datatype:   DataType
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:  value InventedName
type of datatype is  <class 'Literate_01.BaseDataType'>
	!!! Base type error for  InventedName  in dt  value InventedName
validating datatype:  value Method
type of datatype is  <class 'ldm.Literate_01.BaseDataType'>
in calc attribute, attname is  language
the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Valuetype: CodeExpression  is  []
Considering CodeExpression.language for inversion... 
	dtc =  optional  Code (O_O)
	dt  =   Code  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Code
	SKIPPING inverse for..  No such class as  Code
in calc attribute, attname is  expression
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Valuetype: CodeExpression  is  []
Considering CodeExpression.expression for inversion... 
	dtc =  optional  String (O_O)
	dt  =   String  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = String
	Singular for String is String
	SKIPPING CodeExpression.expression, a  String. core type String is a value type
validating datatype:   Code
type of datatype is  <class 'Literate_01.BaseDataType'>
	!!! Base type error for  Code  in dt   Code
validating datatype:   String
type of datatype is  <class 'Literate_01.BaseDataType'>
in calc attribute, attname is  coreClass
the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Valuetype: SimpleDataTypeSubtpeOfDataType  is  []
Considering SimpleDataTypeSubtpeOfDataType.coreClass for inversion... 
	dtc =  optional  Class (O_O)
	dt  =   Class  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Class
	Singular for Class is Class
	Inverting SimpleDataTypeSubtpeOfDataType.coreClass, a  Class. core type Class not a value type
	Invrse AttNam =  inverseOfCoreClass
	Inverse dt =  value SimpleDataTypeSubtpeOfDataType
	Inverse dtc =  optional value SimpleDataTypeSubtpeOfDataType (M_1)
	Creating inverse attribute:  Attribute(container=None, one_liner=OneLiner(content='Inverse attribute for SimpleDataTypeSubtpeOfDataType.coreClass from which this was implied.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, prefix=None, name=AttributeName(container=None, content='inverseOfCoreClass', _type='AttributeName'), parenthetical=None, abbreviation=None, data_type_clause=DataTypeClause(container=None, data_type=BaseDataType(container=None, class_name=ClassReference(container=None, content='SimpleDataTypeSubtpeOfDataType', _type='ClassReference'), as_value_type=AsValue(content=False, _type='AsValue')), is_optional_lit=IsOptional(content=False, _type='IsOptional'), cardinality=<Cardinality.MANY_ONE: 'M_1'>), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])
Adding implied attribute:  Attribute: inverseOfCoreClass  in  Class: Class
Found section named:  Implied Attributes for Class
Setting container of <Attribute>:inverseOfAllSubjects to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value LiterateDataModel (M_1)] to <Attribute>:inverseOfAllSubjects
Setting container of <BaseDataType>:[value LiterateDataModel] to <DataTypeClause>:[optional value LiterateDataModel (M_1)]
Setting container of <ClassReference>:LiterateDataModel to <BaseDataType>:[value LiterateDataModel]
Setting container of <AttributeName>:inverseOfAllSubjects to <Attribute>:inverseOfAllSubjects
Setting container of <AttributeReference>:[LiterateDataModel.allSubjects] to <Attribute>:inverseOfAllSubjects
Setting container of <ClassReference>:LiterateDataModel to <AttributeReference>:[LiterateDataModel.allSubjects]
Setting container of <AttributeName>:allSubjects to <AttributeReference>:[LiterateDataModel.allSubjects]
Setting container of <Attribute>:inverseOfAllClasses to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value LiterateDataModel (M_1)] to <Attribute>:inverseOfAllClasses
Setting container of <BaseDataType>:[value LiterateDataModel] to <DataTypeClause>:[optional value LiterateDataModel (M_1)]
Setting container of <ClassReference>:LiterateDataModel to <BaseDataType>:[value LiterateDataModel]
Setting container of <AttributeName>:inverseOfAllClasses to <Attribute>:inverseOfAllClasses
Setting container of <AttributeReference>:[LiterateDataModel.allClasses] to <Attribute>:inverseOfAllClasses
Setting container of <ClassReference>:LiterateDataModel to <AttributeReference>:[LiterateDataModel.allClasses]
Setting container of <AttributeName>:allClasses to <AttributeReference>:[LiterateDataModel.allClasses]
Setting container of <Attribute>:inverseOfClasses to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value Subject (M_1)] to <Attribute>:inverseOfClasses
Setting container of <BaseDataType>:[value Subject] to <DataTypeClause>:[optional value Subject (M_1)]
Setting container of <ClassReference>:Subject to <BaseDataType>:[value Subject]
Setting container of <AttributeName>:inverseOfClasses to <Attribute>:inverseOfClasses
Setting container of <AttributeReference>:[Subject.classes] to <Attribute>:inverseOfClasses
Setting container of <ClassReference>:Subject to <AttributeReference>:[Subject.classes]
Setting container of <AttributeName>:classes to <AttributeReference>:[Subject.classes]
Setting container of <Attribute>:inverseOfBasedOn to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value Class (M_1)] to <Attribute>:inverseOfBasedOn
Setting container of <BaseDataType>:[value Class] to <DataTypeClause>:[optional value Class (M_1)]
Setting container of <ClassReference>:Class to <BaseDataType>:[value Class]
Setting container of <AttributeName>:inverseOfBasedOn to <Attribute>:inverseOfBasedOn
Setting container of <AttributeReference>:[Class.basedOn] to <Attribute>:inverseOfBasedOn
Setting container of <ClassReference>:Class to <AttributeReference>:[Class.basedOn]
Setting container of <AttributeName>:basedOn to <AttributeReference>:[Class.basedOn]
Setting container of <Attribute>:inverseOfSubtypes to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value Class (M_1)] to <Attribute>:inverseOfSubtypes
Setting container of <BaseDataType>:[value Class] to <DataTypeClause>:[optional value Class (M_1)]
Setting container of <ClassReference>:Class to <BaseDataType>:[value Class]
Setting container of <AttributeName>:inverseOfSubtypes to <Attribute>:inverseOfSubtypes
Setting container of <AttributeReference>:[Class.subtypes] to <Attribute>:inverseOfSubtypes
Setting container of <ClassReference>:Class to <AttributeReference>:[Class.subtypes]
Setting container of <AttributeName>:subtypes to <AttributeReference>:[Class.subtypes]
Setting container of <Attribute>:inverseOfClasses to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value Subtyping (M_1)] to <Attribute>:inverseOfClasses
Setting container of <BaseDataType>:[value Subtyping] to <DataTypeClause>:[optional value Subtyping (M_1)]
Setting container of <ClassReference>:Subtyping to <BaseDataType>:[value Subtyping]
Setting container of <AttributeName>:inverseOfClasses to <Attribute>:inverseOfClasses
Setting container of <AttributeReference>:[Subtyping.classes] to <Attribute>:inverseOfClasses
Setting container of <ClassReference>:Subtyping to <AttributeReference>:[Subtyping.classes]
Setting container of <AttributeName>:classes to <AttributeReference>:[Subtyping.classes]
Setting container of <Attribute>:inverseOfCoreClass to <AttributeSection>:Implied Attributes for Class
Setting container of <DataTypeClause>:[optional value SimpleDataTypeSubtpeOfDataType (M_1)] to <Attribute>:inverseOfCoreClass
Setting container of <BaseDataType>:[value SimpleDataTypeSubtpeOfDataType] to <DataTypeClause>:[optional value SimpleDataTypeSubtpeOfDataType (M_1)]
Setting container of <ClassReference>:SimpleDataTypeSubtpeOfDataType to <BaseDataType>:[value SimpleDataTypeSubtpeOfDataType]
Setting container of <AttributeName>:inverseOfCoreClass to <Attribute>:inverseOfCoreClass
Added implied attribute:  Attribute: inverseOfCoreClass  in  Class: Class
... Containees of section are:  ['<Attribute>:inverseOfAllSubjects', '<Attribute>:inverseOfAllClasses', '<Attribute>:inverseOfClasses', '<Attribute>:inverseOfBasedOn', '<Attribute>:inverseOfSubtypes', '<Attribute>:inverseOfClasses', '<Attribute>:inverseOfCoreClass']
... Containees of att are:  ['<DataTypeClause>:[optional value SimpleDataTypeSubtpeOfDataType (M_1)]', '<AttributeName>:inverseOfCoreClass']
... Chain from name is:  <AttributeName>:inverseOfCoreClass -> <Attribute>:inverseOfCoreClass -> <AttributeSection>:Implied Attributes for Class -> <Class>:Class -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from attribute is:  <Attribute>:inverseOfCoreClass -> <AttributeSection>:Implied Attributes for Class -> <Class>:Class -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
... Chain from section is:  <AttributeSection>:Implied Attributes for Class -> <Class>:Class -> <SubjectC>:Classes -> <SubjectB>:The Model and its Subjects -> <LiterateModel>:Literate Data Model
<Attribute>:inverseOfCoreClass contains <DataTypeClause>:[optional value SimpleDataTypeSubtpeOfDataType (M_1)]
	<DataTypeClause>:[optional value SimpleDataTypeSubtpeOfDataType (M_1)] contains <BaseDataType>:[value SimpleDataTypeSubtpeOfDataType]
		<BaseDataType>:[value SimpleDataTypeSubtpeOfDataType] contains <ClassReference>:SimpleDataTypeSubtpeOfDataType
<Attribute>:inverseOfCoreClass contains <AttributeName>:inverseOfCoreClass
validating datatype:   Class
type of datatype is  <class 'Literate_01.BaseDataType'>
in calc attribute, attname is  aggregation
the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Valuetype: ComplexDataType  is  []
Considering ComplexDataType.aggregation for inversion... 
	dtc =  optional  AggregatingOperator (O_O)
	dt  =   AggregatingOperator  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = AggregatingOperator
	Singular for AggregatingOperator is AggregatingOperator
	SKIPPING ComplexDataType.aggregation, a  AggregatingOperator. core type AggregatingOperator is a value type
in calc attribute, attname is  aggregatedTypes
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Valuetype: ComplexDataType  is  []
Considering ComplexDataType.aggregatedTypes for inversion... 
	dtc =  optional List of  DataTypes (O_O)
	dt  =  List of  DataTypes  --  <class 'Literate_01.ListDataType'>
	typename of dt is: ListDataType
	Target type0 = DataTypes
	Singular for DataTypes is DataType
	SKIPPING ComplexDataType.aggregatedTypes, a List of  DataTypes. core type DataType is a value type
validating datatype:   AggregatingOperator
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:  List of  DataTypes
type of datatype is  <class 'Literate_01.ListDataType'>
in calc attribute, attname is  name
the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Valuetype: AggregatingOperator  is  []
Considering AggregatingOperator.name for inversion... 
	dtc =  optional  Code (O_O)
	dt  =   Code  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Code
	SKIPPING inverse for..  No such class as  Code
in calc attribute, attname is  arity
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Valuetype: AggregatingOperator  is  []
Considering AggregatingOperator.arity for inversion... 
	dtc =  optional  Integer (O_O)
	dt  =   Integer  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Integer
	Singular for Integer is Integer
	SKIPPING AggregatingOperator.arity, a  Integer. core type Integer is a value type
in calc attribute, attname is  spelling
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Valuetype: AggregatingOperator  is  []
Considering AggregatingOperator.spelling for inversion... 
	dtc =  optional  Template (O_O)
	dt  =   Template  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Template
	SKIPPING inverse for..  No such class as  Template
validating datatype:   Code
type of datatype is  <class 'Literate_01.BaseDataType'>
	!!! Base type error for  Code  in dt   Code
validating datatype:   Integer
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:   Template
type of datatype is  <class 'Literate_01.BaseDataType'>
	!!! Base type error for  Template  in dt   Template
in calc attribute, attname is  valueTheString
the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
MRO for String =>  ['PrimitiveType']
MRO for CamelName =>  ['String', 'PrimitiveType']
calc attribute override; mro for  Valuetype: CamelName  is  ['String', 'PrimitiveType']
All attributes for Valuetype: String are:  dict_keys([])
All attributes for Valuetype: PrimitiveType are:  dict_keys([])
Considering CamelName.valueTheString for inversion... 
	dtc =  optional  String (O_O)
	dt  =   String  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = String
	Singular for String is String
	SKIPPING CamelName.valueTheString, a  String. core type String is a value type
validating datatype:   String
type of datatype is  <class 'Literate_01.BaseDataType'>
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Constraint'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Constraint'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
in calc attribute, attname is  value
the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
MRO for ValueTypeRichText =>  ['String', 'PrimitiveType']
calc attribute override; mro for  Class: ValueTypeRichText  is  ['String', 'PrimitiveType']
All attributes for Valuetype: String are:  dict_keys([])
All attributes for Valuetype: PrimitiveType are:  dict_keys([])
Considering ValueTypeRichText.value for inversion... 
	dtc =  optional  String (O_O)
	dt  =   String  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = String
	Singular for String is String
	SKIPPING ValueTypeRichText.value, a  String. core type String is a value type
in calc attribute, attname is  format
the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Class: ValueTypeRichText  is  ['String', 'PrimitiveType']
All attributes for Valuetype: String are:  dict_keys([])
All attributes for Valuetype: PrimitiveType are:  dict_keys([])
Considering ValueTypeRichText.format for inversion... 
	dtc =  optional  Code (O_O)
	dt  =   Code  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = Code
	SKIPPING inverse for..  No such class as  Code
validating datatype:   String
type of datatype is  <class 'Literate_01.BaseDataType'>
validating datatype:   Code
type of datatype is  <class 'Literate_01.BaseDataType'>
	!!! Base type error for  Code  in dt   Code
in calc attribute, attname is  value
the_model = Literatemodel: Literate Data Model
In classs_mro, the_model = Literatemodel: Literate Data Model
calc attribute override; mro for  Valuetype: OneLiner  is  []
Considering OneLiner.value for inversion... 
	dtc =  optional  String (O_O)
	dt  =   String  --  <class 'Literate_01.BaseDataType'>
	typename of dt is: BaseDataType
	Target type0 = String
	Singular for String is String
	SKIPPING OneLiner.value, a  String. core type String is a value type
validating datatype:   String
type of datatype is  <class 'Literate_01.BaseDataType'>
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Constraint'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
Seeking <class 'ldm.Literate_01.MinorComponent'> above <class 'Literate_01.Constraint'>. has container = annotation=Union[Container, NoneType] required=False default=None kw_only=True, but that has type  fieldinfo returning none
BUG: <NoneType>:[None] can't handle diagnostics
Call to Validating references...
Before validating:  0  classes in model
Validating references
Validation class refs for  Component with att =  based_on  - has  0
Validation class refs for  Component with att =  dependents  - has  1
Validation class refs for  AnnotationType with att =  based_on  - has  1
Validation class refs for  AnnotationType with att =  dependents  - has  0
Validation class refs for  Annotation with att =  based_on  - has  1
Validation class refs for  Annotation with att =  dependents  - has  0
Validation class refs for  LiterateDataModel with att =  based_on  - has  0
Validation class refs for  LiterateDataModel with att =  dependents  - has  2
Validation class refs for  Subject with att =  based_on  - has  1
Validation class refs for  Subject with att =  dependents  - has  0
Validation class refs for  SubjectArea with att =  based_on  - has  2
Validation class refs for  SubjectArea with att =  dependents  - has  0
Validation class refs for  Class with att =  based_on  - has  0
Validation class refs for  Class with att =  dependents  - has  4
Validation class refs for  Subtyping with att =  based_on  - has  1
Validation class refs for  Subtyping with att =  dependents  - has  0
Validation class refs for  ReferenceType with att =  based_on  - has  0
Validation class refs for  ReferenceType with att =  dependents  - has  0
Validation class refs for  CodeType with att =  based_on  - has  0
Validation class refs for  CodeType with att =  dependents  - has  1
Validation class refs for  CodeValue with att =  based_on  - has  1
Validation class refs for  CodeValue with att =  dependents  - has  0
Validation class refs for  Key with att =  based_on  - has  1
Validation class refs for  Key with att =  dependents  - has  0
Validation class refs for  UniqueKey with att =  based_on  - has  0
Validation class refs for  UniqueKey with att =  dependents  - has  0
Validation class refs for  AttributeSection with att =  based_on  - has  1
Validation class refs for  AttributeSection with att =  dependents  - has  1
Validation class refs for  Attribute with att =  based_on  - has  1
Validation class refs for  Attribute with att =  dependents  - has  1
Validation class refs for  Derivation with att =  based_on  - has  0
Validation class refs for  Derivation with att =  dependents  - has  0
Validation class refs for  Constraint with att =  based_on  - has  0
Validation class refs for  Constraint with att =  dependents  - has  0
Validation class refs for  ClassConstraint with att =  based_on  - has  1
Validation class refs for  ClassConstraint with att =  dependents  - has  0
Validation class refs for  AttributeConstraint with att =  based_on  - has  1
Validation class refs for  AttributeConstraint with att =  dependents  - has  0
Validation class refs for  Method with att =  based_on  - has  0
Validation class refs for  Method with att =  dependents  - has  0
Validation class refs for  ParameterAnInputToAMethod with att =  based_on  - has  0
Validation class refs for  ParameterAnInputToAMethod with att =  dependents  - has  0
Validation class refs for  Message with att =  based_on  - has  0
Validation class refs for  Message with att =  dependents  - has  0
Validation class refs for  CodeExpression with att =  based_on  - has  0
Validation class refs for  CodeExpression with att =  dependents  - has  0
Validation class refs for  DataType with att =  based_on  - has  0
Validation class refs for  DataType with att =  dependents  - has  0
Validation class refs for  SimpleDataTypeSubtpeOfDataType with att =  based_on  - has  0
Validation class refs for  SimpleDataTypeSubtpeOfDataType with att =  dependents  - has  0
Validation class refs for  ComplexDataType with att =  based_on  - has  0
Validation class refs for  ComplexDataType with att =  dependents  - has  0
Validation class refs for  AggregatingOperator with att =  based_on  - has  0
Validation class refs for  AggregatingOperator with att =  dependents  - has  0
Validation class refs for  Emoji with att =  based_on  - has  0
Validation class refs for  Emoji with att =  dependents  - has  0
Validation class refs for  String with att =  based_on  - has  0
Validation class refs for  String with att =  dependents  - has  0
Validation class refs for  CamelName with att =  based_on  - has  0
Validation class refs for  CamelName with att =  dependents  - has  0
Validation class refs for  UpperCamel with att =  based_on  - has  0
Validation class refs for  UpperCamel with att =  dependents  - has  0
Validation class refs for  LowerCamel with att =  based_on  - has  0
Validation class refs for  LowerCamel with att =  dependents  - has  0
Validation class refs for  QualifiedCamel with att =  based_on  - has  0
Validation class refs for  QualifiedCamel with att =  dependents  - has  0
Validation class refs for  ValueTypeRichText with att =  based_on  - has  0
Validation class refs for  ValueTypeRichText with att =  dependents  - has  0
Validation class refs for  OneLiner with att =  based_on  - has  0
Validation class refs for  OneLiner with att =  dependents  - has  0
Validation class refs for  PrimitiveType with att =  based_on  - has  0
Validation class refs for  PrimitiveType with att =  dependents  - has  0
Validation class refs for  String with att =  based_on  - has  0
Validation class refs for  String with att =  dependents  - has  0
Validation class refs for  Integer with att =  based_on  - has  0
Validation class refs for  Integer with att =  dependents  - has  0
Validation class refs for  Decimal with att =  based_on  - has  0
Validation class refs for  Decimal with att =  dependents  - has  0
Validation class refs for  Boolean with att =  based_on  - has  0
Validation class refs for  Boolean with att =  dependents  - has  0
Validation class refs for  Date with att =  based_on  - has  0
Validation class refs for  Date with att =  dependents  - has  0
Validation class refs for  Time with att =  based_on  - has  0
Validation class refs for  Time with att =  dependents  - has  0
Validation class refs for  DateTime with att =  based_on  - has  0
Validation class refs for  DateTime with att =  dependents  - has  0
After validating:  0  classes in model
Validation diagnostics: 92
- Bug (InvalidFieldType) on Default named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Bug (InvalidFieldType) on Constraint named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Warning (Style) on Attribute named oneLiner: oneLiner is too long. (116 chars).
- Error (InvalidBaseType) on BaseDataType named : RichText is not a class name - or plural
- Warning (Style) on Attribute named isEmbellishment: oneLiner is too long. (91 chars).
- Bug (InvalidFieldType) on Default named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Warning (Style) on Class named AnnotationType: oneLiner is too long. (96 chars).
- Bug (InvalidFieldType) on Default named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Warning (Style) on AttributeSection named Implied Attributes for Annotation Type: name is too long. (38 chars).
- Bug (InvalidFieldType) on Default named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Bug (InvalidFieldType) on Default named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Error (InvalidBaseType) on BaseDataType named : RichText is not a class name - or plural
- Warning (Style) on Attribute named isEmbellishment: oneLiner is too long. (92 chars).
- Bug (InvalidFieldType) on Default named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Warning (Style) on AttributeSection named Implied Attributes for Annotation: name is too long. (33 chars).
- Warning (Style) on Class named LiterateDataModel: oneLiner is too long. (112 chars).
- Bug (InvalidFieldType) on Derivation named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Error (MissingValue) on Constraint named : Missing value for required field: 'ocl'
- Bug (InvalidFieldType) on Constraint named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Bug (InvalidFieldType) on Derivation named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Error (MissingValue) on Constraint named : Missing value for required field: 'ocl'
- Bug (InvalidFieldType) on Constraint named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Error (InvalidBaseType) on BaseDataType named : CodingLanguage is not a class name - or plural
- Bug (InvalidFieldType) on Default named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Error (InvalidBaseType) on ListDataType named : CodingLanguages is not a class name - or plural
- Error (InvalidBaseType) on BaseDataType named : TemplateLanguage is not a class name - or plural
- Bug (InvalidFieldType) on Default named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Error (InvalidBaseType) on ListDataType named : TemplateLanguages is not a class name - or plural
- Bug (InvalidFieldType) on Derivation named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Bug (MissingValue) on Class named LiterateDataModel: Required field 'presumed_plural' is missing
- Warning (Style) on Attribute named classes: oneLiner is too long. (91 chars).
- Warning (Style) on Attribute named childSubjects: oneLiner is too long. (94 chars).
- Bug (MissingValue) on Class named Subject: Required field 'presumed_plural' is missing
- Warning (Style) on AttributeSection named Implied Attributes for Subject Area: name is too long. (35 chars).
- Error (InvalidBaseType) on BaseDataType named : LiterateModel is not a class name - or plural
- Warning (Style) on AttributeSection named Implied Attributes for Subject Area: name is too long. (35 chars).
- Error (InvalidBaseType) on BaseDataType named : Xyz is not a class name - or plural
- Bug (MissingValue) on Class named SubjectArea: Required field 'presumed_plural' is missing
- Error (MissingValue) on Constraint named : Missing value for required field: 'ocl'
- Bug (InvalidFieldType) on Default named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Error (InvalidBaseType) on BaseDataType named : Es is not a class name - or plural
- Warning (Style) on Attribute named attributes: oneLiner is too long. (91 chars).
- Bug (MissingValue) on Class named Class: Required field 'presumed_plural' is missing
- Bug (InvalidFieldType) on Default named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Bug (InvalidFieldType) on Default named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Warning (Style) on AttributeSection named Implied Attributes for Subtyping: name is too long. (32 chars).
- Error (InvalidBaseType) on BaseDataType named : NameString is not a class name - or plural
- Error (InvalidBaseType) on BaseDataType named : RichText is not a class name - or plural
- Warning (Style) on AttributeSection named Implied Attributes for Code Value: name is too long. (33 chars).
- Error (MissingValue) on Constraint named : Missing value for required field: 'ocl'
- Bug (InvalidFieldType) on Constraint named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Error (MissingValue) on Constraint named : Missing value for required field: 'ocl'
- Bug (InvalidFieldType) on Constraint named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Warning (Style) on AttributeSection named Implied Attributes for Attribute Section: name is too long. (40 chars).
- Warning (Style) on AttributeSection named Implied Attributes for Attribute Section: name is too long. (40 chars).
- Bug (InvalidFieldType) on Default named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Error (InvalidBaseType) on BaseDataType named : CardinalityCode is not a class name - or plural
- Warning (Style) on Default named : Formula one_liner is too long (220 chars)
- Bug (InvalidFieldType) on Default named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Error (InvalidBaseType) on BaseDataType named : InventedName is not a class name - or plural
- Error (InvalidBaseType) on BaseDataType named : InventedName is not a class name - or plural
- Bug (InvalidFieldType) on Derivation named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Bug (InvalidFieldType) on Derivation named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Warning (Style) on Attribute named default: oneLiner is too long. (143 chars).
- Bug (MissingValue) on Attribute named overrides: Required field 'data_type_clause' is missing
- Warning (Style) on AttributeSection named Implied Attributes for Attribute: name is too long. (32 chars).
- Bug (MissingValue) on Class named Attribute: Required field 'presumed_plural' is missing
- Error (InvalidBaseType) on BaseDataType named : RichText is not a class name - or plural
- Bug (MissingValue) on ValueType named Derivation: Required field 'presumed_plural' is missing
- Error (InvalidBaseType) on BaseDataType named : RichText is not a class name - or plural
- Error (InvalidBaseType) on BaseDataType named : InventedName is not a class name - or plural
- Error (InvalidBaseType) on BaseDataType named : Code is not a class name - or plural
- Bug (MissingValue) on ValueType named Constraint: Required field 'presumed_plural' is missing
- Warning (Style) on AttributeSection named Implied Attributes for Class Constraint: name is too long. (39 chars).
- Warning (Style) on AttributeSection named Implied Attributes for Attribute Constraint: name is too long. (43 chars).
- Bug (MissingValue) on Class named Method: Required field 'presumed_plural' is missing
- Error (InvalidBaseType) on BaseDataType named : InventedName is not a class name - or plural
- Warning (Style) on AttributeSection named Implied Attributes for Parameter An Input To A Method: name is too long. (53 chars).
- Bug (MissingValue) on Class named ParameterAnInputToAMethod: Required field 'presumed_plural' is missing
- Error (InvalidBaseType) on BaseDataType named : Code is not a class name - or plural
- Error (InvalidBaseType) on BaseDataType named : Code is not a class name - or plural
- Error (InvalidBaseType) on BaseDataType named : Template is not a class name - or plural
- Error (MissingValue) on Constraint named : Missing value for required field: 'ocl'
- Bug (InvalidFieldType) on Constraint named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Warning (Style) on Constraint named : Formula one_liner is too long (129 chars)
- Error (MissingValue) on Constraint named : Missing value for required field: 'ocl'
- Error (InvalidBaseType) on BaseDataType named : Code is not a class name - or plural
- Error (MissingValue) on Constraint named : Missing value for required field: 'ocl'
- Bug (InvalidFieldType) on Constraint named : For field 'container' - expected typing.Optional[utils.class_container.Container], but got <class 'pydantic.fields.FieldInfo'>
- Warning (Style) on SubjectB named Appendices: oneLiner is too long. (126 chars).
- Error (InvalidClassReference) on Class named SubjectArea: Invalid reference to 'LiterateModel' in based_on
- Error (InvalidClassReference) on Class named SubjectArea: Invalid reference to 'Xyz' in based_on
..Created dict for validated model: ldm/ldm_models/Literate/Literate_results/Literate_PD_04.v_model.yaml

Phase: counting diagnostics
92 	 All Diagnostics
13 	 Bug - Default - InvalidFieldType- NoConstraintName
7 	 Bug - Constraint - InvalidFieldType- NoConstraintName
7 	 Warning - Attribute - Style- checkOneLinerLength
21 	 Error - BaseDataType - InvalidBaseType- checkClassReference
2 	 Warning - Class - Style- checkOneLinerLength
12 	 Warning - AttributeSection - Style- NoConstraintName
5 	 Bug - Derivation - InvalidFieldType- NoConstraintName
8 	 Error - Constraint - MissingValue- NoConstraintName
2 	 Error - ListDataType - InvalidBaseType- checkClassReference
7 	 Bug - Class - MissingValue- NoConstraintName
1 	 Warning - Default - Style- NoConstraintName
1 	 Bug - Attribute - MissingValue- NoConstraintName
2 	 Bug - ValueType - MissingValue- NoConstraintName
1 	 Warning - Constraint - Style- NoConstraintName
1 	 Warning - SubjectB - Style- checkOneLinerLength
2 	 Error - Class - InvalidClassReference- checkListedClassReference
pattern is ldm/ldm_models/Literate/Literate_results/*dict*.yaml
pattern is ldm/ldm_models/Literate/Literate_results/*model*.yaml
Dict names are:  ['Literate_PD_02.dict.yaml', 'Literate_PD_03.model.yaml', 'Literate_PD_04.v_model.yaml']
All combos are:
['Literate_PD_02.dict.yaml', 'Literate_PD_03.model.yaml']
['Literate_PD_03.model.yaml', 'Literate_PD_04.v_model.yaml']
Combo is: ['Literate_PD_02.dict.yaml', 'Literate_PD_03.model.yaml']
Including:  Literate_PD_02.dict.yaml
Including:  Literate_PD_03.model.yaml
Combo is: ['Literate_PD_03.model.yaml', 'Literate_PD_04.v_model.yaml']
Including:  Literate_PD_03.model.yaml
Including:  Literate_PD_04.v_model.yaml

Phase: Create extract for diagrams
Registered as_extract for object
Registered as_extract for LiterateModel
Registered as_extract for Class
Faculty class Extractors created
Faculty patches setup:
  Component.validate -> validate_component
  Component.as_html -> component_html
  LiterateModel.validate -> validate_literate_model
  LiterateModel.as_html -> literate_model_html
  LiterateModel.as_extract -> model_extract
  SubjectE.validate -> validate_subject_e
  SubjectE.as_html -> subject_html
  Class.validate -> validate_class
  Class.as_html -> class_html
  Class.as_extract -> class_extract
  AttributeSection.validate -> validate_attribute_section
  AttributeSection.as_html -> attribute_section_html
  Attribute.validate -> validate_attribute
  Attribute.as_html -> attribute_html
  Formula.validate -> validate_formula
  Formula.as_html -> formula_html
  Constraint.validate -> validate_constraint
  object.as_html -> any_html
  object.as_extract -> any_extract
  Paragraph.as_html -> paragraph_html
  OneLiner.as_html -> one_liner_html
  CodeBlock.as_html -> code_block_html
  str.as_html -> str_html
  list.as_html -> list_html
  Annotation.as_html -> annotation_html
  Emoji.as_html -> emoji_html
  Casing.as_html -> casing_html
  ClassName.as_html -> class_name_html
  ClassReference.as_html -> class_reference_html
  SubtypeBy.as_html -> subtype_by_html
  DataTypeClause.as_html -> dtc_html
  BaseDataType.as_html -> bdt_html
  ListDataType.as_html -> ldt_html
  SetDataType.as_html -> sdt_as_html
  MappingDataType.as_html -> mdt_html
  IsOptional.as_html -> is_optional_html
  AsValue.as_html -> as_value_html
  Diagnostic.as_html -> diagnostic_html
  Subtyping.as_html -> subtyping_html
  AttributeName.as_html -> attribute_name_html
  AttributeReference.as_html -> attribute_reference_html
Created Extractprs() =  <ldm.ldm_extractors.Extractors object at 0x00000259F4DD2120>
Patches are...
Function validate_component registered as validate for target Component
Function component_html registered as as_html for target Component
Function validate_literate_model registered as validate for target LiterateModel
Function literate_model_html registered as as_html for target LiterateModel
Function model_extract registered as as_extract for target LiterateModel
Function validate_subject_e registered as validate for target SubjectE
Function subject_html registered as as_html for target SubjectE
Function validate_class registered as validate for target Class
Function class_html registered as as_html for target Class
Function class_extract registered as as_extract for target Class
Function validate_attribute_section registered as validate for target AttributeSection
Function attribute_section_html registered as as_html for target AttributeSection
Function validate_attribute registered as validate for target Attribute
Function attribute_html registered as as_html for target Attribute
Function validate_formula registered as validate for target Formula
Function formula_html registered as as_html for target Formula
Function validate_constraint registered as validate for target Constraint
Function any_html registered as as_html for target object
Function any_extract registered as as_extract for target object
Function paragraph_html registered as as_html for target Paragraph
Function one_liner_html registered as as_html for target OneLiner
Function code_block_html registered as as_html for target CodeBlock
Function str_html registered as as_html for target str
Function list_html registered as as_html for target list
Function annotation_html registered as as_html for target Annotation
Function emoji_html registered as as_html for target Emoji
Function casing_html registered as as_html for target Casing
Function class_name_html registered as as_html for target ClassName
Function class_reference_html registered as as_html for target ClassReference
Function subtype_by_html registered as as_html for target SubtypeBy
Function dtc_html registered as as_html for target DataTypeClause
Function bdt_html registered as as_html for target BaseDataType
Function ldt_html registered as as_html for target ListDataType
Function sdt_as_html registered as as_html for target SetDataType
Function mdt_html registered as as_html for target MappingDataType
Function is_optional_html registered as as_html for target IsOptional
Function as_value_html registered as as_html for target AsValue
Function diagnostic_html registered as as_html for target Diagnostic
Function subtyping_html registered as as_html for target Subtyping
Function attribute_name_html registered as as_html for target AttributeName
Function attribute_reference_html registered as as_html for target AttributeReference
Subjectb: Preliminaries doesn't look Trivial, but ascending...
Literatemodel: Literate Data Model is NOT Trivial!
extracting  Class: Component
Found the model?  Literatemodel: Literate Data Model
Base type names for  String are ['String']
Subjectb: Trivial Low level Data Types is Trivial!
extract skipping attribute - normalName - target type String is trivial
Base type names for  CamelName are ['CamelName']
extract skipping attribute - name - target type CamelName is trivial
Base type names for  QualifiedCamel are ['QualifiedCamel']
extract skipping attribute - qualifiedName - target type QualifiedCamel is trivial
Base type names for  CamelName are ['CamelName']
extract skipping attribute - abbreviatedName - target type CamelName is trivial
Base type names for  OneLiner are ['OneLiner']
extract skipping attribute - oneLiner - target type OneLiner is trivial
Base type names for  RichText are ['RichText']
extract skipping attribute - elaboration - target type RichText does not name a class
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isEmbellishment - target type Boolean is trivial
Extract is  {'_type': 'Class', 'name': 'Component', 'edges': []}
extracting  Class: AnnotationType
Found the model?  Literatemodel: Literate Data Model
Cardinality is 'M:1'
Base type names for  Emoji are ['Emoji']
extract skipping attribute - emoji - target type Emoji is trivial
Base type names for  String are ['String']
extract skipping attribute - emojiName - target type String is trivial
Base type names for  String are ['String']
extract skipping attribute - emojiUnicode - target type String is trivial
Base type names for  LowerCamel are ['LowerCamel']
extract skipping attribute - label - target type LowerCamel is trivial
Base type names for  UpperCamel are ['UpperCamel']
extract skipping attribute - plural - target type UpperCamel is trivial
Base type names for  OneLiner are ['OneLiner']
extract skipping attribute - purpose - target type OneLiner is trivial
Extract is  {'_type': 'Class', 'name': 'AnnotationType', 'edges': [{'relation': 'based_on', 'to': 'LiterateDataModel', 'cardinality': 'M:1'}]}
extracting  Class: Annotation
Found the model?  Literatemodel: Literate Data Model
Cardinality is 'M:1'
Base type names for  AnnotationType are ['AnnotationType']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Base type names for  CamelName are ['CamelName']
extract skipping attribute - label - target type CamelName is trivial
Base type names for  Emoji are ['Emoji']
extract skipping attribute - emoji - target type Emoji is trivial
Base type names for  RichText are ['RichText']
extract skipping attribute - content - target type RichText does not name a class
Extract is  {'_type': 'Class', 'name': 'Annotation', 'edges': [{'relation': 'based_on', 'to': 'Component', 'cardinality': 'M:1'}, {'relation': 'annotationType', 'to': 'AnnotationType', 'cardinality': 'O_O'}]}
Subjectb: The Model and its Subjects doesn't look Trivial, but ascending...
extracting  Class: LiterateDataModel
Found the model?  Literatemodel: Literate Data Model
Cardinality is '1:1'
Base type names for  UpperCamel are ['UpperCamel']
extract skipping attribute - name - target type UpperCamel is trivial
Base type names for List of  Classes are ['Classes']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Base type names for List of  Classes are ['Classes']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Extract is  {'_type': 'Class', 'name': 'LiterateDataModel', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'allSubjects', 'to': 'Classes', 'cardinality': 'O_O'}, {'relation': 'allClasses', 'to': 'Classes', 'cardinality': 'O_O'}]}
extracting  Class: Subject
Found the model?  Literatemodel: Literate Data Model
Cardinality is '1:1'
Cardinality is 'M:1'
Base type names for  UpperCamel are ['UpperCamel']
extract skipping attribute - name - target type UpperCamel is trivial
Base type names for  Subject are ['Subject']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Base type names for List of  Classes are ['Classes']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Base type names for List of  Subjects are ['Subjects']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Extract is  {'_type': 'Class', 'name': 'Subject', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'LiterateDataModel', 'cardinality': 'M:1'}, {'relation': 'parentSubject', 'to': 'Subject', 'cardinality': 'O_O'}, {'relation': 'classes', 'to': 'Classes', 'cardinality': 'O_O'}, {'relation': 'childSubjects', 'to': 'Subjects', 'cardinality': 'O_O'}]}
extracting  Class: SubjectArea
Found the model?  Literatemodel: Literate Data Model
Cardinality is '1:1'
Cardinality is 'M:1'
Cardinality is 'M:1'
Extract is  {'_type': 'Class', 'name': 'SubjectArea', 'edges': [{'relation': 'subtype_of', 'to': 'Subject', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'LiterateModel', 'cardinality': 'M:1'}, {'relation': 'based_on', 'to': 'Xyz', 'cardinality': 'M:1'}]}
extracting  Class: Class
Found the model?  Literatemodel: Literate Data Model
Cardinality is '1:1'
Base type names for  UpperCamel are ['UpperCamel']
extract skipping attribute - pluralForm - target type UpperCamel is trivial
Base type names for Set of  Class are ['Class']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Base type names for  Es are ['Es']
extract skipping attribute - supertypes - target type Es does not name a class
Base type names for List of  Subtypings are ['Subtypings']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Base type names for List of  Classes are ['Classes']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Base type names for List of  Attributes are ['Attributes']
Subjectb: Attributes doesn't look Trivial, but ascending...
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Base type names for List of  AttributeSections are ['AttributeSections']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Base type names for List of  Constraints are ['Constraints']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Base type names for List of  Methods are ['Methods']
Subjectb: Methods doesn't look Trivial, but ascending...
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Extract is  {'_type': 'Class', 'name': 'Class_', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'basedOn', 'to': 'Class_', 'cardinality': 'O_O'}, {'relation': 'subtypings', 'to': 'Subtypings', 'cardinality': 'O_O'}, {'relation': 'subtypes', 'to': 'Classes', 'cardinality': 'O_O'}, {'relation': 'attributes', 'to': 'Attributes', 'cardinality': 'O_O'}, {'relation': 'attributeSections', 'to': 'AttributeSections', 'cardinality': 'O_O'}, {'relation': 'constraints', 'to': 'Constraints', 'cardinality': 'O_O'}, {'relation': 'methods', 'to': 'Methods', 'cardinality': 'O_O'}]}
extracting  Class: Subtyping
Found the model?  Literatemodel: Literate Data Model
Cardinality is 'M:1'
Base type names for  LowerCamel are ['LowerCamel']
extract skipping attribute - name - target type LowerCamel is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isExclusive - target type Boolean is trivial
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isExhaustive - target type Boolean is trivial
Base type names for List of  Classes are ['Classes']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Extract is  {'_type': 'Class', 'name': 'Subtyping', 'edges': [{'relation': 'based_on', 'to': 'Class_', 'cardinality': 'M:1'}, {'relation': 'classes', 'to': 'Classes', 'cardinality': 'O_O'}]}
extracting  Class: ReferenceType
Found the model?  Literatemodel: Literate Data Model
Cardinality is '1:1'
Extract is  {'_type': 'Class', 'name': 'ReferenceType', 'edges': [{'relation': 'subtype_of', 'to': 'Class_', 'cardinality': '1:1'}]}
extracting  Valuetype: CodeType
Found the model?  Literatemodel: Literate Data Model
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isCaptive - target type Boolean is trivial
Extract is  {'_type': 'ValueType', 'name': 'CodeType', 'edges': []}
extracting  Valuetype: CodeValue
Found the model?  Literatemodel: Literate Data Model
Cardinality is 'M:1'
Base type names for  NameString are ['NameString']
extract skipping attribute - code - target type NameString does not name a class
Base type names for  RichText are ['RichText']
extract skipping attribute - description - target type RichText does not name a class
Extract is  {'_type': 'ValueType', 'name': 'CodeValue', 'edges': [{'relation': 'based_on', 'to': 'CodeType', 'cardinality': 'M:1'}]}
extracting  Class: Key
Found the model?  Literatemodel: Literate Data Model
Cardinality is '1:1'
Cardinality is 'M:1'
Base type names for List of  Attributes are ['Attributes']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Extract is  {'_type': 'Class', 'name': 'Key', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'Class_', 'cardinality': 'M:1'}, {'relation': 'keyAttributes', 'to': 'Attributes', 'cardinality': 'O_O'}]}
extracting  Class: UniqueKey
Found the model?  Literatemodel: Literate Data Model
Cardinality is '1:1'
Extract is  {'_type': 'Class', 'name': 'UniqueKey', 'edges': [{'relation': 'subtype_of', 'to': 'Key', 'cardinality': '1:1'}]}
extracting  Class: AttributeSection
Found the model?  Literatemodel: Literate Data Model
Cardinality is '1:1'
Cardinality is 'M:1'
Base type names for  Boolean are ['Boolean']
extract skipping attribute - isOptional - target type Boolean is trivial
Extract is  {'_type': 'Class', 'name': 'AttributeSection', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'Class_', 'cardinality': 'M:1'}]}
extracting  Class: Attribute
Found the model?  Literatemodel: Literate Data Model
Cardinality is '1:1'
Cardinality is 'M:1'
Base type names for  LowerCamel are ['LowerCamel']
extract skipping attribute - name - target type LowerCamel is trivial
Base type names for  DataType are ['DataType']
Subjectb: Trivial Data Types is Trivial!
extract skipping attribute - dataType - target type DataType is trivial
Extract is  {'_type': 'Class', 'name': 'Attribute', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'AttributeSection', 'cardinality': 'M:1'}]}
extracting  Valuetype: Derivation
Found the model?  Literatemodel: Literate Data Model
Base type names for  RichText are ['RichText']
extract skipping attribute - statement - target type RichText does not name a class
Base type names for  CodeExpression are ['CodeExpression']
extract skipping attribute - expression - target type CodeExpression is trivial
Extract is  {'_type': 'ValueType', 'name': 'Derivation', 'edges': []}
extracting  Valuetype: Constraint
Found the model?  Literatemodel: Literate Data Model
Cardinality is '1:1'
Base type names for  RichText are ['RichText']
extract skipping attribute - statement - target type RichText does not name a class
Base type names for value InventedName are ['InventedName']
extract skipping attribute - expression - target type InventedName does not name a class
Base type names for  Code are ['Code']
extract skipping attribute - severity - target type Code does not name a class
Extract is  {'_type': 'ValueType', 'name': 'Constraint', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}]}
extracting  Valuetype: ClassConstraint
Found the model?  Literatemodel: Literate Data Model
Cardinality is '1:1'
Cardinality is 'M:1'
Extract is  {'_type': 'ValueType', 'name': 'ClassConstraint', 'edges': [{'relation': 'subtype_of', 'to': 'Constraint', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'Class_', 'cardinality': 'M:1'}]}
extracting  Valuetype: AttributeConstraint
Found the model?  Literatemodel: Literate Data Model
Cardinality is '1:1'
Cardinality is 'M:1'
Extract is  {'_type': 'ValueType', 'name': 'AttributeConstraint', 'edges': [{'relation': 'subtype_of', 'to': 'Constraint', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'Attribute', 'cardinality': 'M:1'}]}
extracting  Class: Method
Found the model?  Literatemodel: Literate Data Model
Cardinality is '1:1'
Base type names for List of  Parameters are ['Parameters']
Cardinality is <Cardinality.ONE_ONE: 'O_O'>
Base type names for  DataType are ['DataType']
extract skipping attribute - returnType - target type DataType is trivial
Extract is  {'_type': 'Class', 'name': 'Method', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'parameters', 'to': 'Parameters', 'cardinality': 'O_O'}]}
extracting  Class: ParameterAnInputToAMethod
Found the model?  Literatemodel: Literate Data Model
Cardinality is '1:1'
Base type names for  DataType are ['DataType']
extract skipping attribute - type - target type DataType is trivial
Base type names for value InventedName are ['InventedName']
extract skipping attribute - cardinality - target type InventedName does not name a class
Extract is  {'_type': 'Class', 'name': 'ParameterAnInputToAMethod', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}]}
Extract skipping trivial class (is_istrivial) Message
Extract skipping trivial class (is_istrivial) CodeExpression
Extract skipping trivial class (is_istrivial) DataType
Extract skipping trivial class (is_istrivial) SimpleDataTypeSubtpeOfDataType
Extract skipping trivial class (is_istrivial) ComplexDataType
Extract skipping trivial class (is_istrivial) AggregatingOperator
Extract skipping trivial class (is_istrivial) Emoji
Extract skipping trivial class (is_istrivial) String
Extract skipping trivial class (is_istrivial) CamelName
Extract skipping trivial class (is_istrivial) UpperCamel
Extract skipping trivial class (is_istrivial) LowerCamel
Extract skipping trivial class (is_istrivial) QualifiedCamel
Extract skipping trivial class (is_istrivial) ValueTypeRichText
Extract skipping trivial class (is_istrivial) OneLiner
Extract skipping trivial class (is_istrivial) PrimitiveType
Extract skipping trivial class (is_istrivial) String
Extract skipping trivial class (is_istrivial) Integer
Extract skipping trivial class (is_istrivial) Decimal
Extract skipping trivial class (is_istrivial) Boolean
Extract skipping trivial class (is_istrivial) Date
Extract skipping trivial class (is_istrivial) Time
Extract skipping trivial class (is_istrivial) DateTime
And the extract is....
{'_type': 'LiterateModel', 'name': 'Literate Data Model', 'classes': [{'_type': 'Class', 'name': 'Component', 'edges': []}, {'_type': 'Class', 'name': 'AnnotationType', 'edges': [{'relation': 'based_on', 'to': 'LiterateDataModel', 'cardinality': 'M:1'}]}, {'_type': 'Class', 'name': 'Annotation', 'edges': [{'relation': 'based_on', 'to': 'Component', 'cardinality': 'M:1'}, {'relation': 'annotationType', 'to': 'AnnotationType', 'cardinality': 'O_O'}]}, {'_type': 'Class', 'name': 'LiterateDataModel', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'allSubjects', 'to': 'Classes', 'cardinality': 'O_O'}, {'relation': 'allClasses', 'to': 'Classes', 'cardinality': 'O_O'}]}, {'_type': 'Class', 'name': 'Subject', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'LiterateDataModel', 'cardinality': 'M:1'}, {'relation': 'parentSubject', 'to': 'Subject', 'cardinality': 'O_O'}, {'relation': 'classes', 'to': 'Classes', 'cardinality': 'O_O'}, {'relation': 'childSubjects', 'to': 'Subjects', 'cardinality': 'O_O'}]}, {'_type': 'Class', 'name': 'SubjectArea', 'edges': [{'relation': 'subtype_of', 'to': 'Subject', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'LiterateModel', 'cardinality': 'M:1'}, {'relation': 'based_on', 'to': 'Xyz', 'cardinality': 'M:1'}]}, {'_type': 'Class', 'name': 'Class_', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'basedOn', 'to': 'Class_', 'cardinality': 'O_O'}, {'relation': 'subtypings', 'to': 'Subtypings', 'cardinality': 'O_O'}, {'relation': 'subtypes', 'to': 'Classes', 'cardinality': 'O_O'}, {'relation': 'attributes', 'to': 'Attributes', 'cardinality': 'O_O'}, {'relation': 'attributeSections', 'to': 'AttributeSections', 'cardinality': 'O_O'}, {'relation': 'constraints', 'to': 'Constraints', 'cardinality': 'O_O'}, {'relation': 'methods', 'to': 'Methods', 'cardinality': 'O_O'}]}, {'_type': 'Class', 'name': 'Subtyping', 'edges': [{'relation': 'based_on', 'to': 'Class_', 'cardinality': 'M:1'}, {'relation': 'classes', 'to': 'Classes', 'cardinality': 'O_O'}]}, {'_type': 'Class', 'name': 'ReferenceType', 'edges': [{'relation': 'subtype_of', 'to': 'Class_', 'cardinality': '1:1'}]}, {'_type': 'ValueType', 'name': 'CodeType', 'edges': []}, {'_type': 'ValueType', 'name': 'CodeValue', 'edges': [{'relation': 'based_on', 'to': 'CodeType', 'cardinality': 'M:1'}]}, {'_type': 'Class', 'name': 'Key', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'Class_', 'cardinality': 'M:1'}, {'relation': 'keyAttributes', 'to': 'Attributes', 'cardinality': 'O_O'}]}, {'_type': 'Class', 'name': 'UniqueKey', 'edges': [{'relation': 'subtype_of', 'to': 'Key', 'cardinality': '1:1'}]}, {'_type': 'Class', 'name': 'AttributeSection', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'Class_', 'cardinality': 'M:1'}]}, {'_type': 'Class', 'name': 'Attribute', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'AttributeSection', 'cardinality': 'M:1'}]}, {'_type': 'ValueType', 'name': 'Derivation', 'edges': []}, {'_type': 'ValueType', 'name': 'Constraint', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}]}, {'_type': 'ValueType', 'name': 'ClassConstraint', 'edges': [{'relation': 'subtype_of', 'to': 'Constraint', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'Class_', 'cardinality': 'M:1'}]}, {'_type': 'ValueType', 'name': 'AttributeConstraint', 'edges': [{'relation': 'subtype_of', 'to': 'Constraint', 'cardinality': '1:1'}, {'relation': 'based_on', 'to': 'Attribute', 'cardinality': 'M:1'}]}, {'_type': 'Class', 'name': 'Method', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}, {'relation': 'parameters', 'to': 'Parameters', 'cardinality': 'O_O'}]}, {'_type': 'Class', 'name': 'ParameterAnInputToAMethod', 'edges': [{'relation': 'subtype_of', 'to': 'Component', 'cardinality': '1:1'}]}]}

Phase: Validating to JSON Schema
Schema path is:  ldm/ldm_models/Literate/Literate_results/LiterateMeta/LiterateMetaModel_01_PD_schema.yaml
Object  path is:  ldm/ldm_models/Literate/Literate_results/Literate_PD_04.v_model.yaml
140  validation errors found!
Error at path: ['subjects', 0, 'classes', 0, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 3, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 4, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 5, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 6, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 7, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 8, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 9, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 10, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 11, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 12, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 13, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 14, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 15, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 16, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 17, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 18, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 19, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 20, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 21, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 22, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 23, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 24, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 25, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 26, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 27, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 28, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 29, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 30, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 31, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 0, 'attributes', 32, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 1, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 1, 'attribute_sections', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 1, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 1, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 1, 'attributes', 3, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 1, 'attributes', 4, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 1, 'attributes', 5, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 2, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 2, 'attribute_sections', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 2, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 2, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 2, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 0, 'classes', 2, 'attributes', 3, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 0, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 0, 'attribute_sections', 0, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 0, 'attribute_sections', 0, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 0, 'attribute_sections', 0, 'attributes', 3, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 0, 'attribute_sections', 0, 'attributes', 4, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 0, 'attribute_sections', 0, 'attributes', 5, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 0, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 0, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 1, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 1, 'attribute_sections', 0, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 1, 'attribute_sections', 0, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 1, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 1, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 1, 'attributes', 3, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 2, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'classes', 2, 'attribute_sections', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attribute_sections', 0, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attribute_sections', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attribute_sections', 1, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attribute_sections', 1, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attribute_sections', 1, 'attributes', 3, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attribute_sections', 1, 'attributes', 4, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attribute_sections', 1, 'attributes', 5, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attribute_sections', 1, 'attributes', 6, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attributes', 3, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attributes', 4, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attributes', 5, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attributes', 6, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attributes', 7, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 0, 'attributes', 8, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 1, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 1, 'attribute_sections', 0, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 1, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 1, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 1, 'attributes', 3, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 3, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 4, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 4, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 4, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 5, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 1, 'subjects', 0, 'classes', 5, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 0, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 0, 'attribute_sections', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 0, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 0, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 0, 'attributes', 3, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 1, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 1, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 1, 'attributes', 3, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 2, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 2, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 2, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 4, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 4, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attribute_sections', 4, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 1, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 2, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 2, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 3, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 3, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 3, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 4, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 2, 'classes', 5, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 3, 'classes', 0, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 3, 'classes', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 3, 'classes', 0, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 3, 'classes', 1, 'attribute_sections', 0, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['M_1'] is not valid under any of the given schemas

Error at path: ['subjects', 3, 'classes', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 3, 'classes', 1, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 4, 'classes', 1, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 4, 'classes', 1, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 4, 'classes', 3, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 4, 'classes', 4, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 4, 'classes', 4, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 4, 'classes', 5, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 4, 'classes', 5, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 4, 'classes', 5, 'attributes', 2, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 5, 'classes', 2, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 5, 'classes', 6, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 5, 'classes', 6, 'attributes', 1, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

Error at path: ['subjects', 5, 'classes', 7, 'attributes', 0, 'data_type_clause', 'cardinality'],
Message: ['O_O'] is not valid under any of the given schemas

140  validation errors found!

Phase: Skipping Render to Markdown

Phase: Creating HTML using the Faculty
HTMLing Model Literate Data Model
Doing html for 0 classes and 7 subjects
HTMLing subject Literate Data Model
	Doing html for 0 classes and 7 subjects
HTMLing subject Preliminaries
	Doing html for 3 classes and 0 subjects
class_names_clause for attribute  subtypes  class_names_clause handed:  [ClassReference(container=None, content='LiterateDataModel', _type='ClassReference'), ClassReference(container=None, content='Subject', _type='ClassReference'), ClassReference(container=None, content='Class', _type='ClassReference'), ClassReference(container=None, content='Key', _type='ClassReference'), ClassReference(container=None, content='AttributeSection', _type='ClassReference'), ClassReference(container=None, content='Attribute', _type='ClassReference'), ClassReference(container=None, content='Constraint', _type='ClassReference'), ClassReference(container=None, content='Method', _type='ClassReference'), ClassReference(container=None, content='ParameterAnInputToAMethod', _type='ClassReference')]
html-id for normalName = Component__normalName
html-id for name = Component__name
html-id for qualifiedName = Component__qualifiedName
html-id for abbreviatedName = Component__abbreviatedName
html-id for oneLiner = Component__oneLiner
html-id for elaboration = Component__elaboration
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
html-id for isEmbellishment = Component__isEmbellishment
Showing 11 of 21 classes
creating png  for mermaid in C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\diagrams\diagram_1_mermaid.png
Generating single mermaid chart
html-id for emoji = AnnotationType__emoji
html-id for emojiName = AnnotationType__emojiName
html-id for emojiUnicode = AnnotationType__emojiUnicode
html-id for label = AnnotationType__label
html-id for plural = AnnotationType__plural
html-id for purpose = AnnotationType__purpose
html-id for baseLiterateDataModel = AnnotationType__baseLiterateDataModel
html-id for inverseOfAnnotationType = AnnotationType__inverseOfAnnotationType
Showing 3 of 21 classes
creating png  for mermaid in C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\diagrams\diagram_2_mermaid.png
Generating single mermaid chart
html-id for annotationType = Annotation__annotationType
html-id for label = Annotation__label
html-id for emoji = Annotation__emoji
html-id for content = Annotation__content
html-id for isEmbellishment = Annotation__isEmbellishment
html-id for baseComponent = Annotation__baseComponent
Showing 3 of 21 classes
creating png  for mermaid in C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\diagrams\diagram_3_mermaid.png
Generating single mermaid chart
HTMLing subject The Model and its Subjects
	Doing html for 3 classes and 1 subjects
html-id for name = LiterateDataModel__name
html-id for allSubjects = LiterateDataModel__allSubjects
html-id for allClasses = LiterateDataModel__allClasses
html-id for annotationTypes = LiterateDataModel__annotationTypes
html-id for preferredCodingLanguage = LiterateDataModel__preferredCodingLanguage
html-id for alternateCodingLanguages = LiterateDataModel__alternateCodingLanguages
html-id for preferredTemplateLanguage = LiterateDataModel__preferredTemplateLanguage
html-id for alternateTemplateLanguages = LiterateDataModel__alternateTemplateLanguages
html-id for aiFunctions = LiterateDataModel__aiFunctions
Showing 4 of 21 classes
creating png  for mermaid in C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\diagrams\diagram_4_mermaid.png
Generating single mermaid chart
class_names_clause for attribute  subtypes  class_names_clause handed:  [ClassReference(container=None, content='SubjectArea', _type='ClassReference')]
html-id for name = Subject__name
html-id for parentSubject = Subject__parentSubject
html-id for classes = Subject__classes
html-id for childSubjects = Subject__childSubjects
html-id for baseLiterateDataModel = Subject__baseLiterateDataModel
html-id for inverseOfParentSubject = Subject__inverseOfParentSubject
html-id for inverseOfChildSubjects = Subject__inverseOfChildSubjects
Showing 4 of 21 classes
creating png  for mermaid in C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\diagrams\diagram_5_mermaid.png
Generating single mermaid chart
html-id for baseLiterateModel = SubjectArea__baseLiterateModel
html-id for baseXyz = SubjectArea__baseXyz
Showing 2 of 21 classes
creating png  for mermaid in C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\diagrams\diagram_6_mermaid.png
Generating single mermaid chart
HTMLing subject Classes
	Doing html for 7 classes and 0 subjects
class_names_clause for attribute  subtypes  class_names_clause handed:  [ClassReference(container=None, content='ReferenceType', _type='ClassReference')]
html-id for pluralForm = Class__pluralForm
html-id for basedOn = Class__basedOn
html-id for supertypes = Class__supertypes
html-id for subtypings = Class__subtypings
html-id for subtypes = Class__subtypes
html-id for attributes = Class__attributes
html-id for attributeSections = Class__attributeSections
html-id for constraints = Class__constraints
html-id for methods = Class__methods
html-id for dependents = Class__dependents
html-id for uniqueKeys = Class__uniqueKeys
html-id for inverseOfAllSubjects = Class__inverseOfAllSubjects
html-id for inverseOfAllClasses = Class__inverseOfAllClasses
html-id for inverseOfClasses = Class__inverseOfClasses
html-id for inverseOfBasedOn = Class__inverseOfBasedOn
html-id for inverseOfSubtypes = Class__inverseOfSubtypes
html-id for inverseOfClasses = Class__inverseOfClasses
html-id for inverseOfCoreClass = Class__inverseOfCoreClass
Showing 7 of 21 classes
creating png  for mermaid in C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\diagrams\diagram_7_mermaid.png
Generating single mermaid chart
html-id for name = Subtyping__name
html-id for isExclusive = Subtyping__isExclusive
html-id for isExhaustive = Subtyping__isExhaustive
html-id for classes = Subtyping__classes
html-id for inverseOfSubtypings = Subtyping__inverseOfSubtypings
html-id for baseClass = Subtyping__baseClass
Showing 2 of 21 classes
creating png  for mermaid in C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\diagrams\diagram_8_mermaid.png
Generating single mermaid chart
Showing 2 of 21 classes
creating png  for mermaid in C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\diagrams\diagram_9_mermaid.png
Generating single mermaid chart
html-id for isCaptive = CodeType__isCaptive
Showing 2 of 21 classes
creating png  for mermaid in C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\diagrams\diagram_10_mermaid.png
Generating single mermaid chart
html-id for code = CodeValue__code
html-id for description = CodeValue__description
html-id for baseCodeType = CodeValue__baseCodeType
Showing 2 of 21 classes
creating png  for mermaid in C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\diagrams\diagram_11_mermaid.png
Generating single mermaid chart
class_names_clause for attribute  subtypes  class_names_clause handed:  [ClassReference(container=None, content='UniqueKey', _type='ClassReference')]
html-id for keyAttributes = Key__keyAttributes
html-id for baseClass = Key__baseClass
Showing 4 of 21 classes
creating png  for mermaid in C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\diagrams\diagram_12_mermaid.png
Generating single mermaid chart
Showing 2 of 21 classes
creating png  for mermaid in C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\diagrams\diagram_13_mermaid.png
Generating single mermaid chart
HTMLing subject Attributes
	Doing html for 6 classes and 0 subjects
html-id for isOptional = AttributeSection__isOptional
html-id for inverseOfAttributeSections = AttributeSection__inverseOfAttributeSections
html-id for baseClass = AttributeSection__baseClass
Showing 4 of 21 classes
creating png  for mermaid in C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\diagrams\diagram_14_mermaid.png
Generating single mermaid chart
html-id for name = Attribute__name
html-id for dataType = Attribute__dataType
html-id for isOptional = Attribute__isOptional
html-id for cardinality = Attribute__cardinality
html-id for author = Attribute__author
html-id for books = Attribute__books
html-id for isInvertible = Attribute__isInvertible
html-id for inverseClass = Attribute__inverseClass
html-id for inverseAttribute = Attribute__inverseAttribute
html-id for inverseIsOptional = Attribute__inverseIsOptional
html-id for default = Attribute__default
html-id for derivation = Attribute__derivation
html-id for constraints = Attribute__constraints
html-id for overrides = Attribute__overrides
html-id for inverseOfAttributes = Attribute__inverseOfAttributes
html-id for inverseOfKeyAttributes = Attribute__inverseOfKeyAttributes
html-id for baseAttributeSection = Attribute__baseAttributeSection
Showing 4 of 21 classes
creating png  for mermaid in C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\diagrams\diagram_15_mermaid.png
Generating single mermaid chart
html-id for statement = Derivation__statement
html-id for expression = Derivation__expression
Focal points not contained in nodes - skipping diagram
class_names_clause for attribute  subtypes  class_names_clause handed:  [ClassReference(container=None, content='ClassConstraint', _type='ClassReference'), ClassReference(container=None, content='AttributeConstraint', _type='ClassReference')]
html-id for statement = Constraint__statement
html-id for expression = Constraint__expression
html-id for severity = Constraint__severity
Showing 4 of 21 classes
creating png  for mermaid in C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\diagrams\diagram_16_mermaid.png
Generating single mermaid chart
html-id for baseClass = ClassConstraint__baseClass
Showing 3 of 21 classes
creating png  for mermaid in C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\diagrams\diagram_17_mermaid.png
Generating single mermaid chart
html-id for baseAttribute = AttributeConstraint__baseAttribute
Showing 3 of 21 classes
creating png  for mermaid in C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\diagrams\diagram_18_mermaid.png
Generating single mermaid chart
HTMLing subject Methods
	Doing html for 2 classes and 0 subjects
html-id for parameters = Method__parameters
html-id for returnType = Method__returnType
html-id for inverseOfMethods = Method__inverseOfMethods
Showing 2 of 21 classes
creating png  for mermaid in C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\diagrams\diagram_19_mermaid.png
Generating single mermaid chart
html-id for type = ParameterAnInputToAMethod__type
html-id for cardinality = ParameterAnInputToAMethod__cardinality
html-id for inverseOfParameters = ParameterAnInputToAMethod__inverseOfParameters
Showing 2 of 21 classes
creating png  for mermaid in C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\diagrams\diagram_20_mermaid.png
Generating single mermaid chart
HTMLing subject Trivial Data Types
	Doing html for 6 classes and 0 subjects
html-id for language = CodeExpression__language
html-id for expression = CodeExpression__expression
html-id for coreClass = SimpleDataTypeSubtpeOfDataType__coreClass
html-id for aggregation = ComplexDataType__aggregation
html-id for aggregatedTypes = ComplexDataType__aggregatedTypes
html-id for name = AggregatingOperator__name
html-id for arity = AggregatingOperator__arity
html-id for spelling = AggregatingOperator__spelling
HTMLing subject Trivial Low level Data Types
	Doing html for 16 classes and 2 subjects
class_names_clause for attribute  subtypes  class_names_clause handed:  [ClassReference(container=None, content='UpperCamel', _type='ClassReference'), ClassReference(container=None, content='LowerCamel', _type='ClassReference')]
html-id for valueTheString = CamelName__valueTheString
html-id for value = ValueTypeRichText__value
html-id for format = ValueTypeRichText__format
html-id for value = OneLiner__value
class_names_clause for attribute  subtypes  class_names_clause handed:  [ClassReference(container=None, content='String', _type='ClassReference'), ClassReference(container=None, content='Integer', _type='ClassReference'), ClassReference(container=None, content='Decimal', _type='ClassReference'), ClassReference(container=None, content='Boolean', _type='ClassReference'), ClassReference(container=None, content='Date', _type='ClassReference'), ClassReference(container=None, content='Time', _type='ClassReference'), ClassReference(container=None, content='DateTime', _type='ClassReference')]
class_names_clause for attribute  subtypes  class_names_clause handed:  [ClassReference(container=None, content='CamelName', _type='ClassReference'), ClassReference(container=None, content='QualifiedCamel', _type='ClassReference'), ClassReference(container=None, content='ValueTypeRichText', _type='ClassReference')]
HTMLing subject Annotation Types Used
	Doing html for 0 classes and 0 subjects
creating png  for puml in C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\diagrams\diagram_21_puml.png
PUML png file saved to: C:\Users\fmkat\Dropbox\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm\ldm_models\Literate\Literate_results\diagrams\diagram_21_puml.png
HTMLing subject Annotation types as CSV
	Doing html for 0 classes and 0 subjects
HTMLing subject Appendices
	Doing html for 0 classes and 0 subjects
Body classes are None
Saved styled dictionary to ldm/ldm_models/Literate/Literate_results/Literate_PD_07_as.html
Body classes are ['reviewing']
Saved styled dictionary (for review) to ldm/ldm_models/Literate/Literate_results/Literate_PD_07_as.review.html

Phase: Saving HTML for PDF 
Body classes are None
Saved styled dictionary to ldm/ldm_models/Literate/Literate_results/Literate_PD_08_as_pdf.html
Body classes are ['reviewing']
Saved styled dictionary (for review) to ldm/ldm_models/Literate/Literate_results/Literate_PD_08_as_pdf.review.html

Phase: Creating PDF from html and css - using Prince
