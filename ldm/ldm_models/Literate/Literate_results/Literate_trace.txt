
Phase: Parsing model: ldm/ldm_models/Literate/Literate.md
PARSING ldm/ldm_models/Literate/Literate.md

Phase: Deriving dict for model
adding name value. one_liner -.  name

adding name value. one_liner -.  false

adding name value. based_on -. [ClassName(content='LiterateDataModel', _type='ClassName')]
adding name value. one_liner -.  based on label

adding name value. based_on -. [ClassName(content='Component', _type='ClassName')]
adding name value. one_liner -.  from annotationType

adding name value. one_liner -.  from annotation type

adding name value. one_liner -.  false

adding name value. abbreviation -. LDM
adding name value. plural -.  LiterateDataModels

parsing subtypeOfs:   Component

SubtypeOf result is  [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. one_liner -.  gathering s.allSubjects over s in subjectAreas

Patched att_name is one_liner for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is one_liner
adding name value. one_liner -.  Subject names must be unique across the model.

adding name value. one_liner -.  gathering s.allClasses over s in allSubjects.

Patched att_name is one_liner for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is one_liner
adding name value. one_liner -.  Class names must be unique across the model.

adding name value. one_liner -.  OCL

adding name value. one_liner -.  Handlebars

adding name value. one_liner -.  ['aiEnglishPlural()']

adding name value. plural -.  Subjects

parsing subtypeOfs:   Component

SubtypeOf result is  [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. dependent_of -. [ClassName(content='LiterateDataModel', _type='ClassName')]
adding name value. inverse -. {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject', _type='AttributeName')}
adding name value. plural -.  SubjectAreas

parsing subtypeOfs:   Subject

SubtypeOf result is  [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. where -.  parentSubject is absent

adding name value. plural -.  Classes

parsing subtypeOfs:   Component

SubtypeOf result is  [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
Patched att_name is one_liner for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is one_liner
adding name value. one_liner -.  Within each Class, attribute names must be unique.

adding name value. one_liner -.  the regular plural, formed by adding "s" or "es".

adding name value. inverse -. {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}
adding name value. inverse -. {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}
adding name value. dependent_of -. [ClassName(content='Class', _type='ClassName')]
adding name value. one_liner -.  true

adding name value. one_liner -.  true

parsing subtypeOfs:   Class.

SubtypeOf result is  [(ClassName(content='Class', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Class', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
parsing subtypeOfs:   Class.

SubtypeOf result is  [(ClassName(content='Class', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Class', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
parsing subtypeOfs:   ValueType.

SubtypeOf result is  [(ClassName(content='ValueType', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='ValueType', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
parsing subtypeOfs:   Component

SubtypeOf result is  [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. dependent_of -. [ClassName(content='Class', _type='ClassName')]
Patched att_name is one_liner for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is one_liner
adding name value. one_liner -.  each attribute must be a direct or inherited of the base class.

Patched att_name is one_liner for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is one_liner
adding name value. one_liner -.  no repetitions allowed in keyAttributes
> üëç **Issue**: introduce PureLists?
parsing subtypeOfs:   Key

SubtypeOf result is  [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
parsing subtypeOfs:   Component.

SubtypeOf result is  [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. based_on -. [ClassName(content='Class', _type='ClassName')]
adding name value. plural -.  Attributes

parsing subtypeOfs:   Component

SubtypeOf result is  [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. based_on -. [ClassName(content='AttributeSection', _type='ClassName')]
adding name value. overrides -. {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}
adding name value. one_liner -. *** False

adding name value. one_liner -. ***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.
For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.
Inventing name for:  1:1 Author
Inventing name for:  N:M Set of Books
adding name value. one_liner -.  true if the data type is a class or a simple collection of members of a class.

adding name value. one_liner -.  from the data type. Null unless arrribute is invertible.

adding name value. plural -.  Derivations

adding name value. plural -.  Constraints

parsing subtypeOfs:   Component

SubtypeOf result is  [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
Inventing name for:  e.g., OCL _(CodeExpression
parsing subtypeOfs:   Constraint

SubtypeOf result is  [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. based_on -. [ClassName(content='Class', _type='ClassName')]
parsing subtypeOfs:   Constraint

SubtypeOf result is  [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. based_on -. [ClassName(content='Attribute', _type='ClassName')]
adding name value. plural -.  Methods

parsing subtypeOfs:   Component

SubtypeOf result is  [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. plural -.  Parameters

parsing subtypeOfs:   Component

SubtypeOf result is  [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
Inventing name for:  e.g., optional, required
parsing subtypeOfs:   String

SubtypeOf result is  [(ClassName(content='String', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='String', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
Patched att_name is one_liner for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is one_liner
adding name value. one_liner -.  Must follow the camel case naming convention and not be empty.

parsing subtypeOfs:   CamelName

SubtypeOf result is  [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. where -.  content begins with an upper case letter.

parsing subtypeOfs:   CamelName

SubtypeOf result is  [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. where -.  content begins with a lower case letter.

parsing subtypeOfs:   String

SubtypeOf result is  [(ClassName(content='String', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='String', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
Patched att_name is one_liner for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is one_liner
adding name value. one_liner -.  content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.

parsing subtypeOfs:   String

SubtypeOf result is  [(ClassName(content='String', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='String', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
parsing subtypeOfs:   RichText

SubtypeOf result is  [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
Patched att_name is one_liner for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is one_liner
adding name value. one_liner -.  must not containa line break or new line character

parsing subtypeOfs:   ValueType
A basic, built-in data type
SubtypeOf result is  [(ClassName(content='ValueTypeABasic', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName')), (ClassName(content='BuiltInDataType', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='ValueTypeABasic', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName')), (ClassName(content='BuiltInDataType', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]
.. full dict saved  in ldm/ldm_models/Literate/Literate_results/Literate.dict.yaml and ldm/ldm_models/Literate/Literate_results/Literate.dict.json
Building class map for module: ldm.Literate_01
Class map is
{   'Annotation': <class 'ldm.Literate_01.Annotation'>,
    'AsValue': <class 'utils.class_pom_token.AsValue'>,
    'Attribute': <class 'ldm.Literate_01.Attribute'>,
    'AttributeName': <class 'ldm.Literate_01.AttributeName'>,
    'AttributeReference': <class 'ldm.Literate_01.AttributeReference'>,
    'AttributeSection': <class 'ldm.Literate_01.AttributeSection'>,
    'AttributeSectionName': <class 'ldm.Literate_01.AttributeSectionName'>,
    'BaseDataType': <class 'ldm.Literate_01.BaseDataType'>,
    'CamelCase': <class 'utils.class_casing.CamelCase'>,
    'Class': <class 'ldm.Literate_01.Class'>,
    'ClassName': <class 'ldm.Literate_01.ClassName'>,
    'Class_': <class 'ldm.Literate_01.Class'>,
    'CodeBlock': <class 'ldm.Literate_01.CodeBlock'>,
    'CodeType': <class 'ldm.Literate_01.CodeType'>,
    'Component': <class 'ldm.Literate_01.Component'>,
    'Constraint': <class 'ldm.Literate_01.Constraint'>,
    'DataType': <class 'ldm.Literate_01.SetDataType'>,
    'DataTypeClause': <class 'ldm.Literate_01.DataTypeClause'>,
    'Default': <class 'ldm.Literate_01.Default'>,
    'Derivation': <class 'ldm.Literate_01.Derivation'>,
    'Diagnostic': <class 'ldm.Literate_01.Diagnostic'>,
    'Emoji': <class 'utils.class_pom_token.Emoji'>,
    'Formula': <class 'ldm.Literate_01.Formula'>,
    'FormulaCoding': <class 'ldm.Literate_01.FormulaCoding'>,
    'IsExclusive': <class 'utils.class_pom_token.IsExclusive'>,
    'IsExhaustive': <class 'utils.class_pom_token.IsExhaustive'>,
    'IsOptional': <class 'utils.class_pom_token.IsOptional'>,
    'Label': <class 'ldm.Literate_01.Label'>,
    'ListDataType': <class 'ldm.Literate_01.ListDataType'>,
    'LiterateModel': <class 'ldm.Literate_01.LiterateModel'>,
    'LowerCamel': <class 'utils.class_casing.LowerCamel'>,
    'MappingDataType': <class 'ldm.Literate_01.MappingDataType'>,
    'MinorComponent': <class 'ldm.Literate_01.MinorComponent'>,
    'ModelName': <class 'ldm.Literate_01.ModelName'>,
    'Natural': <class 'ldm.Literate_01.OneLiner'>,
    'NormalCase': <class 'utils.class_casing.NormalCase'>,
    'OneLiner': <class 'ldm.Literate_01.OneLiner'>,
    'Paragraph': <class 'ldm.Literate_01.Paragraph'>,
    'PresentableBoolean': <class 'utils.class_pom_token.PresentableBoolean'>,
    'ReferenceType': <class 'ldm.Literate_01.ReferenceType'>,
    'SetDataType': <class 'ldm.Literate_01.SetDataType'>,
    'Subject': <class 'ldm.Literate_01.SubjectB'>,
    'SubjectB': <class 'ldm.Literate_01.SubjectB'>,
    'SubjectC': <class 'ldm.Literate_01.SubjectC'>,
    'SubjectD': <class 'ldm.Literate_01.SubjectD'>,
    'SubjectE': <class 'ldm.Literate_01.SubjectE'>,
    'SubjectName': <class 'ldm.Literate_01.SubjectName'>,
    'Subtyping': <class 'ldm.Literate_01.Subtyping'>,
    'SubtypingName': <class 'ldm.Literate_01.SubtypingName'>,
    'UpperCamel': <class 'utils.class_casing.UpperCamel'>,
    'ValueType': <class 'ldm.Literate_01.ValueType'>}

Phase: Creating model from dictionary: ldm/ldm_models/Literate/Literate_results/Literate.dict.yaml
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]} 
In AttSection post-init for For Machinery, is_optional = None
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='LiterateDataModel', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueTypeAnnotationANoteOrCommentAssociatedWithAModelElement', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]} 
In AttSection post-init for For Machinery, is_optional = None
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'preferredCodingLanguage', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodingLanguage', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternateCodingLanguages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodingLanguages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'preferredTemplateLanguage', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'TemplateLanguage', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternateTemplateLanguages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'TemplateLanguages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]} 
In AttSection post-init for Modeling Configuration, is_optional = None
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectASpecificTopicOrThemeWithinTheModel', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it‚Äôs just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'eachClassShouldBeFollowedFirstByTheClassesThatAreDependentOnItAndThen', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'byItsSubtypeClasses', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectAreaAMainTopicOrAreaOfFocusWithinTheModelContainingRelatedSubjectsAndClasses', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it‚Äôs subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'uniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]} 
In AttSection post-init for Implied Attributes, is_optional = None
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isExclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isExhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ReferenceType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeTypeADataTypeOrEnumerationUsedInTheModel', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'listTheCodeValuesAsABullettedListInsideTheDescriptionOfTheAttributeInTheFormCodeDescription', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aCodeTypeWillBeCreatedWithTheNameClassAttributeCodeAndTheCodeValuesListedThatCodeTypeWillBeMarkedAsIsCaptive', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeValue', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> üëç **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AttributeSection', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AttributeAPropertyOrCharacteristicOfAClass', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'listOfEditions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'setOfEdition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'andMoreComplicatedCases', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'InventedName', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'InventedName', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]} 
In AttSection post-init for Cardinalities, is_optional = None
In AttSection post-init for Inverse Attributes, is_optional = None
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there‚Äôs no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]} 
In AttSection post-init for Override Tracking, is_optional = None
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueTypeDerivationARuleOrFormulaForDerivingTheValueOfAnAttribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueTypeConstraintARuleConditionOrValidationThatMustBeSatisfiedByTheModel', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'InventedName', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ClassConstraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AttributeConstraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'MethodABehaviorOrOperationAssociatedWithAClass', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ParameterAnInputToAMethod', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'InventedName', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SimpleDataTypeSubtpeOfDataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ComplexDataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AggregatingOperator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AggregatingOperator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueTypeCamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'valueTheString', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> üìù ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichTextAStringWithMarkupForBlockLevelFormatting', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'html', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'markDown', '_type': 'AttributeName'}, 'parenthetical': ''}]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]} 
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueTypeABasic', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName')), (ClassName(content='BuiltInDataType', _type='ClassName'), SubtypingName(content='subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]}]} 
Created model: <class 'ldm.Literate_01.LiterateModel'>

Phase: Validating model
Validating references...
Validation errors: 56

Phase: counting errors
{"Validation Error in Attribute: Required field 'data_type_clause' is missing": 16, "Validation Error in Class: For field 'based_on' - expected typing.Optional[typing.List[ldm.Literate_01.ClassName]], but got <class 'list'>": 6, "Validation Error in SubjectB: For field 'name' - expected <class 'utils.class_casing.CamelCase'>, but got <class 'ldm.Literate_01.SubjectName'>": 8, "Validation Error in Constraint: For field 'one_liner' - expected typing.Optional[ldm.Literate_01.OneLiner], but got <class 'list'>": 5, "Validation Error in Class: For field 'abbreviation' - expected typing.Optional[utils.class_casing.CamelCase], but got <class 'str'>": 1, "Validation Error in Class: For field 'subtype_of' - expected typing.Optional[typing.Dict[ldm.Literate_01.ClassName, ldm.Literate_01.SubtypingName]], but got <class 'list'>": 17, "Validation Error in Class: For field 'dependent_of' - expected typing.Optional[typing.List[ldm.Literate_01.ClassName]], but got <class 'list'>": 1, "Validation Error in Class: For field 'where' - expected typing.Optional[ldm.Literate_01.OneLiner], but got <class 'str'>": 3, "Validation Error in SubjectC: For field 'name' - expected <class 'utils.class_casing.CamelCase'>, but got <class 'ldm.Literate_01.SubjectName'>": 3, "Validation Error in Attribute: Required field 'name' is missing": 7}
16 	 Validation Error in Attribute: Required field 'data_type_clause' is missing
6 	 Validation Error in Class: For field 'based_on' - expected typing.Optional[typing.List[ldm.Literate_01.ClassName]], but got <class 'list'>
8 	 Validation Error in SubjectB: For field 'name' - expected <class 'utils.class_casing.CamelCase'>, but got <class 'ldm.Literate_01.SubjectName'>
5 	 Validation Error in Constraint: For field 'one_liner' - expected typing.Optional[ldm.Literate_01.OneLiner], but got <class 'list'>
1 	 Validation Error in Class: For field 'abbreviation' - expected typing.Optional[utils.class_casing.CamelCase], but got <class 'str'>
17 	 Validation Error in Class: For field 'subtype_of' - expected typing.Optional[typing.Dict[ldm.Literate_01.ClassName, ldm.Literate_01.SubtypingName]], but got <class 'list'>
1 	 Validation Error in Class: For field 'dependent_of' - expected typing.Optional[typing.List[ldm.Literate_01.ClassName]], but got <class 'list'>
3 	 Validation Error in Class: For field 'where' - expected typing.Optional[ldm.Literate_01.OneLiner], but got <class 'str'>
3 	 Validation Error in SubjectC: For field 'name' - expected <class 'utils.class_casing.CamelCase'>, but got <class 'ldm.Literate_01.SubjectName'>
7 	 Validation Error in Attribute: Required field 'name' is missing

Phase: Serialing model ...
Model serialized to ldm/ldm_models/Literate/Literate_results/Literate.model.json
Model serialized to ldm/ldm_models/Literate/Literate_results/Literate.model.yaml
..Created model files: ldm/ldm_models/Literate/Literate_results/Literate.model.json and ldm/ldm_models/Literate/Literate_results/Literate.model.yaml

Phase: Rendering back to markdown
8  subjects coming in model
WARNING: No render for type <class 'utils.class_pom_token.IsOptional'>
WARNING: No render for type <class 'Literate_01.ClassName'>
WARNING: No render for type <class 'Literate_01.ClassName'>
WARNING: No render for type <class 'utils.class_pom_token.IsOptional'>
WARNING: No render for type <class 'utils.class_pom_token.IsOptional'>
WARNING: No render for type <class 'Literate_01.ClassName'>
WARNING: No render for type <class 'utils.class_pom_token.IsOptional'>
WARNING: No render for type <class 'Literate_01.ClassName'>
WARNING: No render for type <class 'Literate_01.ClassName'>
WARNING: No render for type <class 'Literate_01.ClassName'>
WARNING: No render for type <class 'Literate_01.ClassName'>
WARNING: No render for type <class 'utils.class_pom_token.IsOptional'>
WARNING: No render for type <class 'utils.class_pom_token.IsOptional'>
WARNING: No render for type <class 'utils.class_pom_token.IsOptional'>
WARNING: No render for type <class 'Literate_01.ClassName'>
WARNING: No render for type <class 'Literate_01.ClassName'>

Phase: Creating HTML from model dict
All keys are: 
	 parenthetical
	 constraints
	 derivation
	 content
	 annotations
	 data_type_clause
	 is_optional_lit
	 emoji
	 element_type
	 where
	 abbreviation
	 attributes
	 inverse
	 dependent_of
	 name
	 one_liner
	 subjects
	 based_on
	 default
	 elaboration
	 class_name
	 prefix
	 _type
	 attribute_name
	 t_value
	 data_type
	 label
	 as_value_type
	 subtype_of
	 overrides
	 attribute_sections
	 classes
	 plural
Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   name

Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   false

Orphaned list:  [ClassName(content='LiterateDataModel', _type='ClassName')]
Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   based on label

Orphaned list:  [ClassName(content='Component', _type='ClassName')]
Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   from annotationType

Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   from annotation type

Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   false

Orphaned dict:  abbreviation
[ldm_to_html.py:235 -                  add_key_value_html()] <  Called by dict_to_html with args ('abbreviation', 'LDM', FluentTag(<html><div class="Class"><div class="Class_header header"><span class="prefix value">_</span><a class="ClassName name" id="LiterateDataModel">LiterateDataModel</a><div class="OneLiner mdhtml"><div><p>A representation of a domain's entities, attributes, and relationships,
along with explanatory text and examples</p></div></div></div></div></html>)) {}
ADD_KEY_VALUE
<div class="str">
</div>

[ldm_to_html.py:235 -                  add_key_value_html()] >  Returned None
Orphaned dict:  plural
[ldm_to_html.py:235 -                  add_key_value_html()] <  Called by dict_to_html with args ('plural', ' LiterateDataModels\n', FluentTag(<html><div class="Class"><div class="Class_header header"><span class="prefix value">_</span><a class="ClassName name" id="LiterateDataModel">LiterateDataModel</a><div class="OneLiner mdhtml"><div><p>A representation of a domain's entities, attributes, and relationships,
along with explanatory text and examples</p></div></div></div></div><div class="str"><span class="key">abbreviation:</span></div></html>)) {}
ADD_KEY_VALUE
<div class="str">
</div>

[ldm_to_html.py:235 -                  add_key_value_html()] >  Returned None
Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   gathering s.allSubjects over s in subjectAreas

Orphaned list:  [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]
Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   Subject names must be unique across the model.

Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   gathering s.allClasses over s in allSubjects.

Orphaned list:  [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]
Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   Class names must be unique across the model.

Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   OCL

Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   Handlebars

Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   ['aiEnglishPlural()']

Orphaned dict:  plural
[ldm_to_html.py:235 -                  add_key_value_html()] <  Called by dict_to_html with args ('plural', ' Subjects\n', FluentTag(<html><div class="Class"><div class="Class_header header"><span class="prefix value">_</span><a class="ClassName name" id="SubjectASpecificTopicOrThemeWithinTheModel">SubjectASpecificTopicOrThemeWithinTheModel</a></div></div></html>)) {}
ADD_KEY_VALUE
<div class="str">
</div>

[ldm_to_html.py:235 -                  add_key_value_html()] >  Returned None
Orphaned list:  [ClassName(content='LiterateDataModel', _type='ClassName')]
Orphaned dict:  inverse
[ldm_to_html.py:235 -                  add_key_value_html()] <  Called by dict_to_html with args ('inverse', {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject', _type='AttributeName')}, FluentTag(<html><div class="Attribute"><div class="Attribute_header header"><span class="prefix value">-</span><a class="AttributeName name" id="childSubjects">childSubjects</a><div class="OneLiner mdhtml"><div><p>Any child subjects nested under this subject, in the order in which they should be presented _</p></div></div><span class="parenthetical value">ListOf Subjects</span><span class="data_type_clause value"><span class="list_data_type">List of<span class="base_data_type"><a class="base_class" href="#Subjects">Subjects-es</a>value_es</span></span></span></div></div></html>)) {}
ADD_KEY_VALUE
<div class="dict">
</div>

Orphaned dict:  class_name
[ldm_to_html.py:235 -                  add_key_value_html()] . <  Called by dict_to_html with args ('class_name', ClassName(content='Subject', _type='ClassName'), FluentTag(<html><div class="AttributeReference"></div></html>)) {}
ADD_KEY_VALUE
<div class="ClassName">
</div>

[ldm_to_html.py:235 -                  add_key_value_html()] . >  Returned None
Orphaned dict:  attribute_name
[ldm_to_html.py:235 -                  add_key_value_html()] . <  Called by dict_to_html with args ('attribute_name', AttributeName(content='parentSubject', _type='AttributeName'), FluentTag(<html><div class="AttributeReference"></div><div class="ClassName"><span class="key">class_name:</span></div></html>)) {}
ADD_KEY_VALUE
<div class="AttributeName">
</div>

Orphaned ? <class 'Literate_01.AttributeName'> :  parentSubject
[ldm_to_html.py:235 -                  add_key_value_html()] . >  Returned None
[ldm_to_html.py:235 -                  add_key_value_html()] >  Returned None
Orphaned dict:  plural
[ldm_to_html.py:235 -                  add_key_value_html()] <  Called by dict_to_html with args ('plural', ' SubjectAreas\n', FluentTag(<html><div class="Class"><div class="Class_header header"><span class="prefix value">_</span><a class="ClassName name" id="SubjectAreaAMainTopicOrAreaOfFocusWithinTheModelContainingRelatedSubjectsAndClasses">SubjectAreaAMainTopicOrAreaOfFocusWithinTheModelContainingRelatedSubjectsAndClasses</a></div></div></html>)) {}
ADD_KEY_VALUE
<div class="str">
</div>

[ldm_to_html.py:235 -                  add_key_value_html()] >  Returned None
Orphaned dict:  where
[ldm_to_html.py:235 -                  add_key_value_html()] <  Called by dict_to_html with args ('where', ' parentSubject is absent\n', FluentTag(<html><div class="Class"><div class="Class_header header"><span class="prefix value">_</span><a class="ClassName name" id="SubjectAreaAMainTopicOrAreaOfFocusWithinTheModelContainingRelatedSubjectsAndClasses">SubjectAreaAMainTopicOrAreaOfFocusWithinTheModelContainingRelatedSubjectsAndClasses</a></div></div><div class="str"><span class="key">plural:</span></div><div class="subtype_of_clause"><span class="clause_label">subtype_of</span><div class="subtype_pairs"></div><div class="subtype_pair"><span class="class_name_link" href="#Subject">Subject</span>bySomething</div></div></html>)) {}
ADD_KEY_VALUE
<div class="str">
</div>

[ldm_to_html.py:235 -                  add_key_value_html()] >  Returned None
Orphaned dict:  plural
[ldm_to_html.py:235 -                  add_key_value_html()] <  Called by dict_to_html with args ('plural', ' Classes\n', FluentTag(<html><div class="Class"><div class="Class_header header"><span class="prefix value">_</span><a class="ClassName name" id="Class">Class</a><div class="OneLiner mdhtml"><div><p>A key entity or object type in the model, often corresponding to a real-world concept</p></div></div></div></div></html>)) {}
ADD_KEY_VALUE
<div class="str">
</div>

[ldm_to_html.py:235 -                  add_key_value_html()] >  Returned None
Orphaned list:  [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]
Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   Within each Class, attribute names must be unique.

Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   the regular plural, formed by adding "s" or "es".

Orphaned dict:  inverse
[ldm_to_html.py:235 -                  add_key_value_html()] <  Called by dict_to_html with args ('inverse', {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}, FluentTag(<html><div class="Attribute"><div class="Attribute_header header"><span class="prefix value">-</span><a class="AttributeName name" id="dependents">dependents</a><div class="OneLiner mdhtml"><div><p>the Classes which are basedOn this Class</p></div></div><span class="parenthetical value">optional SetOf Classes</span><span class="data_type_clause value"><span class="set_data_type">Set of<span class="base_data_type"><a class="base_class" href="#Classes">Classes-es</a>value_es</span></span></span></div></div></html>)) {}
ADD_KEY_VALUE
<div class="dict">
</div>

Orphaned dict:  class_name
[ldm_to_html.py:235 -                  add_key_value_html()] . <  Called by dict_to_html with args ('class_name', ClassName(content='Class', _type='ClassName'), FluentTag(<html><div class="AttributeReference"></div></html>)) {}
ADD_KEY_VALUE
<div class="ClassName">
</div>

[ldm_to_html.py:235 -                  add_key_value_html()] . >  Returned None
Orphaned dict:  attribute_name
[ldm_to_html.py:235 -                  add_key_value_html()] . <  Called by dict_to_html with args ('attribute_name', AttributeName(content='basedOn', _type='AttributeName'), FluentTag(<html><div class="AttributeReference"></div><div class="ClassName"><span class="key">class_name:</span></div></html>)) {}
ADD_KEY_VALUE
<div class="AttributeName">
</div>

Orphaned ? <class 'Literate_01.AttributeName'> :  basedOn
[ldm_to_html.py:235 -                  add_key_value_html()] . >  Returned None
[ldm_to_html.py:235 -                  add_key_value_html()] >  Returned None
Orphaned dict:  inverse
[ldm_to_html.py:235 -                  add_key_value_html()] <  Called by dict_to_html with args ('inverse', {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}, FluentTag(<html><div class="Attribute"><div class="Attribute_header header"><span class="prefix value">-</span><a class="AttributeName name" id="uniqueKeys">uniqueKeys</a><span class="parenthetical value">optional Set of UniqueKeys</span><span class="data_type_clause value"><span class="set_data_type">Set of<span class="base_data_type"><a class="base_class" href="#UniqueKeys">UniqueKeys-es</a>value_es</span></span></span></div></div></html>)) {}
ADD_KEY_VALUE
<div class="dict">
</div>

Orphaned dict:  class_name
[ldm_to_html.py:235 -                  add_key_value_html()] . <  Called by dict_to_html with args ('class_name', ClassName(content='UniqueKey', _type='ClassName'), FluentTag(<html><div class="AttributeReference"></div></html>)) {}
ADD_KEY_VALUE
<div class="ClassName">
</div>

[ldm_to_html.py:235 -                  add_key_value_html()] . >  Returned None
Orphaned dict:  attribute_name
[ldm_to_html.py:235 -                  add_key_value_html()] . <  Called by dict_to_html with args ('attribute_name', AttributeName(content='basedOn', _type='AttributeName'), FluentTag(<html><div class="AttributeReference"></div><div class="ClassName"><span class="key">class_name:</span></div></html>)) {}
ADD_KEY_VALUE
<div class="AttributeName">
</div>

Orphaned ? <class 'Literate_01.AttributeName'> :  basedOn
[ldm_to_html.py:235 -                  add_key_value_html()] . >  Returned None
[ldm_to_html.py:235 -                  add_key_value_html()] >  Returned None
Orphaned list:  [ClassName(content='Class', _type='ClassName')]
Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   true

Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   true

Orphaned list:  [ClassName(content='Class', _type='ClassName')]
Orphaned list:  [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]
Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   each attribute must be a direct or inherited of the base class.

Orphaned list:  [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> üëç **Issue**: introduce PureLists?')]
Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   no repetitions allowed in keyAttributes
> üëç **Issue**: introduce PureLists?
Orphaned list:  [ClassName(content='Class', _type='ClassName')]
Orphaned dict:  plural
[ldm_to_html.py:235 -                  add_key_value_html()] <  Called by dict_to_html with args ('plural', ' Attributes\n', FluentTag(<html><div class="Class"><div class="Class_header header"><span class="prefix value">_</span><a class="ClassName name" id="AttributeAPropertyOrCharacteristicOfAClass">AttributeAPropertyOrCharacteristicOfAClass</a></div></div></html>)) {}
ADD_KEY_VALUE
<div class="str">
</div>

[ldm_to_html.py:235 -                  add_key_value_html()] >  Returned None
Orphaned list:  [ClassName(content='AttributeSection', _type='ClassName')]
Orphaned dict:  overrides
[ldm_to_html.py:235 -                  add_key_value_html()] <  Called by dict_to_html with args ('overrides', {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}, FluentTag(<html><div class="Attribute"><div class="Attribute_header header"><span class="prefix value">-</span><a class="AttributeName name" id="name">name</a><span class="parenthetical value">Lower Camel</span><span class="data_type_clause value"><span class="base_data_type"><a class="base_class" href="#LowerCamel">LowerCamel</a>value</span></span></div></div></html>)) {}
ADD_KEY_VALUE
<div class="dict">
</div>

Orphaned dict:  class_name
[ldm_to_html.py:235 -                  add_key_value_html()] . <  Called by dict_to_html with args ('class_name', 'CamelName', FluentTag(<html><div class="AttributeReference"></div></html>)) {}
ADD_KEY_VALUE
<div class="str">
</div>

[ldm_to_html.py:235 -                  add_key_value_html()] . >  Returned None
Orphaned dict:  attribute_name
[ldm_to_html.py:235 -                  add_key_value_html()] . <  Called by dict_to_html with args ('attribute_name', '', FluentTag(<html><div class="AttributeReference"></div><div class="str"><span class="key">class_name:</span></div></html>)) {}
ADD_KEY_VALUE
<div class="str">
</div>

[ldm_to_html.py:235 -                  add_key_value_html()] . >  Returned None
[ldm_to_html.py:235 -                  add_key_value_html()] >  Returned None
Orphaned ? <class 'ldm.Literate_01.OneLiner'> :  *** False

Orphaned ? <class 'ldm.Literate_01.OneLiner'> :  ***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.
For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.
Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   true if the data type is a class or a simple collection of members of a class.

Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   from the data type. Null unless arrribute is invertible.

Orphaned dict:  plural
[ldm_to_html.py:235 -                  add_key_value_html()] <  Called by dict_to_html with args ('plural', ' Derivations\n', FluentTag(<html><div class="Class"><div class="Class_header header"><span class="prefix value">_</span><a class="ClassName name" id="ValueTypeDerivationARuleOrFormulaForDerivingTheValueOfAnAttribute">ValueTypeDerivationARuleOrFormulaForDerivingTheValueOfAnAttribute</a></div></div></html>)) {}
ADD_KEY_VALUE
<div class="str">
</div>

[ldm_to_html.py:235 -                  add_key_value_html()] >  Returned None
Orphaned dict:  plural
[ldm_to_html.py:235 -                  add_key_value_html()] <  Called by dict_to_html with args ('plural', ' Constraints\n', FluentTag(<html><div class="Class"><div class="Class_header header"><span class="prefix value">_</span><a class="ClassName name" id="ValueTypeConstraintARuleConditionOrValidationThatMustBeSatisfiedByTheModel">ValueTypeConstraintARuleConditionOrValidationThatMustBeSatisfiedByTheModel</a></div></div></html>)) {}
ADD_KEY_VALUE
<div class="str">
</div>

[ldm_to_html.py:235 -                  add_key_value_html()] >  Returned None
Orphaned list:  [ClassName(content='Class', _type='ClassName')]
Orphaned list:  [ClassName(content='Attribute', _type='ClassName')]
Orphaned dict:  plural
[ldm_to_html.py:235 -                  add_key_value_html()] <  Called by dict_to_html with args ('plural', ' Methods\n', FluentTag(<html><div class="Class"><div class="Class_header header"><span class="prefix value">_</span><a class="ClassName name" id="MethodABehaviorOrOperationAssociatedWithAClass">MethodABehaviorOrOperationAssociatedWithAClass</a></div></div></html>)) {}
ADD_KEY_VALUE
<div class="str">
</div>

[ldm_to_html.py:235 -                  add_key_value_html()] >  Returned None
Orphaned dict:  plural
[ldm_to_html.py:235 -                  add_key_value_html()] <  Called by dict_to_html with args ('plural', ' Parameters\n', FluentTag(<html><div class="Class"><div class="Class_header header"><span class="prefix value">_</span><a class="ClassName name" id="ParameterAnInputToAMethod">ParameterAnInputToAMethod</a></div></div></html>)) {}
ADD_KEY_VALUE
<div class="str">
</div>

[ldm_to_html.py:235 -                  add_key_value_html()] >  Returned None
Orphaned list:  [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]
Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   Must follow the camel case naming convention and not be empty.

Orphaned dict:  where
[ldm_to_html.py:235 -                  add_key_value_html()] <  Called by dict_to_html with args ('where', ' content begins with an upper case letter.\n', FluentTag(<html><div class="Class"><div class="Class_header header"><span class="prefix value">_</span><a class="ClassName name" id="UpperCamel">UpperCamel</a><div class="OneLiner mdhtml"><div><p>a CamelName that begins with a capital letter</p></div></div></div></div><div class="subtype_of_clause"><span class="clause_label">subtype_of</span><div class="subtype_pairs"></div><div class="subtype_pair"><span class="class_name_link" href="#CamelName">CamelName</span>bySomething</div></div></html>)) {}
ADD_KEY_VALUE
<div class="str">
</div>

[ldm_to_html.py:235 -                  add_key_value_html()] >  Returned None
Orphaned dict:  where
[ldm_to_html.py:235 -                  add_key_value_html()] <  Called by dict_to_html with args ('where', ' content begins with a lower case letter.\n', FluentTag(<html><div class="Class"><div class="Class_header header"><span class="prefix value">_</span><a class="ClassName name" id="LowerCamel">LowerCamel</a><div class="OneLiner mdhtml"><div><p>a CamelName that begins with a lower case letter</p></div></div></div></div><div class="subtype_of_clause"><span class="clause_label">subtype_of</span><div class="subtype_pairs"></div><div class="subtype_pair"><span class="class_name_link" href="#CamelName">CamelName</span>bySomething</div></div></html>)) {}
ADD_KEY_VALUE
<div class="str">
</div>

[ldm_to_html.py:235 -                  add_key_value_html()] >  Returned None
Orphaned list:  [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]
Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.

Orphaned list:  [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]
Orphaned ? <class 'ldm.Literate_01.OneLiner'> :   must not containa line break or new line character

Starting codeblock
<code class="language-puml">
 @startjson

[
{
"label": "Error",
"emoji": "‚ùå",
"emojiName": "cross_mark",
"emojiUnicode": "U+274C",
"purpose": "Indicates a critical error or failure in the model."
},
{
"label": "Warning",
"emoji": "‚ö†Ô∏è",
"emojiName": "warning",
"emojiUnicode": "U+26A0",
"purpose": "Indicates a potential issue or warning in the model."
},
{
"label": "Note",
"emoji": "üìò",
"emojiName": "blue_book",
"emojiUnicode": "U+1F4D8",
"purpose": "Provides additional context, explanations, or clarifications for the annotated element."
},
{
"label": "Issue",
"emoji": "‚ö†Ô∏è",
"emojiName": "warning",
"emojiUnicode": "U+26A0",
"purpose": "Highlights a potential issue or error that needs to be addressed or resolved."
},
{
"label": "Question",
"emoji": "‚ùì",
"emojiName": "question",
"emojiUnicode": "U+2753",
"purpose": "Raises a question or seeks further clarification about the annotated element."
},
{
"label": "Suggestion",
"emoji": "üí°",
"emojiName": "bulb",
"emojiUnicode": "U+1F4A1",
"purpose": "Provides a suggestion or recommendation for improving the model or the annotated element."
},
{
"label": "Info",
"emoji": "‚ÑπÔ∏è",
"emojiName": "information_source",
"emojiUnicode": "U+2139",
"purpose": "Offers relevant information, facts, or details about the annotated element."
},
{
"label": "Todo",
"emoji": "üìå",
"emojiName": "pushpin",
"emojiUnicode": "U+1F4CC",
"purpose": "Indicates a pending task, action item, or future work related to the annotated element."
},
{
"label": "Reference",
"emoji": "üåê",
"emojiName": "globe_with_meridians",
"emojiUnicode": "U+1F310",
"purpose": "Provides a reference or link to an external resource or documentation."
},
{
"label": "See",
"emoji": "üîç",
"emojiName": "mag",
"emojiUnicode": "U+1F50D",
"purpose": "Indicates a cross-reference to another relevant element within the model."
}
]
@endjson
</code>

and Starting codeblock parent for
<function FluentTag.__getattr__.<locals>.wrapped at 0x000001C82A634900>
creating png in ldm/ldm_models/Literate/Literate_results/assets/diagram1.png
PUML png file saved to: ldm/ldm_models/Literate/Literate_results/assets/diagram1.png
creating svg in ldm/ldm_models/Literate/Literate_results/assets/diagram1.svg
PUML svg file saved to: ldm/ldm_models/Literate/Literate_results/assets/diagram1.svg
SVG div for PUML
<div class="diagram svg puml" string="SVG Diagram">
 <img src="assets/diagram1.svg"/>
</div>

Finished codeblock for PUML
<code class="language-puml">
 @startjson

[
{
"label": "Error",
"emoji": "‚ùå",
"emojiName": "cross_mark",
"emojiUnicode": "U+274C",
"purpose": "Indicates a critical error or failure in the model."
},
{
"label": "Warning",
"emoji": "‚ö†Ô∏è",
"emojiName": "warning",
"emojiUnicode": "U+26A0",
"purpose": "Indicates a potential issue or warning in the model."
},
{
"label": "Note",
"emoji": "üìò",
"emojiName": "blue_book",
"emojiUnicode": "U+1F4D8",
"purpose": "Provides additional context, explanations, or clarifications for the annotated element."
},
{
"label": "Issue",
"emoji": "‚ö†Ô∏è",
"emojiName": "warning",
"emojiUnicode": "U+26A0",
"purpose": "Highlights a potential issue or error that needs to be addressed or resolved."
},
{
"label": "Question",
"emoji": "‚ùì",
"emojiName": "question",
"emojiUnicode": "U+2753",
"purpose": "Raises a question or seeks further clarification about the annotated element."
},
{
"label": "Suggestion",
"emoji": "üí°",
"emojiName": "bulb",
"emojiUnicode": "U+1F4A1",
"purpose": "Provides a suggestion or recommendation for improving the model or the annotated element."
},
{
"label": "Info",
"emoji": "‚ÑπÔ∏è",
"emojiName": "information_source",
"emojiUnicode": "U+2139",
"purpose": "Offers relevant information, facts, or details about the annotated element."
},
{
"label": "Todo",
"emoji": "üìå",
"emojiName": "pushpin",
"emojiUnicode": "U+1F4CC",
"purpose": "Indicates a pending task, action item, or future work related to the annotated element."
},
{
"label": "Reference",
"emoji": "üåê",
"emojiName": "globe_with_meridians",
"emojiUnicode": "U+1F310",
"purpose": "Provides a reference or link to an external resource or documentation."
},
{
"label": "See",
"emoji": "üîç",
"emojiName": "mag",
"emojiUnicode": "U+1F50D",
"purpose": "Indicates a cross-reference to another relevant element within the model."
}
]
@endjson
 <div class="diagram svg puml" string="SVG Diagram">
  <img src="assets/diagram1.svg"/>
 </div>
 <div class="diagram png puml" string="PNG Diagram">
  <img src="assets/diagram1.png"/>
 </div>
</code>

and Finished codeblock parent for PUML
<function FluentTag.__getattr__.<locals>.wrapped at 0x000001C82A48FEC0>
Starting codeblock
<code class="language-csv">
 label,emoji,emojiName,emojiUnicode,purpose
Error,‚ùå,cross_mark,U+274C,Indicates a critical error or failure in the model.
Warning,‚ö†Ô∏è,warning,U+26A0,Indicates a potential issue or warning in the model.
Note,,blue_book,U+1F4D8,"Provides additional context, explanations, or clarifications for the annotated element."
Issue,,warning,U+26A0,Highlights a potential issue or error that needs to be addressed or resolved.
Question,‚ùì,question,U+2753,Raises a question or seeks further clarification about the annotated element.
Suggestion,üí°,bulb,U+1F4A1,Provides a suggestion or recommendation for improving the model or the annotated element.
Info,‚ÑπÔ∏è,information_source,U+2139,"Offers relevant information, facts, or details about the annotated element."
Todo,üìå,pushpin,U+1F4CC,"Indicates a pending task, action item, or future work related to the annotated element."
Reference,üåê,globe_with_meridians,U+1F310,Provides a reference or link to an external resource or documentation.
See,,mag,U+1F50D,Indicates a cross-reference to another relevant element within the model.
</code>

and Starting codeblock parent for
<function FluentTag.__getattr__.<locals>.wrapped at 0x000001C82A6342C0>
table follows <div class="codes-table">
 <table border="1" class="dataframe">
  <thead>
   <tr style="text-align: right;">
    <th>
    </th>
    <th>
     label
    </th>
    <th>
     emoji
    </th>
    <th>
     emojiName
    </th>
    <th>
     emojiUnicode
    </th>
    <th>
     purpose
    </th>
   </tr>
  </thead>
  <tbody>
   <tr>
    <th>
     0
    </th>
    <td>
     Error
    </td>
    <td>
     ‚ùå
    </td>
    <td>
     cross_mark
    </td>
    <td>
     U+274C
    </td>
    <td>
     Indicates a critical error or failure in the model.
    </td>
   </tr>
   <tr>
    <th>
     1
    </th>
    <td>
     Warning
    </td>
    <td>
     ‚ö†Ô∏è
    </td>
    <td>
     warning
    </td>
    <td>
     U+26A0
    </td>
    <td>
     Indicates a potential issue or warning in the model.
    </td>
   </tr>
   <tr>
    <th>
     2
    </th>
    <td>
     Note
    </td>
    <td>
     NaN
    </td>
    <td>
     blue_book
    </td>
    <td>
     U+1F4D8
    </td>
    <td>
     Provides additional context, explanations, or clarifications for the annotated element.
    </td>
   </tr>
   <tr>
    <th>
     3
    </th>
    <td>
     Issue
    </td>
    <td>
     NaN
    </td>
    <td>
     warning
    </td>
    <td>
     U+26A0
    </td>
    <td>
     Highlights a potential issue or error that needs to be addressed or resolved.
    </td>
   </tr>
   <tr>
    <th>
     4
    </th>
    <td>
     Question
    </td>
    <td>
     ‚ùì
    </td>
    <td>
     question
    </td>
    <td>
     U+2753
    </td>
    <td>
     Raises a question or seeks further clarification about the annotated element.
    </td>
   </tr>
   <tr>
    <th>
     5
    </th>
    <td>
     Suggestion
    </td>
    <td>
     üí°
    </td>
    <td>
     bulb
    </td>
    <td>
     U+1F4A1
    </td>
    <td>
     Provides a suggestion or recommendation for improving the model or the annotated element.
    </td>
   </tr>
   <tr>
    <th>
     6
    </th>
    <td>
     Info
    </td>
    <td>
     ‚ÑπÔ∏è
    </td>
    <td>
     information_source
    </td>
    <td>
     U+2139
    </td>
    <td>
     Offers relevant information, facts, or details about the annotated element.
    </td>
   </tr>
   <tr>
    <th>
     7
    </th>
    <td>
     Todo
    </td>
    <td>
     üìå
    </td>
    <td>
     pushpin
    </td>
    <td>
     U+1F4CC
    </td>
    <td>
     Indicates a pending task, action item, or future work related to the annotated element.
    </td>
   </tr>
   <tr>
    <th>
     8
    </th>
    <td>
     Reference
    </td>
    <td>
     üåê
    </td>
    <td>
     globe_with_meridians
    </td>
    <td>
     U+1F310
    </td>
    <td>
     Provides a reference or link to an external resource or documentation.
    </td>
   </tr>
   <tr>
    <th>
     9
    </th>
    <td>
     See
    </td>
    <td>
     NaN
    </td>
    <td>
     mag
    </td>
    <td>
     U+1F50D
    </td>
    <td>
     Indicates a cross-reference to another relevant element within the model.
    </td>
   </tr>
  </tbody>
 </table>
</div>

Body classes are None
Saved styled dictionary to ldm/ldm_models/Literate/Literate_results/Literate.html
Body classes are ['reviewing']
Saved styled dictionary (for review) to ldm/ldm_models/Literate/Literate_results/Literate.review.html

Phase: Skipping PDF creation
