
Phase: Warming up
Model dir:  ldm/ldm_models
Model doc:  Literate.md
Model name:  Literate
Model doc path:  ldm/ldm_models/Literate.md
Model module:  Literate01.py
Model module path:  ldm/ldm_models/Literate01.py
Results dir:  ldm/ldm_models/Literate_results

Phase: Parsing model: {model_doc_path}
PARSING ldm/ldm_models/Literate.md
Found LiterateModel_Head: # Literate Data Model
For LiterateModel_Head: # Literate Data Model
  new: LiterateModel
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found SubjectB_Head: ## Preliminaries - the basic structure
For SubjectB_Head: ## Preliminaries - the basic structureof the model
  new: SubjectB
Found BLANK_LINE: 
Found BLANK_LINE: 
Found TEXT_LINE: In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.
Found BLANK_LINE: 
Found TEXT_LINE: We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ **Component** - An element or building block of the literate data model
For Class_Head: _ **Component** - An element or building block of the literate data model
  new: Class
Found Attribute_Head: - **normalName** - the name of the component, not in camel case (*String*)
For Attribute_Head: - **normalName** - the name of the component, not in camel case (*String*)
  new: Attribute
Found BLANK_LINE: 
Found Attribute_Head: - **name** - The name of the component (CamelName)
For Attribute_Head: - **name** - The name of the component (CamelName)
  new: Attribute
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Attribute_Head: - **qualifiedName** - (*QualifiedCamel*)
For Attribute_Head: - **qualifiedName** - (*QualifiedCamel*)
  new: Attribute
Found Attribute_Head: - **abbreviatedName** - a short form of the component's name, used for cross references and improved readability. (*CamelName*)
For Attribute_Head: - **abbreviatedName** - a short form of the component's name, used for cross references and improved readability. (*CamelName*)
  new: Attribute
Found BLANK_LINE: 
Found DEFAULT: ***Default***: name
For DEFAULT: ***Default***: name
  new: Default
Found EXAMPLE: ***Example***: "LDM" is the short form of "Literate Data Model".
For EXAMPLE: ***Example***: "LDM" is the short form of "Literate Data Model".
  new: Annotation
Found BLANK_LINE: 
Found Attribute_Head: - **oneLiner** - A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _(RichLine)_
For Attribute_Head: - **oneLiner** - A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _(RichLine)_
  new: Attribute
Found BLANK_LINE: 
Found Attribute_Head: - **elaboration** - A more detailed explanation or discussion of the component _(RichText)_
For Attribute_Head: - **elaboration** - A more detailed explanation or discussion of the component _(RichText)_
  new: Attribute
Found BLANK_LINE: 
Found AttributeSection_Head: __  ***For Machinery*** - mechanical attributes
For AttributeSection_Head: __  ***For Machinery*** - mechanical attributes
  new: AttributeSection
Found Attribute_Head: - **isEmbellishment** - Indicates whether this component is an embellishment added during post-parsing processing _(Boolean)_
For Attribute_Head: - **isEmbellishment** - Indicates whether this component is an embellishment added during post-parsing processing _(Boolean)_
  new: Attribute
Found DEFAULT: ***Default***: false
For DEFAULT: ***Default***: false
  new: Default
Found NOTE: ***Note***: This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.
For NOTE: ***Note***: This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.
  new: Annotation
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ **AnnotationType** - a kind of note, or aside, used to call attention to additional information about some Component.
For Class_Head: _ **AnnotationType** - a kind of note, or aside, used to call attention to additional information about some Component.
  new: Class
Found BASED_ON: ***Based on*** : Literate Data Model
Found NOTE: ***Note***: Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.
For NOTE: ***Note***: Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.
  new: Annotation
Found Attribute_Head: - **emoji** - an emoji (Emoji)
For Attribute_Head: - **emoji** - an emoji (Emoji)
  new: Attribute
Found Attribute_Head: - **emojiName** - an emoji (String)
For Attribute_Head: - **emojiName** - an emoji (String)
  new: Attribute
Found Attribute_Head: - **emojiUnicode** - the Unicode for the emoji (Unicode)
For Attribute_Head: - **emojiUnicode** - the Unicode for the emoji (Unicode)
  new: Attribute
Found Attribute_Head: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_
For Attribute_Head: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_
  new: Attribute
Found Attribute_Head: - **plural** - the plural form of the label (*UpperCamel*).
For Attribute_Head: - **plural** - the plural form of the label (*UpperCamel*).
  new: Attribute
Found DEFAULT: Default: based on label
For DEFAULT: Default: based on label
  new: Default
Found Attribute_Head: - **Purpose** - the intended reason for the annotation.
For Attribute_Head: - **Purpose** - the intended reason for the annotation.
  new: Attribute
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ ValueType: **Annotation**
For Class_Head: _ ValueType: **Annotation**A note or comment associated with a model element
  new: Class
Found BASED_ON: ***Based on***: Component
Found Attribute_Head: - **annotationType** - (optional Annotation Type)
For Attribute_Head: - **annotationType** - (optional Annotation Type)
  new: Attribute
Found NOTE: Note: An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.
For NOTE: Note: An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.
  new: Annotation
Found Attribute_Head: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_
For Attribute_Head: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_
  new: Attribute
Found BLANK_LINE: 
Found TEXT_LINE: But any short label is valid.
Found DEFAULT: Default: from annotationType
For DEFAULT: Default: from annotationType
  new: Default
Found BLANK_LINE: 
Found Attribute_Head: - **Emoji** - (optional Emoji)
For Attribute_Head: - **Emoji** - (optional Emoji)
  new: Attribute
Found DEFAULT: Default: from annotation type
For DEFAULT: Default: from annotation type
  new: Default
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Attribute_Head: - **content** - The content or body of the annotation (*RichText*)​​​​​​​
For Attribute_Head: - **content** - The content or body of the annotation (*RichText*)​​​​​​​
  new: Attribute
Found AttributeSection_Head: __***For Machinery***
For AttributeSection_Head: __***For Machinery***
  new: AttributeSection
Found Attribute_Head: - **isEmbellishment** - Indicates whether this annotation is an embellishment added during post-parsing processing _(Boolean)_
For Attribute_Head: - **isEmbellishment** - Indicates whether this annotation is an embellishment added during post-parsing processing _(Boolean)_
  new: Attribute
Found DEFAULT: ***Default***: false
For DEFAULT: ***Default***: false
  new: Default
Found NOTE: ***Note***: This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.
For NOTE: ***Note***: This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.
  new: Annotation
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found SubjectB_Head: ## The Model and its Subjects
For SubjectB_Head: ## The Model and its Subjects
  new: SubjectB
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ **LiterateDataModel** - A representation of a domain's entities, attributes, and relationships,
For Class_Head: _ **LiterateDataModel** - A representation of a domain's entities, attributes, and relationships,along with explanatory text and examples
  new: Class
Found ABBREVIATION: ***Abbreviation***: LDM
Found PLURAL: Plural: LiterateDataModels
Found SUBTYPE_OF: Subtype of: Component
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Attribute_Head: - name (UpperCamel )
For Attribute_Head: - name (UpperCamel )
  new: Attribute
Found Attribute_Head: - allSubjects - list of all classes in the model, as ordered in the
For Attribute_Head: - allSubjects - list of all classes in the model, as ordered in thedefinition of the model. (List of Classes)
  new: Attribute
Found DERIVATION: Derivation: gathering s.allSubjects over s in subjectAreas
For DERIVATION: Derivation: gathering s.allSubjects over s in subjectAreas
  new: Derivation
Found BLANK_LINE: 
Found CONSTRAINT: ***Constraint***: Subject names must be unique across the model.
For CONSTRAINT: ***Constraint***: Subject names must be unique across the model.
  new: Constraint
Found Attribute_Head: - allClasses - list of all classes in the model, as ordered in the definition of the model. (List of Classes)
For Attribute_Head: - allClasses - list of all classes in the model, as ordered in the definition of the model. (List of Classes)
  new: Attribute
Found DERIVATION: Derivation: gathering s.allClasses over s in allSubjects.
For DERIVATION: Derivation: gathering s.allClasses over s in allSubjects.
  new: Derivation
Found CONSTRAINT: ***Constraint***: Class names must be unique across the model.
For CONSTRAINT: ***Constraint***: Class names must be unique across the model.
  new: Constraint
Found BLANK_LINE: 
Found AttributeSection_Head: __ 	***Modeling Configuration***
For AttributeSection_Head: __ 	***Modeling Configuration***
  new: AttributeSection
Found Attribute_Head: - **annotationTypes** - (List of AnnotationTypes)
For Attribute_Head: - **annotationTypes** - (List of AnnotationTypes)
  new: Attribute
Found Attribute_Head: - **Preferred Coding Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Coding Language).
For Attribute_Head: - **Preferred Coding Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Coding Language).
  new: Attribute
Found DEFAULT: Default: OCL
For DEFAULT: Default: OCL
  new: Default
Found Attribute_Head: - **alternate Coding Languages** -  (optional List of Coding Languages).
For Attribute_Head: - **alternate Coding Languages** -  (optional List of Coding Languages).
  new: Attribute
Found Attribute_Head: - **Preferred Template Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Template Language).
For Attribute_Head: - **Preferred Template Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Template Language).
  new: Attribute
Found DEFAULT: Default: Handlebars
For DEFAULT: Default: Handlebars
  new: Default
Found Attribute_Head: - **alternate Template Languages** -  (optional List of Template Languages).
For Attribute_Head: - **alternate Template Languages** -  (optional List of Template Languages).
  new: Attribute
Found Attribute_Head: - **aiFunctions** - A list of functions that require sophisticated AI-powered implementation *(List of String)*
For Attribute_Head: - **aiFunctions** - A list of functions that require sophisticated AI-powered implementation *(List of String)*
  new: Attribute
Found DERIVATION: Derivation: ['aiEnglishPlural()']
For DERIVATION: Derivation: ['aiEnglishPlural()']
  new: Derivation
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ **Subject**
For Class_Head: _ **Subject**A specific topic or theme within the model
  new: Class
Found PLURAL: Plural: Subjects
Found SUBTYPE_OF: Subtype of: Component
Found DEPENDENT_OF: Dependent of: LiterateDataModel
Found BLANK_LINE: 
Found TEXT_LINE: Subjects are the chapters an sections of the model.
Found TEXT_LINE: A subject need not contain any Classes if it’s just expository.
Found BLANK_LINE: 
Found Attribute_Head: - name (UpperCamel )
For Attribute_Head: - name (UpperCamel )
  new: Attribute
Found Attribute_Head: - **parentSubject** - The parent subject, if any, under which this subject is nested _(optional Subject)_
For Attribute_Head: - **parentSubject** - The parent subject, if any, under which this subject is nested _(optional Subject)_
  new: Attribute
Found BLANK_LINE: 
Found Attribute_Head: - **Classes** - The major classes related to this subject, in the order in which they should be presented _(ListOf Classes)_
For Attribute_Head: - **Classes** - The major classes related to this subject, in the order in which they should be presented _(ListOf Classes)_
  new: Attribute
Found ISSUE: ***Issue***: define chapter, section, subsection as levels?
For ISSUE: ***Issue***: define chapter, section, subsection as levels?***DSL***: Generally, it is best to present the classes within a Subject in top down order:
  new: Annotation
Found Attribute_Head: - Each Class should be followed first by the classes that are dependent on it, and then
For Attribute_Head: - Each Class should be followed first by the classes that are dependent on it, and then
  new: Attribute
Found Attribute_Head: - By its subtype classes.
For Attribute_Head: - By its subtype classes.
  new: Attribute
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Attribute_Head: - **childSubjects** - Any child subjects nested under this subject, in the order in which they should be presented _(ListOf Subjects)_
For Attribute_Head: - **childSubjects** - Any child subjects nested under this subject, in the order in which they should be presented _(ListOf Subjects)_
  new: Attribute
Found INVERSE: inverse of: Subject.parentSubject.
Found BLANK_LINE: 
Found TEXT_LINE: ***DSL***:  the Classes within a Subject are always displayed before the childSubjects.
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ **SubjectArea**
For Class_Head: _ **SubjectArea**A main topic or area of focus within the model, containing related subjects and classes
  new: Class
Found PLURAL: Plural: SubjectAreas
Found SUBTYPE_OF: Subtype of: Subject
Found WHERE: Where: parentSubject is absent
Found BLANK_LINE: 
Found BLANK_LINE: 
Found SubjectC_Head: ### Classes
For SubjectC_Head: ### Classes
  new: SubjectC
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ **Class** - A key entity or object type in the model, often corresponding to a real-world concept
For Class_Head: _ **Class** - A key entity or object type in the model, often corresponding to a real-world concept
  new: Class
Found BLANK_LINE: 
Found PLURAL: Plural: Classes
Found SUBTYPE_OF: Subtype of: Component
Found CONSTRAINT: ***Constraint***: Within each Class, attribute names must be unique.
For CONSTRAINT: ***Constraint***: Within each Class, attribute names must be unique.
  new: Constraint
Found Attribute_Head: - **pluralForm** - the normal English plural form of the name of the Class (UpperName)
For Attribute_Head: - **pluralForm** - the normal English plural form of the name of the Class (UpperName)
  new: Attribute
Found BLANK_LINE: 
Found TEXT_LINE: Might be Books for the Book class or other regular plurals.
Found TEXT_LINE: But also might be People for Person.
Found BLANK_LINE: 
Found NOTE: Note: When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.
For NOTE: Note: When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.
  new: Annotation
Found BLANK_LINE: 
Found TEXT_LINE: The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.
Found DEFAULT: ***Default***: the regular plural, formed by adding "s" or "es".
For DEFAULT: ***Default***: the regular plural, formed by adding "s" or "es".
  new: Default
Found Attribute_Head: - **basedOn** - the Class or Classes on which this class is dependent (SetOf Classes).
For Attribute_Head: - **basedOn** - the Class or Classes on which this class is dependent (SetOf Classes).
  new: Attribute
Found BLANK_LINE: 
Found BLANK_LINE: 
Found TEXT_LINE: This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.
Found BLANK_LINE: 
Found NOTE: Note: that basedOn and dependentOf are being used synonymousle in this metamodel.
For NOTE: Note: that basedOn and dependentOf are being used synonymousle in this metamodel.ToDo - fix that
  new: Annotation
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Attribute_Head: - **supertypes** - The parent class(es) from which this class inherits attributes _(ListOf Classes)_
For Attribute_Head: - **supertypes** - The parent class(es) from which this class inherits attributes _(ListOf Classes)_
  new: Attribute
Found BLANK_LINE: 
Found Attribute_Head: - **subtypings** - the criteria, or dimensions, by which the class can be divided into subtypes (list of Subtypings).
For Attribute_Head: - **subtypings** - the criteria, or dimensions, by which the class can be divided into subtypes (list of Subtypings).
  new: Attribute
Found BLANK_LINE: 
Found EXAMPLE: Example: in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).
For EXAMPLE: Example: in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).
  new: Annotation
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Attribute_Head: - **subtypes** - Any subtypes or specializations of this class based on it’s subtypings. _(ListOf Classes)_
For Attribute_Head: - **subtypes** - Any subtypes or specializations of this class based on it’s subtypings. _(ListOf Classes)_
  new: Attribute
Found BLANK_LINE: 
Found BLANK_LINE: 
Found EXAMPLE: Example: For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.
For EXAMPLE: Example: For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.
  new: Annotation
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Attribute_Head: - **attributes** - The attributes or properties of the class, in the order in which they should be presented _(ListOf Attributes)_
For Attribute_Head: - **attributes** - The attributes or properties of the class, in the order in which they should be presented _(ListOf Attributes)_
  new: Attribute
Found Attribute_Head: - **attributeSections** - additional attributes or properties of the class, grouped for clarity and elaboration.  _(ListOf AttributeSections)_
For Attribute_Head: - **attributeSections** - additional attributes or properties of the class, grouped for clarity and elaboration.  _(ListOf AttributeSections)_
  new: Attribute
Found BLANK_LINE: 
Found Attribute_Head: - **constraints** - Any constraints, rules, or validations specific to this class _(ListOf Constraints)_
For Attribute_Head: - **constraints** - Any constraints, rules, or validations specific to this class _(ListOf Constraints)_
  new: Attribute
Found NOTE: Note: Constraints may be expressed on either the Class or the Attribute. Always?
For NOTE: Note: Constraints may be expressed on either the Class or the Attribute. Always?Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.
  new: Annotation
Found Attribute_Head: - **methods** - Any behaviors or operations associated with this class _(ListOf Methods)_
For Attribute_Head: - **methods** - Any behaviors or operations associated with this class _(ListOf Methods)_
  new: Attribute
Found BLANK_LINE: 
Found AttributeSection_Head: __  ***Implied Attributes***
For AttributeSection_Head: __  ***Implied Attributes***
  new: AttributeSection
Found Attribute_Head: - **dependents** - the Classes which are basedOn this Class (optional SetOf Classes).
For Attribute_Head: - **dependents** - the Classes which are basedOn this Class (optional SetOf Classes).
  new: Attribute
Found BLANK_LINE: 
Found INVERSE: ***Inverse of***: Class.basedOn
Found Attribute_Head: - UniqueKeys - (optional Set of UniqueKeys).
For Attribute_Head: - UniqueKeys - (optional Set of UniqueKeys).
  new: Attribute
Found BLANK_LINE: 
Found INVERSE: ***Inverse of***:
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ **Subtyping** - a way in which subtypes of a Class may be classified (Subtype of Component).
For Class_Head: _ **Subtyping** - a way in which subtypes of a Class may be classified (Subtype of Component).
  new: Class
Found DEPENDENT_OF: ***Dependent of:*** Class
Found Attribute_Head: - **name** (Upper Name).
For Attribute_Head: - **name** (Upper Name).Usually ByThis or ByThat
  new: Attribute
Found Attribute_Head: - **is exclusive** (Boolean).
For Attribute_Head: - **is exclusive** (Boolean).
  new: Attribute
Found DEFAULT: Default: true
For DEFAULT: Default: true
  new: Default
Found Attribute_Head: - **is exhaustive** (Boolean).
For Attribute_Head: - **is exhaustive** (Boolean).
  new: Attribute
Found DEFAULT: Default: true
For DEFAULT: Default: true
  new: Default
Found Attribute_Head: - **classes** (List of Classes).
For Attribute_Head: - **classes** (List of Classes).
  new: Attribute
Found BLANK_LINE: 
Found TEXT_LINE: ***DSL***:  Shown in the DSL as
Found TEXT_LINE: > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)
Found TEXT_LINE: on the super class. And as
Found TEXT_LINE: > Subtype of: SuperClass byBrand
Found TEXT_LINE: on the subclass.
Found BLANK_LINE: 
Found NOTE: Note: every class can have an unnamed subtyping.
For NOTE: Note: every class can have an unnamed subtyping.Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.
  new: Annotation
Found BLANK_LINE: 
Found Class_Head: _ **ValueType** -
For Class_Head: _ **ValueType** -
  new: Class
Found SUBTYPE_OF: Subtype of: Class.
Found BLANK_LINE: 
Found Class_Head: _ **Reference Type**:
For Class_Head: _ **Reference Type**:
  new: Class
Found SUBTYPE_OF: Subtype of: Class.
Found BLANK_LINE: 
Found Class_Head: _ **CodeType**
For Class_Head: _ **CodeType**A data type or enumeration used in the model
  new: Class
Found SUBTYPE_OF: Subtype of: ValueType.
Found NOTE: Note: Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:
For NOTE: Note: Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:
  new: Annotation
Found Attribute_Head: - List the code values as a bulletted list inside the description of the attribute in the form:
For Attribute_Head: - List the code values as a bulletted list inside the description of the attribute in the form:‘**code**: description’
  new: Attribute
Found Attribute_Head: - A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.
For Attribute_Head: - A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.
  new: Attribute
Found Attribute_Head: - isCaptive - the code type was implied by use in an attribute and is only used for that attribute (Boolean) as
For Attribute_Head: - isCaptive - the code type was implied by use in an attribute and is only used for that attribute (Boolean) as
  new: Attribute
Found Class_Head: _ **Code Value**
For Class_Head: _ **Code Value**
  new: Class
Found WILD: A possible value for an enumerated data class  DependentOf: CodeType
For WILD: A possible value for an enumerated data class  DependentOf: CodeType
  new: Annotation
Found BLANK_LINE: 
Found Attribute_Head: - **code** - A short code or abbreviationi for the value _(NameString)_
For Attribute_Head: - **code** - A short code or abbreviationi for the value _(NameString)_
  new: Attribute
Found Attribute_Head: - **description** - an explanation of what the code means (*RichText*)
For Attribute_Head: - **description** - an explanation of what the code means (*RichText*)
  new: Attribute
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ **Key** - a list of attributes of a class
For Class_Head: _ **Key** - a list of attributes of a class
  new: Class
Found SUBTYPE_OF: Subtype of: Component
Found DEPENDENT_OF: DependentOf: Class
Found Attribute_Head: - keyAttributes - the attributes of the base Class. (List of Attributes ).
For Attribute_Head: - keyAttributes - the attributes of the base Class. (List of Attributes ).
  new: Attribute
Found BLANK_LINE: 
Found CONSTRAINT: Constraint: each attribute must be a direct or inherited of the base class.
For CONSTRAINT: Constraint: each attribute must be a direct or inherited of the base class.
  new: Constraint
Found CONSTRAINT: Constraint: no repetitions allowed in keyAttributes
For CONSTRAINT: Constraint: no repetitions allowed in keyAttributes> 👍 **Issue**: introduce PureLists?
  new: Constraint
Found BLANK_LINE: 
Found BLANK_LINE: 
Found ISSUE: Issue: need ascending descending to support index keys or ordering keys.
For ISSUE: Issue: need ascending descending to support index keys or ordering keys.
  new: Annotation
Found BLANK_LINE: 
Found Class_Head: _ **UniqueKey** - a list of attributes on which instances of the base class may be keyed.
For Class_Head: _ **UniqueKey** - a list of attributes on which instances of the base class may be keyed.
  new: Class
Found SUBTYPE_OF: Subtype of: Key
Found BLANK_LINE: 
Found NOTE: Note: order unimportant for Unique Keys.
For NOTE: Note: order unimportant for Unique Keys.
  new: Annotation
Found BLANK_LINE: 
Found SubjectB_Head: ## Attributes
For SubjectB_Head: ## Attributes
  new: SubjectB
Found BLANK_LINE: 
Found Class_Head: _ **Attribute Section** - a group of attributes for a class that merit a shared explanation.
For Class_Head: _ **Attribute Section** - a group of attributes for a class that merit a shared explanation.
  new: Class
Found SUBTYPE_OF: ***SubtypeOf***: Component.
Found BASED_ON: ***Based on***: Class
Found Attribute_Head: -	isOptional - whether the attributes in this section, taken together, are optional. (Boolean)
For Attribute_Head: -	isOptional - whether the attributes in this section, taken together, are optional. (Boolean)
  new: Attribute
Found BLANK_LINE: 
Found TEXT_LINE: If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.
Found TEXT_LINE: &nbsp;
Found TEXT_LINE: But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ **Attribute**
For Class_Head: _ **Attribute**A property or characteristic of a class
  new: Class
Found PLURAL: Plural: Attributes
Found SUBTYPE_OF: Subtype of: Component
Found BASED_ON: *Based on*: AttributeSection
Found Attribute_Head: - **name** - (Lower Camel).
For Attribute_Head: - **name** - (Lower Camel).
  new: Attribute
Found OVERRIDES: Overrides: CamelName
Found Attribute_Head: - **dataType** - The kind of object to which the attribute refers.  _(DataType)_
For Attribute_Head: - **dataType** - The kind of object to which the attribute refers.  _(DataType)_H 
+ In the simplest cases, the data type will be a class. And the specifier is the just the name of that class.
  new: Attribute
Found BLANK_LINE: 
Found TEXT_LINE: But,
Found Attribute_Head: - List of Editions
For Attribute_Head: - List of Editions
  new: Attribute
Found Attribute_Head: - Set of Edition
For Attribute_Head: - Set of Edition
  new: Attribute
Found Attribute_Head: - ... and more complicated cases.
For Attribute_Head: - ... and more complicated cases.
  new: Attribute
Found SEE: ***See***: the section below on Data Type Specifiers.
For SEE: ***See***: the section below on Data Type Specifiers.
  new: Annotation
Found BLANK_LINE: 
Found AttributeSection_Head: __ **Cardinalities**.
For AttributeSection_Head: __ **Cardinalities**.
  new: AttributeSection
Found Attribute_Head: - **isOptional** - Indicates whether the attribute must have a value for every instance of the class _(Boolean)_
For Attribute_Head: - **isOptional** - Indicates whether the attribute must have a value for every instance of the class _(Boolean)_
  new: Attribute
Found BLANK_LINE: 
Found DEFAULT: ***Default:*** False
For DEFAULT: ***Default:*** False
  new: Default
Found BLANK_LINE: 
Found Attribute_Head: - **cardinality** - The cardinality of the relationship represented by the attribute _(CardinalityCode)_
For Attribute_Head: - **cardinality** - The cardinality of the relationship represented by the attribute _(CardinalityCode)_
  new: Attribute
Found BLANK_LINE: 
Found DEFAULT: ***Default:***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.
For DEFAULT: ***Default:***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.
  new: Default
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found TEXT_LINE: ***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.
Found WILD: For example:
For WILD: For example:
  new: Annotation
Found Attribute_Head: - author (1:1 Author)
For Attribute_Head: - author (1:1 Author)
  new: Attribute
Found Attribute_Head: - books (optional N:M Set of Books)
For Attribute_Head: - books (optional N:M Set of Books)
  new: Attribute
Found BLANK_LINE: 
Found NOTE: ***Note***: how this works with optionality
For NOTE: ***Note***: how this works with optionality
  new: Annotation
Found BLANK_LINE: 
Found AttributeSection_Head: __  ***Inverse Attributes***
For AttributeSection_Head: __  ***Inverse Attributes***
  new: AttributeSection
Found Attribute_Head: - **isInvertible** - (Boolean)
For Attribute_Head: - **isInvertible** - (Boolean)
  new: Attribute
Found DERIVATION: ***Derivation***: true if the data type is a class or a simple collection of members of a class.
For DERIVATION: ***Derivation***: true if the data type is a class or a simple collection of members of a class.
  new: Derivation
Found Attribute_Head: - **inverseClass** - the class which contains, or would contain the inverse attribute (optional Class)
For Attribute_Head: - **inverseClass** - the class which contains, or would contain the inverse attribute (optional Class)
  new: Attribute
Found DERIVATION: ***Derivation***: from the data type. Null unless arrribute is invertible.
For DERIVATION: ***Derivation***: from the data type. Null unless arrribute is invertible.
  new: Derivation
Found Attribute_Head: - **inverseAttribute** - (optional Attribute)
For Attribute_Head: - **inverseAttribute** - (optional Attribute)
  new: Attribute
Found Attribute_Head: - **inverseIsOptional** - (optional Attribute)
For Attribute_Head: - **inverseIsOptional** - (optional Attribute)
  new: Attribute
Found BLANK_LINE: 
Found Class_Head: _ ***Formulas***
For Class_Head: _ ***Formulas***
  new: Class
Found BLANK_LINE: 
Found Attribute_Head: - **default** - The rule or formula for calculating the value, if no value is supplied
For Attribute_Head: - **default** - The rule or formula for calculating the value, if no value is suppliedNow running to a second line with the parenthentical on yet a third line 
+ (optional Derivation)
  new: Attribute
Found NOTE: Note: even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.
For NOTE: Note: even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.And let's see if the note can span extra lines, too
  new: Annotation
Found BLANK_LINE: 
Found TEXT_LINE: Yes, it handled extra lines.  Let's see about additional paras for an annotation
Found BLANK_LINE: 
Found TEXT_LINE: Last paragraph here
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Attribute_Head: - **derivation** - For derived attributes, the rule or formula for calculating the value _(optional Derivation)_
For Attribute_Head: - **derivation** - For derived attributes, the rule or formula for calculating the value _(optional Derivation)_
  new: Attribute
Found ISSUE: ***Issue***: on insert vs on access?
For ISSUE: ***Issue***: on insert vs on access?
  new: Annotation
Found Attribute_Head: - **constraints** - Any validation rules specific to this attribute _(ListOf Constraints)_
For Attribute_Head: - **constraints** - Any validation rules specific to this attribute _(ListOf Constraints)_
  new: Attribute
Found NOTE: Note: from Class.constraints
For NOTE: Note: from Class.constraints
  new: Annotation
Found BLANK_LINE: 
Found AttributeSection_Head: __ Override Tracking
For AttributeSection_Head: __ Override Tracking
  new: AttributeSection
Found Attribute_Head: - Overrides
For Attribute_Head: - Overrides
  new: Attribute
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ ***ValueType:*** **Derivation**
For Class_Head: _ ***ValueType:*** **Derivation**A rule or formula for deriving the value of an attribute
  new: Class
Found PLURAL: Plural: Derivations
Found Attribute_Head: - **statement** - An English language statement of the derivation rule _(RichText)_
For Attribute_Head: - **statement** - An English language statement of the derivation rule _(RichText)_
  new: Attribute
Found Attribute_Head: - **expression** - The formal expression of the derivation in a programming language _(CodeExpression)_
For Attribute_Head: - **expression** - The formal expression of the derivation in a programming language _(CodeExpression)_
  new: Attribute
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ ***ValueType:*** **Constraint**
For Class_Head: _ ***ValueType:*** **Constraint**A rule, condition, or validation that must be satisfied by the model
  new: Class
Found PLURAL: Plural: Constraints
Found SUBTYPE_OF: Subtype of: Component
Found Attribute_Head: - **statement** - An English language statement of the constraint _(RichText)_
For Attribute_Head: - **statement** - An English language statement of the constraint _(RichText)_
  new: Attribute
Found Attribute_Head: - **expression** - The formal expression of the constraint in a programming language (e.g., OCL _(CodeExpression)_
For Attribute_Head: - **expression** - The formal expression of the constraint in a programming language (e.g., OCL _(CodeExpression)_
  new: Attribute
Found Attribute_Head: - **severity** -  (Code)
For Attribute_Head: - **severity** -  (Code)
  new: Attribute
Found Attribute_Head: - - **Warning** - nothing fatal; just a caution
For Attribute_Head: - - **Warning** - nothing fatal; just a caution
  new: Attribute
Found Attribute_Head: - - **Error** - serious. Fix now
For Attribute_Head: - - **Error** - serious. Fix now
  new: Attribute
Found Attribute_Head: - **Message** - (Template)
For Attribute_Head: - **Message** - (Template)
  new: Attribute
Found BLANK_LINE: 
Found Class_Head: _ **Class Constraint**
For Class_Head: _ **Class Constraint**
  new: Class
Found SUBTYPE_OF: **Subtype of**: Constraint
Found BASED_ON: ***Based on***: Class.
Found BLANK_LINE: 
Found Class_Head: _ **Attribute Constraint**
For Class_Head: _ **Attribute Constraint**
  new: Class
Found SUBTYPE_OF: ***Subtype of***: Constraint
Found BASED_ON: ***Based on***: Attribute
Found BLANK_LINE: 
Found Class_Head: _ **CodeExpression**
For Class_Head: _ **CodeExpression**
  new: Class
Found Attribute_Head: - **Language** - the programming language (Code)
For Attribute_Head: - **Language** - the programming language (Code)
  new: Attribute
Found Attribute_Head: - - OCL: Object Constraint Language
For Attribute_Head: - - OCL: Object Constraint Language
  new: Attribute
Found Attribute_Head: - - Java: Java
For Attribute_Head: - - Java: Java
  new: Attribute
Found Attribute_Head: - **Expression** (String)
For Attribute_Head: - **Expression** (String)
  new: Attribute
Found SubjectB_Head: ## Methods
For SubjectB_Head: ## Methods
  new: SubjectB
Found Class_Head: _ **Method**
For Class_Head: _ **Method**A behavior or operation associated with a class
  new: Class
Found PLURAL: Plural: Methods
Found SUBTYPE_OF: Subtype of: Component
Found Attribute_Head: - **parameters** - The input parameters of the method _(ListOf Parameters)_
For Attribute_Head: - **parameters** - The input parameters of the method _(ListOf Parameters)_
  new: Attribute
Found Attribute_Head: - **returnType** - The data type of the value returned by the method _(DataType )_
For Attribute_Head: - **returnType** - The data type of the value returned by the method _(DataType )_
  new: Attribute
Found BLANK_LINE: 
Found Class_Head: _ **Parameter**
For Class_Head: _ **Parameter**An input to a method
  new: Class
Found PLURAL: Plural: Parameters
Found SUBTYPE_OF: Subtype of: Component
Found Attribute_Head: - **type** - The data type of the parameter _(DataType )_
For Attribute_Head: - **type** - The data type of the parameter _(DataType )_
  new: Attribute
Found Attribute_Head: - **cardinality** - The cardinality of the parameter (e.g., optional, required) _(AttributeCardinality)_
For Attribute_Head: - **cardinality** - The cardinality of the parameter (e.g., optional, required) _(AttributeCardinality)_
  new: Attribute
Found BLANK_LINE: 
Found SubjectB_Head: ## Data Types
For SubjectB_Head: ## Data Types
  new: SubjectB
Found BLANK_LINE: 
Found TEXT_LINE: *ValueType*:**Data Type**
Found BLANK_LINE: 
Found Class_Head: _ **Simple Data Type**
For Class_Head: _ **Simple Data Type*****SubtpeOf***: DataType
  new: Class
Found Attribute_Head: - **coreClass** - (Class)
For Attribute_Head: - **coreClass** - (Class)
  new: Attribute
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ **Complex Data Type**
For Class_Head: _ **Complex Data Type**
  new: Class
Found Attribute_Head: - **aggregation** (Aggregating Operator)
For Attribute_Head: - **aggregation** (Aggregating Operator)
  new: Attribute
Found Attribute_Head: - **aggregatedTypes** (List of DataTypes)
For Attribute_Head: - **aggregatedTypes** (List of DataTypes)
  new: Attribute
Found BLANK_LINE: 
Found Class_Head: _ **Aggregating Operator**
For Class_Head: _ **Aggregating Operator**
  new: Class
Found BLANK_LINE: 
Found Attribute_Head: - **Name**- (Code)
For Attribute_Head: - **Name**- (Code)
  new: Attribute
Found Attribute_Head: - - **SetOf**
For Attribute_Head: - - **SetOf**
  new: Attribute
Found Attribute_Head: - - **ListOf**
For Attribute_Head: - - **ListOf**
  new: Attribute
Found Attribute_Head: - - **Mapping**
For Attribute_Head: - - **Mapping**
  new: Attribute
Found Attribute_Head: - **arity** - (Integer)
For Attribute_Head: - **arity** - (Integer)
  new: Attribute
Found Attribute_Head: - **spelling** - (Template)
For Attribute_Head: - **spelling** - (Template)
  new: Attribute
Found BLANK_LINE: 
Found BLANK_LINE: 
Found SubjectB_Head: ## Low level Data Types
For SubjectB_Head: ## Low level Data Types
  new: SubjectB
Found BLANK_LINE: 
Found TEXT_LINE: insert Camel Case.md
Found BLANK_LINE: 
Found Class_Head: _ ***ValueType***: **CamelName**
For Class_Head: _ ***ValueType***: **CamelName**
  new: Class
Found BLANK_LINE: 
Found TEXT_LINE: A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.
Found SUBTYPE_OF: ***Subtype of***: String
Found Attribute_Head: - value: the string (String)
For Attribute_Head: - value: the string (String)
  new: Attribute
Found CONSTRAINT: ***Constraint***: Must follow the camel case naming convention and not be empty.
For CONSTRAINT: ***Constraint***: Must follow the camel case naming convention and not be empty.
  new: Constraint
Found EXAMPLE: Example:  "firstName", "orderDate", "customerID"
For EXAMPLE: Example:  "firstName", "orderDate", "customerID"
  new: Annotation
Found BLANK_LINE: 
Found TEXT_LINE: > 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.
Found BLANK_LINE: 
Found BLANK_LINE: 
Found WILD: *ModelingNote:* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.
For WILD: *ModelingNote:* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.
  new: Annotation
Found BLANK_LINE: 
Found Class_Head: _ **UpperCamel**- a CamelName that begins with a capital letter
For Class_Head: _ **UpperCamel**- a CamelName that begins with a capital letter
  new: Class
Found SUBTYPE_OF: **Subtype of**: CamelName
Found WHERE: **Where**: content begins with an upper case letter.
Found EXAMPLE: Example:_ "Customer", "ProductCategory", "PaymentMethod"
For EXAMPLE: Example:_ "Customer", "ProductCategory", "PaymentMethod"
  new: Annotation
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ **LowerCamel** - a CamelName that begins with a lower case letter
For Class_Head: _ **LowerCamel** - a CamelName that begins with a lower case letter
  new: Class
Found SUBTYPE_OF: **Subtype of**: CamelName
Found WHERE: **Where**: content begins with a lower case letter.
Found BLANK_LINE: 
Found EXAMPLE: Example:  "firstName", "orderTotal", "shippingAddress"
For EXAMPLE: Example:  "firstName", "orderTotal", "shippingAddress"
  new: Annotation
Found BLANK_LINE: 
Found Class_Head: _ **Qualified Camel** - an expression consisting of Camel Names separated by periods
For Class_Head: _ **Qualified Camel** - an expression consisting of Camel Names separated by periods
  new: Class
Found SUBTYPE_OF: ***Subtype of***: String
Found CONSTRAINT: ***Constraint***: content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.
For CONSTRAINT: ***Constraint***: content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.
  new: Constraint
Found BLANK_LINE: 
Found Class_Head: _ **RichText**.  A string with markup for block level formatting.
For Class_Head: _ **RichText**.  A string with markup for block level formatting.
  new: Class
Found SUBTYPE_OF: ***SubtypeOf***: String
Found BLANK_LINE: 
Found Attribute_Head: - **value** - the string content (string)
For Attribute_Head: - **value** - the string content (string)
  new: Attribute
Found Attribute_Head: - **format** - the rich text coding language used (Code)
For Attribute_Head: - **format** - the rich text coding language used (Code)
  new: Attribute
Found Attribute_Head: - **HTML**
For Attribute_Head: - **HTML**
  new: Attribute
Found Attribute_Head: - **MarkDown**
For Attribute_Head: - **MarkDown**
  new: Attribute
Found BLANK_LINE: 
Found Class_Head: _  **RichLine**   - String with markup for line level formatting.
For Class_Head: _  **RichLine**   - String with markup for line level formatting.
  new: Class
Found SUBTYPE_OF: ***SubtypeOf***: RichText
Found BLANK_LINE: 
Found Attribute_Head: - **value** - the string content (string)
For Attribute_Head: - **value** - the string content (string)
  new: Attribute
Found CONSTRAINT: ***Constraint***: must not containa line break or new line character
For CONSTRAINT: ***Constraint***: must not containa line break or new line character
  new: Constraint
Found BLANK_LINE: 
Found Class_Head: _ **PrimitiveType**
For Class_Head: _ **PrimitiveType**
  new: Class
Found SUBTYPE_OF: Subtype of: ValueType
Found WILD: Values:
For WILD: Values:**String** 
+ **Integer** 
+ **Decimal** 
+ **Boolean** 
+ **Date** 
+ **Time** 
+ **DateTime**
  new: Annotation
Found BLANK_LINE: 
Found TEXT_LINE: ===
Found SubjectB_Head: ## Appendices
For SubjectB_Head: ## AppendicesInsert More Sidebars.md 
+ Insert Overrides.md 
+ insert LDM Intro.md 
+ Insert OCL.md 
+ Insert Camel Case.md
  new: SubjectB
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found SubjectC_Head: ### Annotation Types Used
For SubjectC_Head: ### Annotation Types Used
  new: SubjectC
Found BLANK_LINE: 
Found TEXT_LINE: These are the recognized Annotation Types for the LDM model.
Found BLANK_LINE: 
Found BLANK_LINE: 
Found TEXT_LINE: And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.
Found BLANK_LINE: 
Found CODE_FENCE: ```typescript
Found BLANK_LINE: 
Found TEXT_LINE: ===
Found SubjectB_Head: ## Appendices
For SubjectB_Head: ## AppendicesInsert More Sidebars.md 
+ Insert Overrides.md 
+ insert LDM Intro.md 
+ Insert OCL.md 
+ Insert Camel Case.md
  new: SubjectB
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found TEXT_LINE: == content to add
Found Attribute_Head: - minor component
For Attribute_Head: - minor component
  new: Attribute
Found Attribute_Head: - embellishment
For Attribute_Head: - embellishment
  new: Attribute
Found Attribute_Head: - words and phrases
For Attribute_Head: - words and phrases
  new: Attribute

Phase: Deriving dict for model
DerivingDict for Part:  Document
DerivingDict for Part:  LiterateModel
		Full header is: # Literate Data Model



===
ParsingHeader header: # Literate Data Model

ParsingHeader result: {'prefix': '#', 'name': SubjectName(content='Literate Data Model', _type='SubjectName'), 'one_liner': None, 'parenthetical': ''}
===

DerivingDict for Part:  SubjectB
		Full header is: ## Preliminaries - the basic structure
of the model


===
ParsingHeader header: ## Preliminaries - the basic structure
of the model
ParsingHeader result: {'prefix': '##', 'name': SubjectName(content='Preliminaries', _type='SubjectName'), 'one_liner': OneLiner(_type='OneLiner', content='the basic structure\nof the model'), 'parenthetical': ''}
===

DerivingDict for Part:  Class
		Full header is: _ **Component** - An element or building block of the literate data model



===
ParsingHeader header: _ **Component** - An element or building block of the literate data model

ParsingHeader result: {'prefix': '_', 'name': ClassName(content='Component', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content='An element or building block of the literate data model'), 'parenthetical': ''}
===

DerivingDict for Part:  Attribute
		Full header is: - **normalName** - the name of the component, not in camel case (*String*)



===
ParsingHeader header: - **normalName** - the name of the component, not in camel case (*String*)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='normalName', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='the name of the component, not in camel case'), 'parenthetical': '*String*', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='String', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **normalName** - the name of the component, not in camel case (*String*)

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "normalName",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "the name of the component, not in camel case"
  },
  "parenthetical": "*String*",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "String",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': ''}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **name** - The name of the component (CamelName)



===
ParsingHeader header: - **name** - The name of the component (CamelName)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='name', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='The name of the component'), 'parenthetical': 'CamelName', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='CamelName', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **name** - The name of the component (CamelName)

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "name",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "The name of the component"
  },
  "parenthetical": "CamelName",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "CamelName",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **qualifiedName** - (*QualifiedCamel*)



===
ParsingHeader header: - **qualifiedName** - (*QualifiedCamel*)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='qualifiedName', _type='AttributeName'), 'one_liner': None, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='QualifiedCamel', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **qualifiedName** - (*QualifiedCamel*)

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "qualifiedName",
    "_type": "AttributeName"
  },
  "parenthetical": "*QualifiedCamel*",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "QualifiedCamel",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **abbreviatedName** - a short form of the component's name, used for cross references and improved readability. (*CamelName*)



===
ParsingHeader header: - **abbreviatedName** - a short form of the component's name, used for cross references and improved readability. (*CamelName*)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='abbreviatedName', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content="a short form of the component's name, used for cross references and improved readability."), 'parenthetical': '*CamelName*', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='CamelName', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Default
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: ***Default***: name
adding name value. one_liner -.  name

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=' name\n')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  name

Absorbing to one_liner  name
 into {'_type': 'Default'}
after absorb, dict has:  {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}
And the dict has;;;
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": " name\n"
  }
}
Re-display for Part:  Default
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: ***Default***: name

DerivedDict for Part:  Default
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": " name\n"
  }
}
Absorbing to default {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}}
DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'} to annotations
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **abbreviatedName** - a short form of the component's name, used for cross references and improved readability. (*CamelName*)
. . Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ DEFAULT: ***Default***: name
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ EXAMPLE: ***Example***: "LDM" is the short form of "Literate Data Model".

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "abbreviatedName",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "a short form of the component's name, used for cross references and improved readability."
  },
  "parenthetical": "*CamelName*",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "CamelName",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "default": {
    "_type": "Default",
    "one_liner": {
      "_type": "OneLiner",
      "content": " name\n"
    }
  },
  "annotations": [
    {
      "_type": "Annotation",
      "emoji": "",
      "label": "Example",
      "content": "\"LDM\" is the short form of \"Literate Data Model\"."
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}]}
DerivingDict for Part:  Attribute
		Full header is: - **oneLiner** - A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _(RichLine)_



===
ParsingHeader header: - **oneLiner** - A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _(RichLine)_

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='oneLiner', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'), 'parenthetical': 'RichLine', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='RichLine', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **oneLiner** - A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _(RichLine)_

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "oneLiner",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _"
  },
  "parenthetical": "RichLine",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "RichLine",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **elaboration** - A more detailed explanation or discussion of the component _(RichText)_



===
ParsingHeader header: - **elaboration** - A more detailed explanation or discussion of the component _(RichText)_

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='elaboration', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='A more detailed explanation or discussion of the component _'), 'parenthetical': 'RichText', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='RichText', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **elaboration** - A more detailed explanation or discussion of the component _(RichText)_

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "elaboration",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "A more detailed explanation or discussion of the component _"
  },
  "parenthetical": "RichText",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "RichText",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  AttributeSection
		Full header is: __  ***For Machinery*** - mechanical attributes



===
ParsingHeader header: __  ***For Machinery*** - mechanical attributes

ParsingHeader result: {'prefix': '__', 'name': AttributeSectionName(content='For Machinery', _type='AttributeSectionName'), 'one_liner': OneLiner(_type='OneLiner', content='mechanical attributes'), 'parenthetical': ''}
===

DerivingDict for Part:  Attribute
		Full header is: - **isEmbellishment** - Indicates whether this component is an embellishment added during post-parsing processing _(Boolean)_



===
ParsingHeader header: - **isEmbellishment** - Indicates whether this component is an embellishment added during post-parsing processing _(Boolean)_

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='isEmbellishment', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='Indicates whether this component is an embellishment added during post-parsing processing _'), 'parenthetical': 'Boolean', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Boolean', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Default
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: ***Default***: false
adding name value. one_liner -.  false

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=' false\n')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  false

Absorbing to one_liner  false
 into {'_type': 'Default'}
after absorb, dict has:  {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}
And the dict has;;;
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": " false\n"
  }
}
Re-display for Part:  Default
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: ***Default***: false

DerivedDict for Part:  Default
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": " false\n"
  }
}
Absorbing to default {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}}
DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'} to annotations
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **isEmbellishment** - Indicates whether this component is an embellishment added during post-parsing processing _(Boolean)_
. . Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ DEFAULT: ***Default***: false
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ NOTE: ***Note***: This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "isEmbellishment",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "Indicates whether this component is an embellishment added during post-parsing processing _"
  },
  "parenthetical": "Boolean",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Boolean",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "default": {
    "_type": "Default",
    "one_liner": {
      "_type": "OneLiner",
      "content": " false\n"
    }
  },
  "annotations": [
    {
      "_type": "Annotation",
      "emoji": "",
      "label": "Note",
      "content": "This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source."
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]} into {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': ''}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]} to attributes
after absorb, dict has:  {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}
Absorbing to attribute_sections {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]} to attribute_sections
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}]}
DerivingDict for Part:  Class
		Full header is: _ **AnnotationType** - a kind of note, or aside, used to call attention to additional information about some Component.



===
ParsingHeader header: _ **AnnotationType** - a kind of note, or aside, used to call attention to additional information about some Component.

ParsingHeader result: {'prefix': '_', 'name': ClassName(content='AnnotationType', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content='a kind of note, or aside, used to call attention to additional information about some Component.'), 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for BASED_ON: ***Based on*** : Literate Data Model
adding name value. based_on -. [ClassName(content='Literate Data Model', _type='ClassName')]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'based_on': [ClassName(content='Literate Data Model', _type='ClassName')]}
Using ATT_NAME  based_on for based_on
Adding value in ddforpart. based_on -. [ClassName(content='Literate Data Model', _type='ClassName')]
Absorbing to based_on [ClassName(content='Literate Data Model', _type='ClassName')] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': ''}
Extend [ClassName(content='Literate Data Model', _type='ClassName')] to based_on
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "AnnotationType",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "a kind of note, or aside, used to call attention to additional information about some Component."
  },
  "parenthetical": "",
  "based_on": [
    {
      "content": "Literate Data Model",
      "_type": "ClassName"
    }
  ]
}
DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')]}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'} to annotations
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}]}
DerivingDict for Part:  Attribute
		Full header is: - **emoji** - an emoji (Emoji)



===
ParsingHeader header: - **emoji** - an emoji (Emoji)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='emoji', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='an emoji'), 'parenthetical': 'Emoji', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Emoji', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **emoji** - an emoji (Emoji)

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "emoji",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "an emoji"
  },
  "parenthetical": "Emoji",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Emoji",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **emojiName** - an emoji (String)



===
ParsingHeader header: - **emojiName** - an emoji (String)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='emojiName', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='an emoji'), 'parenthetical': 'String', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='String', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **emojiName** - an emoji (String)

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "emojiName",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "an emoji"
  },
  "parenthetical": "String",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "String",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **emojiUnicode** - the Unicode for the emoji (Unicode)



===
ParsingHeader header: - **emojiUnicode** - the Unicode for the emoji (Unicode)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='emojiUnicode', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='the Unicode for the emoji'), 'parenthetical': 'Unicode', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Unicode', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **emojiUnicode** - the Unicode for the emoji (Unicode)

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "emojiUnicode",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "the Unicode for the emoji"
  },
  "parenthetical": "Unicode",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Unicode",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_



===
ParsingHeader header: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='label', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='A short label to indicate the purpose of the annotation _'), 'parenthetical': 'CamelName', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='CamelName', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "label",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "A short label to indicate the purpose of the annotation _"
  },
  "parenthetical": "CamelName",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "CamelName",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **plural** - the plural form of the label (*UpperCamel*).



===
ParsingHeader header: - **plural** - the plural form of the label (*UpperCamel*).

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='plural', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='the plural form of the label'), 'parenthetical': '*UpperCamel*', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='UpperCamel', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Default
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: Default: based on label
adding name value. one_liner -.  based on label

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  based on label

Absorbing to one_liner  based on label
 into {'_type': 'Default'}
after absorb, dict has:  {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}
And the dict has;;;
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": " based on label\n"
  }
}
Re-display for Part:  Default
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: Default: based on label

DerivedDict for Part:  Default
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": " based on label\n"
  }
}
Absorbing to default {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **plural** - the plural form of the label (*UpperCamel*).
. . Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ DEFAULT: Default: based on label

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "plural",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "the plural form of the label"
  },
  "parenthetical": "*UpperCamel*",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "UpperCamel",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "default": {
    "_type": "Default",
    "one_liner": {
      "_type": "OneLiner",
      "content": " based on label\n"
    }
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}]}
DerivingDict for Part:  Attribute
		Full header is: - **Purpose** - the intended reason for the annotation.



===
ParsingHeader header: - **Purpose** - the intended reason for the annotation.

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='Purpose', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='the intended reason for the annotation.'), 'parenthetical': ''}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **Purpose** - the intended reason for the annotation.

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "Purpose",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "the intended reason for the annotation."
  },
  "parenthetical": ""
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}]}
DerivingDict for Part:  Class
		Full header is: _ ValueType: **Annotation**
A note or comment associated with a model element


===
ParsingHeader header: _ ValueType: **Annotation**
A note or comment associated with a model element
ParsingHeader result: {'prefix': '_', 'name': ClassName(content='ValueType Annotation\nA note or comment associated with a model element', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for BASED_ON: ***Based on***: Component
adding name value. based_on -. [ClassName(content='Component', _type='ClassName')]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'based_on': [ClassName(content='Component', _type='ClassName')]}
Using ATT_NAME  based_on for based_on
Adding value in ddforpart. based_on -. [ClassName(content='Component', _type='ClassName')]
Absorbing to based_on [ClassName(content='Component', _type='ClassName')] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': ''}
Extend [ClassName(content='Component', _type='ClassName')] to based_on
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "ValueType Annotation\nA note or comment associated with a model element",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "based_on": [
    {
      "content": "Component",
      "_type": "ClassName"
    }
  ]
}
DerivingDict for Part:  Attribute
		Full header is: - **annotationType** - (optional Annotation Type)



===
ParsingHeader header: - **annotationType** - (optional Annotation Type)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='annotationType', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'optional Annotation Type', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Annotation Type', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'} to annotations
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **annotationType** - (optional Annotation Type)
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ NOTE: Note: An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "annotationType",
    "_type": "AttributeName"
  },
  "parenthetical": "optional Annotation Type",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Annotation Type",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "annotations": [
    {
      "_type": "Annotation",
      "emoji": "",
      "label": "Note",
      "content": "An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*."
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}]}
DerivingDict for Part:  Attribute
		Full header is: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_



===
ParsingHeader header: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='label', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='A short label to indicate the purpose of the annotation _'), 'parenthetical': 'CamelName', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='CamelName', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Default
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: Default: from annotationType
adding name value. one_liner -.  from annotationType

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  from annotationType

Absorbing to one_liner  from annotationType
 into {'_type': 'Default'}
after absorb, dict has:  {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}
And the dict has;;;
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": " from annotationType\n"
  }
}
Re-display for Part:  Default
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: Default: from annotationType

DerivedDict for Part:  Default
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": " from annotationType\n"
  }
}
Absorbing to default {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}]}
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_
_ _ ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='But any short label is valid.', extra_text=[])], extra_text=[])]
. . Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ DEFAULT: Default: from annotationType

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "label",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "A short label to indicate the purpose of the annotation _"
  },
  "parenthetical": "CamelName",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "CamelName",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "elaboration": [
    {
      "_type": "Paragraph",
      "content": "But any short label is valid.\n"
    }
  ],
  "default": {
    "_type": "Default",
    "one_liner": {
      "_type": "OneLiner",
      "content": " from annotationType\n"
    }
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}]}
DerivingDict for Part:  Attribute
		Full header is: - **Emoji** - (optional Emoji)



===
ParsingHeader header: - **Emoji** - (optional Emoji)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='Emoji', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'optional Emoji', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Emoji', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Default
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: Default: from annotation type
adding name value. one_liner -.  from annotation type

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  from annotation type

Absorbing to one_liner  from annotation type
 into {'_type': 'Default'}
after absorb, dict has:  {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}
And the dict has;;;
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": " from annotation type\n"
  }
}
Re-display for Part:  Default
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: Default: from annotation type

DerivedDict for Part:  Default
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": " from annotation type\n"
  }
}
Absorbing to default {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **Emoji** - (optional Emoji)
. . Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ DEFAULT: Default: from annotation type

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "Emoji",
    "_type": "AttributeName"
  },
  "parenthetical": "optional Emoji",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Emoji",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "default": {
    "_type": "Default",
    "one_liner": {
      "_type": "OneLiner",
      "content": " from annotation type\n"
    }
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}]}
DerivingDict for Part:  Attribute
		Full header is: - **content** - The content or body of the annotation (*RichText*)​​​​​​​



===
ParsingHeader header: - **content** - The content or body of the annotation (*RichText*)​​​​​​​

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='content', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='The content or body of the annotation'), 'parenthetical': '*RichText*', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='RichText', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **content** - The content or body of the annotation (*RichText*)​​​​​​​

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "content",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "The content or body of the annotation"
  },
  "parenthetical": "*RichText*",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "RichText",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  AttributeSection
		Full header is: __***For Machinery***



===
ParsingHeader header: __***For Machinery***

ParsingHeader result: {'prefix': '__', 'name': AttributeSectionName(content='For Machinery', _type='AttributeSectionName'), 'one_liner': None, 'parenthetical': ''}
===

DerivingDict for Part:  Attribute
		Full header is: - **isEmbellishment** - Indicates whether this annotation is an embellishment added during post-parsing processing _(Boolean)_



===
ParsingHeader header: - **isEmbellishment** - Indicates whether this annotation is an embellishment added during post-parsing processing _(Boolean)_

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='isEmbellishment', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='Indicates whether this annotation is an embellishment added during post-parsing processing _'), 'parenthetical': 'Boolean', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Boolean', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Default
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: ***Default***: false
adding name value. one_liner -.  false

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=' false\n')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  false

Absorbing to one_liner  false
 into {'_type': 'Default'}
after absorb, dict has:  {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}
And the dict has;;;
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": " false\n"
  }
}
Re-display for Part:  Default
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: ***Default***: false

DerivedDict for Part:  Default
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": " false\n"
  }
}
Absorbing to default {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}}
DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'} to annotations
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **isEmbellishment** - Indicates whether this annotation is an embellishment added during post-parsing processing _(Boolean)_
. . Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ DEFAULT: ***Default***: false
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ NOTE: ***Note***: This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "isEmbellishment",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "Indicates whether this annotation is an embellishment added during post-parsing processing _"
  },
  "parenthetical": "Boolean",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Boolean",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "default": {
    "_type": "Default",
    "one_liner": {
      "_type": "OneLiner",
      "content": " false\n"
    }
  },
  "annotations": [
    {
      "_type": "Annotation",
      "emoji": "",
      "label": "Note",
      "content": "This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source."
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]} into {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': ''}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]} to attributes
after absorb, dict has:  {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}
Absorbing to attribute_sections {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]} to attribute_sections
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}
Absorbing to subjects {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]} into {'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': ''}
Append {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]} to subjects
after absorb, dict has:  {'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}]}
DerivingDict for Part:  SubjectB
		Full header is: ## The Model and its Subjects



===
ParsingHeader header: ## The Model and its Subjects

ParsingHeader result: {'prefix': '##', 'name': SubjectName(content='The Model and its Subjects', _type='SubjectName'), 'one_liner': None, 'parenthetical': ''}
===

DerivingDict for Part:  Class
		Full header is: _ **LiterateDataModel** - A representation of a domain's entities, attributes, and relationships,
along with explanatory text and examples


===
ParsingHeader header: _ **LiterateDataModel** - A representation of a domain's entities, attributes, and relationships,
along with explanatory text and examples
ParsingHeader result: {'prefix': '_', 'name': ClassName(content='LiterateDataModel', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content="A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"), 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for ABBREVIATION: ***Abbreviation***: LDM
adding name value. abbreviation -. LDM
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'abbreviation': 'LDM'}
Using ATT_NAME  abbreviation for abbreviation
Adding value in ddforpart. abbreviation -. LDM
Absorbing to abbreviation LDM into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': ''}
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM'}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "LiterateDataModel",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"
  },
  "parenthetical": "",
  "abbreviation": "LDM"
}
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for PLURAL: Plural: LiterateDataModels
adding name value. plural -.  LiterateDataModels

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'plural': ' LiterateDataModels\n'}
Using ATT_NAME  plural for plural
Adding value in ddforpart. plural -.  LiterateDataModels

Absorbing to plural  LiterateDataModels
 into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM'}
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n'}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "LiterateDataModel",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"
  },
  "parenthetical": "",
  "abbreviation": "LDM",
  "plural": " LiterateDataModels\n"
}
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Component
parsing subtypeOfs:   Component

SubtypeOf result is  [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Using ATT_NAME  subtype_of for subtype_of
Adding value in ddforpart. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
Absorbing to subtype_of [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n'}
Extend [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] to subtype_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "LiterateDataModel",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"
  },
  "parenthetical": "",
  "abbreviation": "LDM",
  "plural": " LiterateDataModels\n",
  "subtype_of": [
    "UnserializablePiece"
  ]
}
DerivingDict for Part:  Attribute
		Full header is: - name (UpperCamel )



===
ParsingHeader header: - name (UpperCamel )

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='name', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'UpperCamel', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='UpperCamel', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - name (UpperCamel )

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "name",
    "_type": "AttributeName"
  },
  "parenthetical": "UpperCamel",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "UpperCamel",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - allSubjects - list of all classes in the model, as ordered in the
definition of the model. (List of Classes)


===
ParsingHeader header: - allSubjects - list of all classes in the model, as ordered in the
definition of the model. (List of Classes)
Created list dt:  List of reference Classes
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='allSubjects', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='list of all classes in the model, as ordered in the\ndefinition of the model.'), 'parenthetical': 'List of Classes', 'data_type_clause': DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Classes', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Derivation
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DERIVATION: Derivation: gathering s.allSubjects over s in subjectAreas
adding name value. one_liner -.  gathering s.allSubjects over s in subjectAreas

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  gathering s.allSubjects over s in subjectAreas

Absorbing to one_liner  gathering s.allSubjects over s in subjectAreas
 into {'_type': 'Derivation'}
after absorb, dict has:  {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}
And the dict has;;;
{
  "_type": "Derivation",
  "one_liner": {
    "_type": "OneLiner",
    "content": " gathering s.allSubjects over s in subjectAreas\n"
  }
}
Re-display for Part:  Derivation
. Derivation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DERIVATION: Derivation: gathering s.allSubjects over s in subjectAreas

DerivedDict for Part:  Derivation
{
  "_type": "Derivation",
  "one_liner": {
    "_type": "OneLiner",
    "content": " gathering s.allSubjects over s in subjectAreas\n"
  }
}
Absorbing to derivation {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}}
DerivingDict for Part:  Constraint
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for CONSTRAINT: ***Constraint***: Subject names must be unique across the model.
Patched att_name is one_liner for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is one_liner
adding name value. one_liner -.  Subject names must be unique across the model.

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  Subject names must be unique across the model.

Absorbing to one_liner  Subject names must be unique across the model.
 into {'_type': 'Constraint'}
Append  Subject names must be unique across the model.
 to one_liner
after absorb, dict has:  {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}
And the dict has;;;
{
  "_type": "Constraint",
  "one_liner": [
    {
      "_type": "OneLiner",
      "content": " Subject names must be unique across the model.\n"
    }
  ]
}
Absorbing to constraints {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}}
Append {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]} to constraints
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - allSubjects - list of all classes in the model, as ordered in thedefinition of the model. (List of Classes)
. . Derivation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ DERIVATION: Derivation: gathering s.allSubjects over s in subjectAreas
. . Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ CONSTRAINT: ***Constraint***: Subject names must be unique across the model.

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "allSubjects",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "list of all classes in the model, as ordered in the\ndefinition of the model."
  },
  "parenthetical": "List of Classes",
  "data_type_clause": {
    "data_type": {
      "_type": "ListDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "Classes",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "derivation": {
    "_type": "Derivation",
    "one_liner": {
      "_type": "OneLiner",
      "content": " gathering s.allSubjects over s in subjectAreas\n"
    }
  },
  "constraints": [
    {
      "_type": "Constraint",
      "one_liner": [
        {
          "_type": "OneLiner",
          "content": " Subject names must be unique across the model.\n"
        }
      ]
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}]}
DerivingDict for Part:  Attribute
		Full header is: - allClasses - list of all classes in the model, as ordered in the definition of the model. (List of Classes)



===
ParsingHeader header: - allClasses - list of all classes in the model, as ordered in the definition of the model. (List of Classes)

Created list dt:  List of reference Classes
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='allClasses', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='list of all classes in the model, as ordered in the definition of the model.'), 'parenthetical': 'List of Classes', 'data_type_clause': DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Classes', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Derivation
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DERIVATION: Derivation: gathering s.allClasses over s in allSubjects.
adding name value. one_liner -.  gathering s.allClasses over s in allSubjects.

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  gathering s.allClasses over s in allSubjects.

Absorbing to one_liner  gathering s.allClasses over s in allSubjects.
 into {'_type': 'Derivation'}
after absorb, dict has:  {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}
And the dict has;;;
{
  "_type": "Derivation",
  "one_liner": {
    "_type": "OneLiner",
    "content": " gathering s.allClasses over s in allSubjects.\n"
  }
}
Re-display for Part:  Derivation
. Derivation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DERIVATION: Derivation: gathering s.allClasses over s in allSubjects.

DerivedDict for Part:  Derivation
{
  "_type": "Derivation",
  "one_liner": {
    "_type": "OneLiner",
    "content": " gathering s.allClasses over s in allSubjects.\n"
  }
}
Absorbing to derivation {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}}
DerivingDict for Part:  Constraint
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for CONSTRAINT: ***Constraint***: Class names must be unique across the model.
Patched att_name is one_liner for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is one_liner
adding name value. one_liner -.  Class names must be unique across the model.

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  Class names must be unique across the model.

Absorbing to one_liner  Class names must be unique across the model.
 into {'_type': 'Constraint'}
Append  Class names must be unique across the model.
 to one_liner
after absorb, dict has:  {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}
And the dict has;;;
{
  "_type": "Constraint",
  "one_liner": [
    {
      "_type": "OneLiner",
      "content": " Class names must be unique across the model.\n"
    }
  ]
}
Absorbing to constraints {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}}
Append {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]} to constraints
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - allClasses - list of all classes in the model, as ordered in the definition of the model. (List of Classes)
. . Derivation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ DERIVATION: Derivation: gathering s.allClasses over s in allSubjects.
. . Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ CONSTRAINT: ***Constraint***: Class names must be unique across the model.

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "allClasses",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "list of all classes in the model, as ordered in the definition of the model."
  },
  "parenthetical": "List of Classes",
  "data_type_clause": {
    "data_type": {
      "_type": "ListDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "Classes",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "derivation": {
    "_type": "Derivation",
    "one_liner": {
      "_type": "OneLiner",
      "content": " gathering s.allClasses over s in allSubjects.\n"
    }
  },
  "constraints": [
    {
      "_type": "Constraint",
      "one_liner": [
        {
          "_type": "OneLiner",
          "content": " Class names must be unique across the model.\n"
        }
      ]
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}]}
DerivingDict for Part:  AttributeSection
		Full header is: __ 	***Modeling Configuration***



===
ParsingHeader header: __ 	***Modeling Configuration***

ParsingHeader result: {'prefix': '__', 'name': AttributeSectionName(content='Modeling Configuration', _type='AttributeSectionName'), 'one_liner': None, 'parenthetical': ''}
===

DerivingDict for Part:  Attribute
		Full header is: - **annotationTypes** - (List of AnnotationTypes)



===
ParsingHeader header: - **annotationTypes** - (List of AnnotationTypes)

Created list dt:  List of reference AnnotationTypes
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='annotationTypes', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='AnnotationTypes', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **annotationTypes** - (List of AnnotationTypes)

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "annotationTypes",
    "_type": "AttributeName"
  },
  "parenthetical": "List of AnnotationTypes",
  "data_type_clause": {
    "data_type": {
      "_type": "ListDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "AnnotationTypes",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': ''}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **Preferred Coding Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Coding Language).



===
ParsingHeader header: - **Preferred Coding Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Coding Language).

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='Preferred Coding Language', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='the recommended lanquage  for expressing derivation, defaults, and constraints'), 'parenthetical': 'Coding Language', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Coding Language', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Default
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: Default: OCL
adding name value. one_liner -.  OCL

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  OCL

Absorbing to one_liner  OCL
 into {'_type': 'Default'}
after absorb, dict has:  {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}
And the dict has;;;
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": " OCL\n"
  }
}
Re-display for Part:  Default
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: Default: OCL

DerivedDict for Part:  Default
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": " OCL\n"
  }
}
Absorbing to default {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **Preferred Coding Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Coding Language).
. . Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ DEFAULT: Default: OCL

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "Preferred Coding Language",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "the recommended lanquage  for expressing derivation, defaults, and constraints"
  },
  "parenthetical": "Coding Language",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Coding Language",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "default": {
    "_type": "Default",
    "one_liner": {
      "_type": "OneLiner",
      "content": " OCL\n"
    }
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}} into {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}} to attributes
after absorb, dict has:  {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}]}
DerivingDict for Part:  Attribute
		Full header is: - **alternate Coding Languages** -  (optional List of Coding Languages).



===
ParsingHeader header: - **alternate Coding Languages** -  (optional List of Coding Languages).

Created list dt:  List of reference Coding Languages
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='alternate Coding Languages', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Coding Languages', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **alternate Coding Languages** -  (optional List of Coding Languages).

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "alternate Coding Languages",
    "_type": "AttributeName"
  },
  "parenthetical": "optional List of Coding Languages",
  "data_type_clause": {
    "data_type": {
      "_type": "ListDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "Coding Languages",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **Preferred Template Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Template Language).



===
ParsingHeader header: - **Preferred Template Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Template Language).

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='Preferred Template Language', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='the recommended lanquage  for expressing derivation, defaults, and constraints'), 'parenthetical': 'Template Language', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Template Language', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Default
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: Default: Handlebars
adding name value. one_liner -.  Handlebars

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  Handlebars

Absorbing to one_liner  Handlebars
 into {'_type': 'Default'}
after absorb, dict has:  {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}
And the dict has;;;
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": " Handlebars\n"
  }
}
Re-display for Part:  Default
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: Default: Handlebars

DerivedDict for Part:  Default
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": " Handlebars\n"
  }
}
Absorbing to default {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **Preferred Template Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Template Language).
. . Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ DEFAULT: Default: Handlebars

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "Preferred Template Language",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "the recommended lanquage  for expressing derivation, defaults, and constraints"
  },
  "parenthetical": "Template Language",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Template Language",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "default": {
    "_type": "Default",
    "one_liner": {
      "_type": "OneLiner",
      "content": " Handlebars\n"
    }
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}} into {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}} to attributes
after absorb, dict has:  {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}]}
DerivingDict for Part:  Attribute
		Full header is: - **alternate Template Languages** -  (optional List of Template Languages).



===
ParsingHeader header: - **alternate Template Languages** -  (optional List of Template Languages).

Created list dt:  List of reference Template Languages
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='alternate Template Languages', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Template Languages', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **alternate Template Languages** -  (optional List of Template Languages).

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "alternate Template Languages",
    "_type": "AttributeName"
  },
  "parenthetical": "optional List of Template Languages",
  "data_type_clause": {
    "data_type": {
      "_type": "ListDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "Template Languages",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **aiFunctions** - A list of functions that require sophisticated AI-powered implementation *(List of String)*



===
ParsingHeader header: - **aiFunctions** - A list of functions that require sophisticated AI-powered implementation *(List of String)*

Created list dt:  List of reference String
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='aiFunctions', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='A list of functions that require sophisticated AI-powered implementation *'), 'parenthetical': 'List of String', 'data_type_clause': DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='String', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Derivation
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DERIVATION: Derivation: ['aiEnglishPlural()']
adding name value. one_liner -.  ['aiEnglishPlural()']

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  ['aiEnglishPlural()']

Absorbing to one_liner  ['aiEnglishPlural()']
 into {'_type': 'Derivation'}
after absorb, dict has:  {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}
And the dict has;;;
{
  "_type": "Derivation",
  "one_liner": {
    "_type": "OneLiner",
    "content": " ['aiEnglishPlural()']\n"
  }
}
Re-display for Part:  Derivation
. Derivation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DERIVATION: Derivation: ['aiEnglishPlural()']

DerivedDict for Part:  Derivation
{
  "_type": "Derivation",
  "one_liner": {
    "_type": "OneLiner",
    "content": " ['aiEnglishPlural()']\n"
  }
}
Absorbing to derivation {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **aiFunctions** - A list of functions that require sophisticated AI-powered implementation *(List of String)*
. . Derivation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ DERIVATION: Derivation: ['aiEnglishPlural()']

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "aiFunctions",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "A list of functions that require sophisticated AI-powered implementation *"
  },
  "parenthetical": "List of String",
  "data_type_clause": {
    "data_type": {
      "_type": "ListDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "String",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "derivation": {
    "_type": "Derivation",
    "one_liner": {
      "_type": "OneLiner",
      "content": " ['aiEnglishPlural()']\n"
    }
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}} into {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}} to attributes
after absorb, dict has:  {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}
Absorbing to attribute_sections {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}]}
Append {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]} to attribute_sections
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': ''}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}]}
DerivingDict for Part:  Class
		Full header is: _ **Subject**
A specific topic or theme within the model


===
ParsingHeader header: _ **Subject**
A specific topic or theme within the model
ParsingHeader result: {'prefix': '_', 'name': ClassName(content='Subject\nA specific topic or theme within the model', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for PLURAL: Plural: Subjects
adding name value. plural -.  Subjects

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'plural': ' Subjects\n'}
Using ATT_NAME  plural for plural
Adding value in ddforpart. plural -.  Subjects

Absorbing to plural  Subjects
 into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': ''}
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n'}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Subject\nA specific topic or theme within the model",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Subjects\n"
}
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Component
parsing subtypeOfs:   Component

SubtypeOf result is  [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Using ATT_NAME  subtype_of for subtype_of
Adding value in ddforpart. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
Absorbing to subtype_of [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n'}
Extend [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] to subtype_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Subject\nA specific topic or theme within the model",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Subjects\n",
  "subtype_of": [
    "UnserializablePiece"
  ]
}
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEPENDENT_OF: Dependent of: LiterateDataModel
adding name value. dependent_of -. [ClassName(content='LiterateDataModel', _type='ClassName')]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')]}
Using ATT_NAME  dependent_of for dependent_of
Adding value in ddforpart. dependent_of -. [ClassName(content='LiterateDataModel', _type='ClassName')]
Absorbing to dependent_of [ClassName(content='LiterateDataModel', _type='ClassName')] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Extend [ClassName(content='LiterateDataModel', _type='ClassName')] to dependent_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Subject\nA specific topic or theme within the model",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Subjects\n",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "dependent_of": [
    {
      "content": "LiterateDataModel",
      "_type": "ClassName"
    }
  ]
}
DerivingDict for Part:  Attribute
		Full header is: - name (UpperCamel )



===
ParsingHeader header: - name (UpperCamel )

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='name', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'UpperCamel', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='UpperCamel', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - name (UpperCamel )

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "name",
    "_type": "AttributeName"
  },
  "parenthetical": "UpperCamel",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "UpperCamel",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **parentSubject** - The parent subject, if any, under which this subject is nested _(optional Subject)_



===
ParsingHeader header: - **parentSubject** - The parent subject, if any, under which this subject is nested _(optional Subject)_

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='parentSubject', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='The parent subject, if any, under which this subject is nested _'), 'parenthetical': 'optional Subject', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Subject', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **parentSubject** - The parent subject, if any, under which this subject is nested _(optional Subject)_

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "parentSubject",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "The parent subject, if any, under which this subject is nested _"
  },
  "parenthetical": "optional Subject",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Subject",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **Classes** - The major classes related to this subject, in the order in which they should be presented _(ListOf Classes)_



===
ParsingHeader header: - **Classes** - The major classes related to this subject, in the order in which they should be presented _(ListOf Classes)_

Created list dt:  List of reference Classes
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='Classes', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='The major classes related to this subject, in the order in which they should be presented _'), 'parenthetical': 'ListOf Classes', 'data_type_clause': DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Classes', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'} to annotations
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **Classes** - The major classes related to this subject, in the order in which they should be presented _(ListOf Classes)_
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ ISSUE: ***Issue***: define chapter, section, subsection as levels?***DSL***: Generally, it is best to present the classes within a Subject in top down order:

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "Classes",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "The major classes related to this subject, in the order in which they should be presented _"
  },
  "parenthetical": "ListOf Classes",
  "data_type_clause": {
    "data_type": {
      "_type": "ListDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "Classes",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "annotations": [
    {
      "_type": "Annotation",
      "emoji": "",
      "label": "Issue",
      "content": "define chapter, section, subsection as levels?"
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}]}
DerivingDict for Part:  Attribute
		Full header is: - Each Class should be followed first by the classes that are dependent on it, and then



===
ParsingHeader header: - Each Class should be followed first by the classes that are dependent on it, and then

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='Each Class should be followed first by the classes that are dependent on it, and then', _type='AttributeName'), 'one_liner': None, 'parenthetical': ''}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - Each Class should be followed first by the classes that are dependent on it, and then

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "Each Class should be followed first by the classes that are dependent on it, and then",
    "_type": "AttributeName"
  },
  "parenthetical": ""
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}]}
DerivingDict for Part:  Attribute
		Full header is: - By its subtype classes.



===
ParsingHeader header: - By its subtype classes.

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='By its subtype classes.', _type='AttributeName'), 'one_liner': None, 'parenthetical': ''}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - By its subtype classes.

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "By its subtype classes.",
    "_type": "AttributeName"
  },
  "parenthetical": ""
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}]}
DerivingDict for Part:  Attribute
		Full header is: - **childSubjects** - Any child subjects nested under this subject, in the order in which they should be presented _(ListOf Subjects)_



===
ParsingHeader header: - **childSubjects** - Any child subjects nested under this subject, in the order in which they should be presented _(ListOf Subjects)_

Created list dt:  List of reference Subjects
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='childSubjects', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='Any child subjects nested under this subject, in the order in which they should be presented _'), 'parenthetical': 'ListOf Subjects', 'data_type_clause': DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Subjects', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for INVERSE: inverse of: Subject.parentSubject.
adding name value. inverse -. {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}}
Using ATT_NAME  inverse for inverse
Adding value in ddforpart. inverse -. {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}
Absorbing to inverse {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}}
And the dict has;;;
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "childSubjects",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "Any child subjects nested under this subject, in the order in which they should be presented _"
  },
  "parenthetical": "ListOf Subjects",
  "data_type_clause": {
    "data_type": {
      "_type": "ListDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "Subjects",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "inverse": {
    "_type": "AttributeReference",
    "class_name": {
      "content": "Subject",
      "_type": "ClassName"
    },
    "attribute_name": {
      "content": "parentSubject.",
      "_type": "AttributeName"
    }
  }
}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **childSubjects** - Any child subjects nested under this subject, in the order in which they should be presented _(ListOf Subjects)_
_ _ INVERSE: inverse of: Subject.parentSubject.
_ _ ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='***DSL***:  the Classes within a Subject are always displayed before the childSubjects.', extra_text=[])], extra_text=[])]

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "childSubjects",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "Any child subjects nested under this subject, in the order in which they should be presented _"
  },
  "parenthetical": "ListOf Subjects",
  "data_type_clause": {
    "data_type": {
      "_type": "ListDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "Subjects",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "inverse": {
    "_type": "AttributeReference",
    "class_name": {
      "content": "Subject",
      "_type": "ClassName"
    },
    "attribute_name": {
      "content": "parentSubject.",
      "_type": "AttributeName"
    }
  },
  "elaboration": [
    {
      "_type": "Paragraph",
      "content": "***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n"
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}]}
DerivingDict for Part:  Class
		Full header is: _ **SubjectArea**
A main topic or area of focus within the model, containing related subjects and classes


===
ParsingHeader header: _ **SubjectArea**
A main topic or area of focus within the model, containing related subjects and classes
ParsingHeader result: {'prefix': '_', 'name': ClassName(content='SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for PLURAL: Plural: SubjectAreas
adding name value. plural -.  SubjectAreas

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'plural': ' SubjectAreas\n'}
Using ATT_NAME  plural for plural
Adding value in ddforpart. plural -.  SubjectAreas

Absorbing to plural  SubjectAreas
 into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': ''}
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n'}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " SubjectAreas\n"
}
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Subject
parsing subtypeOfs:   Subject

SubtypeOf result is  [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Using ATT_NAME  subtype_of for subtype_of
Adding value in ddforpart. subtype_of -. [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
Absorbing to subtype_of [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n'}
Extend [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] to subtype_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " SubjectAreas\n",
  "subtype_of": [
    "UnserializablePiece"
  ]
}
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for WHERE: Where: parentSubject is absent
adding name value. where -.  parentSubject is absent

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'where': ' parentSubject is absent\n'}
Using ATT_NAME  where for where
Adding value in ddforpart. where -.  parentSubject is absent

Absorbing to where  parentSubject is absent
 into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " SubjectAreas\n",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "where": " parentSubject is absent\n"
}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}]}
DerivingDict for Part:  SubjectC
		Full header is: ### Classes



===
ParsingHeader header: ### Classes

ParsingHeader result: {'prefix': '###', 'name': SubjectName(content='Classes', _type='SubjectName'), 'one_liner': None, 'parenthetical': ''}
===

DerivingDict for Part:  Class
		Full header is: _ **Class** - A key entity or object type in the model, often corresponding to a real-world concept



===
ParsingHeader header: _ **Class** - A key entity or object type in the model, often corresponding to a real-world concept

ParsingHeader result: {'prefix': '_', 'name': ClassName(content='Class', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content='A key entity or object type in the model, often corresponding to a real-world concept'), 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for PLURAL: Plural: Classes
adding name value. plural -.  Classes

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'plural': ' Classes\n'}
Using ATT_NAME  plural for plural
Adding value in ddforpart. plural -.  Classes

Absorbing to plural  Classes
 into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': ''}
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n'}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Class",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "A key entity or object type in the model, often corresponding to a real-world concept"
  },
  "parenthetical": "",
  "plural": " Classes\n"
}
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Component
parsing subtypeOfs:   Component

SubtypeOf result is  [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Using ATT_NAME  subtype_of for subtype_of
Adding value in ddforpart. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
Absorbing to subtype_of [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n'}
Extend [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] to subtype_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Class",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "A key entity or object type in the model, often corresponding to a real-world concept"
  },
  "parenthetical": "",
  "plural": " Classes\n",
  "subtype_of": [
    "UnserializablePiece"
  ]
}
DerivingDict for Part:  Constraint
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for CONSTRAINT: ***Constraint***: Within each Class, attribute names must be unique.
Patched att_name is one_liner for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is one_liner
adding name value. one_liner -.  Within each Class, attribute names must be unique.

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  Within each Class, attribute names must be unique.

Absorbing to one_liner  Within each Class, attribute names must be unique.
 into {'_type': 'Constraint'}
Append  Within each Class, attribute names must be unique.
 to one_liner
after absorb, dict has:  {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}
And the dict has;;;
{
  "_type": "Constraint",
  "one_liner": [
    {
      "_type": "OneLiner",
      "content": " Within each Class, attribute names must be unique.\n"
    }
  ]
}
Absorbing to constraints {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Append {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]} to constraints
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}]}
DerivingDict for Part:  Attribute
		Full header is: - **pluralForm** - the normal English plural form of the name of the Class (UpperName)



===
ParsingHeader header: - **pluralForm** - the normal English plural form of the name of the Class (UpperName)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='pluralForm', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='the normal English plural form of the name of the Class'), 'parenthetical': 'UpperName', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='UpperName', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}]}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]} to annotations
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}]}
DerivingDict for Part:  Default
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: ***Default***: the regular plural, formed by adding "s" or "es".
adding name value. one_liner -.  the regular plural, formed by adding "s" or "es".

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  the regular plural, formed by adding "s" or "es".

Absorbing to one_liner  the regular plural, formed by adding "s" or "es".
 into {'_type': 'Default'}
after absorb, dict has:  {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}
And the dict has;;;
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": " the regular plural, formed by adding \"s\" or \"es\".\n"
  }
}
Re-display for Part:  Default
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: ***Default***: the regular plural, formed by adding "s" or "es".

DerivedDict for Part:  Default
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": " the regular plural, formed by adding \"s\" or \"es\".\n"
  }
}
Absorbing to default {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}]}
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **pluralForm** - the normal English plural form of the name of the Class (UpperName)
_ _ ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Might be Books for the Book class or other regular plurals.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='But also might be People for Person.', extra_text=[])], extra_text=[])]
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ NOTE: Note: When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.
_ _ _ ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.', extra_text=[])], extra_text=[])]
. . Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ DEFAULT: ***Default***: the regular plural, formed by adding "s" or "es".

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "pluralForm",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "the normal English plural form of the name of the Class"
  },
  "parenthetical": "UpperName",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "UpperName",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "elaboration": [
    {
      "_type": "Paragraph",
      "content": "Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n"
    }
  ],
  "annotations": [
    {
      "_type": "Annotation",
      "emoji": "",
      "label": "Note",
      "content": "When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.",
      "elaboration": [
        {
          "_type": "Paragraph",
          "content": "The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n"
        }
      ]
    }
  ],
  "default": {
    "_type": "Default",
    "one_liner": {
      "_type": "OneLiner",
      "content": " the regular plural, formed by adding \"s\" or \"es\".\n"
    }
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}]}
DerivingDict for Part:  Attribute
		Full header is: - **basedOn** - the Class or Classes on which this class is dependent (SetOf Classes).



===
ParsingHeader header: - **basedOn** - the Class or Classes on which this class is dependent (SetOf Classes).

Created set dt:  Set of reference Classes
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='basedOn', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='the Class or Classes on which this class is dependent'), 'parenthetical': 'SetOf Classes', 'data_type_clause': DataTypeClause(data_type=SetDataType(_type='SetDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Classes', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}]}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'} to annotations
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **basedOn** - the Class or Classes on which this class is dependent (SetOf Classes).
_ _ ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.', extra_text=[])], extra_text=[])]
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ NOTE: Note: that basedOn and dependentOf are being used synonymousle in this metamodel.ToDo - fix that

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "basedOn",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "the Class or Classes on which this class is dependent"
  },
  "parenthetical": "SetOf Classes",
  "data_type_clause": {
    "data_type": {
      "_type": "SetDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "Classes",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "elaboration": [
    {
      "_type": "Paragraph",
      "content": "This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n"
    }
  ],
  "annotations": [
    {
      "_type": "Annotation",
      "emoji": "",
      "label": "Note",
      "content": "that basedOn and dependentOf are being used synonymousle in this metamodel."
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}]}
DerivingDict for Part:  Attribute
		Full header is: - **supertypes** - The parent class(es) from which this class inherits attributes _(ListOf Classes)_



===
ParsingHeader header: - **supertypes** - The parent class(es) from which this class inherits attributes _(ListOf Classes)_

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='supertypes', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='The parent class'), 'parenthetical': 'es', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='es', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **supertypes** - The parent class(es) from which this class inherits attributes _(ListOf Classes)_

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "supertypes",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "The parent class"
  },
  "parenthetical": "es",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "es",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **subtypings** - the criteria, or dimensions, by which the class can be divided into subtypes (list of Subtypings).



===
ParsingHeader header: - **subtypings** - the criteria, or dimensions, by which the class can be divided into subtypes (list of Subtypings).

Created list dt:  List of reference Subtypings
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='subtypings', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='the criteria, or dimensions, by which the class can be divided into subtypes'), 'parenthetical': 'list of Subtypings', 'data_type_clause': DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Subtypings', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'} to annotations
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **subtypings** - the criteria, or dimensions, by which the class can be divided into subtypes (list of Subtypings).
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ EXAMPLE: Example: in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "subtypings",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "the criteria, or dimensions, by which the class can be divided into subtypes"
  },
  "parenthetical": "list of Subtypings",
  "data_type_clause": {
    "data_type": {
      "_type": "ListDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "Subtypings",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "annotations": [
    {
      "_type": "Annotation",
      "emoji": "",
      "label": "Example",
      "content": "in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History)."
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}]}
DerivingDict for Part:  Attribute
		Full header is: - **subtypes** - Any subtypes or specializations of this class based on it’s subtypings. _(ListOf Classes)_



===
ParsingHeader header: - **subtypes** - Any subtypes or specializations of this class based on it’s subtypings. _(ListOf Classes)_

Created list dt:  List of reference Classes
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='subtypes', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='Any subtypes or specializations of this class based on it’s subtypings. _'), 'parenthetical': 'ListOf Classes', 'data_type_clause': DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Classes', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'} to annotations
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **subtypes** - Any subtypes or specializations of this class based on it’s subtypings. _(ListOf Classes)_
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ EXAMPLE: Example: For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "subtypes",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "Any subtypes or specializations of this class based on it\u2019s subtypings. _"
  },
  "parenthetical": "ListOf Classes",
  "data_type_clause": {
    "data_type": {
      "_type": "ListDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "Classes",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "annotations": [
    {
      "_type": "Annotation",
      "emoji": "",
      "label": "Example",
      "content": "For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`."
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}]}
DerivingDict for Part:  Attribute
		Full header is: - **attributes** - The attributes or properties of the class, in the order in which they should be presented _(ListOf Attributes)_



===
ParsingHeader header: - **attributes** - The attributes or properties of the class, in the order in which they should be presented _(ListOf Attributes)_

Created list dt:  List of reference Attributes
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='attributes', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='The attributes or properties of the class, in the order in which they should be presented _'), 'parenthetical': 'ListOf Attributes', 'data_type_clause': DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Attributes', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **attributes** - The attributes or properties of the class, in the order in which they should be presented _(ListOf Attributes)_

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "attributes",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "The attributes or properties of the class, in the order in which they should be presented _"
  },
  "parenthetical": "ListOf Attributes",
  "data_type_clause": {
    "data_type": {
      "_type": "ListDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "Attributes",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **attributeSections** - additional attributes or properties of the class, grouped for clarity and elaboration.  _(ListOf AttributeSections)_



===
ParsingHeader header: - **attributeSections** - additional attributes or properties of the class, grouped for clarity and elaboration.  _(ListOf AttributeSections)_

Created list dt:  List of reference AttributeSections
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='attributeSections', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='additional attributes or properties of the class, grouped for clarity and elaboration.  _'), 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='AttributeSections', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **attributeSections** - additional attributes or properties of the class, grouped for clarity and elaboration.  _(ListOf AttributeSections)_

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "attributeSections",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "additional attributes or properties of the class, grouped for clarity and elaboration.  _"
  },
  "parenthetical": "ListOf AttributeSections",
  "data_type_clause": {
    "data_type": {
      "_type": "ListDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "AttributeSections",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **constraints** - Any constraints, rules, or validations specific to this class _(ListOf Constraints)_



===
ParsingHeader header: - **constraints** - Any constraints, rules, or validations specific to this class _(ListOf Constraints)_

Created list dt:  List of reference Constraints
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='constraints', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='Any constraints, rules, or validations specific to this class _'), 'parenthetical': 'ListOf Constraints', 'data_type_clause': DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Constraints', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'} to annotations
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **constraints** - Any constraints, rules, or validations specific to this class _(ListOf Constraints)_
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ NOTE: Note: Constraints may be expressed on either the Class or the Attribute. Always?Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "constraints",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "Any constraints, rules, or validations specific to this class _"
  },
  "parenthetical": "ListOf Constraints",
  "data_type_clause": {
    "data_type": {
      "_type": "ListDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "Constraints",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "annotations": [
    {
      "_type": "Annotation",
      "emoji": "",
      "label": "Note",
      "content": "Constraints may be expressed on either the Class or the Attribute. Always?"
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}]}
DerivingDict for Part:  Attribute
		Full header is: - **methods** - Any behaviors or operations associated with this class _(ListOf Methods)_



===
ParsingHeader header: - **methods** - Any behaviors or operations associated with this class _(ListOf Methods)_

Created list dt:  List of reference Methods
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='methods', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='Any behaviors or operations associated with this class _'), 'parenthetical': 'ListOf Methods', 'data_type_clause': DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Methods', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **methods** - Any behaviors or operations associated with this class _(ListOf Methods)_

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "methods",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "Any behaviors or operations associated with this class _"
  },
  "parenthetical": "ListOf Methods",
  "data_type_clause": {
    "data_type": {
      "_type": "ListDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "Methods",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  AttributeSection
		Full header is: __  ***Implied Attributes***



===
ParsingHeader header: __  ***Implied Attributes***

ParsingHeader result: {'prefix': '__', 'name': AttributeSectionName(content='Implied Attributes', _type='AttributeSectionName'), 'one_liner': None, 'parenthetical': ''}
===

DerivingDict for Part:  Attribute
		Full header is: - **dependents** - the Classes which are basedOn this Class (optional SetOf Classes).



===
ParsingHeader header: - **dependents** - the Classes which are basedOn this Class (optional SetOf Classes).

Created set dt:  Set of reference Classes
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='dependents', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='the Classes which are basedOn this Class'), 'parenthetical': 'optional SetOf Classes', 'data_type_clause': DataTypeClause(data_type=SetDataType(_type='SetDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Classes', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for INVERSE: ***Inverse of***: Class.basedOn
adding name value. inverse -. {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}
Using ATT_NAME  inverse for inverse
Adding value in ddforpart. inverse -. {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}
Absorbing to inverse {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}
And the dict has;;;
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "dependents",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "the Classes which are basedOn this Class"
  },
  "parenthetical": "optional SetOf Classes",
  "data_type_clause": {
    "data_type": {
      "_type": "SetDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "Classes",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "inverse": {
    "_type": "AttributeReference",
    "class_name": {
      "content": "Class",
      "_type": "ClassName"
    },
    "attribute_name": {
      "content": "basedOn",
      "_type": "AttributeName"
    }
  }
}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **dependents** - the Classes which are basedOn this Class (optional SetOf Classes).
_ _ INVERSE: ***Inverse of***: Class.basedOn

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "dependents",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "the Classes which are basedOn this Class"
  },
  "parenthetical": "optional SetOf Classes",
  "data_type_clause": {
    "data_type": {
      "_type": "SetDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "Classes",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "inverse": {
    "_type": "AttributeReference",
    "class_name": {
      "content": "Class",
      "_type": "ClassName"
    },
    "attribute_name": {
      "content": "basedOn",
      "_type": "AttributeName"
    }
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}} into {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': ''}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}} to attributes
after absorb, dict has:  {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}
DerivingDict for Part:  Attribute
		Full header is: - UniqueKeys - (optional Set of UniqueKeys).



===
ParsingHeader header: - UniqueKeys - (optional Set of UniqueKeys).

Created set dt:  Set of reference UniqueKeys
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='UniqueKeys', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': DataTypeClause(data_type=SetDataType(_type='SetDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='UniqueKeys', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for INVERSE: ***Inverse of***:UniqueKey.basedOn
adding name value. inverse -. {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}
Using ATT_NAME  inverse for inverse
Adding value in ddforpart. inverse -. {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}
Absorbing to inverse {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}
And the dict has;;;
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "UniqueKeys",
    "_type": "AttributeName"
  },
  "parenthetical": "optional Set of UniqueKeys",
  "data_type_clause": {
    "data_type": {
      "_type": "SetDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "UniqueKeys",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "inverse": {
    "_type": "AttributeReference",
    "class_name": {
      "content": "UniqueKey",
      "_type": "ClassName"
    },
    "attribute_name": {
      "content": "basedOn",
      "_type": "AttributeName"
    }
  }
}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - UniqueKeys - (optional Set of UniqueKeys).
_ _ INVERSE: ***Inverse of***:UniqueKey.basedOn

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "UniqueKeys",
    "_type": "AttributeName"
  },
  "parenthetical": "optional Set of UniqueKeys",
  "data_type_clause": {
    "data_type": {
      "_type": "SetDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "UniqueKeys",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "inverse": {
    "_type": "AttributeReference",
    "class_name": {
      "content": "UniqueKey",
      "_type": "ClassName"
    },
    "attribute_name": {
      "content": "basedOn",
      "_type": "AttributeName"
    }
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}} into {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}} to attributes
after absorb, dict has:  {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}
Absorbing to attribute_sections {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]} to attribute_sections
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]} into {'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': ''}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]} to classes
after absorb, dict has:  {'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}]}
DerivingDict for Part:  Class
		Full header is: _ **Subtyping** - a way in which subtypes of a Class may be classified (Subtype of Component).



===
ParsingHeader header: _ **Subtyping** - a way in which subtypes of a Class may be classified (Subtype of Component).

ParsingHeader result: {'prefix': '_', 'name': ClassName(content='Subtyping', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content='a way in which subtypes of a Class may be classified'), 'parenthetical': 'Subtype of Component'}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEPENDENT_OF: ***Dependent of:*** Class
adding name value. dependent_of -. [ClassName(content='Class', _type='ClassName')]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'dependent_of': [ClassName(content='Class', _type='ClassName')]}
Using ATT_NAME  dependent_of for dependent_of
Adding value in ddforpart. dependent_of -. [ClassName(content='Class', _type='ClassName')]
Absorbing to dependent_of [ClassName(content='Class', _type='ClassName')] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component'}
Extend [ClassName(content='Class', _type='ClassName')] to dependent_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Subtyping",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "a way in which subtypes of a Class may be classified"
  },
  "parenthetical": "Subtype of Component",
  "dependent_of": [
    {
      "content": "Class",
      "_type": "ClassName"
    }
  ]
}
DerivingDict for Part:  Attribute
		Full header is: - **name** (Upper Name).
Usually ByThis or ByThat


===
ParsingHeader header: - **name** (Upper Name).
Usually ByThis or ByThat
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='name', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'Upper Name', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Upper Name', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **name** (Upper Name).Usually ByThis or ByThat

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "name",
    "_type": "AttributeName"
  },
  "parenthetical": "Upper Name",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Upper Name",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **is exclusive** (Boolean).



===
ParsingHeader header: - **is exclusive** (Boolean).

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='is exclusive', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'Boolean', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Boolean', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Default
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: Default: true
adding name value. one_liner -.  true

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=' true\n')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  true

Absorbing to one_liner  true
 into {'_type': 'Default'}
after absorb, dict has:  {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}
And the dict has;;;
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": " true\n"
  }
}
Re-display for Part:  Default
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: Default: true

DerivedDict for Part:  Default
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": " true\n"
  }
}
Absorbing to default {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **is exclusive** (Boolean).
. . Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ DEFAULT: Default: true

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "is exclusive",
    "_type": "AttributeName"
  },
  "parenthetical": "Boolean",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Boolean",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "default": {
    "_type": "Default",
    "one_liner": {
      "_type": "OneLiner",
      "content": " true\n"
    }
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}]}
DerivingDict for Part:  Attribute
		Full header is: - **is exhaustive** (Boolean).



===
ParsingHeader header: - **is exhaustive** (Boolean).

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='is exhaustive', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'Boolean', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Boolean', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Default
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: Default: true
adding name value. one_liner -.  true

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=' true\n')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  true

Absorbing to one_liner  true
 into {'_type': 'Default'}
after absorb, dict has:  {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}
And the dict has;;;
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": " true\n"
  }
}
Re-display for Part:  Default
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: Default: true

DerivedDict for Part:  Default
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": " true\n"
  }
}
Absorbing to default {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **is exhaustive** (Boolean).
. . Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ DEFAULT: Default: true

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "is exhaustive",
    "_type": "AttributeName"
  },
  "parenthetical": "Boolean",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Boolean",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "default": {
    "_type": "Default",
    "one_liner": {
      "_type": "OneLiner",
      "content": " true\n"
    }
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}]}
DerivingDict for Part:  Attribute
		Full header is: - **classes** (List of Classes).



===
ParsingHeader header: - **classes** (List of Classes).

Created list dt:  List of reference Classes
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='classes', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'List of Classes', 'data_type_clause': DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Classes', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}]}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'} to annotations
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **classes** (List of Classes).
_ _ ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='***DSL***:  Shown in the DSL as', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='> Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='on the super class. And as', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='> Subtype of: SuperClass byBrand', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='on the subclass.', extra_text=[])], extra_text=[])]
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ NOTE: Note: every class can have an unnamed subtyping.Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "classes",
    "_type": "AttributeName"
  },
  "parenthetical": "List of Classes",
  "data_type_clause": {
    "data_type": {
      "_type": "ListDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "Classes",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "elaboration": [
    {
      "_type": "Paragraph",
      "content": "***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n"
    }
  ],
  "annotations": [
    {
      "_type": "Annotation",
      "emoji": "",
      "label": "Note",
      "content": "every class can have an unnamed subtyping."
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]} into {'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]} to classes
after absorb, dict has:  {'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}]}
DerivingDict for Part:  Class
		Full header is: _ **ValueType** -



===
ParsingHeader header: _ **ValueType** -

ParsingHeader result: {'prefix': '_', 'name': ClassName(content='ValueType', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Class.
parsing subtypeOfs:   Class.

SubtypeOf result is  [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Using ATT_NAME  subtype_of for subtype_of
Adding value in ddforpart. subtype_of -. [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
Absorbing to subtype_of [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': ''}
Extend [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] to subtype_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "ValueType",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ]
}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]} into {'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]} to classes
after absorb, dict has:  {'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}]}
DerivingDict for Part:  Class
		Full header is: _ **Reference Type**:



===
ParsingHeader header: _ **Reference Type**:

ParsingHeader result: {'prefix': '_', 'name': ClassName(content='Reference Type', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Class.
parsing subtypeOfs:   Class.

SubtypeOf result is  [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Using ATT_NAME  subtype_of for subtype_of
Adding value in ddforpart. subtype_of -. [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
Absorbing to subtype_of [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': ''}
Extend [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] to subtype_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Reference Type",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ]
}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]} into {'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]} to classes
after absorb, dict has:  {'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}]}
DerivingDict for Part:  Class
		Full header is: _ **CodeType**
A data type or enumeration used in the model


===
ParsingHeader header: _ **CodeType**
A data type or enumeration used in the model
ParsingHeader result: {'prefix': '_', 'name': ClassName(content='CodeType\nA data type or enumeration used in the model', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: ValueType.
parsing subtypeOfs:   ValueType.

SubtypeOf result is  [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Using ATT_NAME  subtype_of for subtype_of
Adding value in ddforpart. subtype_of -. [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
Absorbing to subtype_of [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': ''}
Extend [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] to subtype_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "CodeType\nA data type or enumeration used in the model",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ]
}
DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"} to annotations
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}]}
DerivingDict for Part:  Attribute
		Full header is: - List the code values as a bulletted list inside the description of the attribute in the form:
‘**code**: description’


===
ParsingHeader header: - List the code values as a bulletted list inside the description of the attribute in the form:
‘**code**: description’
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', _type='AttributeName'), 'one_liner': None, 'parenthetical': ''}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - List the code values as a bulletted list inside the description of the attribute in the form:‘**code**: description’

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "List the code values as a bulletted list inside the description of the attribute in the form\n\u2018code description\u2019",
    "_type": "AttributeName"
  },
  "parenthetical": ""
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}]}
DerivingDict for Part:  Attribute
		Full header is: - A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.



===
ParsingHeader header: - A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', _type='AttributeName'), 'one_liner': None, 'parenthetical': ''}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.",
    "_type": "AttributeName"
  },
  "parenthetical": ""
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}]}
DerivingDict for Part:  Attribute
		Full header is: - isCaptive - the code type was implied by use in an attribute and is only used for that attribute (Boolean) as



===
ParsingHeader header: - isCaptive - the code type was implied by use in an attribute and is only used for that attribute (Boolean) as

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='isCaptive', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='the code type was implied by use in an attribute and is only used for that attribute'), 'parenthetical': 'Boolean', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Boolean', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - isCaptive - the code type was implied by use in an attribute and is only used for that attribute (Boolean) as

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "isCaptive",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "the code type was implied by use in an attribute and is only used for that attribute"
  },
  "parenthetical": "Boolean",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Boolean",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} into {'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} to classes
after absorb, dict has:  {'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}
DerivingDict for Part:  Class
		Full header is: _ **Code Value**



===
ParsingHeader header: _ **Code Value**

ParsingHeader result: {'prefix': '_', 'name': ClassName(content='Code Value', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
===

DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': ''}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'} to annotations
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}]}
DerivingDict for Part:  Attribute
		Full header is: - **code** - A short code or abbreviationi for the value _(NameString)_



===
ParsingHeader header: - **code** - A short code or abbreviationi for the value _(NameString)_

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='code', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='A short code or abbreviationi for the value _'), 'parenthetical': 'NameString', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='NameString', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **code** - A short code or abbreviationi for the value _(NameString)_

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "code",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "A short code or abbreviationi for the value _"
  },
  "parenthetical": "NameString",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "NameString",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **description** - an explanation of what the code means (*RichText*)



===
ParsingHeader header: - **description** - an explanation of what the code means (*RichText*)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='description', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='an explanation of what the code means'), 'parenthetical': '*RichText*', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='RichText', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **description** - an explanation of what the code means (*RichText*)

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "description",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "an explanation of what the code means"
  },
  "parenthetical": "*RichText*",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "RichText",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} into {'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} to classes
after absorb, dict has:  {'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}
DerivingDict for Part:  Class
		Full header is: _ **Key** - a list of attributes of a class



===
ParsingHeader header: _ **Key** - a list of attributes of a class

ParsingHeader result: {'prefix': '_', 'name': ClassName(content='Key', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content='a list of attributes of a class'), 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Component
parsing subtypeOfs:   Component

SubtypeOf result is  [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Using ATT_NAME  subtype_of for subtype_of
Adding value in ddforpart. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
Absorbing to subtype_of [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': ''}
Extend [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] to subtype_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Key",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "a list of attributes of a class"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ]
}
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEPENDENT_OF: DependentOf: Class
adding name value. dependent_of -. [ClassName(content='Class', _type='ClassName')]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'dependent_of': [ClassName(content='Class', _type='ClassName')]}
Using ATT_NAME  dependent_of for dependent_of
Adding value in ddforpart. dependent_of -. [ClassName(content='Class', _type='ClassName')]
Absorbing to dependent_of [ClassName(content='Class', _type='ClassName')] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Extend [ClassName(content='Class', _type='ClassName')] to dependent_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Key",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "a list of attributes of a class"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "dependent_of": [
    {
      "content": "Class",
      "_type": "ClassName"
    }
  ]
}
DerivingDict for Part:  Attribute
		Full header is: - keyAttributes - the attributes of the base Class. (List of Attributes ).



===
ParsingHeader header: - keyAttributes - the attributes of the base Class. (List of Attributes ).

Created list dt:  List of reference Attributes
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='keyAttributes', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='the attributes of the base Class.'), 'parenthetical': 'List of Attributes', 'data_type_clause': DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Attributes', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Constraint
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for CONSTRAINT: Constraint: each attribute must be a direct or inherited of the base class.
Patched att_name is one_liner for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is one_liner
adding name value. one_liner -.  each attribute must be a direct or inherited of the base class.

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  each attribute must be a direct or inherited of the base class.

Absorbing to one_liner  each attribute must be a direct or inherited of the base class.
 into {'_type': 'Constraint'}
Append  each attribute must be a direct or inherited of the base class.
 to one_liner
after absorb, dict has:  {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}
And the dict has;;;
{
  "_type": "Constraint",
  "one_liner": [
    {
      "_type": "OneLiner",
      "content": " each attribute must be a direct or inherited of the base class.\n"
    }
  ]
}
Absorbing to constraints {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
Append {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]} to constraints
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}]}
DerivingDict for Part:  Constraint
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for CONSTRAINT: Constraint: no repetitions allowed in keyAttributes> 👍 **Issue**: introduce PureLists?
Patched att_name is one_liner for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is one_liner
adding name value. one_liner -.  no repetitions allowed in keyAttributes
> 👍 **Issue**: introduce PureLists?
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  no repetitions allowed in keyAttributes
> 👍 **Issue**: introduce PureLists?
Absorbing to one_liner  no repetitions allowed in keyAttributes
> 👍 **Issue**: introduce PureLists? into {'_type': 'Constraint'}
Append  no repetitions allowed in keyAttributes
> 👍 **Issue**: introduce PureLists? to one_liner
after absorb, dict has:  {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}
And the dict has;;;
{
  "_type": "Constraint",
  "one_liner": [
    {
      "_type": "OneLiner",
      "content": " no repetitions allowed in keyAttributes\n> \ud83d\udc4d **Issue**: introduce PureLists?"
    }
  ]
}
Absorbing to constraints {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}]}
Append {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]} to constraints
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}]}
DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}]}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'} to annotations
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - keyAttributes - the attributes of the base Class. (List of Attributes ).
. . Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ CONSTRAINT: Constraint: each attribute must be a direct or inherited of the base class.
. . Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ CONSTRAINT: Constraint: no repetitions allowed in keyAttributes> 👍 **Issue**: introduce PureLists?
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ ISSUE: Issue: need ascending descending to support index keys or ordering keys.

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "keyAttributes",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "the attributes of the base Class."
  },
  "parenthetical": "List of Attributes",
  "data_type_clause": {
    "data_type": {
      "_type": "ListDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "Attributes",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "constraints": [
    {
      "_type": "Constraint",
      "one_liner": [
        {
          "_type": "OneLiner",
          "content": " each attribute must be a direct or inherited of the base class.\n"
        }
      ]
    },
    {
      "_type": "Constraint",
      "one_liner": [
        {
          "_type": "OneLiner",
          "content": " no repetitions allowed in keyAttributes\n> \ud83d\udc4d **Issue**: introduce PureLists?"
        }
      ]
    }
  ],
  "annotations": [
    {
      "_type": "Annotation",
      "emoji": "",
      "label": "Issue",
      "content": "need ascending descending to support index keys or ordering keys."
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]} into {'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]} to classes
after absorb, dict has:  {'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}]}
DerivingDict for Part:  Class
		Full header is: _ **UniqueKey** - a list of attributes on which instances of the base class may be keyed.



===
ParsingHeader header: _ **UniqueKey** - a list of attributes on which instances of the base class may be keyed.

ParsingHeader result: {'prefix': '_', 'name': ClassName(content='UniqueKey', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content='a list of attributes on which instances of the base class may be keyed.'), 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Key
parsing subtypeOfs:   Key

SubtypeOf result is  [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Using ATT_NAME  subtype_of for subtype_of
Adding value in ddforpart. subtype_of -. [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
Absorbing to subtype_of [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': ''}
Extend [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] to subtype_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "UniqueKey",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "a list of attributes on which instances of the base class may be keyed."
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ]
}
DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'} to annotations
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]} into {'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]} to classes
after absorb, dict has:  {'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}
Absorbing to subjects {'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}]}
Append {'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]} to subjects
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}
Absorbing to subjects {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]} into {'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}]}
Append {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]} to subjects
after absorb, dict has:  {'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}]}
DerivingDict for Part:  SubjectB
		Full header is: ## Attributes



===
ParsingHeader header: ## Attributes

ParsingHeader result: {'prefix': '##', 'name': SubjectName(content='Attributes', _type='SubjectName'), 'one_liner': None, 'parenthetical': ''}
===

DerivingDict for Part:  Class
		Full header is: _ **Attribute Section** - a group of attributes for a class that merit a shared explanation.



===
ParsingHeader header: _ **Attribute Section** - a group of attributes for a class that merit a shared explanation.

ParsingHeader result: {'prefix': '_', 'name': ClassName(content='Attribute Section', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content='a group of attributes for a class that merit a shared explanation.'), 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: ***SubtypeOf***: Component.
parsing subtypeOfs:   Component.

SubtypeOf result is  [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Using ATT_NAME  subtype_of for subtype_of
Adding value in ddforpart. subtype_of -. [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
Absorbing to subtype_of [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': ''}
Extend [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] to subtype_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Attribute Section",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "a group of attributes for a class that merit a shared explanation."
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ]
}
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for BASED_ON: ***Based on***: Class
adding name value. based_on -. [ClassName(content='Class', _type='ClassName')]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'based_on': [ClassName(content='Class', _type='ClassName')]}
Using ATT_NAME  based_on for based_on
Adding value in ddforpart. based_on -. [ClassName(content='Class', _type='ClassName')]
Absorbing to based_on [ClassName(content='Class', _type='ClassName')] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Extend [ClassName(content='Class', _type='ClassName')] to based_on
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Attribute Section",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "a group of attributes for a class that merit a shared explanation."
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "based_on": [
    {
      "content": "Class",
      "_type": "ClassName"
    }
  ]
}
DerivingDict for Part:  Attribute
		Full header is: -	isOptional - whether the attributes in this section, taken together, are optional. (Boolean)



===
ParsingHeader header: -	isOptional - whether the attributes in this section, taken together, are optional. (Boolean)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='isOptional', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='whether the attributes in this section, taken together, are optional.'), 'parenthetical': 'Boolean', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Boolean', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: -	isOptional - whether the attributes in this section, taken together, are optional. (Boolean)
_ _ ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='&nbsp;', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.', extra_text=[])], extra_text=[])]

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "isOptional",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "whether the attributes in this section, taken together, are optional."
  },
  "parenthetical": "Boolean",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Boolean",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "elaboration": [
    {
      "_type": "Paragraph",
      "content": "If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n"
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': ''}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}]}
DerivingDict for Part:  Class
		Full header is: _ **Attribute**
A property or characteristic of a class


===
ParsingHeader header: _ **Attribute**
A property or characteristic of a class
ParsingHeader result: {'prefix': '_', 'name': ClassName(content='Attribute\nA property or characteristic of a class', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for PLURAL: Plural: Attributes
adding name value. plural -.  Attributes

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'plural': ' Attributes\n'}
Using ATT_NAME  plural for plural
Adding value in ddforpart. plural -.  Attributes

Absorbing to plural  Attributes
 into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': ''}
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n'}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Attribute\nA property or characteristic of a class",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Attributes\n"
}
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Component
parsing subtypeOfs:   Component

SubtypeOf result is  [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Using ATT_NAME  subtype_of for subtype_of
Adding value in ddforpart. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
Absorbing to subtype_of [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n'}
Extend [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] to subtype_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Attribute\nA property or characteristic of a class",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Attributes\n",
  "subtype_of": [
    "UnserializablePiece"
  ]
}
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for BASED_ON: *Based on*: AttributeSection
adding name value. based_on -. [ClassName(content='AttributeSection', _type='ClassName')]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'based_on': [ClassName(content='AttributeSection', _type='ClassName')]}
Using ATT_NAME  based_on for based_on
Adding value in ddforpart. based_on -. [ClassName(content='AttributeSection', _type='ClassName')]
Absorbing to based_on [ClassName(content='AttributeSection', _type='ClassName')] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Extend [ClassName(content='AttributeSection', _type='ClassName')] to based_on
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Attribute\nA property or characteristic of a class",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Attributes\n",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "based_on": [
    {
      "content": "AttributeSection",
      "_type": "ClassName"
    }
  ]
}
DerivingDict for Part:  Attribute
		Full header is: - **name** - (Lower Camel).



===
ParsingHeader header: - **name** - (Lower Camel).

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='name', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'Lower Camel', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Lower Camel', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for OVERRIDES: Overrides: CamelName
adding name value. overrides -. {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}
Using ATT_NAME  overrides for overrides
Adding value in ddforpart. overrides -. {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}
Absorbing to overrides {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}
And the dict has;;;
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "name",
    "_type": "AttributeName"
  },
  "parenthetical": "Lower Camel",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Lower Camel",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "overrides": {
    "_type": "AttributeReference",
    "class_name": "CamelName",
    "attribute_name": ""
  }
}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **name** - (Lower Camel).
_ _ OVERRIDES: Overrides: CamelName

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "name",
    "_type": "AttributeName"
  },
  "parenthetical": "Lower Camel",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Lower Camel",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "overrides": {
    "_type": "AttributeReference",
    "class_name": "CamelName",
    "attribute_name": ""
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}]}
DerivingDict for Part:  Attribute
		Full header is: - **dataType** - The kind of object to which the attribute refers.  _(DataType)_
H
In the simplest cases, the data type will be a class. And the specifier is the just the name of that class.


===
ParsingHeader header: - **dataType** - The kind of object to which the attribute refers.  _(DataType)_
H
In the simplest cases, the data type will be a class. And the specifier is the just the name of that class.
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='dataType', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='The kind of object to which the attribute refers.  _'), 'parenthetical': 'DataType', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='DataType', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **dataType** - The kind of object to which the attribute refers.  _(DataType)_H 
+ In the simplest cases, the data type will be a class. And the specifier is the just the name of that class.
_ _ ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='But,', extra_text=[])], extra_text=[])]

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "dataType",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "The kind of object to which the attribute refers.  _"
  },
  "parenthetical": "DataType",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "DataType",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "elaboration": [
    {
      "_type": "Paragraph",
      "content": "But,\n"
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}]}
DerivingDict for Part:  Attribute
		Full header is: - List of Editions



===
ParsingHeader header: - List of Editions

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='List of Editions', _type='AttributeName'), 'one_liner': None, 'parenthetical': ''}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - List of Editions

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "List of Editions",
    "_type": "AttributeName"
  },
  "parenthetical": ""
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}]}
DerivingDict for Part:  Attribute
		Full header is: - Set of Edition



===
ParsingHeader header: - Set of Edition

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='Set of Edition', _type='AttributeName'), 'one_liner': None, 'parenthetical': ''}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - Set of Edition

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "Set of Edition",
    "_type": "AttributeName"
  },
  "parenthetical": ""
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}]}
DerivingDict for Part:  Attribute
		Full header is: - ... and more complicated cases.



===
ParsingHeader header: - ... and more complicated cases.

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='... and more complicated cases.', _type='AttributeName'), 'one_liner': None, 'parenthetical': ''}
===

DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': ''}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'} to annotations
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - ... and more complicated cases.
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ SEE: ***See***: the section below on Data Type Specifiers.

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "... and more complicated cases.",
    "_type": "AttributeName"
  },
  "parenthetical": "",
  "annotations": [
    {
      "_type": "Annotation",
      "emoji": "",
      "label": "See",
      "content": "the section below on Data Type Specifiers."
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}]}
DerivingDict for Part:  AttributeSection
		Full header is: __ **Cardinalities**.



===
ParsingHeader header: __ **Cardinalities**.

ParsingHeader result: {'prefix': '__', 'name': AttributeSectionName(content='Cardinalities.', _type='AttributeSectionName'), 'one_liner': None, 'parenthetical': ''}
===

DerivingDict for Part:  Attribute
		Full header is: - **isOptional** - Indicates whether the attribute must have a value for every instance of the class _(Boolean)_



===
ParsingHeader header: - **isOptional** - Indicates whether the attribute must have a value for every instance of the class _(Boolean)_

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='isOptional', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='Indicates whether the attribute must have a value for every instance of the class _'), 'parenthetical': 'Boolean', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Boolean', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Default
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: ***Default:*** False
adding name value. one_liner -. *** False

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -. *** False

Absorbing to one_liner *** False
 into {'_type': 'Default'}
after absorb, dict has:  {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}
And the dict has;;;
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": "*** False\n"
  }
}
Re-display for Part:  Default
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: ***Default:*** False

DerivedDict for Part:  Default
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": "*** False\n"
  }
}
Absorbing to default {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **isOptional** - Indicates whether the attribute must have a value for every instance of the class _(Boolean)_
. . Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ DEFAULT: ***Default:*** False

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "isOptional",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "Indicates whether the attribute must have a value for every instance of the class _"
  },
  "parenthetical": "Boolean",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Boolean",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "default": {
    "_type": "Default",
    "one_liner": {
      "_type": "OneLiner",
      "content": "*** False\n"
    }
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}} into {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': ''}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}} to attributes
after absorb, dict has:  {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}]}
DerivingDict for Part:  Attribute
		Full header is: - **cardinality** - The cardinality of the relationship represented by the attribute _(CardinalityCode)_



===
ParsingHeader header: - **cardinality** - The cardinality of the relationship represented by the attribute _(CardinalityCode)_

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='cardinality', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='The cardinality of the relationship represented by the attribute _'), 'parenthetical': 'CardinalityCode', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='CardinalityCode', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Default
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: ***Default:***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.
adding name value. one_liner -. ***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.
For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -. ***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.
For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.
Absorbing to one_liner ***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.
For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly. into {'_type': 'Default'}
after absorb, dict has:  {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.')}
And the dict has;;;
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": "***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly."
  }
}
Re-display for Part:  Default
. Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DEFAULT: ***Default:***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.
_ _ ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.', extra_text=[])], extra_text=[])]

DerivedDict for Part:  Default
{
  "_type": "Default",
  "one_liner": {
    "_type": "OneLiner",
    "content": "***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly."
  },
  "elaboration": [
    {
      "_type": "Paragraph",
      "content": "***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n"
    }
  ]
}
Absorbing to default {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}}
DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''} to annotations
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **cardinality** - The cardinality of the relationship represented by the attribute _(CardinalityCode)_
. . Default - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ DEFAULT: ***Default:***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.
_ _ _ ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.', extra_text=[])], extra_text=[])]
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ WILD: For example:

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "cardinality",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "The cardinality of the relationship represented by the attribute _"
  },
  "parenthetical": "CardinalityCode",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "CardinalityCode",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "default": {
    "_type": "Default",
    "one_liner": {
      "_type": "OneLiner",
      "content": "***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly."
    },
    "elaboration": [
      {
        "_type": "Paragraph",
        "content": "***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n"
      }
    ]
  },
  "annotations": [
    {
      "_type": "Annotation",
      "emoji": "",
      "label": "For example",
      "content": ""
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]} into {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]} to attributes
after absorb, dict has:  {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}]}
DerivingDict for Part:  Attribute
		Full header is: - author (1:1 Author)



===
ParsingHeader header: - author (1:1 Author)

Inventing name for:  1:1 Author
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='author', _type='AttributeName'), 'one_liner': None, 'parenthetical': '1:1 Author', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Invented Name', _type='ClassName'), as_value_type=AsValue(t_value=True, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - author (1:1 Author)

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "author",
    "_type": "AttributeName"
  },
  "parenthetical": "1:1 Author",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Invented Name",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": true,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - books (optional N:M Set of Books)



===
ParsingHeader header: - books (optional N:M Set of Books)

Inventing name for:  N:M Set of Books
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='books', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Invented Name', _type='ClassName'), as_value_type=AsValue(t_value=True, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'} to annotations
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - books (optional N:M Set of Books)
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ NOTE: ***Note***: how this works with optionality

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "books",
    "_type": "AttributeName"
  },
  "parenthetical": "optional N:M Set of Books",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Invented Name",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": true,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "annotations": [
    {
      "_type": "Annotation",
      "emoji": "",
      "label": "Note",
      "content": "how this works with optionality"
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]} into {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]} to attributes
after absorb, dict has:  {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}
Absorbing to attribute_sections {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}]}
Append {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]} to attribute_sections
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}]}
DerivingDict for Part:  AttributeSection
		Full header is: __  ***Inverse Attributes***



===
ParsingHeader header: __  ***Inverse Attributes***

ParsingHeader result: {'prefix': '__', 'name': AttributeSectionName(content='Inverse Attributes', _type='AttributeSectionName'), 'one_liner': None, 'parenthetical': ''}
===

DerivingDict for Part:  Attribute
		Full header is: - **isInvertible** - (Boolean)



===
ParsingHeader header: - **isInvertible** - (Boolean)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='isInvertible', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'Boolean', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Boolean', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Derivation
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DERIVATION: ***Derivation***: true if the data type is a class or a simple collection of members of a class.
adding name value. one_liner -.  true if the data type is a class or a simple collection of members of a class.

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  true if the data type is a class or a simple collection of members of a class.

Absorbing to one_liner  true if the data type is a class or a simple collection of members of a class.
 into {'_type': 'Derivation'}
after absorb, dict has:  {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}
And the dict has;;;
{
  "_type": "Derivation",
  "one_liner": {
    "_type": "OneLiner",
    "content": " true if the data type is a class or a simple collection of members of a class.\n"
  }
}
Re-display for Part:  Derivation
. Derivation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DERIVATION: ***Derivation***: true if the data type is a class or a simple collection of members of a class.

DerivedDict for Part:  Derivation
{
  "_type": "Derivation",
  "one_liner": {
    "_type": "OneLiner",
    "content": " true if the data type is a class or a simple collection of members of a class.\n"
  }
}
Absorbing to derivation {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **isInvertible** - (Boolean)
. . Derivation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ DERIVATION: ***Derivation***: true if the data type is a class or a simple collection of members of a class.

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "isInvertible",
    "_type": "AttributeName"
  },
  "parenthetical": "Boolean",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Boolean",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "derivation": {
    "_type": "Derivation",
    "one_liner": {
      "_type": "OneLiner",
      "content": " true if the data type is a class or a simple collection of members of a class.\n"
    }
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}} into {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': ''}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}} to attributes
after absorb, dict has:  {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}]}
DerivingDict for Part:  Attribute
		Full header is: - **inverseClass** - the class which contains, or would contain the inverse attribute (optional Class)



===
ParsingHeader header: - **inverseClass** - the class which contains, or would contain the inverse attribute (optional Class)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='inverseClass', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='the class which contains, or would contain the inverse attribute'), 'parenthetical': 'optional Class', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Class', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Derivation
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DERIVATION: ***Derivation***: from the data type. Null unless arrribute is invertible.
adding name value. one_liner -.  from the data type. Null unless arrribute is invertible.

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  from the data type. Null unless arrribute is invertible.

Absorbing to one_liner  from the data type. Null unless arrribute is invertible.
 into {'_type': 'Derivation'}
after absorb, dict has:  {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}
And the dict has;;;
{
  "_type": "Derivation",
  "one_liner": {
    "_type": "OneLiner",
    "content": " from the data type. Null unless arrribute is invertible.\n"
  }
}
Re-display for Part:  Derivation
. Derivation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ DERIVATION: ***Derivation***: from the data type. Null unless arrribute is invertible.

DerivedDict for Part:  Derivation
{
  "_type": "Derivation",
  "one_liner": {
    "_type": "OneLiner",
    "content": " from the data type. Null unless arrribute is invertible.\n"
  }
}
Absorbing to derivation {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **inverseClass** - the class which contains, or would contain the inverse attribute (optional Class)
. . Derivation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ DERIVATION: ***Derivation***: from the data type. Null unless arrribute is invertible.

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "inverseClass",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "the class which contains, or would contain the inverse attribute"
  },
  "parenthetical": "optional Class",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Class",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "derivation": {
    "_type": "Derivation",
    "one_liner": {
      "_type": "OneLiner",
      "content": " from the data type. Null unless arrribute is invertible.\n"
    }
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}} into {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}} to attributes
after absorb, dict has:  {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}]}
DerivingDict for Part:  Attribute
		Full header is: - **inverseAttribute** - (optional Attribute)



===
ParsingHeader header: - **inverseAttribute** - (optional Attribute)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='inverseAttribute', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'optional Attribute', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Attribute', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **inverseAttribute** - (optional Attribute)

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "inverseAttribute",
    "_type": "AttributeName"
  },
  "parenthetical": "optional Attribute",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Attribute",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **inverseIsOptional** - (optional Attribute)



===
ParsingHeader header: - **inverseIsOptional** - (optional Attribute)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='inverseIsOptional', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'optional Attribute', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Attribute', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **inverseIsOptional** - (optional Attribute)

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "inverseIsOptional",
    "_type": "AttributeName"
  },
  "parenthetical": "optional Attribute",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Attribute",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Absorbing to attribute_sections {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}]}
Append {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} to attribute_sections
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}]}
DerivingDict for Part:  Class
		Full header is: _ ***Formulas***



===
ParsingHeader header: _ ***Formulas***

ParsingHeader result: {'prefix': '_', 'name': ClassName(content='Formulas', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
===

DerivingDict for Part:  Attribute
		Full header is: - **default** - The rule or formula for calculating the value, if no value is supplied
Now running to a second line with the parenthentical on yet a third line
(optional Derivation)


===
ParsingHeader header: - **default** - The rule or formula for calculating the value, if no value is supplied
Now running to a second line with the parenthentical on yet a third line
(optional Derivation)
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='default', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'), 'parenthetical': 'optional Derivation', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Derivation', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]} to annotations
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **default** - The rule or formula for calculating the value, if no value is suppliedNow running to a second line with the parenthentical on yet a third line 
+ (optional Derivation)
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ NOTE: Note: even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.And let's see if the note can span extra lines, too
_ _ _ ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content="Yes, it handled extra lines.  Let's see about additional paras for an annotation", extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Last paragraph here', extra_text=[])], extra_text=[])]

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "default",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line"
  },
  "parenthetical": "optional Derivation",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Derivation",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "annotations": [
    {
      "_type": "Annotation",
      "emoji": "",
      "label": "Note",
      "content": "even when an Attribute has a default derivation, there\u2019s no guarantee that every instance will have an assigned value. Example needed.",
      "elaboration": [
        {
          "_type": "Paragraph",
          "content": "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"
        },
        {
          "_type": "Paragraph",
          "content": "Last paragraph here\n"
        }
      ]
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': ''}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}]}
DerivingDict for Part:  Attribute
		Full header is: - **derivation** - For derived attributes, the rule or formula for calculating the value _(optional Derivation)_



===
ParsingHeader header: - **derivation** - For derived attributes, the rule or formula for calculating the value _(optional Derivation)_

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='derivation', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='For derived attributes, the rule or formula for calculating the value _'), 'parenthetical': 'optional Derivation', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Derivation', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'} to annotations
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **derivation** - For derived attributes, the rule or formula for calculating the value _(optional Derivation)_
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ ISSUE: ***Issue***: on insert vs on access?

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "derivation",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "For derived attributes, the rule or formula for calculating the value _"
  },
  "parenthetical": "optional Derivation",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Derivation",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "annotations": [
    {
      "_type": "Annotation",
      "emoji": "",
      "label": "Issue",
      "content": "on insert vs on access?"
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}]}
DerivingDict for Part:  Attribute
		Full header is: - **constraints** - Any validation rules specific to this attribute _(ListOf Constraints)_



===
ParsingHeader header: - **constraints** - Any validation rules specific to this attribute _(ListOf Constraints)_

Created list dt:  List of reference Constraints
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='constraints', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='Any validation rules specific to this attribute _'), 'parenthetical': 'ListOf Constraints', 'data_type_clause': DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Constraints', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'} to annotations
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **constraints** - Any validation rules specific to this attribute _(ListOf Constraints)_
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ NOTE: Note: from Class.constraints

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "constraints",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "Any validation rules specific to this attribute _"
  },
  "parenthetical": "ListOf Constraints",
  "data_type_clause": {
    "data_type": {
      "_type": "ListDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "Constraints",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "annotations": [
    {
      "_type": "Annotation",
      "emoji": "",
      "label": "Note",
      "content": "from Class.constraints"
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}]}
DerivingDict for Part:  AttributeSection
		Full header is: __ Override Tracking



===
ParsingHeader header: __ Override Tracking

ParsingHeader result: {'prefix': '__', 'name': AttributeSectionName(content='Override Tracking', _type='AttributeSectionName'), 'one_liner': None, 'parenthetical': ''}
===

DerivingDict for Part:  Attribute
		Full header is: - Overrides



===
ParsingHeader header: - Overrides

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='Overrides', _type='AttributeName'), 'one_liner': None, 'parenthetical': ''}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - Overrides

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "Overrides",
    "_type": "AttributeName"
  },
  "parenthetical": ""
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''} into {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': ''}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''} to attributes
after absorb, dict has:  {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}
Absorbing to attribute_sections {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}]}
Append {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]} to attribute_sections
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}]}
DerivingDict for Part:  Class
		Full header is: _ ***ValueType:*** **Derivation**
A rule or formula for deriving the value of an attribute


===
ParsingHeader header: _ ***ValueType:*** **Derivation**
A rule or formula for deriving the value of an attribute
ParsingHeader result: {'prefix': '_', 'name': ClassName(content='ValueType Derivation\nA rule or formula for deriving the value of an attribute', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for PLURAL: Plural: Derivations
adding name value. plural -.  Derivations

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'plural': ' Derivations\n'}
Using ATT_NAME  plural for plural
Adding value in ddforpart. plural -.  Derivations

Absorbing to plural  Derivations
 into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': ''}
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n'}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "ValueType Derivation\nA rule or formula for deriving the value of an attribute",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Derivations\n"
}
DerivingDict for Part:  Attribute
		Full header is: - **statement** - An English language statement of the derivation rule _(RichText)_



===
ParsingHeader header: - **statement** - An English language statement of the derivation rule _(RichText)_

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='statement', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='An English language statement of the derivation rule _'), 'parenthetical': 'RichText', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='RichText', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **statement** - An English language statement of the derivation rule _(RichText)_

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "statement",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "An English language statement of the derivation rule _"
  },
  "parenthetical": "RichText",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "RichText",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n'}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **expression** - The formal expression of the derivation in a programming language _(CodeExpression)_



===
ParsingHeader header: - **expression** - The formal expression of the derivation in a programming language _(CodeExpression)_

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='expression', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='The formal expression of the derivation in a programming language _'), 'parenthetical': 'CodeExpression', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='CodeExpression', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **expression** - The formal expression of the derivation in a programming language _(CodeExpression)_

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "expression",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "The formal expression of the derivation in a programming language _"
  },
  "parenthetical": "CodeExpression",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "CodeExpression",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}
DerivingDict for Part:  Class
		Full header is: _ ***ValueType:*** **Constraint**
A rule, condition, or validation that must be satisfied by the model


===
ParsingHeader header: _ ***ValueType:*** **Constraint**
A rule, condition, or validation that must be satisfied by the model
ParsingHeader result: {'prefix': '_', 'name': ClassName(content='ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for PLURAL: Plural: Constraints
adding name value. plural -.  Constraints

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'plural': ' Constraints\n'}
Using ATT_NAME  plural for plural
Adding value in ddforpart. plural -.  Constraints

Absorbing to plural  Constraints
 into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': ''}
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n'}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Constraints\n"
}
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Component
parsing subtypeOfs:   Component

SubtypeOf result is  [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Using ATT_NAME  subtype_of for subtype_of
Adding value in ddforpart. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
Absorbing to subtype_of [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n'}
Extend [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] to subtype_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Constraints\n",
  "subtype_of": [
    "UnserializablePiece"
  ]
}
DerivingDict for Part:  Attribute
		Full header is: - **statement** - An English language statement of the constraint _(RichText)_



===
ParsingHeader header: - **statement** - An English language statement of the constraint _(RichText)_

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='statement', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='An English language statement of the constraint _'), 'parenthetical': 'RichText', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='RichText', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **statement** - An English language statement of the constraint _(RichText)_

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "statement",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "An English language statement of the constraint _"
  },
  "parenthetical": "RichText",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "RichText",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **expression** - The formal expression of the constraint in a programming language (e.g., OCL _(CodeExpression)_



===
ParsingHeader header: - **expression** - The formal expression of the constraint in a programming language (e.g., OCL _(CodeExpression)_

Inventing name for:  e.g., OCL _(CodeExpression
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='expression', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='The formal expression of the constraint in a programming language'), 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Invented Name', _type='ClassName'), as_value_type=AsValue(t_value=True, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **expression** - The formal expression of the constraint in a programming language (e.g., OCL _(CodeExpression)_

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "expression",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "The formal expression of the constraint in a programming language"
  },
  "parenthetical": "e.g., OCL _(CodeExpression",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Invented Name",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": true,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **severity** -  (Code)



===
ParsingHeader header: - **severity** -  (Code)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='severity', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'Code', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Code', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **severity** -  (Code)

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "severity",
    "_type": "AttributeName"
  },
  "parenthetical": "Code",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Code",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - - **Warning** - nothing fatal; just a caution



===
ParsingHeader header: - - **Warning** - nothing fatal; just a caution

ParsingHeader result: {'prefix': '-', 'name': None, 'one_liner': OneLiner(_type='OneLiner', content='**Warning** - nothing fatal; just a caution'), 'parenthetical': ''}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - - **Warning** - nothing fatal; just a caution

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "one_liner": {
    "_type": "OneLiner",
    "content": "**Warning** - nothing fatal; just a caution"
  },
  "parenthetical": ""
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}]}
DerivingDict for Part:  Attribute
		Full header is: - - **Error** - serious. Fix now



===
ParsingHeader header: - - **Error** - serious. Fix now

ParsingHeader result: {'prefix': '-', 'name': None, 'one_liner': OneLiner(_type='OneLiner', content='**Error** - serious. Fix now'), 'parenthetical': ''}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - - **Error** - serious. Fix now

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "one_liner": {
    "_type": "OneLiner",
    "content": "**Error** - serious. Fix now"
  },
  "parenthetical": ""
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}]}
Append {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}]}
DerivingDict for Part:  Attribute
		Full header is: - **Message** - (Template)



===
ParsingHeader header: - **Message** - (Template)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='Message', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'Template', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Template', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **Message** - (Template)

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "Message",
    "_type": "AttributeName"
  },
  "parenthetical": "Template",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Template",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}
DerivingDict for Part:  Class
		Full header is: _ **Class Constraint**



===
ParsingHeader header: _ **Class Constraint**

ParsingHeader result: {'prefix': '_', 'name': ClassName(content='Class Constraint', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: **Subtype of**: Constraint
parsing subtypeOfs:   Constraint

SubtypeOf result is  [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Using ATT_NAME  subtype_of for subtype_of
Adding value in ddforpart. subtype_of -. [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
Absorbing to subtype_of [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': ''}
Extend [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] to subtype_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Class Constraint",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ]
}
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for BASED_ON: ***Based on***: Class.
adding name value. based_on -. [ClassName(content='Class.', _type='ClassName')]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'based_on': [ClassName(content='Class.', _type='ClassName')]}
Using ATT_NAME  based_on for based_on
Adding value in ddforpart. based_on -. [ClassName(content='Class.', _type='ClassName')]
Absorbing to based_on [ClassName(content='Class.', _type='ClassName')] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Extend [ClassName(content='Class.', _type='ClassName')] to based_on
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Class Constraint",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "based_on": [
    {
      "content": "Class.",
      "_type": "ClassName"
    }
  ]
}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}]}
DerivingDict for Part:  Class
		Full header is: _ **Attribute Constraint**



===
ParsingHeader header: _ **Attribute Constraint**

ParsingHeader result: {'prefix': '_', 'name': ClassName(content='Attribute Constraint', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: ***Subtype of***: Constraint
parsing subtypeOfs:   Constraint

SubtypeOf result is  [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Using ATT_NAME  subtype_of for subtype_of
Adding value in ddforpart. subtype_of -. [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
Absorbing to subtype_of [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': ''}
Extend [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] to subtype_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Attribute Constraint",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ]
}
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for BASED_ON: ***Based on***: Attribute
adding name value. based_on -. [ClassName(content='Attribute', _type='ClassName')]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'based_on': [ClassName(content='Attribute', _type='ClassName')]}
Using ATT_NAME  based_on for based_on
Adding value in ddforpart. based_on -. [ClassName(content='Attribute', _type='ClassName')]
Absorbing to based_on [ClassName(content='Attribute', _type='ClassName')] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Extend [ClassName(content='Attribute', _type='ClassName')] to based_on
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Attribute Constraint",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "based_on": [
    {
      "content": "Attribute",
      "_type": "ClassName"
    }
  ]
}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}]}
DerivingDict for Part:  Class
		Full header is: _ **CodeExpression**



===
ParsingHeader header: _ **CodeExpression**

ParsingHeader result: {'prefix': '_', 'name': ClassName(content='CodeExpression', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
===

DerivingDict for Part:  Attribute
		Full header is: - **Language** - the programming language (Code)



===
ParsingHeader header: - **Language** - the programming language (Code)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='Language', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='the programming language'), 'parenthetical': 'Code', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Code', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **Language** - the programming language (Code)

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "Language",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "the programming language"
  },
  "parenthetical": "Code",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Code",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': ''}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - - OCL: Object Constraint Language



===
ParsingHeader header: - - OCL: Object Constraint Language

ParsingHeader result: {'prefix': '-', 'name': None, 'one_liner': OneLiner(_type='OneLiner', content='OCL: Object Constraint Language'), 'parenthetical': ''}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - - OCL: Object Constraint Language

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "one_liner": {
    "_type": "OneLiner",
    "content": "OCL: Object Constraint Language"
  },
  "parenthetical": ""
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}]}
DerivingDict for Part:  Attribute
		Full header is: - - Java: Java



===
ParsingHeader header: - - Java: Java

ParsingHeader result: {'prefix': '-', 'name': None, 'one_liner': OneLiner(_type='OneLiner', content='Java: Java'), 'parenthetical': ''}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - - Java: Java

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "one_liner": {
    "_type": "OneLiner",
    "content": "Java: Java"
  },
  "parenthetical": ""
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}]}
Append {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}]}
DerivingDict for Part:  Attribute
		Full header is: - **Expression** (String)



===
ParsingHeader header: - **Expression** (String)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='Expression', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'String', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='String', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **Expression** (String)

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "Expression",
    "_type": "AttributeName"
  },
  "parenthetical": "String",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "String",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}
Absorbing to subjects {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]} into {'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}]}
Append {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]} to subjects
after absorb, dict has:  {'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}]}
DerivingDict for Part:  SubjectB
		Full header is: ## Methods



===
ParsingHeader header: ## Methods

ParsingHeader result: {'prefix': '##', 'name': SubjectName(content='Methods', _type='SubjectName'), 'one_liner': None, 'parenthetical': ''}
===

DerivingDict for Part:  Class
		Full header is: _ **Method**
A behavior or operation associated with a class


===
ParsingHeader header: _ **Method**
A behavior or operation associated with a class
ParsingHeader result: {'prefix': '_', 'name': ClassName(content='Method\nA behavior or operation associated with a class', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for PLURAL: Plural: Methods
adding name value. plural -.  Methods

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'plural': ' Methods\n'}
Using ATT_NAME  plural for plural
Adding value in ddforpart. plural -.  Methods

Absorbing to plural  Methods
 into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': ''}
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n'}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Method\nA behavior or operation associated with a class",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Methods\n"
}
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Component
parsing subtypeOfs:   Component

SubtypeOf result is  [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Using ATT_NAME  subtype_of for subtype_of
Adding value in ddforpart. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
Absorbing to subtype_of [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n'}
Extend [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] to subtype_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Method\nA behavior or operation associated with a class",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Methods\n",
  "subtype_of": [
    "UnserializablePiece"
  ]
}
DerivingDict for Part:  Attribute
		Full header is: - **parameters** - The input parameters of the method _(ListOf Parameters)_



===
ParsingHeader header: - **parameters** - The input parameters of the method _(ListOf Parameters)_

Created list dt:  List of reference Parameters
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='parameters', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='The input parameters of the method _'), 'parenthetical': 'ListOf Parameters', 'data_type_clause': DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Parameters', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **parameters** - The input parameters of the method _(ListOf Parameters)_

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "parameters",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "The input parameters of the method _"
  },
  "parenthetical": "ListOf Parameters",
  "data_type_clause": {
    "data_type": {
      "_type": "ListDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "Parameters",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **returnType** - The data type of the value returned by the method _(DataType )_



===
ParsingHeader header: - **returnType** - The data type of the value returned by the method _(DataType )_

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='returnType', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='The data type of the value returned by the method _'), 'parenthetical': 'DataType', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='DataType', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **returnType** - The data type of the value returned by the method _(DataType )_

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "returnType",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "The data type of the value returned by the method _"
  },
  "parenthetical": "DataType",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "DataType",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': ''}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}
DerivingDict for Part:  Class
		Full header is: _ **Parameter**
An input to a method


===
ParsingHeader header: _ **Parameter**
An input to a method
ParsingHeader result: {'prefix': '_', 'name': ClassName(content='Parameter\nAn input to a method', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for PLURAL: Plural: Parameters
adding name value. plural -.  Parameters

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'plural': ' Parameters\n'}
Using ATT_NAME  plural for plural
Adding value in ddforpart. plural -.  Parameters

Absorbing to plural  Parameters
 into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': ''}
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n'}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Parameter\nAn input to a method",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Parameters\n"
}
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Component
parsing subtypeOfs:   Component

SubtypeOf result is  [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Using ATT_NAME  subtype_of for subtype_of
Adding value in ddforpart. subtype_of -. [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
Absorbing to subtype_of [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n'}
Extend [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] to subtype_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Parameter\nAn input to a method",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Parameters\n",
  "subtype_of": [
    "UnserializablePiece"
  ]
}
DerivingDict for Part:  Attribute
		Full header is: - **type** - The data type of the parameter _(DataType )_



===
ParsingHeader header: - **type** - The data type of the parameter _(DataType )_

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='type', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='The data type of the parameter _'), 'parenthetical': 'DataType', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='DataType', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **type** - The data type of the parameter _(DataType )_

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "type",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "The data type of the parameter _"
  },
  "parenthetical": "DataType",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "DataType",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **cardinality** - The cardinality of the parameter (e.g., optional, required) _(AttributeCardinality)_



===
ParsingHeader header: - **cardinality** - The cardinality of the parameter (e.g., optional, required) _(AttributeCardinality)_

Inventing name for:  e.g., optional, required
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='cardinality', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='The cardinality of the parameter'), 'parenthetical': 'e.g., optional, required', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Invented Name', _type='ClassName'), as_value_type=AsValue(t_value=True, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **cardinality** - The cardinality of the parameter (e.g., optional, required) _(AttributeCardinality)_

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "cardinality",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "The cardinality of the parameter"
  },
  "parenthetical": "e.g., optional, required",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Invented Name",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": true,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}
Absorbing to subjects {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]} into {'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}]}
Append {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]} to subjects
after absorb, dict has:  {'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}]}
DerivingDict for Part:  SubjectB
		Full header is: ## Data Types



===
ParsingHeader header: ## Data Types

ParsingHeader result: {'prefix': '##', 'name': SubjectName(content='Data Types', _type='SubjectName'), 'one_liner': None, 'parenthetical': ''}
===

DerivingDict for Part:  Class
		Full header is: _ **Simple Data Type**
***SubtpeOf***: DataType


===
ParsingHeader header: _ **Simple Data Type**
***SubtpeOf***: DataType
ParsingHeader result: {'prefix': '_', 'name': ClassName(content='Simple Data Type\nSubtpeOf DataType', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
===

DerivingDict for Part:  Attribute
		Full header is: - **coreClass** - (Class)



===
ParsingHeader header: - **coreClass** - (Class)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='coreClass', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'Class', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Class', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **coreClass** - (Class)

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "coreClass",
    "_type": "AttributeName"
  },
  "parenthetical": "Class",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Class",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': ''}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}
DerivingDict for Part:  Class
		Full header is: _ **Complex Data Type**



===
ParsingHeader header: _ **Complex Data Type**

ParsingHeader result: {'prefix': '_', 'name': ClassName(content='Complex Data Type', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
===

DerivingDict for Part:  Attribute
		Full header is: - **aggregation** (Aggregating Operator)



===
ParsingHeader header: - **aggregation** (Aggregating Operator)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='aggregation', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'Aggregating Operator', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Aggregating Operator', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **aggregation** (Aggregating Operator)

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "aggregation",
    "_type": "AttributeName"
  },
  "parenthetical": "Aggregating Operator",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Aggregating Operator",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': ''}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **aggregatedTypes** (List of DataTypes)



===
ParsingHeader header: - **aggregatedTypes** (List of DataTypes)

Created list dt:  List of reference DataTypes
ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='aggregatedTypes', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'List of DataTypes', 'data_type_clause': DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='DataTypes', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **aggregatedTypes** (List of DataTypes)

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "aggregatedTypes",
    "_type": "AttributeName"
  },
  "parenthetical": "List of DataTypes",
  "data_type_clause": {
    "data_type": {
      "_type": "ListDataType",
      "element_type": {
        "_type": "BaseDataType",
        "class_name": {
          "content": "DataTypes",
          "_type": "ClassName"
        },
        "as_value_type": {
          "t_value": false,
          "_type": "AsValue"
        }
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}
DerivingDict for Part:  Class
		Full header is: _ **Aggregating Operator**



===
ParsingHeader header: _ **Aggregating Operator**

ParsingHeader result: {'prefix': '_', 'name': ClassName(content='Aggregating Operator', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
===

DerivingDict for Part:  Attribute
		Full header is: - **Name**- (Code)



===
ParsingHeader header: - **Name**- (Code)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='Name', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'Code', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Code', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **Name**- (Code)

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "Name",
    "_type": "AttributeName"
  },
  "parenthetical": "Code",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Code",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': ''}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - - **SetOf**



===
ParsingHeader header: - - **SetOf**

ParsingHeader result: {'prefix': '-', 'name': None, 'one_liner': OneLiner(_type='OneLiner', content='**SetOf**'), 'parenthetical': ''}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - - **SetOf**

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "one_liner": {
    "_type": "OneLiner",
    "content": "**SetOf**"
  },
  "parenthetical": ""
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}]}
DerivingDict for Part:  Attribute
		Full header is: - - **ListOf**



===
ParsingHeader header: - - **ListOf**

ParsingHeader result: {'prefix': '-', 'name': None, 'one_liner': OneLiner(_type='OneLiner', content='**ListOf**'), 'parenthetical': ''}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - - **ListOf**

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "one_liner": {
    "_type": "OneLiner",
    "content": "**ListOf**"
  },
  "parenthetical": ""
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}]}
Append {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}]}
DerivingDict for Part:  Attribute
		Full header is: - - **Mapping**



===
ParsingHeader header: - - **Mapping**

ParsingHeader result: {'prefix': '-', 'name': None, 'one_liner': OneLiner(_type='OneLiner', content='**Mapping**'), 'parenthetical': ''}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - - **Mapping**

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "one_liner": {
    "_type": "OneLiner",
    "content": "**Mapping**"
  },
  "parenthetical": ""
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}]}
Append {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}]}
DerivingDict for Part:  Attribute
		Full header is: - **arity** - (Integer)



===
ParsingHeader header: - **arity** - (Integer)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='arity', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'Integer', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Integer', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **arity** - (Integer)

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "arity",
    "_type": "AttributeName"
  },
  "parenthetical": "Integer",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Integer",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **spelling** - (Template)



===
ParsingHeader header: - **spelling** - (Template)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='spelling', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'Template', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Template', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **spelling** - (Template)

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "spelling",
    "_type": "AttributeName"
  },
  "parenthetical": "Template",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Template",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}
Absorbing to subjects {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]} into {'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}]}
Append {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]} to subjects
after absorb, dict has:  {'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}]}
DerivingDict for Part:  SubjectB
		Full header is: ## Low level Data Types



===
ParsingHeader header: ## Low level Data Types

ParsingHeader result: {'prefix': '##', 'name': SubjectName(content='Low level Data Types', _type='SubjectName'), 'one_liner': None, 'parenthetical': ''}
===

DerivingDict for Part:  Class
		Full header is: _ ***ValueType***: **CamelName**



===
ParsingHeader header: _ ***ValueType***: **CamelName**

ParsingHeader result: {'prefix': '_', 'name': ClassName(content='ValueType CamelName', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: ***Subtype of***: String
parsing subtypeOfs:   String

SubtypeOf result is  [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Using ATT_NAME  subtype_of for subtype_of
Adding value in ddforpart. subtype_of -. [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
Absorbing to subtype_of [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}]}
Extend [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] to subtype_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "ValueType CamelName",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "elaboration": [
    {
      "_type": "Paragraph",
      "content": "A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n"
    }
  ],
  "subtype_of": [
    "UnserializablePiece"
  ]
}
DerivingDict for Part:  Attribute
		Full header is: - value: the string (String)



===
ParsingHeader header: - value: the string (String)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='value the string', _type='AttributeName'), 'one_liner': None, 'parenthetical': 'String', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='String', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Constraint
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for CONSTRAINT: ***Constraint***: Must follow the camel case naming convention and not be empty.
Patched att_name is one_liner for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is one_liner
adding name value. one_liner -.  Must follow the camel case naming convention and not be empty.

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  Must follow the camel case naming convention and not be empty.

Absorbing to one_liner  Must follow the camel case naming convention and not be empty.
 into {'_type': 'Constraint'}
Append  Must follow the camel case naming convention and not be empty.
 to one_liner
after absorb, dict has:  {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}
And the dict has;;;
{
  "_type": "Constraint",
  "one_liner": [
    {
      "_type": "OneLiner",
      "content": " Must follow the camel case naming convention and not be empty.\n"
    }
  ]
}
Absorbing to constraints {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
Append {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]} to constraints
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}]}
DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}]}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]} to annotations
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}]}
DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}]}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'} to annotations
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - value: the string (String)
. . Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ CONSTRAINT: ***Constraint***: Must follow the camel case naming convention and not be empty.
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ EXAMPLE: Example:  "firstName", "orderDate", "customerID"
_ _ _ ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.', extra_text=[])], extra_text=[])]
. . Annotation - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ WILD: *ModelingNote:* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "value the string",
    "_type": "AttributeName"
  },
  "parenthetical": "String",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "String",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "constraints": [
    {
      "_type": "Constraint",
      "one_liner": [
        {
          "_type": "OneLiner",
          "content": " Must follow the camel case naming convention and not be empty.\n"
        }
      ]
    }
  ],
  "annotations": [
    {
      "_type": "Annotation",
      "emoji": "",
      "label": "Example",
      "content": "\"firstName\", \"orderDate\", \"customerID\"",
      "elaboration": [
        {
          "_type": "Paragraph",
          "content": "> \ud83d\udcdd ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n"
        }
      ]
    },
    {
      "_type": "Annotation",
      "emoji": "",
      "label": "ModelingNote",
      "content": "* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model."
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}]}
DerivingDict for Part:  Class
		Full header is: _ **UpperCamel**- a CamelName that begins with a capital letter



===
ParsingHeader header: _ **UpperCamel**- a CamelName that begins with a capital letter

ParsingHeader result: {'prefix': '_', 'name': ClassName(content='UpperCamel', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content='a CamelName that begins with a capital letter'), 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: **Subtype of**: CamelName
parsing subtypeOfs:   CamelName

SubtypeOf result is  [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Using ATT_NAME  subtype_of for subtype_of
Adding value in ddforpart. subtype_of -. [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
Absorbing to subtype_of [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': ''}
Extend [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] to subtype_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "UpperCamel",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "a CamelName that begins with a capital letter"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ]
}
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for WHERE: **Where**: content begins with an upper case letter.
adding name value. where -.  content begins with an upper case letter.

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'where': ' content begins with an upper case letter.\n'}
Using ATT_NAME  where for where
Adding value in ddforpart. where -.  content begins with an upper case letter.

Absorbing to where  content begins with an upper case letter.
 into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n'}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "UpperCamel",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "a CamelName that begins with a capital letter"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "where": " content begins with an upper case letter.\n"
}
DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n'}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'} to annotations
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}]}
DerivingDict for Part:  Class
		Full header is: _ **LowerCamel** - a CamelName that begins with a lower case letter



===
ParsingHeader header: _ **LowerCamel** - a CamelName that begins with a lower case letter

ParsingHeader result: {'prefix': '_', 'name': ClassName(content='LowerCamel', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content='a CamelName that begins with a lower case letter'), 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: **Subtype of**: CamelName
parsing subtypeOfs:   CamelName

SubtypeOf result is  [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Using ATT_NAME  subtype_of for subtype_of
Adding value in ddforpart. subtype_of -. [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
Absorbing to subtype_of [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': ''}
Extend [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] to subtype_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "LowerCamel",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "a CamelName that begins with a lower case letter"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ]
}
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for WHERE: **Where**: content begins with a lower case letter.
adding name value. where -.  content begins with a lower case letter.

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'where': ' content begins with a lower case letter.\n'}
Using ATT_NAME  where for where
Adding value in ddforpart. where -.  content begins with a lower case letter.

Absorbing to where  content begins with a lower case letter.
 into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n'}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "LowerCamel",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "a CamelName that begins with a lower case letter"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "where": " content begins with a lower case letter.\n"
}
DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n'}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'} to annotations
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}]}
DerivingDict for Part:  Class
		Full header is: _ **Qualified Camel** - an expression consisting of Camel Names separated by periods



===
ParsingHeader header: _ **Qualified Camel** - an expression consisting of Camel Names separated by periods

ParsingHeader result: {'prefix': '_', 'name': ClassName(content='Qualified Camel', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content='an expression consisting of Camel Names separated by periods'), 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: ***Subtype of***: String
parsing subtypeOfs:   String

SubtypeOf result is  [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Using ATT_NAME  subtype_of for subtype_of
Adding value in ddforpart. subtype_of -. [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
Absorbing to subtype_of [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': ''}
Extend [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] to subtype_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Qualified Camel",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "an expression consisting of Camel Names separated by periods"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ]
}
DerivingDict for Part:  Constraint
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for CONSTRAINT: ***Constraint***: content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.
Patched att_name is one_liner for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is one_liner
adding name value. one_liner -.  content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.

Absorbing to one_liner  content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.
 into {'_type': 'Constraint'}
Append  content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.
 to one_liner
after absorb, dict has:  {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}
And the dict has;;;
{
  "_type": "Constraint",
  "one_liner": [
    {
      "_type": "OneLiner",
      "content": " content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n"
    }
  ]
}
Absorbing to constraints {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Append {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]} to constraints
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}]}
DerivingDict for Part:  Class
		Full header is: _ **RichText**.  A string with markup for block level formatting.



===
ParsingHeader header: _ **RichText**.  A string with markup for block level formatting.

ParsingHeader result: {'prefix': '_', 'name': ClassName(content='RichText.  A string with markup for block level formatting.', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: ***SubtypeOf***: String
parsing subtypeOfs:   String

SubtypeOf result is  [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Using ATT_NAME  subtype_of for subtype_of
Adding value in ddforpart. subtype_of -. [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
Absorbing to subtype_of [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': ''}
Extend [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] to subtype_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "RichText.  A string with markup for block level formatting.",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ]
}
DerivingDict for Part:  Attribute
		Full header is: - **value** - the string content (string)



===
ParsingHeader header: - **value** - the string content (string)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='value', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='the string content'), 'parenthetical': 'string', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='string', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **value** - the string content (string)

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "value",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "the string content"
  },
  "parenthetical": "string",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "string",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **format** - the rich text coding language used (Code)



===
ParsingHeader header: - **format** - the rich text coding language used (Code)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='format', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='the rich text coding language used'), 'parenthetical': 'Code', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Code', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **format** - the rich text coding language used (Code)

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "format",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "the rich text coding language used"
  },
  "parenthetical": "Code",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "Code",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  }
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
DerivingDict for Part:  Attribute
		Full header is: - **HTML**



===
ParsingHeader header: - **HTML**

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='HTML', _type='AttributeName'), 'one_liner': None, 'parenthetical': ''}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **HTML**

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "HTML",
    "_type": "AttributeName"
  },
  "parenthetical": ""
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}]}
DerivingDict for Part:  Attribute
		Full header is: - **MarkDown**



===
ParsingHeader header: - **MarkDown**

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='MarkDown', _type='AttributeName'), 'one_liner': None, 'parenthetical': ''}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **MarkDown**

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "MarkDown",
    "_type": "AttributeName"
  },
  "parenthetical": ""
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}
DerivingDict for Part:  Class
		Full header is: _  **RichLine**   - String with markup for line level formatting.



===
ParsingHeader header: _  **RichLine**   - String with markup for line level formatting.

ParsingHeader result: {'prefix': '_', 'name': ClassName(content='RichLine', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content='String with markup for line level formatting.'), 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: ***SubtypeOf***: RichText
parsing subtypeOfs:   RichText

SubtypeOf result is  [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Using ATT_NAME  subtype_of for subtype_of
Adding value in ddforpart. subtype_of -. [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
Absorbing to subtype_of [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': ''}
Extend [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] to subtype_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "RichLine",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "String with markup for line level formatting."
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ]
}
DerivingDict for Part:  Attribute
		Full header is: - **value** - the string content (string)



===
ParsingHeader header: - **value** - the string content (string)

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='value', _type='AttributeName'), 'one_liner': OneLiner(_type='OneLiner', content='the string content'), 'parenthetical': 'string', 'data_type_clause': DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='string', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause')}
===

DerivingDict for Part:  Constraint
[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for CONSTRAINT: ***Constraint***: must not containa line break or new line character
Patched att_name is one_liner for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is one_liner
adding name value. one_liner -.  must not containa line break or new line character

[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'one_liner': OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')}
Using ATT_NAME  one_liner for one_liner
Adding value in ddforpart. one_liner -.  must not containa line break or new line character

Absorbing to one_liner  must not containa line break or new line character
 into {'_type': 'Constraint'}
Append  must not containa line break or new line character
 to one_liner
after absorb, dict has:  {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}
And the dict has;;;
{
  "_type": "Constraint",
  "one_liner": [
    {
      "_type": "OneLiner",
      "content": " must not containa line break or new line character\n"
    }
  ]
}
Absorbing to constraints {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]} into {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}
Append {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]} to constraints
after absorb, dict has:  {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}
Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - **value** - the string content (string)
. . Constraint - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ _ CONSTRAINT: ***Constraint***: must not containa line break or new line character

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "value",
    "_type": "AttributeName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "the string content"
  },
  "parenthetical": "string",
  "data_type_clause": {
    "data_type": {
      "_type": "BaseDataType",
      "class_name": {
        "content": "string",
        "_type": "ClassName"
      },
      "as_value_type": {
        "t_value": false,
        "_type": "AsValue"
      }
    },
    "is_optional_lit": {
      "t_value": false,
      "_type": "IsOptional"
    },
    "_type": "DataTypeClause"
  },
  "constraints": [
    {
      "_type": "Constraint",
      "one_liner": [
        {
          "_type": "OneLiner",
          "content": " must not containa line break or new line character\n"
        }
      ]
    }
  ]
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]} to attributes
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]}]}
DerivingDict for Part:  Class
		Full header is: _ **PrimitiveType**



===
ParsingHeader header: _ **PrimitiveType**

ParsingHeader result: {'prefix': '_', 'name': ClassName(content='PrimitiveType', _type='ClassName'), 'one_liner': None, 'parenthetical': ''}
===

[dull_parser_core.py:180 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: ValueTypeA basic, built-in data type
parsing subtypeOfs:   ValueType
A basic, built-in data type
SubtypeOf result is  [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
adding name value. subtype_of -. [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
[dull_parser_core.py:180 -                  derive_clause_dict()] >  Returned {'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Using ATT_NAME  subtype_of for subtype_of
Adding value in ddforpart. subtype_of -. [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]
Absorbing to subtype_of [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': ''}
Extend [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))] to subtype_of
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
And the dict has;;;
{
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "PrimitiveType",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece",
    "UnserializablePiece"
  ]
}
DerivingDict for Part:  Annotation
Absorbing to annotations {'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]} into {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
Append {'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]} to annotations
after absorb, dict has:  {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]}]}
Absorbing to classes {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]}]}
Append {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]}]} to classes
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]}]}]}
Absorbing to subjects {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]}]}]} into {'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}]}
Append {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]}]}]} to subjects
after absorb, dict has:  {'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]}]}]}]}
DerivingDict for Part:  SubjectB
		Full header is: ## Appendices
Insert More Sidebars.md
Insert Overrides.md
insert LDM Intro.md
Insert OCL.md
Insert Camel Case.md


===
ParsingHeader header: ## Appendices
Insert More Sidebars.md
Insert Overrides.md
insert LDM Intro.md
Insert OCL.md
Insert Camel Case.md
ParsingHeader result: {'prefix': '##', 'name': SubjectName(content='Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', _type='SubjectName'), 'one_liner': None, 'parenthetical': ''}
===

DerivingDict for Part:  SubjectC
		Full header is: ### Annotation Types Used



===
ParsingHeader header: ### Annotation Types Used

ParsingHeader result: {'prefix': '###', 'name': SubjectName(content='Annotation Types Used', _type='SubjectName'), 'one_liner': None, 'parenthetical': ''}
===

Absorbing to subjects {'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Annotation Types Used', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'These are the recognized Annotation Types for the LDM model.\n'}, {'_type': 'Paragraph', 'content': 'And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.\n'}, {'_type': 'CodeBlock', 'content': '```typescript\ninterface AnnotationType {\nlabel: string;\nemoji: string;\nemojiName: string;\nemojiUnicode: string;\npurpose: string;\n}\n// LINK: LiterateDataModel.annotationTypes\nconst annotationTypes: AnnotationType[] = [\n{\nlabel: "Error",\nemoji: "",\nemojiName: "cross_mark",\nemojiUnicode: "U+274C",\npurpose: "Indicates a critical error or failure in the model."\n},\n{\nlabel: "Warning",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Indicates a potential issue or warning in the model."\n},\n{\nlabel: "Note",\nemoji: "",\nemojiName: "blue_book",\nemojiUnicode: "U+1F4D8",\npurpose: "Provides additional context, explanations, or clarifications for the annotated element."\n},\n{\nlabel: "Issue",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Highlights a potential issue or error that needs to be addressed or resolved."\n},\n{\nlabel: "Question",\nemoji: "",\nemojiName: "question",\nemojiUnicode: "U+2753",\npurpose: "Raises a question or seeks further clarification about the annotated element."\n},\n{\nlabel: "Suggestion",\nemoji: "",\nemojiName: "bulb",\nemojiUnicode: "U+1F4A1",\npurpose: "Provides a suggestion or recommendation for improving the model or the annotated element."\n},\n{\nlabel: "Info",\nemoji: "",\nemojiName: "information_source",\nemojiUnicode: "U+2139",\npurpose: "Offers relevant information, facts, or details about the annotated element."\n},\n{\nlabel: "Todo",\nemoji: "",\nemojiName: "pushpin",\nemojiUnicode: "U+1F4CC",\npurpose: "Indicates a pending task, action item, or future work related to the annotated element."\n},\n{\nlabel: "Reference",\nemoji: "",\nemojiName: "globe_with_meridians",\nemojiUnicode: "U+1F310",\npurpose: "Provides a reference or link to an external resource or documentation."\n},\n{\nlabel: "See",\nemoji: "",\nemojiName: "mag",\nemojiUnicode: "U+1F50D",\npurpose: "Indicates a cross-reference to another relevant element within the model."\n}\n];\n```'}, {'_type': 'Paragraph', 'content': '===\n'}]} into {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': ''}
Append {'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Annotation Types Used', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'These are the recognized Annotation Types for the LDM model.\n'}, {'_type': 'Paragraph', 'content': 'And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.\n'}, {'_type': 'CodeBlock', 'content': '```typescript\ninterface AnnotationType {\nlabel: string;\nemoji: string;\nemojiName: string;\nemojiUnicode: string;\npurpose: string;\n}\n// LINK: LiterateDataModel.annotationTypes\nconst annotationTypes: AnnotationType[] = [\n{\nlabel: "Error",\nemoji: "",\nemojiName: "cross_mark",\nemojiUnicode: "U+274C",\npurpose: "Indicates a critical error or failure in the model."\n},\n{\nlabel: "Warning",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Indicates a potential issue or warning in the model."\n},\n{\nlabel: "Note",\nemoji: "",\nemojiName: "blue_book",\nemojiUnicode: "U+1F4D8",\npurpose: "Provides additional context, explanations, or clarifications for the annotated element."\n},\n{\nlabel: "Issue",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Highlights a potential issue or error that needs to be addressed or resolved."\n},\n{\nlabel: "Question",\nemoji: "",\nemojiName: "question",\nemojiUnicode: "U+2753",\npurpose: "Raises a question or seeks further clarification about the annotated element."\n},\n{\nlabel: "Suggestion",\nemoji: "",\nemojiName: "bulb",\nemojiUnicode: "U+1F4A1",\npurpose: "Provides a suggestion or recommendation for improving the model or the annotated element."\n},\n{\nlabel: "Info",\nemoji: "",\nemojiName: "information_source",\nemojiUnicode: "U+2139",\npurpose: "Offers relevant information, facts, or details about the annotated element."\n},\n{\nlabel: "Todo",\nemoji: "",\nemojiName: "pushpin",\nemojiUnicode: "U+1F4CC",\npurpose: "Indicates a pending task, action item, or future work related to the annotated element."\n},\n{\nlabel: "Reference",\nemoji: "",\nemojiName: "globe_with_meridians",\nemojiUnicode: "U+1F310",\npurpose: "Provides a reference or link to an external resource or documentation."\n},\n{\nlabel: "See",\nemoji: "",\nemojiName: "mag",\nemojiUnicode: "U+1F50D",\npurpose: "Indicates a cross-reference to another relevant element within the model."\n}\n];\n```'}, {'_type': 'Paragraph', 'content': '===\n'}]} to subjects
after absorb, dict has:  {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Annotation Types Used', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'These are the recognized Annotation Types for the LDM model.\n'}, {'_type': 'Paragraph', 'content': 'And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.\n'}, {'_type': 'CodeBlock', 'content': '```typescript\ninterface AnnotationType {\nlabel: string;\nemoji: string;\nemojiName: string;\nemojiUnicode: string;\npurpose: string;\n}\n// LINK: LiterateDataModel.annotationTypes\nconst annotationTypes: AnnotationType[] = [\n{\nlabel: "Error",\nemoji: "",\nemojiName: "cross_mark",\nemojiUnicode: "U+274C",\npurpose: "Indicates a critical error or failure in the model."\n},\n{\nlabel: "Warning",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Indicates a potential issue or warning in the model."\n},\n{\nlabel: "Note",\nemoji: "",\nemojiName: "blue_book",\nemojiUnicode: "U+1F4D8",\npurpose: "Provides additional context, explanations, or clarifications for the annotated element."\n},\n{\nlabel: "Issue",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Highlights a potential issue or error that needs to be addressed or resolved."\n},\n{\nlabel: "Question",\nemoji: "",\nemojiName: "question",\nemojiUnicode: "U+2753",\npurpose: "Raises a question or seeks further clarification about the annotated element."\n},\n{\nlabel: "Suggestion",\nemoji: "",\nemojiName: "bulb",\nemojiUnicode: "U+1F4A1",\npurpose: "Provides a suggestion or recommendation for improving the model or the annotated element."\n},\n{\nlabel: "Info",\nemoji: "",\nemojiName: "information_source",\nemojiUnicode: "U+2139",\npurpose: "Offers relevant information, facts, or details about the annotated element."\n},\n{\nlabel: "Todo",\nemoji: "",\nemojiName: "pushpin",\nemojiUnicode: "U+1F4CC",\npurpose: "Indicates a pending task, action item, or future work related to the annotated element."\n},\n{\nlabel: "Reference",\nemoji: "",\nemojiName: "globe_with_meridians",\nemojiUnicode: "U+1F310",\npurpose: "Provides a reference or link to an external resource or documentation."\n},\n{\nlabel: "See",\nemoji: "",\nemojiName: "mag",\nemojiUnicode: "U+1F50D",\npurpose: "Indicates a cross-reference to another relevant element within the model."\n}\n];\n```'}, {'_type': 'Paragraph', 'content': '===\n'}]}]}
Absorbing to subjects {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Annotation Types Used', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'These are the recognized Annotation Types for the LDM model.\n'}, {'_type': 'Paragraph', 'content': 'And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.\n'}, {'_type': 'CodeBlock', 'content': '```typescript\ninterface AnnotationType {\nlabel: string;\nemoji: string;\nemojiName: string;\nemojiUnicode: string;\npurpose: string;\n}\n// LINK: LiterateDataModel.annotationTypes\nconst annotationTypes: AnnotationType[] = [\n{\nlabel: "Error",\nemoji: "",\nemojiName: "cross_mark",\nemojiUnicode: "U+274C",\npurpose: "Indicates a critical error or failure in the model."\n},\n{\nlabel: "Warning",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Indicates a potential issue or warning in the model."\n},\n{\nlabel: "Note",\nemoji: "",\nemojiName: "blue_book",\nemojiUnicode: "U+1F4D8",\npurpose: "Provides additional context, explanations, or clarifications for the annotated element."\n},\n{\nlabel: "Issue",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Highlights a potential issue or error that needs to be addressed or resolved."\n},\n{\nlabel: "Question",\nemoji: "",\nemojiName: "question",\nemojiUnicode: "U+2753",\npurpose: "Raises a question or seeks further clarification about the annotated element."\n},\n{\nlabel: "Suggestion",\nemoji: "",\nemojiName: "bulb",\nemojiUnicode: "U+1F4A1",\npurpose: "Provides a suggestion or recommendation for improving the model or the annotated element."\n},\n{\nlabel: "Info",\nemoji: "",\nemojiName: "information_source",\nemojiUnicode: "U+2139",\npurpose: "Offers relevant information, facts, or details about the annotated element."\n},\n{\nlabel: "Todo",\nemoji: "",\nemojiName: "pushpin",\nemojiUnicode: "U+1F4CC",\npurpose: "Indicates a pending task, action item, or future work related to the annotated element."\n},\n{\nlabel: "Reference",\nemoji: "",\nemojiName: "globe_with_meridians",\nemojiUnicode: "U+1F310",\npurpose: "Provides a reference or link to an external resource or documentation."\n},\n{\nlabel: "See",\nemoji: "",\nemojiName: "mag",\nemojiUnicode: "U+1F50D",\npurpose: "Indicates a cross-reference to another relevant element within the model."\n}\n];\n```'}, {'_type': 'Paragraph', 'content': '===\n'}]}]} into {'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]}]}]}]}
Append {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Annotation Types Used', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'These are the recognized Annotation Types for the LDM model.\n'}, {'_type': 'Paragraph', 'content': 'And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.\n'}, {'_type': 'CodeBlock', 'content': '```typescript\ninterface AnnotationType {\nlabel: string;\nemoji: string;\nemojiName: string;\nemojiUnicode: string;\npurpose: string;\n}\n// LINK: LiterateDataModel.annotationTypes\nconst annotationTypes: AnnotationType[] = [\n{\nlabel: "Error",\nemoji: "",\nemojiName: "cross_mark",\nemojiUnicode: "U+274C",\npurpose: "Indicates a critical error or failure in the model."\n},\n{\nlabel: "Warning",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Indicates a potential issue or warning in the model."\n},\n{\nlabel: "Note",\nemoji: "",\nemojiName: "blue_book",\nemojiUnicode: "U+1F4D8",\npurpose: "Provides additional context, explanations, or clarifications for the annotated element."\n},\n{\nlabel: "Issue",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Highlights a potential issue or error that needs to be addressed or resolved."\n},\n{\nlabel: "Question",\nemoji: "",\nemojiName: "question",\nemojiUnicode: "U+2753",\npurpose: "Raises a question or seeks further clarification about the annotated element."\n},\n{\nlabel: "Suggestion",\nemoji: "",\nemojiName: "bulb",\nemojiUnicode: "U+1F4A1",\npurpose: "Provides a suggestion or recommendation for improving the model or the annotated element."\n},\n{\nlabel: "Info",\nemoji: "",\nemojiName: "information_source",\nemojiUnicode: "U+2139",\npurpose: "Offers relevant information, facts, or details about the annotated element."\n},\n{\nlabel: "Todo",\nemoji: "",\nemojiName: "pushpin",\nemojiUnicode: "U+1F4CC",\npurpose: "Indicates a pending task, action item, or future work related to the annotated element."\n},\n{\nlabel: "Reference",\nemoji: "",\nemojiName: "globe_with_meridians",\nemojiUnicode: "U+1F310",\npurpose: "Provides a reference or link to an external resource or documentation."\n},\n{\nlabel: "See",\nemoji: "",\nemojiName: "mag",\nemojiUnicode: "U+1F50D",\npurpose: "Indicates a cross-reference to another relevant element within the model."\n}\n];\n```'}, {'_type': 'Paragraph', 'content': '===\n'}]}]} to subjects
after absorb, dict has:  {'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Annotation Types Used', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'These are the recognized Annotation Types for the LDM model.\n'}, {'_type': 'Paragraph', 'content': 'And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.\n'}, {'_type': 'CodeBlock', 'content': '```typescript\ninterface AnnotationType {\nlabel: string;\nemoji: string;\nemojiName: string;\nemojiUnicode: string;\npurpose: string;\n}\n// LINK: LiterateDataModel.annotationTypes\nconst annotationTypes: AnnotationType[] = [\n{\nlabel: "Error",\nemoji: "",\nemojiName: "cross_mark",\nemojiUnicode: "U+274C",\npurpose: "Indicates a critical error or failure in the model."\n},\n{\nlabel: "Warning",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Indicates a potential issue or warning in the model."\n},\n{\nlabel: "Note",\nemoji: "",\nemojiName: "blue_book",\nemojiUnicode: "U+1F4D8",\npurpose: "Provides additional context, explanations, or clarifications for the annotated element."\n},\n{\nlabel: "Issue",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Highlights a potential issue or error that needs to be addressed or resolved."\n},\n{\nlabel: "Question",\nemoji: "",\nemojiName: "question",\nemojiUnicode: "U+2753",\npurpose: "Raises a question or seeks further clarification about the annotated element."\n},\n{\nlabel: "Suggestion",\nemoji: "",\nemojiName: "bulb",\nemojiUnicode: "U+1F4A1",\npurpose: "Provides a suggestion or recommendation for improving the model or the annotated element."\n},\n{\nlabel: "Info",\nemoji: "",\nemojiName: "information_source",\nemojiUnicode: "U+2139",\npurpose: "Offers relevant information, facts, or details about the annotated element."\n},\n{\nlabel: "Todo",\nemoji: "",\nemojiName: "pushpin",\nemojiUnicode: "U+1F4CC",\npurpose: "Indicates a pending task, action item, or future work related to the annotated element."\n},\n{\nlabel: "Reference",\nemoji: "",\nemojiName: "globe_with_meridians",\nemojiUnicode: "U+1F310",\npurpose: "Provides a reference or link to an external resource or documentation."\n},\n{\nlabel: "See",\nemoji: "",\nemojiName: "mag",\nemojiUnicode: "U+1F50D",\npurpose: "Indicates a cross-reference to another relevant element within the model."\n}\n];\n```'}, {'_type': 'Paragraph', 'content': '===\n'}]}]}]}
DerivingDict for Part:  SubjectB
		Full header is: ## Appendices
Insert More Sidebars.md
Insert Overrides.md
insert LDM Intro.md
Insert OCL.md
Insert Camel Case.md


===
ParsingHeader header: ## Appendices
Insert More Sidebars.md
Insert Overrides.md
insert LDM Intro.md
Insert OCL.md
Insert Camel Case.md
ParsingHeader result: {'prefix': '##', 'name': SubjectName(content='Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', _type='SubjectName'), 'one_liner': None, 'parenthetical': ''}
===

Absorbing to subjects {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '== content to add\n'}]} into {'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Annotation Types Used', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'These are the recognized Annotation Types for the LDM model.\n'}, {'_type': 'Paragraph', 'content': 'And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.\n'}, {'_type': 'CodeBlock', 'content': '```typescript\ninterface AnnotationType {\nlabel: string;\nemoji: string;\nemojiName: string;\nemojiUnicode: string;\npurpose: string;\n}\n// LINK: LiterateDataModel.annotationTypes\nconst annotationTypes: AnnotationType[] = [\n{\nlabel: "Error",\nemoji: "",\nemojiName: "cross_mark",\nemojiUnicode: "U+274C",\npurpose: "Indicates a critical error or failure in the model."\n},\n{\nlabel: "Warning",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Indicates a potential issue or warning in the model."\n},\n{\nlabel: "Note",\nemoji: "",\nemojiName: "blue_book",\nemojiUnicode: "U+1F4D8",\npurpose: "Provides additional context, explanations, or clarifications for the annotated element."\n},\n{\nlabel: "Issue",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Highlights a potential issue or error that needs to be addressed or resolved."\n},\n{\nlabel: "Question",\nemoji: "",\nemojiName: "question",\nemojiUnicode: "U+2753",\npurpose: "Raises a question or seeks further clarification about the annotated element."\n},\n{\nlabel: "Suggestion",\nemoji: "",\nemojiName: "bulb",\nemojiUnicode: "U+1F4A1",\npurpose: "Provides a suggestion or recommendation for improving the model or the annotated element."\n},\n{\nlabel: "Info",\nemoji: "",\nemojiName: "information_source",\nemojiUnicode: "U+2139",\npurpose: "Offers relevant information, facts, or details about the annotated element."\n},\n{\nlabel: "Todo",\nemoji: "",\nemojiName: "pushpin",\nemojiUnicode: "U+1F4CC",\npurpose: "Indicates a pending task, action item, or future work related to the annotated element."\n},\n{\nlabel: "Reference",\nemoji: "",\nemojiName: "globe_with_meridians",\nemojiUnicode: "U+1F310",\npurpose: "Provides a reference or link to an external resource or documentation."\n},\n{\nlabel: "See",\nemoji: "",\nemojiName: "mag",\nemojiUnicode: "U+1F50D",\npurpose: "Indicates a cross-reference to another relevant element within the model."\n}\n];\n```'}, {'_type': 'Paragraph', 'content': '===\n'}]}]}]}
Append {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '== content to add\n'}]} to subjects
after absorb, dict has:  {'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Annotation Types Used', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'These are the recognized Annotation Types for the LDM model.\n'}, {'_type': 'Paragraph', 'content': 'And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.\n'}, {'_type': 'CodeBlock', 'content': '```typescript\ninterface AnnotationType {\nlabel: string;\nemoji: string;\nemojiName: string;\nemojiUnicode: string;\npurpose: string;\n}\n// LINK: LiterateDataModel.annotationTypes\nconst annotationTypes: AnnotationType[] = [\n{\nlabel: "Error",\nemoji: "",\nemojiName: "cross_mark",\nemojiUnicode: "U+274C",\npurpose: "Indicates a critical error or failure in the model."\n},\n{\nlabel: "Warning",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Indicates a potential issue or warning in the model."\n},\n{\nlabel: "Note",\nemoji: "",\nemojiName: "blue_book",\nemojiUnicode: "U+1F4D8",\npurpose: "Provides additional context, explanations, or clarifications for the annotated element."\n},\n{\nlabel: "Issue",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Highlights a potential issue or error that needs to be addressed or resolved."\n},\n{\nlabel: "Question",\nemoji: "",\nemojiName: "question",\nemojiUnicode: "U+2753",\npurpose: "Raises a question or seeks further clarification about the annotated element."\n},\n{\nlabel: "Suggestion",\nemoji: "",\nemojiName: "bulb",\nemojiUnicode: "U+1F4A1",\npurpose: "Provides a suggestion or recommendation for improving the model or the annotated element."\n},\n{\nlabel: "Info",\nemoji: "",\nemojiName: "information_source",\nemojiUnicode: "U+2139",\npurpose: "Offers relevant information, facts, or details about the annotated element."\n},\n{\nlabel: "Todo",\nemoji: "",\nemojiName: "pushpin",\nemojiUnicode: "U+1F4CC",\npurpose: "Indicates a pending task, action item, or future work related to the annotated element."\n},\n{\nlabel: "Reference",\nemoji: "",\nemojiName: "globe_with_meridians",\nemojiUnicode: "U+1F310",\npurpose: "Provides a reference or link to an external resource or documentation."\n},\n{\nlabel: "See",\nemoji: "",\nemojiName: "mag",\nemojiUnicode: "U+1F50D",\npurpose: "Indicates a cross-reference to another relevant element within the model."\n}\n];\n```'}, {'_type': 'Paragraph', 'content': '===\n'}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '== content to add\n'}]}]}
Absorbing to literate_models {'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Annotation Types Used', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'These are the recognized Annotation Types for the LDM model.\n'}, {'_type': 'Paragraph', 'content': 'And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.\n'}, {'_type': 'CodeBlock', 'content': '```typescript\ninterface AnnotationType {\nlabel: string;\nemoji: string;\nemojiName: string;\nemojiUnicode: string;\npurpose: string;\n}\n// LINK: LiterateDataModel.annotationTypes\nconst annotationTypes: AnnotationType[] = [\n{\nlabel: "Error",\nemoji: "",\nemojiName: "cross_mark",\nemojiUnicode: "U+274C",\npurpose: "Indicates a critical error or failure in the model."\n},\n{\nlabel: "Warning",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Indicates a potential issue or warning in the model."\n},\n{\nlabel: "Note",\nemoji: "",\nemojiName: "blue_book",\nemojiUnicode: "U+1F4D8",\npurpose: "Provides additional context, explanations, or clarifications for the annotated element."\n},\n{\nlabel: "Issue",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Highlights a potential issue or error that needs to be addressed or resolved."\n},\n{\nlabel: "Question",\nemoji: "",\nemojiName: "question",\nemojiUnicode: "U+2753",\npurpose: "Raises a question or seeks further clarification about the annotated element."\n},\n{\nlabel: "Suggestion",\nemoji: "",\nemojiName: "bulb",\nemojiUnicode: "U+1F4A1",\npurpose: "Provides a suggestion or recommendation for improving the model or the annotated element."\n},\n{\nlabel: "Info",\nemoji: "",\nemojiName: "information_source",\nemojiUnicode: "U+2139",\npurpose: "Offers relevant information, facts, or details about the annotated element."\n},\n{\nlabel: "Todo",\nemoji: "",\nemojiName: "pushpin",\nemojiUnicode: "U+1F4CC",\npurpose: "Indicates a pending task, action item, or future work related to the annotated element."\n},\n{\nlabel: "Reference",\nemoji: "",\nemojiName: "globe_with_meridians",\nemojiUnicode: "U+1F310",\npurpose: "Provides a reference or link to an external resource or documentation."\n},\n{\nlabel: "See",\nemoji: "",\nemojiName: "mag",\nemojiUnicode: "U+1F50D",\npurpose: "Indicates a cross-reference to another relevant element within the model."\n}\n];\n```'}, {'_type': 'Paragraph', 'content': '===\n'}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '== content to add\n'}]}]} into {'_type': 'Document'}
Append {'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Annotation Types Used', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'These are the recognized Annotation Types for the LDM model.\n'}, {'_type': 'Paragraph', 'content': 'And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.\n'}, {'_type': 'CodeBlock', 'content': '```typescript\ninterface AnnotationType {\nlabel: string;\nemoji: string;\nemojiName: string;\nemojiUnicode: string;\npurpose: string;\n}\n// LINK: LiterateDataModel.annotationTypes\nconst annotationTypes: AnnotationType[] = [\n{\nlabel: "Error",\nemoji: "",\nemojiName: "cross_mark",\nemojiUnicode: "U+274C",\npurpose: "Indicates a critical error or failure in the model."\n},\n{\nlabel: "Warning",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Indicates a potential issue or warning in the model."\n},\n{\nlabel: "Note",\nemoji: "",\nemojiName: "blue_book",\nemojiUnicode: "U+1F4D8",\npurpose: "Provides additional context, explanations, or clarifications for the annotated element."\n},\n{\nlabel: "Issue",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Highlights a potential issue or error that needs to be addressed or resolved."\n},\n{\nlabel: "Question",\nemoji: "",\nemojiName: "question",\nemojiUnicode: "U+2753",\npurpose: "Raises a question or seeks further clarification about the annotated element."\n},\n{\nlabel: "Suggestion",\nemoji: "",\nemojiName: "bulb",\nemojiUnicode: "U+1F4A1",\npurpose: "Provides a suggestion or recommendation for improving the model or the annotated element."\n},\n{\nlabel: "Info",\nemoji: "",\nemojiName: "information_source",\nemojiUnicode: "U+2139",\npurpose: "Offers relevant information, facts, or details about the annotated element."\n},\n{\nlabel: "Todo",\nemoji: "",\nemojiName: "pushpin",\nemojiUnicode: "U+1F4CC",\npurpose: "Indicates a pending task, action item, or future work related to the annotated element."\n},\n{\nlabel: "Reference",\nemoji: "",\nemojiName: "globe_with_meridians",\nemojiUnicode: "U+1F310",\npurpose: "Provides a reference or link to an external resource or documentation."\n},\n{\nlabel: "See",\nemoji: "",\nemojiName: "mag",\nemojiUnicode: "U+1F50D",\npurpose: "Indicates a cross-reference to another relevant element within the model."\n}\n];\n```'}, {'_type': 'Paragraph', 'content': '===\n'}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '== content to add\n'}]}]} to literate_models
after absorb, dict has:  {'_type': 'Document', 'literate_models': [{'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Annotation Types Used', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'These are the recognized Annotation Types for the LDM model.\n'}, {'_type': 'Paragraph', 'content': 'And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.\n'}, {'_type': 'CodeBlock', 'content': '```typescript\ninterface AnnotationType {\nlabel: string;\nemoji: string;\nemojiName: string;\nemojiUnicode: string;\npurpose: string;\n}\n// LINK: LiterateDataModel.annotationTypes\nconst annotationTypes: AnnotationType[] = [\n{\nlabel: "Error",\nemoji: "",\nemojiName: "cross_mark",\nemojiUnicode: "U+274C",\npurpose: "Indicates a critical error or failure in the model."\n},\n{\nlabel: "Warning",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Indicates a potential issue or warning in the model."\n},\n{\nlabel: "Note",\nemoji: "",\nemojiName: "blue_book",\nemojiUnicode: "U+1F4D8",\npurpose: "Provides additional context, explanations, or clarifications for the annotated element."\n},\n{\nlabel: "Issue",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Highlights a potential issue or error that needs to be addressed or resolved."\n},\n{\nlabel: "Question",\nemoji: "",\nemojiName: "question",\nemojiUnicode: "U+2753",\npurpose: "Raises a question or seeks further clarification about the annotated element."\n},\n{\nlabel: "Suggestion",\nemoji: "",\nemojiName: "bulb",\nemojiUnicode: "U+1F4A1",\npurpose: "Provides a suggestion or recommendation for improving the model or the annotated element."\n},\n{\nlabel: "Info",\nemoji: "",\nemojiName: "information_source",\nemojiUnicode: "U+2139",\npurpose: "Offers relevant information, facts, or details about the annotated element."\n},\n{\nlabel: "Todo",\nemoji: "",\nemojiName: "pushpin",\nemojiUnicode: "U+1F4CC",\npurpose: "Indicates a pending task, action item, or future work related to the annotated element."\n},\n{\nlabel: "Reference",\nemoji: "",\nemojiName: "globe_with_meridians",\nemojiUnicode: "U+1F310",\npurpose: "Provides a reference or link to an external resource or documentation."\n},\n{\nlabel: "See",\nemoji: "",\nemojiName: "mag",\nemojiUnicode: "U+1F50D",\npurpose: "Indicates a cross-reference to another relevant element within the model."\n}\n];\n```'}, {'_type': 'Paragraph', 'content': '===\n'}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '== content to add\n'}]}]}]}
DerivingDict for Part:  Attribute
		Full header is: - minor component



===
ParsingHeader header: - minor component

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='minor component', _type='AttributeName'), 'one_liner': None, 'parenthetical': ''}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - minor component

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "minor component",
    "_type": "AttributeName"
  },
  "parenthetical": ""
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'minor component', '_type': 'AttributeName'}, 'parenthetical': ''} into {'_type': 'Document', 'literate_models': [{'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Annotation Types Used', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'These are the recognized Annotation Types for the LDM model.\n'}, {'_type': 'Paragraph', 'content': 'And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.\n'}, {'_type': 'CodeBlock', 'content': '```typescript\ninterface AnnotationType {\nlabel: string;\nemoji: string;\nemojiName: string;\nemojiUnicode: string;\npurpose: string;\n}\n// LINK: LiterateDataModel.annotationTypes\nconst annotationTypes: AnnotationType[] = [\n{\nlabel: "Error",\nemoji: "",\nemojiName: "cross_mark",\nemojiUnicode: "U+274C",\npurpose: "Indicates a critical error or failure in the model."\n},\n{\nlabel: "Warning",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Indicates a potential issue or warning in the model."\n},\n{\nlabel: "Note",\nemoji: "",\nemojiName: "blue_book",\nemojiUnicode: "U+1F4D8",\npurpose: "Provides additional context, explanations, or clarifications for the annotated element."\n},\n{\nlabel: "Issue",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Highlights a potential issue or error that needs to be addressed or resolved."\n},\n{\nlabel: "Question",\nemoji: "",\nemojiName: "question",\nemojiUnicode: "U+2753",\npurpose: "Raises a question or seeks further clarification about the annotated element."\n},\n{\nlabel: "Suggestion",\nemoji: "",\nemojiName: "bulb",\nemojiUnicode: "U+1F4A1",\npurpose: "Provides a suggestion or recommendation for improving the model or the annotated element."\n},\n{\nlabel: "Info",\nemoji: "",\nemojiName: "information_source",\nemojiUnicode: "U+2139",\npurpose: "Offers relevant information, facts, or details about the annotated element."\n},\n{\nlabel: "Todo",\nemoji: "",\nemojiName: "pushpin",\nemojiUnicode: "U+1F4CC",\npurpose: "Indicates a pending task, action item, or future work related to the annotated element."\n},\n{\nlabel: "Reference",\nemoji: "",\nemojiName: "globe_with_meridians",\nemojiUnicode: "U+1F310",\npurpose: "Provides a reference or link to an external resource or documentation."\n},\n{\nlabel: "See",\nemoji: "",\nemojiName: "mag",\nemojiUnicode: "U+1F50D",\npurpose: "Indicates a cross-reference to another relevant element within the model."\n}\n];\n```'}, {'_type': 'Paragraph', 'content': '===\n'}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '== content to add\n'}]}]}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'minor component', '_type': 'AttributeName'}, 'parenthetical': ''} to attributes
after absorb, dict has:  {'_type': 'Document', 'literate_models': [{'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Annotation Types Used', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'These are the recognized Annotation Types for the LDM model.\n'}, {'_type': 'Paragraph', 'content': 'And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.\n'}, {'_type': 'CodeBlock', 'content': '```typescript\ninterface AnnotationType {\nlabel: string;\nemoji: string;\nemojiName: string;\nemojiUnicode: string;\npurpose: string;\n}\n// LINK: LiterateDataModel.annotationTypes\nconst annotationTypes: AnnotationType[] = [\n{\nlabel: "Error",\nemoji: "",\nemojiName: "cross_mark",\nemojiUnicode: "U+274C",\npurpose: "Indicates a critical error or failure in the model."\n},\n{\nlabel: "Warning",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Indicates a potential issue or warning in the model."\n},\n{\nlabel: "Note",\nemoji: "",\nemojiName: "blue_book",\nemojiUnicode: "U+1F4D8",\npurpose: "Provides additional context, explanations, or clarifications for the annotated element."\n},\n{\nlabel: "Issue",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Highlights a potential issue or error that needs to be addressed or resolved."\n},\n{\nlabel: "Question",\nemoji: "",\nemojiName: "question",\nemojiUnicode: "U+2753",\npurpose: "Raises a question or seeks further clarification about the annotated element."\n},\n{\nlabel: "Suggestion",\nemoji: "",\nemojiName: "bulb",\nemojiUnicode: "U+1F4A1",\npurpose: "Provides a suggestion or recommendation for improving the model or the annotated element."\n},\n{\nlabel: "Info",\nemoji: "",\nemojiName: "information_source",\nemojiUnicode: "U+2139",\npurpose: "Offers relevant information, facts, or details about the annotated element."\n},\n{\nlabel: "Todo",\nemoji: "",\nemojiName: "pushpin",\nemojiUnicode: "U+1F4CC",\npurpose: "Indicates a pending task, action item, or future work related to the annotated element."\n},\n{\nlabel: "Reference",\nemoji: "",\nemojiName: "globe_with_meridians",\nemojiUnicode: "U+1F310",\npurpose: "Provides a reference or link to an external resource or documentation."\n},\n{\nlabel: "See",\nemoji: "",\nemojiName: "mag",\nemojiUnicode: "U+1F50D",\npurpose: "Indicates a cross-reference to another relevant element within the model."\n}\n];\n```'}, {'_type': 'Paragraph', 'content': '===\n'}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '== content to add\n'}]}]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'minor component', '_type': 'AttributeName'}, 'parenthetical': ''}]}
DerivingDict for Part:  Attribute
		Full header is: - embellishment



===
ParsingHeader header: - embellishment

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='embellishment', _type='AttributeName'), 'one_liner': None, 'parenthetical': ''}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - embellishment

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "embellishment",
    "_type": "AttributeName"
  },
  "parenthetical": ""
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'embellishment', '_type': 'AttributeName'}, 'parenthetical': ''} into {'_type': 'Document', 'literate_models': [{'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Annotation Types Used', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'These are the recognized Annotation Types for the LDM model.\n'}, {'_type': 'Paragraph', 'content': 'And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.\n'}, {'_type': 'CodeBlock', 'content': '```typescript\ninterface AnnotationType {\nlabel: string;\nemoji: string;\nemojiName: string;\nemojiUnicode: string;\npurpose: string;\n}\n// LINK: LiterateDataModel.annotationTypes\nconst annotationTypes: AnnotationType[] = [\n{\nlabel: "Error",\nemoji: "",\nemojiName: "cross_mark",\nemojiUnicode: "U+274C",\npurpose: "Indicates a critical error or failure in the model."\n},\n{\nlabel: "Warning",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Indicates a potential issue or warning in the model."\n},\n{\nlabel: "Note",\nemoji: "",\nemojiName: "blue_book",\nemojiUnicode: "U+1F4D8",\npurpose: "Provides additional context, explanations, or clarifications for the annotated element."\n},\n{\nlabel: "Issue",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Highlights a potential issue or error that needs to be addressed or resolved."\n},\n{\nlabel: "Question",\nemoji: "",\nemojiName: "question",\nemojiUnicode: "U+2753",\npurpose: "Raises a question or seeks further clarification about the annotated element."\n},\n{\nlabel: "Suggestion",\nemoji: "",\nemojiName: "bulb",\nemojiUnicode: "U+1F4A1",\npurpose: "Provides a suggestion or recommendation for improving the model or the annotated element."\n},\n{\nlabel: "Info",\nemoji: "",\nemojiName: "information_source",\nemojiUnicode: "U+2139",\npurpose: "Offers relevant information, facts, or details about the annotated element."\n},\n{\nlabel: "Todo",\nemoji: "",\nemojiName: "pushpin",\nemojiUnicode: "U+1F4CC",\npurpose: "Indicates a pending task, action item, or future work related to the annotated element."\n},\n{\nlabel: "Reference",\nemoji: "",\nemojiName: "globe_with_meridians",\nemojiUnicode: "U+1F310",\npurpose: "Provides a reference or link to an external resource or documentation."\n},\n{\nlabel: "See",\nemoji: "",\nemojiName: "mag",\nemojiUnicode: "U+1F50D",\npurpose: "Indicates a cross-reference to another relevant element within the model."\n}\n];\n```'}, {'_type': 'Paragraph', 'content': '===\n'}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '== content to add\n'}]}]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'minor component', '_type': 'AttributeName'}, 'parenthetical': ''}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'embellishment', '_type': 'AttributeName'}, 'parenthetical': ''} to attributes
after absorb, dict has:  {'_type': 'Document', 'literate_models': [{'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Annotation Types Used', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'These are the recognized Annotation Types for the LDM model.\n'}, {'_type': 'Paragraph', 'content': 'And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.\n'}, {'_type': 'CodeBlock', 'content': '```typescript\ninterface AnnotationType {\nlabel: string;\nemoji: string;\nemojiName: string;\nemojiUnicode: string;\npurpose: string;\n}\n// LINK: LiterateDataModel.annotationTypes\nconst annotationTypes: AnnotationType[] = [\n{\nlabel: "Error",\nemoji: "",\nemojiName: "cross_mark",\nemojiUnicode: "U+274C",\npurpose: "Indicates a critical error or failure in the model."\n},\n{\nlabel: "Warning",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Indicates a potential issue or warning in the model."\n},\n{\nlabel: "Note",\nemoji: "",\nemojiName: "blue_book",\nemojiUnicode: "U+1F4D8",\npurpose: "Provides additional context, explanations, or clarifications for the annotated element."\n},\n{\nlabel: "Issue",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Highlights a potential issue or error that needs to be addressed or resolved."\n},\n{\nlabel: "Question",\nemoji: "",\nemojiName: "question",\nemojiUnicode: "U+2753",\npurpose: "Raises a question or seeks further clarification about the annotated element."\n},\n{\nlabel: "Suggestion",\nemoji: "",\nemojiName: "bulb",\nemojiUnicode: "U+1F4A1",\npurpose: "Provides a suggestion or recommendation for improving the model or the annotated element."\n},\n{\nlabel: "Info",\nemoji: "",\nemojiName: "information_source",\nemojiUnicode: "U+2139",\npurpose: "Offers relevant information, facts, or details about the annotated element."\n},\n{\nlabel: "Todo",\nemoji: "",\nemojiName: "pushpin",\nemojiUnicode: "U+1F4CC",\npurpose: "Indicates a pending task, action item, or future work related to the annotated element."\n},\n{\nlabel: "Reference",\nemoji: "",\nemojiName: "globe_with_meridians",\nemojiUnicode: "U+1F310",\npurpose: "Provides a reference or link to an external resource or documentation."\n},\n{\nlabel: "See",\nemoji: "",\nemojiName: "mag",\nemojiUnicode: "U+1F50D",\npurpose: "Indicates a cross-reference to another relevant element within the model."\n}\n];\n```'}, {'_type': 'Paragraph', 'content': '===\n'}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '== content to add\n'}]}]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'minor component', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'embellishment', '_type': 'AttributeName'}, 'parenthetical': ''}]}
DerivingDict for Part:  Attribute
		Full header is: - words and phrases



===
ParsingHeader header: - words and phrases

ParsingHeader result: {'prefix': '-', 'name': AttributeName(content='words and phrases', _type='AttributeName'), 'one_liner': None, 'parenthetical': ''}
===

Re-display for Part:  Attribute
. Attribute - <class 'dull_dsl.dull_parser_core.DocPart'> 
_ _ Attribute_Head: - words and phrases

DerivedDict for Part:  Attribute
{
  "_type": "Attribute",
  "prefix": "-",
  "name": {
    "content": "words and phrases",
    "_type": "AttributeName"
  },
  "parenthetical": ""
}
Absorbing to attributes {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'words and phrases', '_type': 'AttributeName'}, 'parenthetical': ''} into {'_type': 'Document', 'literate_models': [{'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Annotation Types Used', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'These are the recognized Annotation Types for the LDM model.\n'}, {'_type': 'Paragraph', 'content': 'And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.\n'}, {'_type': 'CodeBlock', 'content': '```typescript\ninterface AnnotationType {\nlabel: string;\nemoji: string;\nemojiName: string;\nemojiUnicode: string;\npurpose: string;\n}\n// LINK: LiterateDataModel.annotationTypes\nconst annotationTypes: AnnotationType[] = [\n{\nlabel: "Error",\nemoji: "",\nemojiName: "cross_mark",\nemojiUnicode: "U+274C",\npurpose: "Indicates a critical error or failure in the model."\n},\n{\nlabel: "Warning",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Indicates a potential issue or warning in the model."\n},\n{\nlabel: "Note",\nemoji: "",\nemojiName: "blue_book",\nemojiUnicode: "U+1F4D8",\npurpose: "Provides additional context, explanations, or clarifications for the annotated element."\n},\n{\nlabel: "Issue",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Highlights a potential issue or error that needs to be addressed or resolved."\n},\n{\nlabel: "Question",\nemoji: "",\nemojiName: "question",\nemojiUnicode: "U+2753",\npurpose: "Raises a question or seeks further clarification about the annotated element."\n},\n{\nlabel: "Suggestion",\nemoji: "",\nemojiName: "bulb",\nemojiUnicode: "U+1F4A1",\npurpose: "Provides a suggestion or recommendation for improving the model or the annotated element."\n},\n{\nlabel: "Info",\nemoji: "",\nemojiName: "information_source",\nemojiUnicode: "U+2139",\npurpose: "Offers relevant information, facts, or details about the annotated element."\n},\n{\nlabel: "Todo",\nemoji: "",\nemojiName: "pushpin",\nemojiUnicode: "U+1F4CC",\npurpose: "Indicates a pending task, action item, or future work related to the annotated element."\n},\n{\nlabel: "Reference",\nemoji: "",\nemojiName: "globe_with_meridians",\nemojiUnicode: "U+1F310",\npurpose: "Provides a reference or link to an external resource or documentation."\n},\n{\nlabel: "See",\nemoji: "",\nemojiName: "mag",\nemojiUnicode: "U+1F50D",\npurpose: "Indicates a cross-reference to another relevant element within the model."\n}\n];\n```'}, {'_type': 'Paragraph', 'content': '===\n'}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '== content to add\n'}]}]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'minor component', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'embellishment', '_type': 'AttributeName'}, 'parenthetical': ''}]}
Append {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'words and phrases', '_type': 'AttributeName'}, 'parenthetical': ''} to attributes
after absorb, dict has:  {'_type': 'Document', 'literate_models': [{'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Annotation Types Used', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'These are the recognized Annotation Types for the LDM model.\n'}, {'_type': 'Paragraph', 'content': 'And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.\n'}, {'_type': 'CodeBlock', 'content': '```typescript\ninterface AnnotationType {\nlabel: string;\nemoji: string;\nemojiName: string;\nemojiUnicode: string;\npurpose: string;\n}\n// LINK: LiterateDataModel.annotationTypes\nconst annotationTypes: AnnotationType[] = [\n{\nlabel: "Error",\nemoji: "",\nemojiName: "cross_mark",\nemojiUnicode: "U+274C",\npurpose: "Indicates a critical error or failure in the model."\n},\n{\nlabel: "Warning",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Indicates a potential issue or warning in the model."\n},\n{\nlabel: "Note",\nemoji: "",\nemojiName: "blue_book",\nemojiUnicode: "U+1F4D8",\npurpose: "Provides additional context, explanations, or clarifications for the annotated element."\n},\n{\nlabel: "Issue",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Highlights a potential issue or error that needs to be addressed or resolved."\n},\n{\nlabel: "Question",\nemoji: "",\nemojiName: "question",\nemojiUnicode: "U+2753",\npurpose: "Raises a question or seeks further clarification about the annotated element."\n},\n{\nlabel: "Suggestion",\nemoji: "",\nemojiName: "bulb",\nemojiUnicode: "U+1F4A1",\npurpose: "Provides a suggestion or recommendation for improving the model or the annotated element."\n},\n{\nlabel: "Info",\nemoji: "",\nemojiName: "information_source",\nemojiUnicode: "U+2139",\npurpose: "Offers relevant information, facts, or details about the annotated element."\n},\n{\nlabel: "Todo",\nemoji: "",\nemojiName: "pushpin",\nemojiUnicode: "U+1F4CC",\npurpose: "Indicates a pending task, action item, or future work related to the annotated element."\n},\n{\nlabel: "Reference",\nemoji: "",\nemojiName: "globe_with_meridians",\nemojiUnicode: "U+1F310",\npurpose: "Provides a reference or link to an external resource or documentation."\n},\n{\nlabel: "See",\nemoji: "",\nemojiName: "mag",\nemojiUnicode: "U+1F50D",\npurpose: "Indicates a cross-reference to another relevant element within the model."\n}\n];\n```'}, {'_type': 'Paragraph', 'content': '===\n'}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '== content to add\n'}]}]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'minor component', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'embellishment', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'words and phrases', '_type': 'AttributeName'}, 'parenthetical': ''}]}
{'_type': 'Document', 'literate_models': [{'_type': 'LiterateModel', 'prefix': '#', 'name': {'content': 'Literate Data Model', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Preliminaries', '_type': 'SubjectName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the basic structure\nof the model'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.\n'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'The Model and its Subjects', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Classes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Attributes', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Methods', '_type': 'SubjectName'}, 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Low level Data Types', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md\n'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]}, {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': {'content': 'Annotation Types Used', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'These are the recognized Annotation Types for the LDM model.\n'}, {'_type': 'Paragraph', 'content': 'And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.\n'}, {'_type': 'CodeBlock', 'content': '```typescript\ninterface AnnotationType {\nlabel: string;\nemoji: string;\nemojiName: string;\nemojiUnicode: string;\npurpose: string;\n}\n// LINK: LiterateDataModel.annotationTypes\nconst annotationTypes: AnnotationType[] = [\n{\nlabel: "Error",\nemoji: "",\nemojiName: "cross_mark",\nemojiUnicode: "U+274C",\npurpose: "Indicates a critical error or failure in the model."\n},\n{\nlabel: "Warning",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Indicates a potential issue or warning in the model."\n},\n{\nlabel: "Note",\nemoji: "",\nemojiName: "blue_book",\nemojiUnicode: "U+1F4D8",\npurpose: "Provides additional context, explanations, or clarifications for the annotated element."\n},\n{\nlabel: "Issue",\nemoji: "",\nemojiName: "warning",\nemojiUnicode: "U+26A0",\npurpose: "Highlights a potential issue or error that needs to be addressed or resolved."\n},\n{\nlabel: "Question",\nemoji: "",\nemojiName: "question",\nemojiUnicode: "U+2753",\npurpose: "Raises a question or seeks further clarification about the annotated element."\n},\n{\nlabel: "Suggestion",\nemoji: "",\nemojiName: "bulb",\nemojiUnicode: "U+1F4A1",\npurpose: "Provides a suggestion or recommendation for improving the model or the annotated element."\n},\n{\nlabel: "Info",\nemoji: "",\nemojiName: "information_source",\nemojiUnicode: "U+2139",\npurpose: "Offers relevant information, facts, or details about the annotated element."\n},\n{\nlabel: "Todo",\nemoji: "",\nemojiName: "pushpin",\nemojiUnicode: "U+1F4CC",\npurpose: "Indicates a pending task, action item, or future work related to the annotated element."\n},\n{\nlabel: "Reference",\nemoji: "",\nemojiName: "globe_with_meridians",\nemojiUnicode: "U+1F310",\npurpose: "Provides a reference or link to an external resource or documentation."\n},\n{\nlabel: "See",\nemoji: "",\nemojiName: "mag",\nemojiUnicode: "U+1F50D",\npurpose: "Indicates a cross-reference to another relevant element within the model."\n}\n];\n```'}, {'_type': 'Paragraph', 'content': '===\n'}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '== content to add\n'}]}]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'minor component', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'embellishment', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'words and phrases', '_type': 'AttributeName'}, 'parenthetical': ''}]}
.. dict saved  in ldm/ldm_models/Literate_results/Literate.dict.yaml and ldm/ldm_models/Literate_results/Literate.dict.json
Building class map for module: ldm.Literate_01
Class map is
{   'Annotation': <class 'ldm.Literate_01.Annotation'>,
    'AsValue': <class 'class_pom_token.AsValue'>,
    'Attribute': <class 'ldm.Literate_01.Attribute'>,
    'AttributeName': <class 'ldm.Literate_01.AttributeName'>,
    'AttributeReference': <class 'ldm.Literate_01.AttributeReference'>,
    'AttributeSection': <class 'ldm.Literate_01.AttributeSection'>,
    'AttributeSectionName': <class 'ldm.Literate_01.AttributeSectionName'>,
    'BaseDataType': <class 'ldm.Literate_01.BaseDataType'>,
    'CamelCase': <class 'class_casing.CamelCase'>,
    'Class': <class 'ldm.Literate_01.Class'>,
    'ClassName': <class 'ldm.Literate_01.ClassName'>,
    'Class_': <class 'ldm.Literate_01.Class'>,
    'CodeBlock': <class 'ldm.Literate_01.CodeBlock'>,
    'CodeType': <class 'ldm.Literate_01.CodeType'>,
    'Component': <class 'ldm.Literate_01.Component'>,
    'Constraint': <class 'ldm.Literate_01.Constraint'>,
    'DataType': <class 'ldm.Literate_01.SetDataType'>,
    'DataTypeClause': <class 'ldm.Literate_01.DataTypeClause'>,
    'Default': <class 'ldm.Literate_01.Default'>,
    'Derivation': <class 'ldm.Literate_01.Derivation'>,
    'Diagnostic': <class 'ldm.Literate_01.Diagnostic'>,
    'Emoji': <class 'class_pom_token.Emoji'>,
    'Formula': <class 'ldm.Literate_01.Formula'>,
    'FormulaCoding': <class 'ldm.Literate_01.FormulaCoding'>,
    'IsExclusive': <class 'class_pom_token.IsExclusive'>,
    'IsExhaustive': <class 'class_pom_token.IsExhaustive'>,
    'IsOptional': <class 'class_pom_token.IsOptional'>,
    'Label': <class 'ldm.Literate_01.Label'>,
    'ListDataType': <class 'ldm.Literate_01.ListDataType'>,
    'LiterateModel': <class 'ldm.Literate_01.LiterateModel'>,
    'LowerCamel': <class 'class_casing.LowerCamel'>,
    'MappingDataType': <class 'ldm.Literate_01.MappingDataType'>,
    'MinorComponent': <class 'ldm.Literate_01.MinorComponent'>,
    'Natural': <class 'ldm.Literate_01.OneLiner'>,
    'NormalCase': <class 'class_casing.NormalCase'>,
    'OneLiner': <class 'ldm.Literate_01.OneLiner'>,
    'Paragraph': <class 'ldm.Literate_01.Paragraph'>,
    'PresentableBoolean': <class 'class_pom_token.PresentableBoolean'>,
    'ReferenceType': <class 'ldm.Literate_01.ReferenceType'>,
    'SetDataType': <class 'ldm.Literate_01.SetDataType'>,
    'Subject': <class 'ldm.Literate_01.SubjectB'>,
    'SubjectB': <class 'ldm.Literate_01.SubjectB'>,
    'SubjectC': <class 'ldm.Literate_01.SubjectC'>,
    'SubjectD': <class 'ldm.Literate_01.SubjectD'>,
    'SubjectE': <class 'ldm.Literate_01.SubjectE'>,
    'SubjectName': <class 'ldm.Literate_01.SubjectName'>,
    'Subtyping': <class 'ldm.Literate_01.Subtyping'>,
    'SubtypingName': <class 'ldm.Literate_01.SubtypingName'>,
    'UpperCamel': <class 'class_casing.UpperCamel'>,
    'ValueType': <class 'ldm.Literate_01.ValueType'>}

Phase: Creating model from dictionary: ldm/ldm_models/Literate_results/Literate.dict.yaml
ObjectCreator Creating object of type: LiterateModel - named {'content': 'Literate Data Model', '_type': 'SubjectName'}
ObjectCreator Creating object of type: SubjectName - named Unnamed
ObjectCreator Creating object of type: SubjectB - named {'content': 'Preliminaries', '_type': 'SubjectName'}
ObjectCreator Creating object of type: SubjectName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: Paragraph - named Unnamed
ObjectCreator Creating object of type: Paragraph - named Unnamed
ObjectCreator Creating object of type: Class - named {'content': 'Component', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Component', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An element or building block of the literate data model'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'normalName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the name of the component, not in camel case'}, 'parenthetical': '*String*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The name of the component'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'qualifiedName', '_type': 'AttributeName'}, 'parenthetical': '*QualifiedCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'abbreviatedName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': "a short form of the component's name, used for cross references and improved readability."}, 'parenthetical': '*CamelName*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' name\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'oneLiner', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'}, 'parenthetical': 'RichLine', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'elaboration', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A more detailed explanation or discussion of the component _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'mechanical attributes'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this component is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}]}]}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'normalName', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'name', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'qualifiedName', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'abbreviatedName', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Default - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'oneLiner', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'elaboration', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: AttributeSection - named {'content': 'For Machinery', '_type': 'AttributeSectionName'}
ObjectCreator Creating object of type: AttributeSectionName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'isEmbellishment', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Default - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed
In AttSection post-init for For Machinery, is_optional = None


KWARGS are {'prefix': '_', 'name': ClassName(content='Component', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content='An element or building block of the literate data model'), 'parenthetical': '', 'attributes': [Attribute(one_liner=OneLiner(_type='OneLiner', content='the name of the component, not in camel case'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='normalName', _type='AttributeName'), parenthetical='*String*', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='String', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='The name of the component'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='name', _type='AttributeName'), parenthetical='CamelName', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='CamelName', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='qualifiedName', _type='AttributeName'), parenthetical='*QualifiedCamel*', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='QualifiedCamel', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content="a short form of the component's name, used for cross references and improved readability."), elaboration=[], annotations=[Annotation(label='Example', content='"LDM" is the short form of "Literate Data Model".', emoji='', elaboration=[], _type='Annotation')], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='abbreviatedName', _type='AttributeName'), parenthetical='*CamelName*', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='CamelName', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(_type='OneLiner', content=' name\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Default', english=Paragraph(_type='Paragraph', content=''), code=None), constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='oneLiner', _type='AttributeName'), parenthetical='RichLine', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='RichLine', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='A more detailed explanation or discussion of the component _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='elaboration', _type='AttributeName'), parenthetical='RichText', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='RichText', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])], 'attribute_sections': [AttributeSection(one_liner=OneLiner(_type='OneLiner', content='mechanical attributes'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='AttributeSection', prefix='__', name=AttributeSectionName(content='For Machinery', _type='AttributeSectionName'), parenthetical='', abbreviation=None, is_optional=IsOptional(t_value=False, _type='IsOptional'), attributes=[Attribute(one_liner=OneLiner(_type='OneLiner', content='Indicates whether this component is an embellishment added during post-parsing processing _'), elaboration=[], annotations=[Annotation(label='Note', content='This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.', emoji='', elaboration=[], _type='Annotation')], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='isEmbellishment', _type='AttributeName'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Boolean', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(_type='OneLiner', content=' false\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Default', english=Paragraph(_type='Paragraph', content=''), code=None), constraints=[])])]}
{
  "prefix": "_",
  "name": {
    "content": "Component",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "An element or building block of the literate data model"
  },
  "parenthetical": "",
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the name of the component, not in camel case"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "normalName",
        "_type": "AttributeName"
      },
      "parenthetical": "*String*",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "String",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The name of the component"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "name",
        "_type": "AttributeName"
      },
      "parenthetical": "CamelName",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "CamelName",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "qualifiedName",
        "_type": "AttributeName"
      },
      "parenthetical": "*QualifiedCamel*",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "QualifiedCamel",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "a short form of the component's name, used for cross references and improved readability."
      },
      "annotations": [
        {
          "label": "Example",
          "content": "\"LDM\" is the short form of \"Literate Data Model\".",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "abbreviatedName",
        "_type": "AttributeName"
      },
      "parenthetical": "*CamelName*",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "CamelName",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "default": {
        "one_liner": {
          "_type": "OneLiner",
          "content": " name\n"
        },
        "is_embellishment": false,
        "_type": "Default",
        "english": {
          "_type": "Paragraph",
          "content": ""
        }
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "oneLiner",
        "_type": "AttributeName"
      },
      "parenthetical": "RichLine",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "RichLine",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "A more detailed explanation or discussion of the component _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "elaboration",
        "_type": "AttributeName"
      },
      "parenthetical": "RichText",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "RichText",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ],
  "attribute_sections": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "mechanical attributes"
      },
      "is_embellishment": false,
      "_type": "AttributeSection",
      "prefix": "__",
      "name": {
        "content": "For Machinery",
        "_type": "AttributeSectionName"
      },
      "parenthetical": "",
      "is_optional": {
        "t_value": false,
        "_type": "IsOptional"
      },
      "attributes": [
        {
          "one_liner": {
            "_type": "OneLiner",
            "content": "Indicates whether this component is an embellishment added during post-parsing processing _"
          },
          "annotations": [
            {
              "label": "Note",
              "content": "This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.",
              "emoji": "",
              "_type": "Annotation"
            }
          ],
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "isEmbellishment",
            "_type": "AttributeName"
          },
          "parenthetical": "Boolean",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "Boolean",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": false,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          },
          "default": {
            "one_liner": {
              "_type": "OneLiner",
              "content": " false\n"
            },
            "is_embellishment": false,
            "_type": "Default",
            "english": {
              "_type": "Paragraph",
              "content": ""
            }
          }
        }
      ]
    }
  ]
}
...Createed object of type: Class
... = Class: Component
final object is  {
  "one_liner": {
    "_type": "OneLiner",
    "content": "An element or building block of the literate data model"
  },
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Component",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "is_value_type": false,
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the name of the component, not in camel case"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "normalName",
        "_type": "AttributeName"
      },
      "parenthetical": "*String*",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "String",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The name of the component"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "name",
        "_type": "AttributeName"
      },
      "parenthetical": "CamelName",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "CamelName",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "qualifiedName",
        "_type": "AttributeName"
      },
      "parenthetical": "*QualifiedCamel*",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "QualifiedCamel",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "a short form of the component's name, used for cross references and improved readability."
      },
      "annotations": [
        {
          "label": "Example",
          "content": "\"LDM\" is the short form of \"Literate Data Model\".",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "abbreviatedName",
        "_type": "AttributeName"
      },
      "parenthetical": "*CamelName*",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "CamelName",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "default": {
        "one_liner": {
          "_type": "OneLiner",
          "content": " name\n"
        },
        "is_embellishment": false,
        "_type": "Default",
        "english": {
          "_type": "Paragraph",
          "content": ""
        }
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "oneLiner",
        "_type": "AttributeName"
      },
      "parenthetical": "RichLine",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "RichLine",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "A more detailed explanation or discussion of the component _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "elaboration",
        "_type": "AttributeName"
      },
      "parenthetical": "RichText",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "RichText",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ],
  "attribute_sections": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "mechanical attributes"
      },
      "is_embellishment": false,
      "_type": "AttributeSection",
      "prefix": "__",
      "name": {
        "content": "For Machinery",
        "_type": "AttributeSectionName"
      },
      "parenthetical": "",
      "is_optional": {
        "t_value": false,
        "_type": "IsOptional"
      },
      "attributes": [
        {
          "one_liner": {
            "_type": "OneLiner",
            "content": "Indicates whether this component is an embellishment added during post-parsing processing _"
          },
          "annotations": [
            {
              "label": "Note",
              "content": "This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.",
              "emoji": "",
              "_type": "Annotation"
            }
          ],
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "isEmbellishment",
            "_type": "AttributeName"
          },
          "parenthetical": "Boolean",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "Boolean",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": false,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          },
          "default": {
            "one_liner": {
              "_type": "OneLiner",
              "content": " false\n"
            },
            "is_embellishment": false,
            "_type": "Default",
            "english": {
              "_type": "Paragraph",
              "content": ""
            }
          }
        }
      ]
    }
  ]
}
ObjectCreator Creating object of type: Class - named {'content': 'AnnotationType', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'AnnotationType', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a kind of note, or aside, used to call attention to additional information about some Component.'}, 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emoji', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiName', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an emoji'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'emojiUnicode', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Unicode for the emoji'}, 'parenthetical': 'Unicode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'plural', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the plural form of the label'}, 'parenthetical': '*UpperCamel*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' based on label\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Purpose', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the intended reason for the annotation.'}, 'parenthetical': ''}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'emoji', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'emojiName', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'emojiUnicode', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'label', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'plural', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Default - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'Purpose', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='AnnotationType', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content='a kind of note, or aside, used to call attention to additional information about some Component.'), 'parenthetical': '', 'based_on': [ClassName(content='Literate Data Model', _type='ClassName')], 'annotations': [Annotation(label='Note', content='Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.', emoji='', elaboration=[], _type='Annotation')], 'attributes': [Attribute(one_liner=OneLiner(_type='OneLiner', content='an emoji'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='emoji', _type='AttributeName'), parenthetical='Emoji', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Emoji', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='an emoji'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='emojiName', _type='AttributeName'), parenthetical='String', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='String', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='the Unicode for the emoji'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='emojiUnicode', _type='AttributeName'), parenthetical='Unicode', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Unicode', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='A short label to indicate the purpose of the annotation _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='label', _type='AttributeName'), parenthetical='CamelName', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='CamelName', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='the plural form of the label'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='plural', _type='AttributeName'), parenthetical='*UpperCamel*', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='UpperCamel', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(_type='OneLiner', content=' based on label\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Default', english=Paragraph(_type='Paragraph', content=''), code=None), constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='the intended reason for the annotation.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='Purpose', _type='AttributeName'), parenthetical='', abbreviation=None, data_type_clause=None, overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])]}
{
  "prefix": "_",
  "name": {
    "content": "AnnotationType",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "a kind of note, or aside, used to call attention to additional information about some Component."
  },
  "parenthetical": "",
  "based_on": [
    {
      "content": "Literate Data Model",
      "_type": "ClassName"
    }
  ],
  "annotations": [
    {
      "label": "Note",
      "content": "Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.",
      "emoji": "",
      "_type": "Annotation"
    }
  ],
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "an emoji"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "emoji",
        "_type": "AttributeName"
      },
      "parenthetical": "Emoji",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Emoji",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "an emoji"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "emojiName",
        "_type": "AttributeName"
      },
      "parenthetical": "String",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "String",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the Unicode for the emoji"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "emojiUnicode",
        "_type": "AttributeName"
      },
      "parenthetical": "Unicode",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Unicode",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "A short label to indicate the purpose of the annotation _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "label",
        "_type": "AttributeName"
      },
      "parenthetical": "CamelName",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "CamelName",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the plural form of the label"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "plural",
        "_type": "AttributeName"
      },
      "parenthetical": "*UpperCamel*",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "UpperCamel",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "default": {
        "one_liner": {
          "_type": "OneLiner",
          "content": " based on label\n"
        },
        "is_embellishment": false,
        "_type": "Default",
        "english": {
          "_type": "Paragraph",
          "content": ""
        }
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the intended reason for the annotation."
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "Purpose",
        "_type": "AttributeName"
      },
      "parenthetical": ""
    }
  ]
}
...Createed object of type: Class
... = Class: AnnotationType
final object is  {
  "one_liner": {
    "_type": "OneLiner",
    "content": "a kind of note, or aside, used to call attention to additional information about some Component."
  },
  "annotations": [
    {
      "label": "Note",
      "content": "Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.",
      "emoji": "",
      "_type": "Annotation"
    }
  ],
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "AnnotationType",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "based_on": [
    {
      "content": "Literate Data Model",
      "_type": "ClassName"
    }
  ],
  "is_value_type": false,
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "an emoji"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "emoji",
        "_type": "AttributeName"
      },
      "parenthetical": "Emoji",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Emoji",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "an emoji"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "emojiName",
        "_type": "AttributeName"
      },
      "parenthetical": "String",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "String",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the Unicode for the emoji"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "emojiUnicode",
        "_type": "AttributeName"
      },
      "parenthetical": "Unicode",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Unicode",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "A short label to indicate the purpose of the annotation _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "label",
        "_type": "AttributeName"
      },
      "parenthetical": "CamelName",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "CamelName",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the plural form of the label"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "plural",
        "_type": "AttributeName"
      },
      "parenthetical": "*UpperCamel*",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "UpperCamel",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "default": {
        "one_liner": {
          "_type": "OneLiner",
          "content": " based on label\n"
        },
        "is_embellishment": false,
        "_type": "Default",
        "english": {
          "_type": "Paragraph",
          "content": ""
        }
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the intended reason for the annotation."
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "Purpose",
        "_type": "AttributeName"
      },
      "parenthetical": ""
    }
  ]
}
ObjectCreator Creating object of type: Class - named {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'}, 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationType', '_type': 'AttributeName'}, 'parenthetical': 'optional Annotation Type', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'label', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short label to indicate the purpose of the annotation _'}, 'parenthetical': 'CamelName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.\n'}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotationType\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Emoji', '_type': 'AttributeName'}, 'parenthetical': 'optional Emoji', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' from annotation type\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'content', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The content or body of the annotation'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'For Machinery', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isEmbellishment', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether this annotation is an embellishment added during post-parsing processing _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' false\n')}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'annotationType', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'label', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Paragraph - named Unnamed
ObjectCreator Creating object of type: Default - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'Emoji', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Default - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'content', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: AttributeSection - named {'content': 'For Machinery', '_type': 'AttributeSectionName'}
ObjectCreator Creating object of type: AttributeSectionName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'isEmbellishment', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Default - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed
In AttSection post-init for For Machinery, is_optional = None


KWARGS are {'prefix': '_', 'name': ClassName(content='ValueType Annotation\nA note or comment associated with a model element', _type='ClassName'), 'parenthetical': '', 'based_on': [ClassName(content='Component', _type='ClassName')], 'attributes': [Attribute(one_liner=None, elaboration=[], annotations=[Annotation(label='Note', content='An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.', emoji='', elaboration=[], _type='Annotation')], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='annotationType', _type='AttributeName'), parenthetical='optional Annotation Type', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Annotation Type', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='A short label to indicate the purpose of the annotation _'), elaboration=[Paragraph(_type='Paragraph', content='But any short label is valid.\n')], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='label', _type='AttributeName'), parenthetical='CamelName', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='CamelName', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(_type='OneLiner', content=' from annotationType\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Default', english=Paragraph(_type='Paragraph', content=''), code=None), constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='Emoji', _type='AttributeName'), parenthetical='optional Emoji', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Emoji', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(_type='OneLiner', content=' from annotation type\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Default', english=Paragraph(_type='Paragraph', content=''), code=None), constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='The content or body of the annotation'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='content', _type='AttributeName'), parenthetical='*RichText*', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='RichText', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])], 'attribute_sections': [AttributeSection(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='AttributeSection', prefix='__', name=AttributeSectionName(content='For Machinery', _type='AttributeSectionName'), parenthetical='', abbreviation=None, is_optional=IsOptional(t_value=False, _type='IsOptional'), attributes=[Attribute(one_liner=OneLiner(_type='OneLiner', content='Indicates whether this annotation is an embellishment added during post-parsing processing _'), elaboration=[], annotations=[Annotation(label='Note', content='This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.', emoji='', elaboration=[], _type='Annotation')], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='isEmbellishment', _type='AttributeName'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Boolean', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(_type='OneLiner', content=' false\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Default', english=Paragraph(_type='Paragraph', content=''), code=None), constraints=[])])]}
{
  "prefix": "_",
  "name": {
    "content": "ValueType Annotation\nA note or comment associated with a model element",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "based_on": [
    {
      "content": "Component",
      "_type": "ClassName"
    }
  ],
  "attributes": [
    {
      "annotations": [
        {
          "label": "Note",
          "content": "An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "annotationType",
        "_type": "AttributeName"
      },
      "parenthetical": "optional Annotation Type",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Annotation Type",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "A short label to indicate the purpose of the annotation _"
      },
      "elaboration": [
        {
          "_type": "Paragraph",
          "content": "But any short label is valid.\n"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "label",
        "_type": "AttributeName"
      },
      "parenthetical": "CamelName",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "CamelName",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "default": {
        "one_liner": {
          "_type": "OneLiner",
          "content": " from annotationType\n"
        },
        "is_embellishment": false,
        "_type": "Default",
        "english": {
          "_type": "Paragraph",
          "content": ""
        }
      }
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "Emoji",
        "_type": "AttributeName"
      },
      "parenthetical": "optional Emoji",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Emoji",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "default": {
        "one_liner": {
          "_type": "OneLiner",
          "content": " from annotation type\n"
        },
        "is_embellishment": false,
        "_type": "Default",
        "english": {
          "_type": "Paragraph",
          "content": ""
        }
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The content or body of the annotation"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "content",
        "_type": "AttributeName"
      },
      "parenthetical": "*RichText*",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "RichText",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ],
  "attribute_sections": [
    {
      "is_embellishment": false,
      "_type": "AttributeSection",
      "prefix": "__",
      "name": {
        "content": "For Machinery",
        "_type": "AttributeSectionName"
      },
      "parenthetical": "",
      "is_optional": {
        "t_value": false,
        "_type": "IsOptional"
      },
      "attributes": [
        {
          "one_liner": {
            "_type": "OneLiner",
            "content": "Indicates whether this annotation is an embellishment added during post-parsing processing _"
          },
          "annotations": [
            {
              "label": "Note",
              "content": "This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.",
              "emoji": "",
              "_type": "Annotation"
            }
          ],
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "isEmbellishment",
            "_type": "AttributeName"
          },
          "parenthetical": "Boolean",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "Boolean",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": false,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          },
          "default": {
            "one_liner": {
              "_type": "OneLiner",
              "content": " false\n"
            },
            "is_embellishment": false,
            "_type": "Default",
            "english": {
              "_type": "Paragraph",
              "content": ""
            }
          }
        }
      ]
    }
  ]
}
...Createed object of type: Class
... = Class: ValueType Annotation
A note or comment associated with a model element
final object is  {
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "ValueType Annotation\nA note or comment associated with a model element",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "based_on": [
    {
      "content": "Component",
      "_type": "ClassName"
    }
  ],
  "is_value_type": false,
  "attributes": [
    {
      "annotations": [
        {
          "label": "Note",
          "content": "An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "annotationType",
        "_type": "AttributeName"
      },
      "parenthetical": "optional Annotation Type",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Annotation Type",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "A short label to indicate the purpose of the annotation _"
      },
      "elaboration": [
        {
          "_type": "Paragraph",
          "content": "But any short label is valid.\n"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "label",
        "_type": "AttributeName"
      },
      "parenthetical": "CamelName",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "CamelName",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "default": {
        "one_liner": {
          "_type": "OneLiner",
          "content": " from annotationType\n"
        },
        "is_embellishment": false,
        "_type": "Default",
        "english": {
          "_type": "Paragraph",
          "content": ""
        }
      }
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "Emoji",
        "_type": "AttributeName"
      },
      "parenthetical": "optional Emoji",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Emoji",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "default": {
        "one_liner": {
          "_type": "OneLiner",
          "content": " from annotation type\n"
        },
        "is_embellishment": false,
        "_type": "Default",
        "english": {
          "_type": "Paragraph",
          "content": ""
        }
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The content or body of the annotation"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "content",
        "_type": "AttributeName"
      },
      "parenthetical": "*RichText*",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "RichText",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ],
  "attribute_sections": [
    {
      "is_embellishment": false,
      "_type": "AttributeSection",
      "prefix": "__",
      "name": {
        "content": "For Machinery",
        "_type": "AttributeSectionName"
      },
      "parenthetical": "",
      "is_optional": {
        "t_value": false,
        "_type": "IsOptional"
      },
      "attributes": [
        {
          "one_liner": {
            "_type": "OneLiner",
            "content": "Indicates whether this annotation is an embellishment added during post-parsing processing _"
          },
          "annotations": [
            {
              "label": "Note",
              "content": "This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.",
              "emoji": "",
              "_type": "Annotation"
            }
          ],
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "isEmbellishment",
            "_type": "AttributeName"
          },
          "parenthetical": "Boolean",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "Boolean",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": false,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          },
          "default": {
            "one_liner": {
              "_type": "OneLiner",
              "content": " false\n"
            },
            "is_embellishment": false,
            "_type": "Default",
            "english": {
              "_type": "Paragraph",
              "content": ""
            }
          }
        }
      ]
    }
  ]
}
ObjectCreator Creating object of type: SubjectB - named {'content': 'The Model and its Subjects', '_type': 'SubjectName'}
ObjectCreator Creating object of type: SubjectName - named Unnamed
ObjectCreator Creating object of type: Class - named {'content': 'LiterateDataModel', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LiterateDataModel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"}, 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the\ndefinition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'allClasses', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'list of all classes in the model, as ordered in the definition of the model.'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n')}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')]}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'annotationTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of AnnotationTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Coding Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Coding Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' OCL\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Coding Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Coding Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Preferred Template Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the recommended lanquage  for expressing derivation, defaults, and constraints'}, 'parenthetical': 'Template Language', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' Handlebars\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'alternate Template Languages', '_type': 'AttributeName'}, 'parenthetical': 'optional List of Template Languages', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aiFunctions', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A list of functions that require sophisticated AI-powered implementation *'}, 'parenthetical': 'List of String', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n")}}]}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'name', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'allSubjects', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: ListDataType - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Derivation - named Unnamed
ObjectCreator Creating object of type: Constraint - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'allClasses', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: ListDataType - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Derivation - named Unnamed
ObjectCreator Creating object of type: Constraint - named Unnamed
ObjectCreator Creating object of type: AttributeSection - named {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'}
ObjectCreator Creating object of type: AttributeSectionName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'annotationTypes', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: ListDataType - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'Preferred Coding Language', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Default - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'alternate Coding Languages', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: ListDataType - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'Preferred Template Language', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Default - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'alternate Template Languages', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: ListDataType - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'aiFunctions', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: ListDataType - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Derivation - named Unnamed
In AttSection post-init for Modeling Configuration, is_optional = None


KWARGS are {'prefix': '_', 'name': ClassName(content='LiterateDataModel', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content="A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"), 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='name', _type='AttributeName'), parenthetical='UpperCamel', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='UpperCamel', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='list of all classes in the model, as ordered in the\ndefinition of the model.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='allSubjects', _type='AttributeName'), parenthetical='List of Classes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Classes', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=Derivation(one_liner=OneLiner(_type='OneLiner', content=' gathering s.allSubjects over s in subjectAreas\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Derivation', english=Paragraph(_type='Paragraph', content=''), code=None), default=None, constraints=[Constraint(one_liner=[OneLiner(_type='OneLiner', content=' Subject names must be unique across the model.\n')], elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Constraint', english=Paragraph(_type='Paragraph', content=''), code=None, message=Paragraph(_type='Paragraph', content=''), severity=None)]), Attribute(one_liner=OneLiner(_type='OneLiner', content='list of all classes in the model, as ordered in the definition of the model.'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='allClasses', _type='AttributeName'), parenthetical='List of Classes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Classes', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=Derivation(one_liner=OneLiner(_type='OneLiner', content=' gathering s.allClasses over s in allSubjects.\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Derivation', english=Paragraph(_type='Paragraph', content=''), code=None), default=None, constraints=[Constraint(one_liner=[OneLiner(_type='OneLiner', content=' Class names must be unique across the model.\n')], elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Constraint', english=Paragraph(_type='Paragraph', content=''), code=None, message=Paragraph(_type='Paragraph', content=''), severity=None)])], 'attribute_sections': [AttributeSection(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='AttributeSection', prefix='__', name=AttributeSectionName(content='Modeling Configuration', _type='AttributeSectionName'), parenthetical='', abbreviation=None, is_optional=IsOptional(t_value=False, _type='IsOptional'), attributes=[Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='annotationTypes', _type='AttributeName'), parenthetical='List of AnnotationTypes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='AnnotationTypes', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='the recommended lanquage  for expressing derivation, defaults, and constraints'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='Preferred Coding Language', _type='AttributeName'), parenthetical='Coding Language', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Coding Language', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(_type='OneLiner', content=' OCL\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Default', english=Paragraph(_type='Paragraph', content=''), code=None), constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='alternate Coding Languages', _type='AttributeName'), parenthetical='optional List of Coding Languages', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Coding Languages', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='the recommended lanquage  for expressing derivation, defaults, and constraints'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='Preferred Template Language', _type='AttributeName'), parenthetical='Template Language', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Template Language', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(_type='OneLiner', content=' Handlebars\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Default', english=Paragraph(_type='Paragraph', content=''), code=None), constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='alternate Template Languages', _type='AttributeName'), parenthetical='optional List of Template Languages', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Template Languages', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='A list of functions that require sophisticated AI-powered implementation *'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='aiFunctions', _type='AttributeName'), parenthetical='List of String', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='String', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=Derivation(one_liner=OneLiner(_type='OneLiner', content=" ['aiEnglishPlural()']\n"), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Derivation', english=Paragraph(_type='Paragraph', content=''), code=None), default=None, constraints=[])])]}
{
  "prefix": "_",
  "name": {
    "content": "LiterateDataModel",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"
  },
  "parenthetical": "",
  "abbreviation": "LDM",
  "plural": " LiterateDataModels\n",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "attributes": [
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "name",
        "_type": "AttributeName"
      },
      "parenthetical": "UpperCamel",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "UpperCamel",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "list of all classes in the model, as ordered in the\ndefinition of the model."
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "allSubjects",
        "_type": "AttributeName"
      },
      "parenthetical": "List of Classes",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Classes",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "derivation": {
        "one_liner": {
          "_type": "OneLiner",
          "content": " gathering s.allSubjects over s in subjectAreas\n"
        },
        "is_embellishment": false,
        "_type": "Derivation",
        "english": {
          "_type": "Paragraph",
          "content": ""
        }
      },
      "constraints": [
        {
          "one_liner": [
            {
              "_type": "OneLiner",
              "content": " Subject names must be unique across the model.\n"
            }
          ],
          "is_embellishment": false,
          "_type": "Constraint",
          "english": {
            "_type": "Paragraph",
            "content": ""
          },
          "message": {
            "_type": "Paragraph",
            "content": ""
          }
        }
      ]
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "list of all classes in the model, as ordered in the definition of the model."
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "allClasses",
        "_type": "AttributeName"
      },
      "parenthetical": "List of Classes",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Classes",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "derivation": {
        "one_liner": {
          "_type": "OneLiner",
          "content": " gathering s.allClasses over s in allSubjects.\n"
        },
        "is_embellishment": false,
        "_type": "Derivation",
        "english": {
          "_type": "Paragraph",
          "content": ""
        }
      },
      "constraints": [
        {
          "one_liner": [
            {
              "_type": "OneLiner",
              "content": " Class names must be unique across the model.\n"
            }
          ],
          "is_embellishment": false,
          "_type": "Constraint",
          "english": {
            "_type": "Paragraph",
            "content": ""
          },
          "message": {
            "_type": "Paragraph",
            "content": ""
          }
        }
      ]
    }
  ],
  "attribute_sections": [
    {
      "is_embellishment": false,
      "_type": "AttributeSection",
      "prefix": "__",
      "name": {
        "content": "Modeling Configuration",
        "_type": "AttributeSectionName"
      },
      "parenthetical": "",
      "is_optional": {
        "t_value": false,
        "_type": "IsOptional"
      },
      "attributes": [
        {
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "annotationTypes",
            "_type": "AttributeName"
          },
          "parenthetical": "List of AnnotationTypes",
          "data_type_clause": {
            "data_type": {
              "_type": "ListDataType",
              "element_type": {
                "_type": "BaseDataType",
                "class_name": {
                  "content": "AnnotationTypes",
                  "_type": "ClassName"
                },
                "as_value_type": {
                  "t_value": false,
                  "_type": "AsValue"
                }
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          }
        },
        {
          "one_liner": {
            "_type": "OneLiner",
            "content": "the recommended lanquage  for expressing derivation, defaults, and constraints"
          },
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "Preferred Coding Language",
            "_type": "AttributeName"
          },
          "parenthetical": "Coding Language",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "Coding Language",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": false,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          },
          "default": {
            "one_liner": {
              "_type": "OneLiner",
              "content": " OCL\n"
            },
            "is_embellishment": false,
            "_type": "Default",
            "english": {
              "_type": "Paragraph",
              "content": ""
            }
          }
        },
        {
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "alternate Coding Languages",
            "_type": "AttributeName"
          },
          "parenthetical": "optional List of Coding Languages",
          "data_type_clause": {
            "data_type": {
              "_type": "ListDataType",
              "element_type": {
                "_type": "BaseDataType",
                "class_name": {
                  "content": "Coding Languages",
                  "_type": "ClassName"
                },
                "as_value_type": {
                  "t_value": false,
                  "_type": "AsValue"
                }
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          }
        },
        {
          "one_liner": {
            "_type": "OneLiner",
            "content": "the recommended lanquage  for expressing derivation, defaults, and constraints"
          },
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "Preferred Template Language",
            "_type": "AttributeName"
          },
          "parenthetical": "Template Language",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "Template Language",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": false,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          },
          "default": {
            "one_liner": {
              "_type": "OneLiner",
              "content": " Handlebars\n"
            },
            "is_embellishment": false,
            "_type": "Default",
            "english": {
              "_type": "Paragraph",
              "content": ""
            }
          }
        },
        {
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "alternate Template Languages",
            "_type": "AttributeName"
          },
          "parenthetical": "optional List of Template Languages",
          "data_type_clause": {
            "data_type": {
              "_type": "ListDataType",
              "element_type": {
                "_type": "BaseDataType",
                "class_name": {
                  "content": "Template Languages",
                  "_type": "ClassName"
                },
                "as_value_type": {
                  "t_value": false,
                  "_type": "AsValue"
                }
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          }
        },
        {
          "one_liner": {
            "_type": "OneLiner",
            "content": "A list of functions that require sophisticated AI-powered implementation *"
          },
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "aiFunctions",
            "_type": "AttributeName"
          },
          "parenthetical": "List of String",
          "data_type_clause": {
            "data_type": {
              "_type": "ListDataType",
              "element_type": {
                "_type": "BaseDataType",
                "class_name": {
                  "content": "String",
                  "_type": "ClassName"
                },
                "as_value_type": {
                  "t_value": false,
                  "_type": "AsValue"
                }
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          },
          "derivation": {
            "one_liner": {
              "_type": "OneLiner",
              "content": " ['aiEnglishPlural()']\n"
            },
            "is_embellishment": false,
            "_type": "Derivation",
            "english": {
              "_type": "Paragraph",
              "content": ""
            }
          }
        }
      ]
    }
  ]
}
...Createed object of type: Class
... = Class: LiterateDataModel
final object is  {
  "one_liner": {
    "_type": "OneLiner",
    "content": "A representation of a domain's entities, attributes, and relationships,\nalong with explanatory text and examples"
  },
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "LiterateDataModel",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "abbreviation": "LDM",
  "plural": " LiterateDataModels\n",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "is_value_type": false,
  "attributes": [
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "name",
        "_type": "AttributeName"
      },
      "parenthetical": "UpperCamel",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "UpperCamel",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "list of all classes in the model, as ordered in the\ndefinition of the model."
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "allSubjects",
        "_type": "AttributeName"
      },
      "parenthetical": "List of Classes",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Classes",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "derivation": {
        "one_liner": {
          "_type": "OneLiner",
          "content": " gathering s.allSubjects over s in subjectAreas\n"
        },
        "is_embellishment": false,
        "_type": "Derivation",
        "english": {
          "_type": "Paragraph",
          "content": ""
        }
      },
      "constraints": [
        {
          "one_liner": [
            {
              "_type": "OneLiner",
              "content": " Subject names must be unique across the model.\n"
            }
          ],
          "is_embellishment": false,
          "_type": "Constraint",
          "english": {
            "_type": "Paragraph",
            "content": ""
          },
          "message": {
            "_type": "Paragraph",
            "content": ""
          }
        }
      ]
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "list of all classes in the model, as ordered in the definition of the model."
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "allClasses",
        "_type": "AttributeName"
      },
      "parenthetical": "List of Classes",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Classes",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "derivation": {
        "one_liner": {
          "_type": "OneLiner",
          "content": " gathering s.allClasses over s in allSubjects.\n"
        },
        "is_embellishment": false,
        "_type": "Derivation",
        "english": {
          "_type": "Paragraph",
          "content": ""
        }
      },
      "constraints": [
        {
          "one_liner": [
            {
              "_type": "OneLiner",
              "content": " Class names must be unique across the model.\n"
            }
          ],
          "is_embellishment": false,
          "_type": "Constraint",
          "english": {
            "_type": "Paragraph",
            "content": ""
          },
          "message": {
            "_type": "Paragraph",
            "content": ""
          }
        }
      ]
    }
  ],
  "attribute_sections": [
    {
      "is_embellishment": false,
      "_type": "AttributeSection",
      "prefix": "__",
      "name": {
        "content": "Modeling Configuration",
        "_type": "AttributeSectionName"
      },
      "parenthetical": "",
      "is_optional": {
        "t_value": false,
        "_type": "IsOptional"
      },
      "attributes": [
        {
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "annotationTypes",
            "_type": "AttributeName"
          },
          "parenthetical": "List of AnnotationTypes",
          "data_type_clause": {
            "data_type": {
              "_type": "ListDataType",
              "element_type": {
                "_type": "BaseDataType",
                "class_name": {
                  "content": "AnnotationTypes",
                  "_type": "ClassName"
                },
                "as_value_type": {
                  "t_value": false,
                  "_type": "AsValue"
                }
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          }
        },
        {
          "one_liner": {
            "_type": "OneLiner",
            "content": "the recommended lanquage  for expressing derivation, defaults, and constraints"
          },
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "Preferred Coding Language",
            "_type": "AttributeName"
          },
          "parenthetical": "Coding Language",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "Coding Language",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": false,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          },
          "default": {
            "one_liner": {
              "_type": "OneLiner",
              "content": " OCL\n"
            },
            "is_embellishment": false,
            "_type": "Default",
            "english": {
              "_type": "Paragraph",
              "content": ""
            }
          }
        },
        {
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "alternate Coding Languages",
            "_type": "AttributeName"
          },
          "parenthetical": "optional List of Coding Languages",
          "data_type_clause": {
            "data_type": {
              "_type": "ListDataType",
              "element_type": {
                "_type": "BaseDataType",
                "class_name": {
                  "content": "Coding Languages",
                  "_type": "ClassName"
                },
                "as_value_type": {
                  "t_value": false,
                  "_type": "AsValue"
                }
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          }
        },
        {
          "one_liner": {
            "_type": "OneLiner",
            "content": "the recommended lanquage  for expressing derivation, defaults, and constraints"
          },
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "Preferred Template Language",
            "_type": "AttributeName"
          },
          "parenthetical": "Template Language",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "Template Language",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": false,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          },
          "default": {
            "one_liner": {
              "_type": "OneLiner",
              "content": " Handlebars\n"
            },
            "is_embellishment": false,
            "_type": "Default",
            "english": {
              "_type": "Paragraph",
              "content": ""
            }
          }
        },
        {
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "alternate Template Languages",
            "_type": "AttributeName"
          },
          "parenthetical": "optional List of Template Languages",
          "data_type_clause": {
            "data_type": {
              "_type": "ListDataType",
              "element_type": {
                "_type": "BaseDataType",
                "class_name": {
                  "content": "Template Languages",
                  "_type": "ClassName"
                },
                "as_value_type": {
                  "t_value": false,
                  "_type": "AsValue"
                }
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          }
        },
        {
          "one_liner": {
            "_type": "OneLiner",
            "content": "A list of functions that require sophisticated AI-powered implementation *"
          },
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "aiFunctions",
            "_type": "AttributeName"
          },
          "parenthetical": "List of String",
          "data_type_clause": {
            "data_type": {
              "_type": "ListDataType",
              "element_type": {
                "_type": "BaseDataType",
                "class_name": {
                  "content": "String",
                  "_type": "ClassName"
                },
                "as_value_type": {
                  "t_value": false,
                  "_type": "AsValue"
                }
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          },
          "derivation": {
            "one_liner": {
              "_type": "OneLiner",
              "content": " ['aiEnglishPlural()']\n"
            },
            "is_embellishment": false,
            "_type": "Derivation",
            "english": {
              "_type": "Paragraph",
              "content": ""
            }
          }
        }
      ]
    }
  ]
}
ObjectCreator Creating object of type: Class - named {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'UpperCamel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parentSubject', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent subject, if any, under which this subject is nested _'}, 'parenthetical': 'optional Subject', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Classes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The major classes related to this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'By its subtype classes.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'childSubjects', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any child subjects nested under this subject, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Subjects', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Subject', _type='ClassName'), 'attribute_name': AttributeName(content='parentSubject.', _type='AttributeName')}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n'}]}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: Paragraph - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'name', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'parentSubject', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'Classes', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: ListDataType - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'By its subtype classes.', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'childSubjects', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: ListDataType - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: AttributeReference - named Unnamed
ObjectCreator Creating object of type: Paragraph - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='Subject\nA specific topic or theme within the model', _type='ClassName'), 'parenthetical': '', 'plural': ' Subjects\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='LiterateDataModel', _type='ClassName')], 'elaboration': [Paragraph(_type='Paragraph', content='Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it’s just expository.\n')], 'attributes': [Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='name', _type='AttributeName'), parenthetical='UpperCamel', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='UpperCamel', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='The parent subject, if any, under which this subject is nested _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='parentSubject', _type='AttributeName'), parenthetical='optional Subject', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Subject', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='The major classes related to this subject, in the order in which they should be presented _'), elaboration=[], annotations=[Annotation(label='Issue', content='define chapter, section, subsection as levels?', emoji='', elaboration=[], _type='Annotation')], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='Classes', _type='AttributeName'), parenthetical='ListOf Classes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Classes', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='Each Class should be followed first by the classes that are dependent on it, and then', _type='AttributeName'), parenthetical='', abbreviation=None, data_type_clause=None, overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='By its subtype classes.', _type='AttributeName'), parenthetical='', abbreviation=None, data_type_clause=None, overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='Any child subjects nested under this subject, in the order in which they should be presented _'), elaboration=[Paragraph(_type='Paragraph', content='***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n')], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='childSubjects', _type='AttributeName'), parenthetical='ListOf Subjects', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Subjects', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=AttributeReference(class_name=ClassName(content='Subject', _type='ClassName'), attribute_name=AttributeName(content='parentSubject.', _type='AttributeName'), _type='AttributeReference'), inverse_of=None, derivation=None, default=None, constraints=[])]}
{
  "prefix": "_",
  "name": {
    "content": "Subject\nA specific topic or theme within the model",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Subjects\n",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "dependent_of": [
    {
      "content": "LiterateDataModel",
      "_type": "ClassName"
    }
  ],
  "elaboration": [
    {
      "_type": "Paragraph",
      "content": "Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it\u2019s just expository.\n"
    }
  ],
  "attributes": [
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "name",
        "_type": "AttributeName"
      },
      "parenthetical": "UpperCamel",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "UpperCamel",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The parent subject, if any, under which this subject is nested _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "parentSubject",
        "_type": "AttributeName"
      },
      "parenthetical": "optional Subject",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Subject",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The major classes related to this subject, in the order in which they should be presented _"
      },
      "annotations": [
        {
          "label": "Issue",
          "content": "define chapter, section, subsection as levels?",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "Classes",
        "_type": "AttributeName"
      },
      "parenthetical": "ListOf Classes",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Classes",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "Each Class should be followed first by the classes that are dependent on it, and then",
        "_type": "AttributeName"
      },
      "parenthetical": ""
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "By its subtype classes.",
        "_type": "AttributeName"
      },
      "parenthetical": ""
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "Any child subjects nested under this subject, in the order in which they should be presented _"
      },
      "elaboration": [
        {
          "_type": "Paragraph",
          "content": "***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "childSubjects",
        "_type": "AttributeName"
      },
      "parenthetical": "ListOf Subjects",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Subjects",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "inverse": {
        "class_name": {
          "content": "Subject",
          "_type": "ClassName"
        },
        "attribute_name": {
          "content": "parentSubject.",
          "_type": "AttributeName"
        },
        "_type": "AttributeReference"
      }
    }
  ]
}
...Createed object of type: Class
... = Class: Subject
A specific topic or theme within the model
final object is  {
  "elaboration": [
    {
      "_type": "Paragraph",
      "content": "Subjects are the chapters an sections of the model.\n \n+ A subject need not contain any Classes if it\u2019s just expository.\n"
    }
  ],
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Subject\nA specific topic or theme within the model",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Subjects\n",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "dependent_of": [
    {
      "content": "LiterateDataModel",
      "_type": "ClassName"
    }
  ],
  "is_value_type": false,
  "attributes": [
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "name",
        "_type": "AttributeName"
      },
      "parenthetical": "UpperCamel",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "UpperCamel",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The parent subject, if any, under which this subject is nested _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "parentSubject",
        "_type": "AttributeName"
      },
      "parenthetical": "optional Subject",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Subject",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The major classes related to this subject, in the order in which they should be presented _"
      },
      "annotations": [
        {
          "label": "Issue",
          "content": "define chapter, section, subsection as levels?",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "Classes",
        "_type": "AttributeName"
      },
      "parenthetical": "ListOf Classes",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Classes",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "Each Class should be followed first by the classes that are dependent on it, and then",
        "_type": "AttributeName"
      },
      "parenthetical": ""
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "By its subtype classes.",
        "_type": "AttributeName"
      },
      "parenthetical": ""
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "Any child subjects nested under this subject, in the order in which they should be presented _"
      },
      "elaboration": [
        {
          "_type": "Paragraph",
          "content": "***DSL***:  the Classes within a Subject are always displayed before the childSubjects.\n"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "childSubjects",
        "_type": "AttributeName"
      },
      "parenthetical": "ListOf Subjects",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Subjects",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "inverse": {
        "class_name": {
          "content": "Subject",
          "_type": "ClassName"
        },
        "attribute_name": {
          "content": "parentSubject.",
          "_type": "AttributeName"
        },
        "_type": "AttributeReference"
      }
    }
  ]
}
ObjectCreator Creating object of type: Class - named {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'} 
ObjectCreator Creating object of type: ClassName - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', _type='ClassName'), 'parenthetical': '', 'plural': ' SubjectAreas\n', 'subtype_of': [(ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' parentSubject is absent\n'}
{
  "prefix": "_",
  "name": {
    "content": "SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " SubjectAreas\n",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "where": " parentSubject is absent\n"
}
...Createed object of type: Class
... = Class: SubjectArea
A main topic or area of focus within the model, containing related subjects and classes
final object is  {
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " SubjectAreas\n",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "is_value_type": false,
  "where": " parentSubject is absent\n"
}
ObjectCreator Creating object of type: SubjectC - named {'content': 'Classes', '_type': 'SubjectName'}
ObjectCreator Creating object of type: SubjectName - named Unnamed
ObjectCreator Creating object of type: Class - named {'content': 'Class', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A key entity or object type in the model, often corresponding to a real-world concept'}, 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')]}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'pluralForm', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the normal English plural form of the name of the Class'}, 'parenthetical': 'UpperName', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n'}]}], 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'basedOn', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Class or Classes on which this class is dependent'}, 'parenthetical': 'SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'supertypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The parent class'}, 'parenthetical': 'es', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypings', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the criteria, or dimensions, by which the class can be divided into subtypes'}, 'parenthetical': 'list of Subtypings', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'subtypes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any subtypes or specializations of this class based on it’s subtypings. _'}, 'parenthetical': 'ListOf Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The attributes or properties of the class, in the order in which they should be presented _'}, 'parenthetical': 'ListOf Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'attributeSections', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _'}, 'parenthetical': 'ListOf AttributeSections', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any constraints, rules, or validations specific to this class _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'methods', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any behaviors or operations associated with this class _'}, 'parenthetical': 'ListOf Methods', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dependents', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the Classes which are basedOn this Class'}, 'parenthetical': 'optional SetOf Classes', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='Class', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'UniqueKeys', '_type': 'AttributeName'}, 'parenthetical': 'optional Set of UniqueKeys', 'data_type_clause': {'data_type': {'_type': 'SetDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'inverse': {'_type': 'AttributeReference', 'class_name': ClassName(content='UniqueKey', _type='ClassName'), 'attribute_name': AttributeName(content='basedOn', _type='AttributeName')}}]}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: Constraint - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'pluralForm', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Paragraph - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed
ObjectCreator Creating object of type: Paragraph - named Unnamed
ObjectCreator Creating object of type: Default - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'basedOn', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: SetDataType - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Paragraph - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'supertypes', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'subtypings', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: ListDataType - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'subtypes', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: ListDataType - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'attributes', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: ListDataType - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'attributeSections', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: ListDataType - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'constraints', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: ListDataType - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'methods', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: ListDataType - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: AttributeSection - named {'content': 'Implied Attributes', '_type': 'AttributeSectionName'}
ObjectCreator Creating object of type: AttributeSectionName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'dependents', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: SetDataType - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: AttributeReference - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'UniqueKeys', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: SetDataType - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: AttributeReference - named Unnamed
In AttSection post-init for Implied Attributes, is_optional = None


KWARGS are {'prefix': '_', 'name': ClassName(content='Class', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content='A key entity or object type in the model, often corresponding to a real-world concept'), 'parenthetical': '', 'plural': ' Classes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [Constraint(one_liner=[OneLiner(_type='OneLiner', content=' Within each Class, attribute names must be unique.\n')], elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Constraint', english=Paragraph(_type='Paragraph', content=''), code=None, message=Paragraph(_type='Paragraph', content=''), severity=None)], 'attributes': [Attribute(one_liner=OneLiner(_type='OneLiner', content='the normal English plural form of the name of the Class'), elaboration=[Paragraph(_type='Paragraph', content='Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n')], annotations=[Annotation(label='Note', content='When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', emoji='', elaboration=[Paragraph(_type='Paragraph', content='The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n')], _type='Annotation')], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='pluralForm', _type='AttributeName'), parenthetical='UpperName', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='UpperName', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(_type='OneLiner', content=' the regular plural, formed by adding "s" or "es".\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Default', english=Paragraph(_type='Paragraph', content=''), code=None), constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='the Class or Classes on which this class is dependent'), elaboration=[Paragraph(_type='Paragraph', content='This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n')], annotations=[Annotation(label='Note', content='that basedOn and dependentOf are being used synonymousle in this metamodel.', emoji='', elaboration=[], _type='Annotation')], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='basedOn', _type='AttributeName'), parenthetical='SetOf Classes', abbreviation=None, data_type_clause=DataTypeClause(data_type=SetDataType(_type='SetDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Classes', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='The parent class'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='supertypes', _type='AttributeName'), parenthetical='es', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='es', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='the criteria, or dimensions, by which the class can be divided into subtypes'), elaboration=[], annotations=[Annotation(label='Example', content='in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).', emoji='', elaboration=[], _type='Annotation')], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='subtypings', _type='AttributeName'), parenthetical='list of Subtypings', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Subtypings', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='Any subtypes or specializations of this class based on it’s subtypings. _'), elaboration=[], annotations=[Annotation(label='Example', content='For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.', emoji='', elaboration=[], _type='Annotation')], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='subtypes', _type='AttributeName'), parenthetical='ListOf Classes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Classes', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='The attributes or properties of the class, in the order in which they should be presented _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='attributes', _type='AttributeName'), parenthetical='ListOf Attributes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Attributes', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='additional attributes or properties of the class, grouped for clarity and elaboration.  _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='attributeSections', _type='AttributeName'), parenthetical='ListOf AttributeSections', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='AttributeSections', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='Any constraints, rules, or validations specific to this class _'), elaboration=[], annotations=[Annotation(label='Note', content='Constraints may be expressed on either the Class or the Attribute. Always?', emoji='', elaboration=[], _type='Annotation')], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='constraints', _type='AttributeName'), parenthetical='ListOf Constraints', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Constraints', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='Any behaviors or operations associated with this class _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='methods', _type='AttributeName'), parenthetical='ListOf Methods', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Methods', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])], 'attribute_sections': [AttributeSection(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='AttributeSection', prefix='__', name=AttributeSectionName(content='Implied Attributes', _type='AttributeSectionName'), parenthetical='', abbreviation=None, is_optional=IsOptional(t_value=False, _type='IsOptional'), attributes=[Attribute(one_liner=OneLiner(_type='OneLiner', content='the Classes which are basedOn this Class'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='dependents', _type='AttributeName'), parenthetical='optional SetOf Classes', abbreviation=None, data_type_clause=DataTypeClause(data_type=SetDataType(_type='SetDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Classes', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=AttributeReference(class_name=ClassName(content='Class', _type='ClassName'), attribute_name=AttributeName(content='basedOn', _type='AttributeName'), _type='AttributeReference'), inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='UniqueKeys', _type='AttributeName'), parenthetical='optional Set of UniqueKeys', abbreviation=None, data_type_clause=DataTypeClause(data_type=SetDataType(_type='SetDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='UniqueKeys', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=AttributeReference(class_name=ClassName(content='UniqueKey', _type='ClassName'), attribute_name=AttributeName(content='basedOn', _type='AttributeName'), _type='AttributeReference'), inverse_of=None, derivation=None, default=None, constraints=[])])]}
{
  "prefix": "_",
  "name": {
    "content": "Class",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "A key entity or object type in the model, often corresponding to a real-world concept"
  },
  "parenthetical": "",
  "plural": " Classes\n",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "constraints": [
    {
      "one_liner": [
        {
          "_type": "OneLiner",
          "content": " Within each Class, attribute names must be unique.\n"
        }
      ],
      "is_embellishment": false,
      "_type": "Constraint",
      "english": {
        "_type": "Paragraph",
        "content": ""
      },
      "message": {
        "_type": "Paragraph",
        "content": ""
      }
    }
  ],
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the normal English plural form of the name of the Class"
      },
      "elaboration": [
        {
          "_type": "Paragraph",
          "content": "Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n"
        }
      ],
      "annotations": [
        {
          "label": "Note",
          "content": "When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.",
          "emoji": "",
          "elaboration": [
            {
              "_type": "Paragraph",
              "content": "The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n"
            }
          ],
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "pluralForm",
        "_type": "AttributeName"
      },
      "parenthetical": "UpperName",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "UpperName",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "default": {
        "one_liner": {
          "_type": "OneLiner",
          "content": " the regular plural, formed by adding \"s\" or \"es\".\n"
        },
        "is_embellishment": false,
        "_type": "Default",
        "english": {
          "_type": "Paragraph",
          "content": ""
        }
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the Class or Classes on which this class is dependent"
      },
      "elaboration": [
        {
          "_type": "Paragraph",
          "content": "This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n"
        }
      ],
      "annotations": [
        {
          "label": "Note",
          "content": "that basedOn and dependentOf are being used synonymousle in this metamodel.",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "basedOn",
        "_type": "AttributeName"
      },
      "parenthetical": "SetOf Classes",
      "data_type_clause": {
        "data_type": {
          "_type": "SetDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Classes",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The parent class"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "supertypes",
        "_type": "AttributeName"
      },
      "parenthetical": "es",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "es",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the criteria, or dimensions, by which the class can be divided into subtypes"
      },
      "annotations": [
        {
          "label": "Example",
          "content": "in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "subtypings",
        "_type": "AttributeName"
      },
      "parenthetical": "list of Subtypings",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Subtypings",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "Any subtypes or specializations of this class based on it\u2019s subtypings. _"
      },
      "annotations": [
        {
          "label": "Example",
          "content": "For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "subtypes",
        "_type": "AttributeName"
      },
      "parenthetical": "ListOf Classes",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Classes",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The attributes or properties of the class, in the order in which they should be presented _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "attributes",
        "_type": "AttributeName"
      },
      "parenthetical": "ListOf Attributes",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Attributes",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "additional attributes or properties of the class, grouped for clarity and elaboration.  _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "attributeSections",
        "_type": "AttributeName"
      },
      "parenthetical": "ListOf AttributeSections",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "AttributeSections",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "Any constraints, rules, or validations specific to this class _"
      },
      "annotations": [
        {
          "label": "Note",
          "content": "Constraints may be expressed on either the Class or the Attribute. Always?",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "constraints",
        "_type": "AttributeName"
      },
      "parenthetical": "ListOf Constraints",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Constraints",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "Any behaviors or operations associated with this class _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "methods",
        "_type": "AttributeName"
      },
      "parenthetical": "ListOf Methods",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Methods",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ],
  "attribute_sections": [
    {
      "is_embellishment": false,
      "_type": "AttributeSection",
      "prefix": "__",
      "name": {
        "content": "Implied Attributes",
        "_type": "AttributeSectionName"
      },
      "parenthetical": "",
      "is_optional": {
        "t_value": false,
        "_type": "IsOptional"
      },
      "attributes": [
        {
          "one_liner": {
            "_type": "OneLiner",
            "content": "the Classes which are basedOn this Class"
          },
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "dependents",
            "_type": "AttributeName"
          },
          "parenthetical": "optional SetOf Classes",
          "data_type_clause": {
            "data_type": {
              "_type": "SetDataType",
              "element_type": {
                "_type": "BaseDataType",
                "class_name": {
                  "content": "Classes",
                  "_type": "ClassName"
                },
                "as_value_type": {
                  "t_value": false,
                  "_type": "AsValue"
                }
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          },
          "inverse": {
            "class_name": {
              "content": "Class",
              "_type": "ClassName"
            },
            "attribute_name": {
              "content": "basedOn",
              "_type": "AttributeName"
            },
            "_type": "AttributeReference"
          }
        },
        {
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "UniqueKeys",
            "_type": "AttributeName"
          },
          "parenthetical": "optional Set of UniqueKeys",
          "data_type_clause": {
            "data_type": {
              "_type": "SetDataType",
              "element_type": {
                "_type": "BaseDataType",
                "class_name": {
                  "content": "UniqueKeys",
                  "_type": "ClassName"
                },
                "as_value_type": {
                  "t_value": false,
                  "_type": "AsValue"
                }
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          },
          "inverse": {
            "class_name": {
              "content": "UniqueKey",
              "_type": "ClassName"
            },
            "attribute_name": {
              "content": "basedOn",
              "_type": "AttributeName"
            },
            "_type": "AttributeReference"
          }
        }
      ]
    }
  ]
}
...Createed object of type: Class
... = Class: Class
final object is  {
  "one_liner": {
    "_type": "OneLiner",
    "content": "A key entity or object type in the model, often corresponding to a real-world concept"
  },
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Class",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Classes\n",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "is_value_type": false,
  "constraints": [
    {
      "one_liner": [
        {
          "_type": "OneLiner",
          "content": " Within each Class, attribute names must be unique.\n"
        }
      ],
      "is_embellishment": false,
      "_type": "Constraint",
      "english": {
        "_type": "Paragraph",
        "content": ""
      },
      "message": {
        "_type": "Paragraph",
        "content": ""
      }
    }
  ],
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the normal English plural form of the name of the Class"
      },
      "elaboration": [
        {
          "_type": "Paragraph",
          "content": "Might be Books for the Book class or other regular plurals.\n \n+ But also might be People for Person.\n"
        }
      ],
      "annotations": [
        {
          "label": "Note",
          "content": "When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.",
          "emoji": "",
          "elaboration": [
            {
              "_type": "Paragraph",
              "content": "The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.\n"
            }
          ],
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "pluralForm",
        "_type": "AttributeName"
      },
      "parenthetical": "UpperName",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "UpperName",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "default": {
        "one_liner": {
          "_type": "OneLiner",
          "content": " the regular plural, formed by adding \"s\" or \"es\".\n"
        },
        "is_embellishment": false,
        "_type": "Default",
        "english": {
          "_type": "Paragraph",
          "content": ""
        }
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the Class or Classes on which this class is dependent"
      },
      "elaboration": [
        {
          "_type": "Paragraph",
          "content": "This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.\n"
        }
      ],
      "annotations": [
        {
          "label": "Note",
          "content": "that basedOn and dependentOf are being used synonymousle in this metamodel.",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "basedOn",
        "_type": "AttributeName"
      },
      "parenthetical": "SetOf Classes",
      "data_type_clause": {
        "data_type": {
          "_type": "SetDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Classes",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The parent class"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "supertypes",
        "_type": "AttributeName"
      },
      "parenthetical": "es",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "es",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the criteria, or dimensions, by which the class can be divided into subtypes"
      },
      "annotations": [
        {
          "label": "Example",
          "content": "in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "subtypings",
        "_type": "AttributeName"
      },
      "parenthetical": "list of Subtypings",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Subtypings",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "Any subtypes or specializations of this class based on it\u2019s subtypings. _"
      },
      "annotations": [
        {
          "label": "Example",
          "content": "For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "subtypes",
        "_type": "AttributeName"
      },
      "parenthetical": "ListOf Classes",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Classes",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The attributes or properties of the class, in the order in which they should be presented _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "attributes",
        "_type": "AttributeName"
      },
      "parenthetical": "ListOf Attributes",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Attributes",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "additional attributes or properties of the class, grouped for clarity and elaboration.  _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "attributeSections",
        "_type": "AttributeName"
      },
      "parenthetical": "ListOf AttributeSections",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "AttributeSections",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "Any constraints, rules, or validations specific to this class _"
      },
      "annotations": [
        {
          "label": "Note",
          "content": "Constraints may be expressed on either the Class or the Attribute. Always?",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "constraints",
        "_type": "AttributeName"
      },
      "parenthetical": "ListOf Constraints",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Constraints",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "Any behaviors or operations associated with this class _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "methods",
        "_type": "AttributeName"
      },
      "parenthetical": "ListOf Methods",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Methods",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ],
  "attribute_sections": [
    {
      "is_embellishment": false,
      "_type": "AttributeSection",
      "prefix": "__",
      "name": {
        "content": "Implied Attributes",
        "_type": "AttributeSectionName"
      },
      "parenthetical": "",
      "is_optional": {
        "t_value": false,
        "_type": "IsOptional"
      },
      "attributes": [
        {
          "one_liner": {
            "_type": "OneLiner",
            "content": "the Classes which are basedOn this Class"
          },
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "dependents",
            "_type": "AttributeName"
          },
          "parenthetical": "optional SetOf Classes",
          "data_type_clause": {
            "data_type": {
              "_type": "SetDataType",
              "element_type": {
                "_type": "BaseDataType",
                "class_name": {
                  "content": "Classes",
                  "_type": "ClassName"
                },
                "as_value_type": {
                  "t_value": false,
                  "_type": "AsValue"
                }
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          },
          "inverse": {
            "class_name": {
              "content": "Class",
              "_type": "ClassName"
            },
            "attribute_name": {
              "content": "basedOn",
              "_type": "AttributeName"
            },
            "_type": "AttributeReference"
          }
        },
        {
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "UniqueKeys",
            "_type": "AttributeName"
          },
          "parenthetical": "optional Set of UniqueKeys",
          "data_type_clause": {
            "data_type": {
              "_type": "SetDataType",
              "element_type": {
                "_type": "BaseDataType",
                "class_name": {
                  "content": "UniqueKeys",
                  "_type": "ClassName"
                },
                "as_value_type": {
                  "t_value": false,
                  "_type": "AsValue"
                }
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          },
          "inverse": {
            "class_name": {
              "content": "UniqueKey",
              "_type": "ClassName"
            },
            "attribute_name": {
              "content": "basedOn",
              "_type": "AttributeName"
            },
            "_type": "AttributeReference"
          }
        }
      ]
    }
  ]
}
ObjectCreator Creating object of type: Class - named {'content': 'Subtyping', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Subtyping', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a way in which subtypes of a Class may be classified'}, 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Upper Name', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exclusive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'is exhaustive', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content=' true\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'classes', '_type': 'AttributeName'}, 'parenthetical': 'List of Classes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.'}]}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'name', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'is exclusive', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Default - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'is exhaustive', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Default - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'classes', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: ListDataType - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Paragraph - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='Subtyping', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content='a way in which subtypes of a Class may be classified'), 'parenthetical': 'Subtype of Component', 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='name', _type='AttributeName'), parenthetical='Upper Name', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Upper Name', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='is exclusive', _type='AttributeName'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Boolean', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(_type='OneLiner', content=' true\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Default', english=Paragraph(_type='Paragraph', content=''), code=None), constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='is exhaustive', _type='AttributeName'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Boolean', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(_type='OneLiner', content=' true\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Default', english=Paragraph(_type='Paragraph', content=''), code=None), constraints=[]), Attribute(one_liner=None, elaboration=[Paragraph(_type='Paragraph', content='***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n')], annotations=[Annotation(label='Note', content='every class can have an unnamed subtyping.', emoji='', elaboration=[], _type='Annotation')], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='classes', _type='AttributeName'), parenthetical='List of Classes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Classes', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])]}
{
  "prefix": "_",
  "name": {
    "content": "Subtyping",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "a way in which subtypes of a Class may be classified"
  },
  "parenthetical": "Subtype of Component",
  "dependent_of": [
    {
      "content": "Class",
      "_type": "ClassName"
    }
  ],
  "attributes": [
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "name",
        "_type": "AttributeName"
      },
      "parenthetical": "Upper Name",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Upper Name",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "is exclusive",
        "_type": "AttributeName"
      },
      "parenthetical": "Boolean",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Boolean",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "default": {
        "one_liner": {
          "_type": "OneLiner",
          "content": " true\n"
        },
        "is_embellishment": false,
        "_type": "Default",
        "english": {
          "_type": "Paragraph",
          "content": ""
        }
      }
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "is exhaustive",
        "_type": "AttributeName"
      },
      "parenthetical": "Boolean",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Boolean",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "default": {
        "one_liner": {
          "_type": "OneLiner",
          "content": " true\n"
        },
        "is_embellishment": false,
        "_type": "Default",
        "english": {
          "_type": "Paragraph",
          "content": ""
        }
      }
    },
    {
      "elaboration": [
        {
          "_type": "Paragraph",
          "content": "***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n"
        }
      ],
      "annotations": [
        {
          "label": "Note",
          "content": "every class can have an unnamed subtyping.",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "classes",
        "_type": "AttributeName"
      },
      "parenthetical": "List of Classes",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Classes",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
...Createed object of type: Class
... = Class: Subtyping
final object is  {
  "one_liner": {
    "_type": "OneLiner",
    "content": "a way in which subtypes of a Class may be classified"
  },
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Subtyping",
    "_type": "ClassName"
  },
  "parenthetical": "Subtype of Component",
  "dependent_of": [
    {
      "content": "Class",
      "_type": "ClassName"
    }
  ],
  "is_value_type": false,
  "attributes": [
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "name",
        "_type": "AttributeName"
      },
      "parenthetical": "Upper Name",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Upper Name",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "is exclusive",
        "_type": "AttributeName"
      },
      "parenthetical": "Boolean",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Boolean",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "default": {
        "one_liner": {
          "_type": "OneLiner",
          "content": " true\n"
        },
        "is_embellishment": false,
        "_type": "Default",
        "english": {
          "_type": "Paragraph",
          "content": ""
        }
      }
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "is exhaustive",
        "_type": "AttributeName"
      },
      "parenthetical": "Boolean",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Boolean",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "default": {
        "one_liner": {
          "_type": "OneLiner",
          "content": " true\n"
        },
        "is_embellishment": false,
        "_type": "Default",
        "english": {
          "_type": "Paragraph",
          "content": ""
        }
      }
    },
    {
      "elaboration": [
        {
          "_type": "Paragraph",
          "content": "***DSL***:  Shown in the DSL as\n \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\n \n+ on the super class. And as\n \n+ > Subtype of: SuperClass byBrand\n \n+ on the subclass.\n"
        }
      ],
      "annotations": [
        {
          "label": "Note",
          "content": "every class can have an unnamed subtyping.",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "classes",
        "_type": "AttributeName"
      },
      "parenthetical": "List of Classes",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Classes",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
ObjectCreator Creating object of type: Class - named {'content': 'ValueType', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]} 
ObjectCreator Creating object of type: ClassName - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='ValueType', _type='ClassName'), 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
{
  "prefix": "_",
  "name": {
    "content": "ValueType",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ]
}
...Createed object of type: Class
... = Class: ValueType
final object is  {
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "ValueType",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "is_value_type": false
}
ObjectCreator Creating object of type: Class - named {'content': 'Reference Type', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Reference Type', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]} 
ObjectCreator Creating object of type: ClassName - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='Reference Type', _type='ClassName'), 'parenthetical': '', 'subtype_of': [(ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))]}
{
  "prefix": "_",
  "name": {
    "content": "Reference Type",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ]
}
...Createed object of type: Class
... = Class: Reference Type
final object is  {
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Reference Type",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "is_value_type": false
}
ObjectCreator Creating object of type: Class - named {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isCaptive', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the code type was implied by use in an attribute and is only used for that attribute'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'isCaptive', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='CodeType\nA data type or enumeration used in the model', _type='ClassName'), 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [Annotation(label='Note', content="Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:", emoji='', elaboration=[], _type='Annotation')], 'attributes': [Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', _type='AttributeName'), parenthetical='', abbreviation=None, data_type_clause=None, overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', _type='AttributeName'), parenthetical='', abbreviation=None, data_type_clause=None, overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='the code type was implied by use in an attribute and is only used for that attribute'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='isCaptive', _type='AttributeName'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Boolean', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])]}
{
  "prefix": "_",
  "name": {
    "content": "CodeType\nA data type or enumeration used in the model",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "annotations": [
    {
      "label": "Note",
      "content": "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:",
      "emoji": "",
      "_type": "Annotation"
    }
  ],
  "attributes": [
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "List the code values as a bulletted list inside the description of the attribute in the form\n\u2018code description\u2019",
        "_type": "AttributeName"
      },
      "parenthetical": ""
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.",
        "_type": "AttributeName"
      },
      "parenthetical": ""
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the code type was implied by use in an attribute and is only used for that attribute"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "isCaptive",
        "_type": "AttributeName"
      },
      "parenthetical": "Boolean",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Boolean",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
...Createed object of type: Class
... = Class: CodeType
A data type or enumeration used in the model
final object is  {
  "annotations": [
    {
      "label": "Note",
      "content": "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:",
      "emoji": "",
      "_type": "Annotation"
    }
  ],
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "CodeType\nA data type or enumeration used in the model",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "is_value_type": false,
  "attributes": [
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "List the code values as a bulletted list inside the description of the attribute in the form\n\u2018code description\u2019",
        "_type": "AttributeName"
      },
      "parenthetical": ""
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.",
        "_type": "AttributeName"
      },
      "parenthetical": ""
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the code type was implied by use in an attribute and is only used for that attribute"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "isCaptive",
        "_type": "AttributeName"
      },
      "parenthetical": "Boolean",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Boolean",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
ObjectCreator Creating object of type: Class - named {'content': 'Code Value', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Code Value', '_type': 'ClassName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'code', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'A short code or abbreviationi for the value _'}, 'parenthetical': 'NameString', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'description', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an explanation of what the code means'}, 'parenthetical': '*RichText*', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'code', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'description', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='Code Value', _type='ClassName'), 'parenthetical': '', 'annotations': [Annotation(label='A possible value for an enumerated data class  DependentOf', content='CodeType', emoji='', elaboration=[], _type='Annotation')], 'attributes': [Attribute(one_liner=OneLiner(_type='OneLiner', content='A short code or abbreviationi for the value _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='code', _type='AttributeName'), parenthetical='NameString', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='NameString', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='an explanation of what the code means'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='description', _type='AttributeName'), parenthetical='*RichText*', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='RichText', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])]}
{
  "prefix": "_",
  "name": {
    "content": "Code Value",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "annotations": [
    {
      "label": "A possible value for an enumerated data class  DependentOf",
      "content": "CodeType",
      "emoji": "",
      "_type": "Annotation"
    }
  ],
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "A short code or abbreviationi for the value _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "code",
        "_type": "AttributeName"
      },
      "parenthetical": "NameString",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "NameString",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "an explanation of what the code means"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "description",
        "_type": "AttributeName"
      },
      "parenthetical": "*RichText*",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "RichText",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
...Createed object of type: Class
... = Class: Code Value
final object is  {
  "annotations": [
    {
      "label": "A possible value for an enumerated data class  DependentOf",
      "content": "CodeType",
      "emoji": "",
      "_type": "Annotation"
    }
  ],
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Code Value",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "is_value_type": false,
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "A short code or abbreviationi for the value _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "code",
        "_type": "AttributeName"
      },
      "parenthetical": "NameString",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "NameString",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "an explanation of what the code means"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "description",
        "_type": "AttributeName"
      },
      "parenthetical": "*RichText*",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "RichText",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
ObjectCreator Creating object of type: Class - named {'content': 'Key', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Key', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes of a class'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'keyAttributes', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the attributes of the base Class.'}, 'parenthetical': 'List of Attributes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')]}, {'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'keyAttributes', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: ListDataType - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Constraint - named Unnamed
ObjectCreator Creating object of type: Constraint - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='Key', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content='a list of attributes of a class'), 'parenthetical': '', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'dependent_of': [ClassName(content='Class', _type='ClassName')], 'attributes': [Attribute(one_liner=OneLiner(_type='OneLiner', content='the attributes of the base Class.'), elaboration=[], annotations=[Annotation(label='Issue', content='need ascending descending to support index keys or ordering keys.', emoji='', elaboration=[], _type='Annotation')], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='keyAttributes', _type='AttributeName'), parenthetical='List of Attributes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Attributes', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[Constraint(one_liner=[OneLiner(_type='OneLiner', content=' each attribute must be a direct or inherited of the base class.\n')], elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Constraint', english=Paragraph(_type='Paragraph', content=''), code=None, message=Paragraph(_type='Paragraph', content=''), severity=None), Constraint(one_liner=[OneLiner(_type='OneLiner', content=' no repetitions allowed in keyAttributes\n> 👍 **Issue**: introduce PureLists?')], elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Constraint', english=Paragraph(_type='Paragraph', content=''), code=None, message=Paragraph(_type='Paragraph', content=''), severity=None)])]}
{
  "prefix": "_",
  "name": {
    "content": "Key",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "a list of attributes of a class"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "dependent_of": [
    {
      "content": "Class",
      "_type": "ClassName"
    }
  ],
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the attributes of the base Class."
      },
      "annotations": [
        {
          "label": "Issue",
          "content": "need ascending descending to support index keys or ordering keys.",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "keyAttributes",
        "_type": "AttributeName"
      },
      "parenthetical": "List of Attributes",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Attributes",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "constraints": [
        {
          "one_liner": [
            {
              "_type": "OneLiner",
              "content": " each attribute must be a direct or inherited of the base class.\n"
            }
          ],
          "is_embellishment": false,
          "_type": "Constraint",
          "english": {
            "_type": "Paragraph",
            "content": ""
          },
          "message": {
            "_type": "Paragraph",
            "content": ""
          }
        },
        {
          "one_liner": [
            {
              "_type": "OneLiner",
              "content": " no repetitions allowed in keyAttributes\n> \ud83d\udc4d **Issue**: introduce PureLists?"
            }
          ],
          "is_embellishment": false,
          "_type": "Constraint",
          "english": {
            "_type": "Paragraph",
            "content": ""
          },
          "message": {
            "_type": "Paragraph",
            "content": ""
          }
        }
      ]
    }
  ]
}
...Createed object of type: Class
... = Class: Key
final object is  {
  "one_liner": {
    "_type": "OneLiner",
    "content": "a list of attributes of a class"
  },
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Key",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "dependent_of": [
    {
      "content": "Class",
      "_type": "ClassName"
    }
  ],
  "is_value_type": false,
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the attributes of the base Class."
      },
      "annotations": [
        {
          "label": "Issue",
          "content": "need ascending descending to support index keys or ordering keys.",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "keyAttributes",
        "_type": "AttributeName"
      },
      "parenthetical": "List of Attributes",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Attributes",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "constraints": [
        {
          "one_liner": [
            {
              "_type": "OneLiner",
              "content": " each attribute must be a direct or inherited of the base class.\n"
            }
          ],
          "is_embellishment": false,
          "_type": "Constraint",
          "english": {
            "_type": "Paragraph",
            "content": ""
          },
          "message": {
            "_type": "Paragraph",
            "content": ""
          }
        },
        {
          "one_liner": [
            {
              "_type": "OneLiner",
              "content": " no repetitions allowed in keyAttributes\n> \ud83d\udc4d **Issue**: introduce PureLists?"
            }
          ],
          "is_embellishment": false,
          "_type": "Constraint",
          "english": {
            "_type": "Paragraph",
            "content": ""
          },
          "message": {
            "_type": "Paragraph",
            "content": ""
          }
        }
      ]
    }
  ]
}
ObjectCreator Creating object of type: Class - named {'content': 'UniqueKey', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UniqueKey', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a list of attributes on which instances of the base class may be keyed.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='UniqueKey', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content='a list of attributes on which instances of the base class may be keyed.'), 'parenthetical': '', 'subtype_of': [(ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [Annotation(label='Note', content='order unimportant for Unique Keys.', emoji='', elaboration=[], _type='Annotation')]}
{
  "prefix": "_",
  "name": {
    "content": "UniqueKey",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "a list of attributes on which instances of the base class may be keyed."
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "annotations": [
    {
      "label": "Note",
      "content": "order unimportant for Unique Keys.",
      "emoji": "",
      "_type": "Annotation"
    }
  ]
}
...Createed object of type: Class
... = Class: UniqueKey
final object is  {
  "one_liner": {
    "_type": "OneLiner",
    "content": "a list of attributes on which instances of the base class may be keyed."
  },
  "annotations": [
    {
      "label": "Note",
      "content": "order unimportant for Unique Keys.",
      "emoji": "",
      "_type": "Annotation"
    }
  ],
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "UniqueKey",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "is_value_type": false
}
ObjectCreator Creating object of type: SubjectB - named {'content': 'Attributes', '_type': 'SubjectName'}
ObjectCreator Creating object of type: SubjectName - named Unnamed
ObjectCreator Creating object of type: Class - named {'content': 'Attribute Section', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Section', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a group of attributes for a class that merit a shared explanation.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'whether the attributes in this section, taken together, are optional.'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n'}]}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'isOptional', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Paragraph - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='Attribute Section', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content='a group of attributes for a class that merit a shared explanation.'), 'parenthetical': '', 'subtype_of': [(ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class', _type='ClassName')], 'attributes': [Attribute(one_liner=OneLiner(_type='OneLiner', content='whether the attributes in this section, taken together, are optional.'), elaboration=[Paragraph(_type='Paragraph', content='If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n')], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='isOptional', _type='AttributeName'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Boolean', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])]}
{
  "prefix": "_",
  "name": {
    "content": "Attribute Section",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "a group of attributes for a class that merit a shared explanation."
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "based_on": [
    {
      "content": "Class",
      "_type": "ClassName"
    }
  ],
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "whether the attributes in this section, taken together, are optional."
      },
      "elaboration": [
        {
          "_type": "Paragraph",
          "content": "If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "isOptional",
        "_type": "AttributeName"
      },
      "parenthetical": "Boolean",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Boolean",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
...Createed object of type: Class
... = Class: Attribute Section
final object is  {
  "one_liner": {
    "_type": "OneLiner",
    "content": "a group of attributes for a class that merit a shared explanation."
  },
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Attribute Section",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "based_on": [
    {
      "content": "Class",
      "_type": "ClassName"
    }
  ],
  "is_value_type": false,
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "whether the attributes in this section, taken together, are optional."
      },
      "elaboration": [
        {
          "_type": "Paragraph",
          "content": "If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.\n \n+ &nbsp;\n \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.\n"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "isOptional",
        "_type": "AttributeName"
      },
      "parenthetical": "Boolean",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Boolean",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
ObjectCreator Creating object of type: Class - named {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'name', '_type': 'AttributeName'}, 'parenthetical': 'Lower Camel', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'dataType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The kind of object to which the attribute refers.  _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'elaboration': [{'_type': 'Paragraph', 'content': 'But,\n'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'List of Editions', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Set of Edition', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': '... and more complicated cases.', '_type': 'AttributeName'}, 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isOptional', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Indicates whether the attribute must have a value for every instance of the class _'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='*** False\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the relationship represented by the attribute _'}, 'parenthetical': 'CardinalityCode', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'default': {'_type': 'Default', 'one_liner': OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'author', '_type': 'AttributeName'}, 'parenthetical': '1:1 Author', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'books', '_type': 'AttributeName'}, 'parenthetical': 'optional N:M Set of Books', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'isInvertible', '_type': 'AttributeName'}, 'parenthetical': 'Boolean', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseClass', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the class which contains, or would contain the inverse attribute'}, 'parenthetical': 'optional Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'derivation': {'_type': 'Derivation', 'one_liner': OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n')}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseAttribute', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'inverseIsOptional', '_type': 'AttributeName'}, 'parenthetical': 'optional Attribute', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'name', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: AttributeReference - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'dataType', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Paragraph - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'List of Editions', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'Set of Edition', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': '... and more complicated cases.', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed
ObjectCreator Creating object of type: AttributeSection - named {'content': 'Cardinalities.', '_type': 'AttributeSectionName'}
ObjectCreator Creating object of type: AttributeSectionName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'isOptional', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Default - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'cardinality', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Default - named Unnamed
ObjectCreator Creating object of type: Paragraph - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'author', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'books', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed
In AttSection post-init for Cardinalities., is_optional = None
ObjectCreator Creating object of type: AttributeSection - named {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'}
ObjectCreator Creating object of type: AttributeSectionName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'isInvertible', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Derivation - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'inverseClass', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Derivation - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'inverseAttribute', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'inverseIsOptional', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
In AttSection post-init for Inverse Attributes, is_optional = None


KWARGS are {'prefix': '_', 'name': ClassName(content='Attribute\nA property or characteristic of a class', _type='ClassName'), 'parenthetical': '', 'plural': ' Attributes\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='AttributeSection', _type='ClassName')], 'attributes': [Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='name', _type='AttributeName'), parenthetical='Lower Camel', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Lower Camel', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=AttributeReference(class_name=ClassName(content='CamelName', _type='ClassName'), attribute_name=AttributeName(content='', _type='AttributeName'), _type='AttributeReference'), inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='The kind of object to which the attribute refers.  _'), elaboration=[Paragraph(_type='Paragraph', content='But,\n')], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='dataType', _type='AttributeName'), parenthetical='DataType', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='DataType', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='List of Editions', _type='AttributeName'), parenthetical='', abbreviation=None, data_type_clause=None, overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='Set of Edition', _type='AttributeName'), parenthetical='', abbreviation=None, data_type_clause=None, overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[Annotation(label='See', content='the section below on Data Type Specifiers.', emoji='', elaboration=[], _type='Annotation')], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='... and more complicated cases.', _type='AttributeName'), parenthetical='', abbreviation=None, data_type_clause=None, overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])], 'attribute_sections': [AttributeSection(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='AttributeSection', prefix='__', name=AttributeSectionName(content='Cardinalities.', _type='AttributeSectionName'), parenthetical='', abbreviation=None, is_optional=IsOptional(t_value=False, _type='IsOptional'), attributes=[Attribute(one_liner=OneLiner(_type='OneLiner', content='Indicates whether the attribute must have a value for every instance of the class _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='isOptional', _type='AttributeName'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Boolean', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(_type='OneLiner', content='*** False\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Default', english=Paragraph(_type='Paragraph', content=''), code=None), constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='The cardinality of the relationship represented by the attribute _'), elaboration=[], annotations=[Annotation(label='For example', content='', emoji='', elaboration=[], _type='Annotation')], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='cardinality', _type='AttributeName'), parenthetical='CardinalityCode', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='CardinalityCode', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=Default(one_liner=OneLiner(_type='OneLiner', content='***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'), elaboration=[Paragraph(_type='Paragraph', content='***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n')], annotations=[], diagnostics=[], is_embellishment=False, _type='Default', english=Paragraph(_type='Paragraph', content=''), code=None), constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='author', _type='AttributeName'), parenthetical='1:1 Author', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Invented Name', _type='ClassName'), as_value_type=AsValue(t_value=True, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[Annotation(label='Note', content='how this works with optionality', emoji='', elaboration=[], _type='Annotation')], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='books', _type='AttributeName'), parenthetical='optional N:M Set of Books', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Invented Name', _type='ClassName'), as_value_type=AsValue(t_value=True, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])]), AttributeSection(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='AttributeSection', prefix='__', name=AttributeSectionName(content='Inverse Attributes', _type='AttributeSectionName'), parenthetical='', abbreviation=None, is_optional=IsOptional(t_value=False, _type='IsOptional'), attributes=[Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='isInvertible', _type='AttributeName'), parenthetical='Boolean', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Boolean', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=Derivation(one_liner=OneLiner(_type='OneLiner', content=' true if the data type is a class or a simple collection of members of a class.\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Derivation', english=Paragraph(_type='Paragraph', content=''), code=None), default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='the class which contains, or would contain the inverse attribute'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='inverseClass', _type='AttributeName'), parenthetical='optional Class', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Class', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=Derivation(one_liner=OneLiner(_type='OneLiner', content=' from the data type. Null unless arrribute is invertible.\n'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Derivation', english=Paragraph(_type='Paragraph', content=''), code=None), default=None, constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='inverseAttribute', _type='AttributeName'), parenthetical='optional Attribute', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Attribute', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='inverseIsOptional', _type='AttributeName'), parenthetical='optional Attribute', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Attribute', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])])]}
{
  "prefix": "_",
  "name": {
    "content": "Attribute\nA property or characteristic of a class",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Attributes\n",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "based_on": [
    {
      "content": "AttributeSection",
      "_type": "ClassName"
    }
  ],
  "attributes": [
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "name",
        "_type": "AttributeName"
      },
      "parenthetical": "Lower Camel",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Lower Camel",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "overrides": {
        "class_name": {
          "content": "CamelName",
          "_type": "ClassName"
        },
        "attribute_name": {
          "content": "",
          "_type": "AttributeName"
        },
        "_type": "AttributeReference"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The kind of object to which the attribute refers.  _"
      },
      "elaboration": [
        {
          "_type": "Paragraph",
          "content": "But,\n"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "dataType",
        "_type": "AttributeName"
      },
      "parenthetical": "DataType",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "DataType",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "List of Editions",
        "_type": "AttributeName"
      },
      "parenthetical": ""
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "Set of Edition",
        "_type": "AttributeName"
      },
      "parenthetical": ""
    },
    {
      "annotations": [
        {
          "label": "See",
          "content": "the section below on Data Type Specifiers.",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "... and more complicated cases.",
        "_type": "AttributeName"
      },
      "parenthetical": ""
    }
  ],
  "attribute_sections": [
    {
      "is_embellishment": false,
      "_type": "AttributeSection",
      "prefix": "__",
      "name": {
        "content": "Cardinalities.",
        "_type": "AttributeSectionName"
      },
      "parenthetical": "",
      "is_optional": {
        "t_value": false,
        "_type": "IsOptional"
      },
      "attributes": [
        {
          "one_liner": {
            "_type": "OneLiner",
            "content": "Indicates whether the attribute must have a value for every instance of the class _"
          },
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "isOptional",
            "_type": "AttributeName"
          },
          "parenthetical": "Boolean",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "Boolean",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": false,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          },
          "default": {
            "one_liner": {
              "_type": "OneLiner",
              "content": "*** False\n"
            },
            "is_embellishment": false,
            "_type": "Default",
            "english": {
              "_type": "Paragraph",
              "content": ""
            }
          }
        },
        {
          "one_liner": {
            "_type": "OneLiner",
            "content": "The cardinality of the relationship represented by the attribute _"
          },
          "annotations": [
            {
              "label": "For example",
              "content": "",
              "emoji": "",
              "_type": "Annotation"
            }
          ],
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "cardinality",
            "_type": "AttributeName"
          },
          "parenthetical": "CardinalityCode",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "CardinalityCode",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": false,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          },
          "default": {
            "one_liner": {
              "_type": "OneLiner",
              "content": "***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly."
            },
            "elaboration": [
              {
                "_type": "Paragraph",
                "content": "***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n"
              }
            ],
            "is_embellishment": false,
            "_type": "Default",
            "english": {
              "_type": "Paragraph",
              "content": ""
            }
          }
        },
        {
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "author",
            "_type": "AttributeName"
          },
          "parenthetical": "1:1 Author",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "Invented Name",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": true,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          }
        },
        {
          "annotations": [
            {
              "label": "Note",
              "content": "how this works with optionality",
              "emoji": "",
              "_type": "Annotation"
            }
          ],
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "books",
            "_type": "AttributeName"
          },
          "parenthetical": "optional N:M Set of Books",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "Invented Name",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": true,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          }
        }
      ]
    },
    {
      "is_embellishment": false,
      "_type": "AttributeSection",
      "prefix": "__",
      "name": {
        "content": "Inverse Attributes",
        "_type": "AttributeSectionName"
      },
      "parenthetical": "",
      "is_optional": {
        "t_value": false,
        "_type": "IsOptional"
      },
      "attributes": [
        {
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "isInvertible",
            "_type": "AttributeName"
          },
          "parenthetical": "Boolean",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "Boolean",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": false,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          },
          "derivation": {
            "one_liner": {
              "_type": "OneLiner",
              "content": " true if the data type is a class or a simple collection of members of a class.\n"
            },
            "is_embellishment": false,
            "_type": "Derivation",
            "english": {
              "_type": "Paragraph",
              "content": ""
            }
          }
        },
        {
          "one_liner": {
            "_type": "OneLiner",
            "content": "the class which contains, or would contain the inverse attribute"
          },
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "inverseClass",
            "_type": "AttributeName"
          },
          "parenthetical": "optional Class",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "Class",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": false,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          },
          "derivation": {
            "one_liner": {
              "_type": "OneLiner",
              "content": " from the data type. Null unless arrribute is invertible.\n"
            },
            "is_embellishment": false,
            "_type": "Derivation",
            "english": {
              "_type": "Paragraph",
              "content": ""
            }
          }
        },
        {
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "inverseAttribute",
            "_type": "AttributeName"
          },
          "parenthetical": "optional Attribute",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "Attribute",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": false,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          }
        },
        {
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "inverseIsOptional",
            "_type": "AttributeName"
          },
          "parenthetical": "optional Attribute",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "Attribute",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": false,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          }
        }
      ]
    }
  ]
}
...Createed object of type: Class
... = Class: Attribute
A property or characteristic of a class
final object is  {
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Attribute\nA property or characteristic of a class",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Attributes\n",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "based_on": [
    {
      "content": "AttributeSection",
      "_type": "ClassName"
    }
  ],
  "is_value_type": false,
  "attributes": [
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "name",
        "_type": "AttributeName"
      },
      "parenthetical": "Lower Camel",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Lower Camel",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "overrides": {
        "class_name": {
          "content": "CamelName",
          "_type": "ClassName"
        },
        "attribute_name": {
          "content": "",
          "_type": "AttributeName"
        },
        "_type": "AttributeReference"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The kind of object to which the attribute refers.  _"
      },
      "elaboration": [
        {
          "_type": "Paragraph",
          "content": "But,\n"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "dataType",
        "_type": "AttributeName"
      },
      "parenthetical": "DataType",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "DataType",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "List of Editions",
        "_type": "AttributeName"
      },
      "parenthetical": ""
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "Set of Edition",
        "_type": "AttributeName"
      },
      "parenthetical": ""
    },
    {
      "annotations": [
        {
          "label": "See",
          "content": "the section below on Data Type Specifiers.",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "... and more complicated cases.",
        "_type": "AttributeName"
      },
      "parenthetical": ""
    }
  ],
  "attribute_sections": [
    {
      "is_embellishment": false,
      "_type": "AttributeSection",
      "prefix": "__",
      "name": {
        "content": "Cardinalities.",
        "_type": "AttributeSectionName"
      },
      "parenthetical": "",
      "is_optional": {
        "t_value": false,
        "_type": "IsOptional"
      },
      "attributes": [
        {
          "one_liner": {
            "_type": "OneLiner",
            "content": "Indicates whether the attribute must have a value for every instance of the class _"
          },
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "isOptional",
            "_type": "AttributeName"
          },
          "parenthetical": "Boolean",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "Boolean",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": false,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          },
          "default": {
            "one_liner": {
              "_type": "OneLiner",
              "content": "*** False\n"
            },
            "is_embellishment": false,
            "_type": "Default",
            "english": {
              "_type": "Paragraph",
              "content": ""
            }
          }
        },
        {
          "one_liner": {
            "_type": "OneLiner",
            "content": "The cardinality of the relationship represented by the attribute _"
          },
          "annotations": [
            {
              "label": "For example",
              "content": "",
              "emoji": "",
              "_type": "Annotation"
            }
          ],
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "cardinality",
            "_type": "AttributeName"
          },
          "parenthetical": "CardinalityCode",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "CardinalityCode",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": false,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          },
          "default": {
            "one_liner": {
              "_type": "OneLiner",
              "content": "***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.\nFor a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly."
            },
            "elaboration": [
              {
                "_type": "Paragraph",
                "content": "***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.\n"
              }
            ],
            "is_embellishment": false,
            "_type": "Default",
            "english": {
              "_type": "Paragraph",
              "content": ""
            }
          }
        },
        {
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "author",
            "_type": "AttributeName"
          },
          "parenthetical": "1:1 Author",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "Invented Name",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": true,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          }
        },
        {
          "annotations": [
            {
              "label": "Note",
              "content": "how this works with optionality",
              "emoji": "",
              "_type": "Annotation"
            }
          ],
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "books",
            "_type": "AttributeName"
          },
          "parenthetical": "optional N:M Set of Books",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "Invented Name",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": true,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          }
        }
      ]
    },
    {
      "is_embellishment": false,
      "_type": "AttributeSection",
      "prefix": "__",
      "name": {
        "content": "Inverse Attributes",
        "_type": "AttributeSectionName"
      },
      "parenthetical": "",
      "is_optional": {
        "t_value": false,
        "_type": "IsOptional"
      },
      "attributes": [
        {
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "isInvertible",
            "_type": "AttributeName"
          },
          "parenthetical": "Boolean",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "Boolean",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": false,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          },
          "derivation": {
            "one_liner": {
              "_type": "OneLiner",
              "content": " true if the data type is a class or a simple collection of members of a class.\n"
            },
            "is_embellishment": false,
            "_type": "Derivation",
            "english": {
              "_type": "Paragraph",
              "content": ""
            }
          }
        },
        {
          "one_liner": {
            "_type": "OneLiner",
            "content": "the class which contains, or would contain the inverse attribute"
          },
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "inverseClass",
            "_type": "AttributeName"
          },
          "parenthetical": "optional Class",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "Class",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": false,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          },
          "derivation": {
            "one_liner": {
              "_type": "OneLiner",
              "content": " from the data type. Null unless arrribute is invertible.\n"
            },
            "is_embellishment": false,
            "_type": "Derivation",
            "english": {
              "_type": "Paragraph",
              "content": ""
            }
          }
        },
        {
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "inverseAttribute",
            "_type": "AttributeName"
          },
          "parenthetical": "optional Attribute",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "Attribute",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": false,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          }
        },
        {
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "inverseIsOptional",
            "_type": "AttributeName"
          },
          "parenthetical": "optional Attribute",
          "data_type_clause": {
            "data_type": {
              "_type": "BaseDataType",
              "class_name": {
                "content": "Attribute",
                "_type": "ClassName"
              },
              "as_value_type": {
                "t_value": false,
                "_type": "AsValue"
              }
            },
            "is_optional_lit": {
              "t_value": false,
              "_type": "IsOptional"
            },
            "_type": "DataTypeClause"
          }
        }
      ]
    }
  ]
}
ObjectCreator Creating object of type: Class - named {'content': 'Formulas', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Formulas', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'default', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"}, {'_type': 'Paragraph', 'content': 'Last paragraph here\n'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'derivation', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'For derived attributes, the rule or formula for calculating the value _'}, 'parenthetical': 'optional Derivation', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'constraints', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'Any validation rules specific to this attribute _'}, 'parenthetical': 'ListOf Constraints', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': {'content': 'Override Tracking', '_type': 'AttributeSectionName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Overrides', '_type': 'AttributeName'}, 'parenthetical': ''}]}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'default', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed
ObjectCreator Creating object of type: Paragraph - named Unnamed
ObjectCreator Creating object of type: Paragraph - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'derivation', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'constraints', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: ListDataType - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed
ObjectCreator Creating object of type: AttributeSection - named {'content': 'Override Tracking', '_type': 'AttributeSectionName'}
ObjectCreator Creating object of type: AttributeSectionName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'Overrides', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
In AttSection post-init for Override Tracking, is_optional = None


KWARGS are {'prefix': '_', 'name': ClassName(content='Formulas', _type='ClassName'), 'parenthetical': '', 'attributes': [Attribute(one_liner=OneLiner(_type='OneLiner', content='The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line'), elaboration=[], annotations=[Annotation(label='Note', content='even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.', emoji='', elaboration=[Paragraph(_type='Paragraph', content="Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"), Paragraph(_type='Paragraph', content='Last paragraph here\n')], _type='Annotation')], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='default', _type='AttributeName'), parenthetical='optional Derivation', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Derivation', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='For derived attributes, the rule or formula for calculating the value _'), elaboration=[], annotations=[Annotation(label='Issue', content='on insert vs on access?', emoji='', elaboration=[], _type='Annotation')], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='derivation', _type='AttributeName'), parenthetical='optional Derivation', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Derivation', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='Any validation rules specific to this attribute _'), elaboration=[], annotations=[Annotation(label='Note', content='from Class.constraints', emoji='', elaboration=[], _type='Annotation')], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='constraints', _type='AttributeName'), parenthetical='ListOf Constraints', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Constraints', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])], 'attribute_sections': [AttributeSection(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='AttributeSection', prefix='__', name=AttributeSectionName(content='Override Tracking', _type='AttributeSectionName'), parenthetical='', abbreviation=None, is_optional=IsOptional(t_value=False, _type='IsOptional'), attributes=[Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='Overrides', _type='AttributeName'), parenthetical='', abbreviation=None, data_type_clause=None, overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])])]}
{
  "prefix": "_",
  "name": {
    "content": "Formulas",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line"
      },
      "annotations": [
        {
          "label": "Note",
          "content": "even when an Attribute has a default derivation, there\u2019s no guarantee that every instance will have an assigned value. Example needed.",
          "emoji": "",
          "elaboration": [
            {
              "_type": "Paragraph",
              "content": "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"
            },
            {
              "_type": "Paragraph",
              "content": "Last paragraph here\n"
            }
          ],
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "default",
        "_type": "AttributeName"
      },
      "parenthetical": "optional Derivation",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Derivation",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "For derived attributes, the rule or formula for calculating the value _"
      },
      "annotations": [
        {
          "label": "Issue",
          "content": "on insert vs on access?",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "derivation",
        "_type": "AttributeName"
      },
      "parenthetical": "optional Derivation",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Derivation",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "Any validation rules specific to this attribute _"
      },
      "annotations": [
        {
          "label": "Note",
          "content": "from Class.constraints",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "constraints",
        "_type": "AttributeName"
      },
      "parenthetical": "ListOf Constraints",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Constraints",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ],
  "attribute_sections": [
    {
      "is_embellishment": false,
      "_type": "AttributeSection",
      "prefix": "__",
      "name": {
        "content": "Override Tracking",
        "_type": "AttributeSectionName"
      },
      "parenthetical": "",
      "is_optional": {
        "t_value": false,
        "_type": "IsOptional"
      },
      "attributes": [
        {
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "Overrides",
            "_type": "AttributeName"
          },
          "parenthetical": ""
        }
      ]
    }
  ]
}
...Createed object of type: Class
... = Class: Formulas
final object is  {
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Formulas",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "is_value_type": false,
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The rule or formula for calculating the value, if no value is supplied\nNow running to a second line with the parenthentical on yet a third line"
      },
      "annotations": [
        {
          "label": "Note",
          "content": "even when an Attribute has a default derivation, there\u2019s no guarantee that every instance will have an assigned value. Example needed.",
          "emoji": "",
          "elaboration": [
            {
              "_type": "Paragraph",
              "content": "Yes, it handled extra lines.  Let's see about additional paras for an annotation\n"
            },
            {
              "_type": "Paragraph",
              "content": "Last paragraph here\n"
            }
          ],
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "default",
        "_type": "AttributeName"
      },
      "parenthetical": "optional Derivation",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Derivation",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "For derived attributes, the rule or formula for calculating the value _"
      },
      "annotations": [
        {
          "label": "Issue",
          "content": "on insert vs on access?",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "derivation",
        "_type": "AttributeName"
      },
      "parenthetical": "optional Derivation",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Derivation",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "Any validation rules specific to this attribute _"
      },
      "annotations": [
        {
          "label": "Note",
          "content": "from Class.constraints",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "constraints",
        "_type": "AttributeName"
      },
      "parenthetical": "ListOf Constraints",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Constraints",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ],
  "attribute_sections": [
    {
      "is_embellishment": false,
      "_type": "AttributeSection",
      "prefix": "__",
      "name": {
        "content": "Override Tracking",
        "_type": "AttributeSectionName"
      },
      "parenthetical": "",
      "is_optional": {
        "t_value": false,
        "_type": "IsOptional"
      },
      "attributes": [
        {
          "is_embellishment": false,
          "_type": "Attribute",
          "prefix": "-",
          "name": {
            "content": "Overrides",
            "_type": "AttributeName"
          },
          "parenthetical": ""
        }
      ]
    }
  ]
}
ObjectCreator Creating object of type: Class - named {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the derivation rule _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the derivation in a programming language _'}, 'parenthetical': 'CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'statement', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'expression', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='ValueType Derivation\nA rule or formula for deriving the value of an attribute', _type='ClassName'), 'parenthetical': '', 'plural': ' Derivations\n', 'attributes': [Attribute(one_liner=OneLiner(_type='OneLiner', content='An English language statement of the derivation rule _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='statement', _type='AttributeName'), parenthetical='RichText', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='RichText', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='The formal expression of the derivation in a programming language _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='expression', _type='AttributeName'), parenthetical='CodeExpression', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='CodeExpression', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])]}
{
  "prefix": "_",
  "name": {
    "content": "ValueType Derivation\nA rule or formula for deriving the value of an attribute",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Derivations\n",
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "An English language statement of the derivation rule _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "statement",
        "_type": "AttributeName"
      },
      "parenthetical": "RichText",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "RichText",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The formal expression of the derivation in a programming language _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "expression",
        "_type": "AttributeName"
      },
      "parenthetical": "CodeExpression",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "CodeExpression",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
...Createed object of type: Class
... = Class: ValueType Derivation
A rule or formula for deriving the value of an attribute
final object is  {
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "ValueType Derivation\nA rule or formula for deriving the value of an attribute",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Derivations\n",
  "is_value_type": false,
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "An English language statement of the derivation rule _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "statement",
        "_type": "AttributeName"
      },
      "parenthetical": "RichText",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "RichText",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The formal expression of the derivation in a programming language _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "expression",
        "_type": "AttributeName"
      },
      "parenthetical": "CodeExpression",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "CodeExpression",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
ObjectCreator Creating object of type: Class - named {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'statement', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'An English language statement of the constraint _'}, 'parenthetical': 'RichText', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'expression', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The formal expression of the constraint in a programming language'}, 'parenthetical': 'e.g., OCL _(CodeExpression', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'severity', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Warning** - nothing fatal; just a caution'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Error** - serious. Fix now'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Message', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'statement', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'expression', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'severity', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: Attribute - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'Message', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', _type='ClassName'), 'parenthetical': '', 'plural': ' Constraints\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [Attribute(one_liner=OneLiner(_type='OneLiner', content='An English language statement of the constraint _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='statement', _type='AttributeName'), parenthetical='RichText', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='RichText', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='The formal expression of the constraint in a programming language'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='expression', _type='AttributeName'), parenthetical='e.g., OCL _(CodeExpression', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Invented Name', _type='ClassName'), as_value_type=AsValue(t_value=True, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='severity', _type='AttributeName'), parenthetical='Code', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Code', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='**Warning** - nothing fatal; just a caution'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=None, parenthetical='', abbreviation=None, data_type_clause=None, overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='**Error** - serious. Fix now'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=None, parenthetical='', abbreviation=None, data_type_clause=None, overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='Message', _type='AttributeName'), parenthetical='Template', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Template', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])]}
{
  "prefix": "_",
  "name": {
    "content": "ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Constraints\n",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "An English language statement of the constraint _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "statement",
        "_type": "AttributeName"
      },
      "parenthetical": "RichText",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "RichText",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The formal expression of the constraint in a programming language"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "expression",
        "_type": "AttributeName"
      },
      "parenthetical": "e.g., OCL _(CodeExpression",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Invented Name",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": true,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "severity",
        "_type": "AttributeName"
      },
      "parenthetical": "Code",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Code",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "**Warning** - nothing fatal; just a caution"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "parenthetical": ""
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "**Error** - serious. Fix now"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "parenthetical": ""
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "Message",
        "_type": "AttributeName"
      },
      "parenthetical": "Template",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Template",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
...Createed object of type: Class
... = Class: ValueType Constraint
A rule, condition, or validation that must be satisfied by the model
final object is  {
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Constraints\n",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "is_value_type": false,
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "An English language statement of the constraint _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "statement",
        "_type": "AttributeName"
      },
      "parenthetical": "RichText",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "RichText",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The formal expression of the constraint in a programming language"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "expression",
        "_type": "AttributeName"
      },
      "parenthetical": "e.g., OCL _(CodeExpression",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Invented Name",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": true,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "severity",
        "_type": "AttributeName"
      },
      "parenthetical": "Code",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Code",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "**Warning** - nothing fatal; just a caution"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "parenthetical": ""
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "**Error** - serious. Fix now"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "parenthetical": ""
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "Message",
        "_type": "AttributeName"
      },
      "parenthetical": "Template",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Template",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
ObjectCreator Creating object of type: Class - named {'content': 'Class Constraint', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Class Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]} 
ObjectCreator Creating object of type: ClassName - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='Class Constraint', _type='ClassName'), 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Class.', _type='ClassName')]}
{
  "prefix": "_",
  "name": {
    "content": "Class Constraint",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "based_on": [
    {
      "content": "Class.",
      "_type": "ClassName"
    }
  ]
}
...Createed object of type: Class
... = Class: Class Constraint
final object is  {
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Class Constraint",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "based_on": [
    {
      "content": "Class.",
      "_type": "ClassName"
    }
  ],
  "is_value_type": false
}
ObjectCreator Creating object of type: Class - named {'content': 'Attribute Constraint', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Attribute Constraint', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]} 
ObjectCreator Creating object of type: ClassName - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='Attribute Constraint', _type='ClassName'), 'parenthetical': '', 'subtype_of': [(ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'based_on': [ClassName(content='Attribute', _type='ClassName')]}
{
  "prefix": "_",
  "name": {
    "content": "Attribute Constraint",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "based_on": [
    {
      "content": "Attribute",
      "_type": "ClassName"
    }
  ]
}
...Createed object of type: Class
... = Class: Attribute Constraint
final object is  {
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Attribute Constraint",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "based_on": [
    {
      "content": "Attribute",
      "_type": "ClassName"
    }
  ],
  "is_value_type": false
}
ObjectCreator Creating object of type: Class - named {'content': 'CodeExpression', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Language', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the programming language'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'OCL: Object Constraint Language'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': 'Java: Java'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Expression', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'Language', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: Attribute - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'Expression', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='CodeExpression', _type='ClassName'), 'parenthetical': '', 'attributes': [Attribute(one_liner=OneLiner(_type='OneLiner', content='the programming language'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='Language', _type='AttributeName'), parenthetical='Code', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Code', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='OCL: Object Constraint Language'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=None, parenthetical='', abbreviation=None, data_type_clause=None, overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='Java: Java'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=None, parenthetical='', abbreviation=None, data_type_clause=None, overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='Expression', _type='AttributeName'), parenthetical='String', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='String', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])]}
{
  "prefix": "_",
  "name": {
    "content": "CodeExpression",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the programming language"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "Language",
        "_type": "AttributeName"
      },
      "parenthetical": "Code",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Code",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "OCL: Object Constraint Language"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "parenthetical": ""
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "Java: Java"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "parenthetical": ""
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "Expression",
        "_type": "AttributeName"
      },
      "parenthetical": "String",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "String",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
...Createed object of type: Class
... = Class: CodeExpression
final object is  {
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "CodeExpression",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "is_value_type": false,
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the programming language"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "Language",
        "_type": "AttributeName"
      },
      "parenthetical": "Code",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Code",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "OCL: Object Constraint Language"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "parenthetical": ""
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "Java: Java"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "parenthetical": ""
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "Expression",
        "_type": "AttributeName"
      },
      "parenthetical": "String",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "String",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
ObjectCreator Creating object of type: SubjectB - named {'content': 'Methods', '_type': 'SubjectName'}
ObjectCreator Creating object of type: SubjectName - named Unnamed
ObjectCreator Creating object of type: Class - named {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'parameters', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The input parameters of the method _'}, 'parenthetical': 'ListOf Parameters', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'returnType', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the value returned by the method _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'parameters', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: ListDataType - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'returnType', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='Method\nA behavior or operation associated with a class', _type='ClassName'), 'parenthetical': '', 'plural': ' Methods\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [Attribute(one_liner=OneLiner(_type='OneLiner', content='The input parameters of the method _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='parameters', _type='AttributeName'), parenthetical='ListOf Parameters', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Parameters', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='The data type of the value returned by the method _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='returnType', _type='AttributeName'), parenthetical='DataType', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='DataType', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])]}
{
  "prefix": "_",
  "name": {
    "content": "Method\nA behavior or operation associated with a class",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Methods\n",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The input parameters of the method _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "parameters",
        "_type": "AttributeName"
      },
      "parenthetical": "ListOf Parameters",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Parameters",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The data type of the value returned by the method _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "returnType",
        "_type": "AttributeName"
      },
      "parenthetical": "DataType",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "DataType",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
...Createed object of type: Class
... = Class: Method
A behavior or operation associated with a class
final object is  {
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Method\nA behavior or operation associated with a class",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Methods\n",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "is_value_type": false,
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The input parameters of the method _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "parameters",
        "_type": "AttributeName"
      },
      "parenthetical": "ListOf Parameters",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "Parameters",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The data type of the value returned by the method _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "returnType",
        "_type": "AttributeName"
      },
      "parenthetical": "DataType",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "DataType",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
ObjectCreator Creating object of type: Class - named {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'}, 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'type', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The data type of the parameter _'}, 'parenthetical': 'DataType', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'cardinality', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'The cardinality of the parameter'}, 'parenthetical': 'e.g., optional, required', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'type', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'cardinality', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='Parameter\nAn input to a method', _type='ClassName'), 'parenthetical': '', 'plural': ' Parameters\n', 'subtype_of': [(ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [Attribute(one_liner=OneLiner(_type='OneLiner', content='The data type of the parameter _'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='type', _type='AttributeName'), parenthetical='DataType', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='DataType', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='The cardinality of the parameter'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='cardinality', _type='AttributeName'), parenthetical='e.g., optional, required', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Invented Name', _type='ClassName'), as_value_type=AsValue(t_value=True, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])]}
{
  "prefix": "_",
  "name": {
    "content": "Parameter\nAn input to a method",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Parameters\n",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The data type of the parameter _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "type",
        "_type": "AttributeName"
      },
      "parenthetical": "DataType",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "DataType",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The cardinality of the parameter"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "cardinality",
        "_type": "AttributeName"
      },
      "parenthetical": "e.g., optional, required",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Invented Name",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": true,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
...Createed object of type: Class
... = Class: Parameter
An input to a method
final object is  {
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Parameter\nAn input to a method",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "plural": " Parameters\n",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "is_value_type": false,
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The data type of the parameter _"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "type",
        "_type": "AttributeName"
      },
      "parenthetical": "DataType",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "DataType",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "The cardinality of the parameter"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "cardinality",
        "_type": "AttributeName"
      },
      "parenthetical": "e.g., optional, required",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Invented Name",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": true,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
ObjectCreator Creating object of type: SubjectB - named {'content': 'Data Types', '_type': 'SubjectName'}
ObjectCreator Creating object of type: SubjectName - named Unnamed
ObjectCreator Creating object of type: Paragraph - named Unnamed
ObjectCreator Creating object of type: Class - named {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'coreClass', '_type': 'AttributeName'}, 'parenthetical': 'Class', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'coreClass', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='Simple Data Type\nSubtpeOf DataType', _type='ClassName'), 'parenthetical': '', 'attributes': [Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='coreClass', _type='AttributeName'), parenthetical='Class', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Class', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])]}
{
  "prefix": "_",
  "name": {
    "content": "Simple Data Type\nSubtpeOf DataType",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "attributes": [
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "coreClass",
        "_type": "AttributeName"
      },
      "parenthetical": "Class",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Class",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
...Createed object of type: Class
... = Class: Simple Data Type
SubtpeOf DataType
final object is  {
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Simple Data Type\nSubtpeOf DataType",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "is_value_type": false,
  "attributes": [
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "coreClass",
        "_type": "AttributeName"
      },
      "parenthetical": "Class",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Class",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
ObjectCreator Creating object of type: Class - named {'content': 'Complex Data Type', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Complex Data Type', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregation', '_type': 'AttributeName'}, 'parenthetical': 'Aggregating Operator', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'aggregatedTypes', '_type': 'AttributeName'}, 'parenthetical': 'List of DataTypes', 'data_type_clause': {'data_type': {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'aggregation', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'aggregatedTypes', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: ListDataType - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='Complex Data Type', _type='ClassName'), 'parenthetical': '', 'attributes': [Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='aggregation', _type='AttributeName'), parenthetical='Aggregating Operator', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Aggregating Operator', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='aggregatedTypes', _type='AttributeName'), parenthetical='List of DataTypes', abbreviation=None, data_type_clause=DataTypeClause(data_type=ListDataType(_type='ListDataType', element_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='DataTypes', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue'))), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])]}
{
  "prefix": "_",
  "name": {
    "content": "Complex Data Type",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "attributes": [
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "aggregation",
        "_type": "AttributeName"
      },
      "parenthetical": "Aggregating Operator",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Aggregating Operator",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "aggregatedTypes",
        "_type": "AttributeName"
      },
      "parenthetical": "List of DataTypes",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "DataTypes",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
...Createed object of type: Class
... = Class: Complex Data Type
final object is  {
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Complex Data Type",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "is_value_type": false,
  "attributes": [
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "aggregation",
        "_type": "AttributeName"
      },
      "parenthetical": "Aggregating Operator",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Aggregating Operator",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "aggregatedTypes",
        "_type": "AttributeName"
      },
      "parenthetical": "List of DataTypes",
      "data_type_clause": {
        "data_type": {
          "_type": "ListDataType",
          "element_type": {
            "_type": "BaseDataType",
            "class_name": {
              "content": "DataTypes",
              "_type": "ClassName"
            },
            "as_value_type": {
              "t_value": false,
              "_type": "AsValue"
            }
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
ObjectCreator Creating object of type: Class - named {'content': 'Aggregating Operator', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'Name', '_type': 'AttributeName'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**SetOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**ListOf**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'one_liner': {'_type': 'OneLiner', 'content': '**Mapping**'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'arity', '_type': 'AttributeName'}, 'parenthetical': 'Integer', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'spelling', '_type': 'AttributeName'}, 'parenthetical': 'Template', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'Name', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: Attribute - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: Attribute - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'arity', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'spelling', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='Aggregating Operator', _type='ClassName'), 'parenthetical': '', 'attributes': [Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='Name', _type='AttributeName'), parenthetical='Code', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Code', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='**SetOf**'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=None, parenthetical='', abbreviation=None, data_type_clause=None, overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='**ListOf**'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=None, parenthetical='', abbreviation=None, data_type_clause=None, overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='**Mapping**'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=None, parenthetical='', abbreviation=None, data_type_clause=None, overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='arity', _type='AttributeName'), parenthetical='Integer', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Integer', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='spelling', _type='AttributeName'), parenthetical='Template', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Template', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])]}
{
  "prefix": "_",
  "name": {
    "content": "Aggregating Operator",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "attributes": [
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "Name",
        "_type": "AttributeName"
      },
      "parenthetical": "Code",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Code",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "**SetOf**"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "parenthetical": ""
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "**ListOf**"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "parenthetical": ""
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "**Mapping**"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "parenthetical": ""
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "arity",
        "_type": "AttributeName"
      },
      "parenthetical": "Integer",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Integer",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "spelling",
        "_type": "AttributeName"
      },
      "parenthetical": "Template",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Template",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
...Createed object of type: Class
... = Class: Aggregating Operator
final object is  {
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Aggregating Operator",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "is_value_type": false,
  "attributes": [
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "Name",
        "_type": "AttributeName"
      },
      "parenthetical": "Code",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Code",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "**SetOf**"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "parenthetical": ""
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "**ListOf**"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "parenthetical": ""
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "**Mapping**"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "parenthetical": ""
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "arity",
        "_type": "AttributeName"
      },
      "parenthetical": "Integer",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Integer",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "spelling",
        "_type": "AttributeName"
      },
      "parenthetical": "Template",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Template",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    }
  ]
}
ObjectCreator Creating object of type: SubjectB - named {'content': 'Low level Data Types', '_type': 'SubjectName'}
ObjectCreator Creating object of type: SubjectName - named Unnamed
ObjectCreator Creating object of type: Paragraph - named Unnamed
ObjectCreator Creating object of type: Class - named {'content': 'ValueType CamelName', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'ValueType CamelName', '_type': 'ClassName'}, 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n'}], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value the string', '_type': 'AttributeName'}, 'parenthetical': 'String', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')]}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: Paragraph - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'value the string', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Constraint - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed
ObjectCreator Creating object of type: Paragraph - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='ValueType CamelName', _type='ClassName'), 'parenthetical': '', 'elaboration': [Paragraph(_type='Paragraph', content='A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n')], 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [Attribute(one_liner=None, elaboration=[], annotations=[Annotation(label='Example', content='"firstName", "orderDate", "customerID"', emoji='', elaboration=[Paragraph(_type='Paragraph', content='> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n')], _type='Annotation'), Annotation(label='ModelingNote', content='* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.', emoji='', elaboration=[], _type='Annotation')], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='value the string', _type='AttributeName'), parenthetical='String', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='String', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[Constraint(one_liner=[OneLiner(_type='OneLiner', content=' Must follow the camel case naming convention and not be empty.\n')], elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Constraint', english=Paragraph(_type='Paragraph', content=''), code=None, message=Paragraph(_type='Paragraph', content=''), severity=None)])]}
{
  "prefix": "_",
  "name": {
    "content": "ValueType CamelName",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "elaboration": [
    {
      "_type": "Paragraph",
      "content": "A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n"
    }
  ],
  "subtype_of": [
    "UnserializablePiece"
  ],
  "attributes": [
    {
      "annotations": [
        {
          "label": "Example",
          "content": "\"firstName\", \"orderDate\", \"customerID\"",
          "emoji": "",
          "elaboration": [
            {
              "_type": "Paragraph",
              "content": "> \ud83d\udcdd ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n"
            }
          ],
          "_type": "Annotation"
        },
        {
          "label": "ModelingNote",
          "content": "* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "value the string",
        "_type": "AttributeName"
      },
      "parenthetical": "String",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "String",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "constraints": [
        {
          "one_liner": [
            {
              "_type": "OneLiner",
              "content": " Must follow the camel case naming convention and not be empty.\n"
            }
          ],
          "is_embellishment": false,
          "_type": "Constraint",
          "english": {
            "_type": "Paragraph",
            "content": ""
          },
          "message": {
            "_type": "Paragraph",
            "content": ""
          }
        }
      ]
    }
  ]
}
...Createed object of type: Class
... = Class: ValueType CamelName
final object is  {
  "elaboration": [
    {
      "_type": "Paragraph",
      "content": "A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.\n"
    }
  ],
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "ValueType CamelName",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "is_value_type": false,
  "attributes": [
    {
      "annotations": [
        {
          "label": "Example",
          "content": "\"firstName\", \"orderDate\", \"customerID\"",
          "emoji": "",
          "elaboration": [
            {
              "_type": "Paragraph",
              "content": "> \ud83d\udcdd ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.\n"
            }
          ],
          "_type": "Annotation"
        },
        {
          "label": "ModelingNote",
          "content": "* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.",
          "emoji": "",
          "_type": "Annotation"
        }
      ],
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "value the string",
        "_type": "AttributeName"
      },
      "parenthetical": "String",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "String",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "constraints": [
        {
          "one_liner": [
            {
              "_type": "OneLiner",
              "content": " Must follow the camel case naming convention and not be empty.\n"
            }
          ],
          "is_embellishment": false,
          "_type": "Constraint",
          "english": {
            "_type": "Paragraph",
            "content": ""
          },
          "message": {
            "_type": "Paragraph",
            "content": ""
          }
        }
      ]
    }
  ]
}
ObjectCreator Creating object of type: Class - named {'content': 'UpperCamel', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a capital letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='UpperCamel', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content='a CamelName that begins with a capital letter'), 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with an upper case letter.\n', 'annotations': [Annotation(label='Example', content='_ "Customer", "ProductCategory", "PaymentMethod"', emoji='', elaboration=[], _type='Annotation')]}
{
  "prefix": "_",
  "name": {
    "content": "UpperCamel",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "a CamelName that begins with a capital letter"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "where": " content begins with an upper case letter.\n",
  "annotations": [
    {
      "label": "Example",
      "content": "_ \"Customer\", \"ProductCategory\", \"PaymentMethod\"",
      "emoji": "",
      "_type": "Annotation"
    }
  ]
}
...Createed object of type: Class
... = Class: UpperCamel
final object is  {
  "one_liner": {
    "_type": "OneLiner",
    "content": "a CamelName that begins with a capital letter"
  },
  "annotations": [
    {
      "label": "Example",
      "content": "_ \"Customer\", \"ProductCategory\", \"PaymentMethod\"",
      "emoji": "",
      "_type": "Annotation"
    }
  ],
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "UpperCamel",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "is_value_type": false,
  "where": " content begins with an upper case letter.\n"
}
ObjectCreator Creating object of type: Class - named {'content': 'LowerCamel', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'LowerCamel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'a CamelName that begins with a lower case letter'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='LowerCamel', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content='a CamelName that begins with a lower case letter'), 'parenthetical': '', 'subtype_of': [(ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'where': ' content begins with a lower case letter.\n', 'annotations': [Annotation(label='Example', content='"firstName", "orderTotal", "shippingAddress"', emoji='', elaboration=[], _type='Annotation')]}
{
  "prefix": "_",
  "name": {
    "content": "LowerCamel",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "a CamelName that begins with a lower case letter"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "where": " content begins with a lower case letter.\n",
  "annotations": [
    {
      "label": "Example",
      "content": "\"firstName\", \"orderTotal\", \"shippingAddress\"",
      "emoji": "",
      "_type": "Annotation"
    }
  ]
}
...Createed object of type: Class
... = Class: LowerCamel
final object is  {
  "one_liner": {
    "_type": "OneLiner",
    "content": "a CamelName that begins with a lower case letter"
  },
  "annotations": [
    {
      "label": "Example",
      "content": "\"firstName\", \"orderTotal\", \"shippingAddress\"",
      "emoji": "",
      "_type": "Annotation"
    }
  ],
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "LowerCamel",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "is_value_type": false,
  "where": " content begins with a lower case letter.\n"
}
ObjectCreator Creating object of type: Class - named {'content': 'Qualified Camel', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'Qualified Camel', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'an expression consisting of Camel Names separated by periods'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')]}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: Constraint - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='Qualified Camel', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content='an expression consisting of Camel Names separated by periods'), 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'constraints': [Constraint(one_liner=[OneLiner(_type='OneLiner', content=' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n')], elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Constraint', english=Paragraph(_type='Paragraph', content=''), code=None, message=Paragraph(_type='Paragraph', content=''), severity=None)]}
{
  "prefix": "_",
  "name": {
    "content": "Qualified Camel",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "an expression consisting of Camel Names separated by periods"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "constraints": [
    {
      "one_liner": [
        {
          "_type": "OneLiner",
          "content": " content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n"
        }
      ],
      "is_embellishment": false,
      "_type": "Constraint",
      "english": {
        "_type": "Paragraph",
        "content": ""
      },
      "message": {
        "_type": "Paragraph",
        "content": ""
      }
    }
  ]
}
...Createed object of type: Class
... = Class: Qualified Camel
final object is  {
  "one_liner": {
    "_type": "OneLiner",
    "content": "an expression consisting of Camel Names separated by periods"
  },
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "Qualified Camel",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "is_value_type": false,
  "constraints": [
    {
      "one_liner": [
        {
          "_type": "OneLiner",
          "content": " content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.\n"
        }
      ],
      "is_embellishment": false,
      "_type": "Constraint",
      "english": {
        "_type": "Paragraph",
        "content": ""
      },
      "message": {
        "_type": "Paragraph",
        "content": ""
      }
    }
  ]
}
ObjectCreator Creating object of type: Class - named {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'format', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the rich text coding language used'}, 'parenthetical': 'Code', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'HTML', '_type': 'AttributeName'}, 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'MarkDown', '_type': 'AttributeName'}, 'parenthetical': ''}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'value', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'format', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'HTML', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'MarkDown', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='RichText.  A string with markup for block level formatting.', _type='ClassName'), 'parenthetical': '', 'subtype_of': [(ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [Attribute(one_liner=OneLiner(_type='OneLiner', content='the string content'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='value', _type='AttributeName'), parenthetical='string', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='string', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=OneLiner(_type='OneLiner', content='the rich text coding language used'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='format', _type='AttributeName'), parenthetical='Code', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='Code', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='HTML', _type='AttributeName'), parenthetical='', abbreviation=None, data_type_clause=None, overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[]), Attribute(one_liner=None, elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='MarkDown', _type='AttributeName'), parenthetical='', abbreviation=None, data_type_clause=None, overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[])]}
{
  "prefix": "_",
  "name": {
    "content": "RichText.  A string with markup for block level formatting.",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the string content"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "value",
        "_type": "AttributeName"
      },
      "parenthetical": "string",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "string",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the rich text coding language used"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "format",
        "_type": "AttributeName"
      },
      "parenthetical": "Code",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Code",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "HTML",
        "_type": "AttributeName"
      },
      "parenthetical": ""
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "MarkDown",
        "_type": "AttributeName"
      },
      "parenthetical": ""
    }
  ]
}
...Createed object of type: Class
... = Class: RichText.  A string with markup for block level formatting.
final object is  {
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "RichText.  A string with markup for block level formatting.",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "is_value_type": false,
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the string content"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "value",
        "_type": "AttributeName"
      },
      "parenthetical": "string",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "string",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the rich text coding language used"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "format",
        "_type": "AttributeName"
      },
      "parenthetical": "Code",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "Code",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      }
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "HTML",
        "_type": "AttributeName"
      },
      "parenthetical": ""
    },
    {
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "MarkDown",
        "_type": "AttributeName"
      },
      "parenthetical": ""
    }
  ]
}
ObjectCreator Creating object of type: Class - named {'content': 'RichLine', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'RichLine', '_type': 'ClassName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'String with markup for line level formatting.'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': {'content': 'value', '_type': 'AttributeName'}, 'one_liner': {'_type': 'OneLiner', 'content': 'the string content'}, 'parenthetical': 'string', 'data_type_clause': {'data_type': {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}, 'is_optional_lit': {'t_value': False, '_type': 'IsOptional'}, '_type': 'DataTypeClause'}, 'constraints': [{'_type': 'Constraint', 'one_liner': [OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')]}]}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: Attribute - named {'content': 'value', '_type': 'AttributeName'}
ObjectCreator Creating object of type: AttributeName - named Unnamed
ObjectCreator Creating object of type: OneLiner - named Unnamed
ObjectCreator Creating object of type: DataTypeClause - named Unnamed
ObjectCreator Creating object of type: BaseDataType - named Unnamed
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: AsValue - named Unnamed
ObjectCreator Creating object of type: IsOptional - named Unnamed
ObjectCreator Creating object of type: Constraint - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='RichLine', _type='ClassName'), 'one_liner': OneLiner(_type='OneLiner', content='String with markup for line level formatting.'), 'parenthetical': '', 'subtype_of': [(ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'attributes': [Attribute(one_liner=OneLiner(_type='OneLiner', content='the string content'), elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Attribute', prefix='-', name=AttributeName(content='value', _type='AttributeName'), parenthetical='string', abbreviation=None, data_type_clause=DataTypeClause(data_type=BaseDataType(_type='BaseDataType', class_name=ClassName(content='string', _type='ClassName'), as_value_type=AsValue(t_value=False, _type='AsValue')), is_optional_lit=IsOptional(t_value=False, _type='IsOptional'), cardinality=None, _type='DataTypeClause'), overrides=None, inverse=None, inverse_of=None, derivation=None, default=None, constraints=[Constraint(one_liner=[OneLiner(_type='OneLiner', content=' must not containa line break or new line character\n')], elaboration=[], annotations=[], diagnostics=[], is_embellishment=False, _type='Constraint', english=Paragraph(_type='Paragraph', content=''), code=None, message=Paragraph(_type='Paragraph', content=''), severity=None)])]}
{
  "prefix": "_",
  "name": {
    "content": "RichLine",
    "_type": "ClassName"
  },
  "one_liner": {
    "_type": "OneLiner",
    "content": "String with markup for line level formatting."
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the string content"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "value",
        "_type": "AttributeName"
      },
      "parenthetical": "string",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "string",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "constraints": [
        {
          "one_liner": [
            {
              "_type": "OneLiner",
              "content": " must not containa line break or new line character\n"
            }
          ],
          "is_embellishment": false,
          "_type": "Constraint",
          "english": {
            "_type": "Paragraph",
            "content": ""
          },
          "message": {
            "_type": "Paragraph",
            "content": ""
          }
        }
      ]
    }
  ]
}
...Createed object of type: Class
... = Class: RichLine
final object is  {
  "one_liner": {
    "_type": "OneLiner",
    "content": "String with markup for line level formatting."
  },
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "RichLine",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece"
  ],
  "is_value_type": false,
  "attributes": [
    {
      "one_liner": {
        "_type": "OneLiner",
        "content": "the string content"
      },
      "is_embellishment": false,
      "_type": "Attribute",
      "prefix": "-",
      "name": {
        "content": "value",
        "_type": "AttributeName"
      },
      "parenthetical": "string",
      "data_type_clause": {
        "data_type": {
          "_type": "BaseDataType",
          "class_name": {
            "content": "string",
            "_type": "ClassName"
          },
          "as_value_type": {
            "t_value": false,
            "_type": "AsValue"
          }
        },
        "is_optional_lit": {
          "t_value": false,
          "_type": "IsOptional"
        },
        "_type": "DataTypeClause"
      },
      "constraints": [
        {
          "one_liner": [
            {
              "_type": "OneLiner",
              "content": " must not containa line break or new line character\n"
            }
          ],
          "is_embellishment": false,
          "_type": "Constraint",
          "english": {
            "_type": "Paragraph",
            "content": ""
          },
          "message": {
            "_type": "Paragraph",
            "content": ""
          }
        }
      ]
    }
  ]
}
ObjectCreator Creating object of type: Class - named {'content': 'PrimitiveType', '_type': 'ClassName'}
Tracing Class - type is <class 'dict'> to <class 'ldm.Literate_01.Class'>, dict = {'_type': 'Class', 'prefix': '_', 'name': {'content': 'PrimitiveType', '_type': 'ClassName'}, 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '', 'elaboration': [{'_type': 'Paragraph', 'content': '===\n'}]}]} 
ObjectCreator Creating object of type: ClassName - named Unnamed
ObjectCreator Creating object of type: Annotation - named Unnamed
ObjectCreator Creating object of type: Paragraph - named Unnamed


KWARGS are {'prefix': '_', 'name': ClassName(content='PrimitiveType', _type='ClassName'), 'parenthetical': '', 'subtype_of': [(ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName')), (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))], 'annotations': [Annotation(label='Values', content='', emoji='', elaboration=[Paragraph(_type='Paragraph', content='===\n')], _type='Annotation')]}
{
  "prefix": "_",
  "name": {
    "content": "PrimitiveType",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece",
    "UnserializablePiece"
  ],
  "annotations": [
    {
      "label": "Values",
      "content": "",
      "emoji": "",
      "elaboration": [
        {
          "_type": "Paragraph",
          "content": "===\n"
        }
      ],
      "_type": "Annotation"
    }
  ]
}
...Createed object of type: Class
... = Class: PrimitiveType
final object is  {
  "annotations": [
    {
      "label": "Values",
      "content": "",
      "emoji": "",
      "elaboration": [
        {
          "_type": "Paragraph",
          "content": "===\n"
        }
      ],
      "_type": "Annotation"
    }
  ],
  "is_embellishment": false,
  "_type": "Class",
  "prefix": "_",
  "name": {
    "content": "PrimitiveType",
    "_type": "ClassName"
  },
  "parenthetical": "",
  "subtype_of": [
    "UnserializablePiece",
    "UnserializablePiece"
  ],
  "is_value_type": false
}
ObjectCreator Creating object of type: SubjectB - named {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}
ObjectCreator Creating object of type: SubjectName - named Unnamed
ObjectCreator Creating object of type: SubjectC - named {'content': 'Annotation Types Used', '_type': 'SubjectName'}
ObjectCreator Creating object of type: SubjectName - named Unnamed
ObjectCreator Creating object of type: Paragraph - named Unnamed
ObjectCreator Creating object of type: Paragraph - named Unnamed
ObjectCreator Creating object of type: CodeBlock - named Unnamed
ObjectCreator Creating object of type: Paragraph - named Unnamed
ObjectCreator Creating object of type: SubjectB - named {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'}
ObjectCreator Creating object of type: SubjectName - named Unnamed
ObjectCreator Creating object of type: Paragraph - named Unnamed
Created model: <class 'ldm.Literate_01.LiterateModel'>

Phase: Validating model
Validating references...
Validation errors: 56

Phase: counting errors
{"Validation Error in Attribute: Required field 'data_type_clause' is missing": 16, "Validation Error in Class: For field 'based_on' - expected typing.Optional[typing.List[ldm.Literate_01.ClassName]], but got <class 'list'>": 6, "Validation Error in SubjectB: For field 'name' - expected <class 'class_casing.CamelCase'>, but got <class 'ldm.Literate_01.SubjectName'>": 8, "Validation Error in Constraint: For field 'one_liner' - expected typing.Optional[ldm.Literate_01.OneLiner], but got <class 'list'>": 5, "Validation Error in Class: For field 'abbreviation' - expected typing.Optional[class_casing.CamelCase], but got <class 'str'>": 1, "Validation Error in Class: For field 'subtype_of' - expected typing.Optional[typing.Dict[ldm.Literate_01.ClassName, ldm.Literate_01.SubtypingName]], but got <class 'list'>": 17, "Validation Error in Class: For field 'dependent_of' - expected typing.Optional[typing.List[ldm.Literate_01.ClassName]], but got <class 'list'>": 1, "Validation Error in Class: For field 'where' - expected typing.Optional[ldm.Literate_01.OneLiner], but got <class 'str'>": 3, "Validation Error in SubjectC: For field 'name' - expected <class 'class_casing.CamelCase'>, but got <class 'ldm.Literate_01.SubjectName'>": 2, "Validation Error in Attribute: Required field 'name' is missing": 7}
16 	 Validation Error in Attribute: Required field 'data_type_clause' is missing
6 	 Validation Error in Class: For field 'based_on' - expected typing.Optional[typing.List[ldm.Literate_01.ClassName]], but got <class 'list'>
8 	 Validation Error in SubjectB: For field 'name' - expected <class 'class_casing.CamelCase'>, but got <class 'ldm.Literate_01.SubjectName'>
5 	 Validation Error in Constraint: For field 'one_liner' - expected typing.Optional[ldm.Literate_01.OneLiner], but got <class 'list'>
1 	 Validation Error in Class: For field 'abbreviation' - expected typing.Optional[class_casing.CamelCase], but got <class 'str'>
17 	 Validation Error in Class: For field 'subtype_of' - expected typing.Optional[typing.Dict[ldm.Literate_01.ClassName, ldm.Literate_01.SubtypingName]], but got <class 'list'>
1 	 Validation Error in Class: For field 'dependent_of' - expected typing.Optional[typing.List[ldm.Literate_01.ClassName]], but got <class 'list'>
3 	 Validation Error in Class: For field 'where' - expected typing.Optional[ldm.Literate_01.OneLiner], but got <class 'str'>
2 	 Validation Error in SubjectC: For field 'name' - expected <class 'class_casing.CamelCase'>, but got <class 'ldm.Literate_01.SubjectName'>
7 	 Validation Error in Attribute: Required field 'name' is missing

Phase: Serialing model ...
Model serialized to ldm/ldm_models/Literate_results/Literate.model.json
Model serialized to ldm/ldm_models/Literate_results/Literate.model.yaml
..Created model files: ldm/ldm_models/Literate_results/Literate.model.json and ldm/ldm_models/Literate_results/Literate.model.yaml

Phase: Rendering back to markdown
Render header: [# ] None () 
Prefix is [ #  ] dislay is  None
8  subjects coming in model
Render header: [## ] Preliminaries () 
Prefix is [ ##  ] dislay is  Preliminaries
Render header: [_ ] Component (None) 
Prefix is [ _  ] dislay is  **Component**
Render header: [- ] normalName (optional reference String) 
Prefix is [ -  ] dislay is  ***normalName***
Render header: [- ] name (optional reference CamelName) 
Prefix is [ -  ] dislay is  ***name***
Render header: [- ] qualifiedName (optional reference QualifiedCamel) 
Prefix is [ -  ] dislay is  ***qualifiedName***
Render header: [- ] abbreviatedName (optional reference CamelName) 
Prefix is [ -  ] dislay is  ***abbreviatedName***
Render header: [- ] oneLiner (optional reference RichLine) 
Prefix is [ -  ] dislay is  ***oneLiner***
Render header: [- ] elaboration (optional reference RichText) 
Prefix is [ -  ] dislay is  ***elaboration***
Render header: [__ ] For Machinery () 
Prefix is [ __  ] dislay is  _For Machinery_
WARNING: No render for type <class 'class_pom_token.IsOptional'>
Render header: [- ] isEmbellishment (optional reference Boolean) 
Prefix is [ -  ] dislay is  ***isEmbellishment***
Render header: [_ ] AnnotationType (None) 
Prefix is [ _  ] dislay is  **AnnotationType**
WARNING: No render for type <class 'Literate_01.ClassName'>
Render header: [- ] emoji (optional reference Emoji) 
Prefix is [ -  ] dislay is  ***emoji***
Render header: [- ] emojiName (optional reference String) 
Prefix is [ -  ] dislay is  ***emojiName***
Render header: [- ] emojiUnicode (optional reference Unicode) 
Prefix is [ -  ] dislay is  ***emojiUnicode***
Render header: [- ] label (optional reference CamelName) 
Prefix is [ -  ] dislay is  ***label***
Render header: [- ] plural (optional reference UpperCamel) 
Prefix is [ -  ] dislay is  ***plural***
Render header: [- ] Purpose (None) 
Prefix is [ -  ] dislay is  ***Purpose***
Render header: [_ ] ValueType Annotation
A note or comment associated with a model element (None) 
Prefix is [ _  ] dislay is  **ValueType Annotation
A note or comment associated with a model element**
WARNING: No render for type <class 'Literate_01.ClassName'>
Render header: [- ] annotationType (optional reference Annotation Type) 
Prefix is [ -  ] dislay is  ***annotationType***
Render header: [- ] label (optional reference CamelName) 
Prefix is [ -  ] dislay is  ***label***
Render header: [- ] Emoji (optional reference Emoji) 
Prefix is [ -  ] dislay is  ***Emoji***
Render header: [- ] content (optional reference RichText) 
Prefix is [ -  ] dislay is  ***content***
Render header: [__ ] For Machinery () 
Prefix is [ __  ] dislay is  _For Machinery_
WARNING: No render for type <class 'class_pom_token.IsOptional'>
Render header: [- ] isEmbellishment (optional reference Boolean) 
Prefix is [ -  ] dislay is  ***isEmbellishment***
0  subjects coming in subject
Render header: [## ] The Model and its Subjects () 
Prefix is [ ##  ] dislay is  The Model and its Subjects
Render header: [_ ] LiterateDataModel (None) 
Prefix is [ _  ] dislay is  **LiterateDataModel**
Render header: [- ] name (optional reference UpperCamel) 
Prefix is [ -  ] dislay is  ***name***
Render header: [- ] allSubjects (optional List of reference Classes) 
Prefix is [ -  ] dislay is  ***allSubjects***
Render header: [- ] allClasses (optional List of reference Classes) 
Prefix is [ -  ] dislay is  ***allClasses***
Render header: [__ ] Modeling Configuration () 
Prefix is [ __  ] dislay is  _Modeling Configuration_
WARNING: No render for type <class 'class_pom_token.IsOptional'>
Render header: [- ] annotationTypes (optional List of reference AnnotationTypes) 
Prefix is [ -  ] dislay is  ***annotationTypes***
Render header: [- ] Preferred Coding Language (optional reference Coding Language) 
Prefix is [ -  ] dislay is  ***Preferred Coding Language***
Render header: [- ] alternate Coding Languages (optional List of reference Coding Languages) 
Prefix is [ -  ] dislay is  ***alternate Coding Languages***
Render header: [- ] Preferred Template Language (optional reference Template Language) 
Prefix is [ -  ] dislay is  ***Preferred Template Language***
Render header: [- ] alternate Template Languages (optional List of reference Template Languages) 
Prefix is [ -  ] dislay is  ***alternate Template Languages***
Render header: [- ] aiFunctions (optional List of reference String) 
Prefix is [ -  ] dislay is  ***aiFunctions***
Render header: [_ ] Subject
A specific topic or theme within the model (None) 
Prefix is [ _  ] dislay is  **Subject
A specific topic or theme within the model**
WARNING: No render for type <class 'Literate_01.ClassName'>
Render header: [- ] name (optional reference UpperCamel) 
Prefix is [ -  ] dislay is  ***name***
Render header: [- ] parentSubject (optional reference Subject) 
Prefix is [ -  ] dislay is  ***parentSubject***
Render header: [- ] Classes (optional List of reference Classes) 
Prefix is [ -  ] dislay is  ***Classes***
Render header: [- ] Each Class should be followed first by the classes that are dependent on it, and then (None) 
Prefix is [ -  ] dislay is  ***Each Class should be followed first by the classes that are dependent on it, and then***
Render header: [- ] By its subtype classes. (None) 
Prefix is [ -  ] dislay is  ***By its subtype classes.***
Render header: [- ] childSubjects (optional List of reference Subjects) 
Prefix is [ -  ] dislay is  ***childSubjects***
Render header: [_ ] SubjectArea
A main topic or area of focus within the model, containing related subjects and classes (None) 
Prefix is [ _  ] dislay is  **SubjectArea
A main topic or area of focus within the model, containing related subjects and classes**
1  subjects coming in subject
Render header: [### ] Classes () 
Prefix is [ ###  ] dislay is  Classes
Render header: [_ ] Class (None) 
Prefix is [ _  ] dislay is  **Class**
Render header: [- ] pluralForm (optional reference UpperName) 
Prefix is [ -  ] dislay is  ***pluralForm***
Render header: [- ] basedOn (optional Set of reference Classes) 
Prefix is [ -  ] dislay is  ***basedOn***
Render header: [- ] supertypes (optional reference es) 
Prefix is [ -  ] dislay is  ***supertypes***
Render header: [- ] subtypings (optional List of reference Subtypings) 
Prefix is [ -  ] dislay is  ***subtypings***
Render header: [- ] subtypes (optional List of reference Classes) 
Prefix is [ -  ] dislay is  ***subtypes***
Render header: [- ] attributes (optional List of reference Attributes) 
Prefix is [ -  ] dislay is  ***attributes***
Render header: [- ] attributeSections (optional List of reference AttributeSections) 
Prefix is [ -  ] dislay is  ***attributeSections***
Render header: [- ] constraints (optional List of reference Constraints) 
Prefix is [ -  ] dislay is  ***constraints***
Render header: [- ] methods (optional List of reference Methods) 
Prefix is [ -  ] dislay is  ***methods***
Render header: [__ ] Implied Attributes () 
Prefix is [ __  ] dislay is  _Implied Attributes_
WARNING: No render for type <class 'class_pom_token.IsOptional'>
Render header: [- ] dependents (optional Set of reference Classes) 
Prefix is [ -  ] dislay is  ***dependents***
Render header: [- ] UniqueKeys (optional Set of reference UniqueKeys) 
Prefix is [ -  ] dislay is  ***UniqueKeys***
Render header: [_ ] Subtyping (None) 
Prefix is [ _  ] dislay is  **Subtyping**
WARNING: No render for type <class 'Literate_01.ClassName'>
Render header: [- ] name (optional reference Upper Name) 
Prefix is [ -  ] dislay is  ***name***
Render header: [- ] is exclusive (optional reference Boolean) 
Prefix is [ -  ] dislay is  ***is exclusive***
Render header: [- ] is exhaustive (optional reference Boolean) 
Prefix is [ -  ] dislay is  ***is exhaustive***
Render header: [- ] classes (optional List of reference Classes) 
Prefix is [ -  ] dislay is  ***classes***
Render header: [_ ] ValueType (None) 
Prefix is [ _  ] dislay is  **ValueType**
Render header: [_ ] Reference Type (None) 
Prefix is [ _  ] dislay is  **Reference Type**
Render header: [_ ] CodeType
A data type or enumeration used in the model (None) 
Prefix is [ _  ] dislay is  **CodeType
A data type or enumeration used in the model**
Render header: [- ] List the code values as a bulletted list inside the description of the attribute in the form
‘code description’ (None) 
Prefix is [ -  ] dislay is  ***List the code values as a bulletted list inside the description of the attribute in the form
‘code description’***
Render header: [- ] A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive. (None) 
Prefix is [ -  ] dislay is  ***A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.***
Render header: [- ] isCaptive (optional reference Boolean) 
Prefix is [ -  ] dislay is  ***isCaptive***
Render header: [_ ] Code Value (None) 
Prefix is [ _  ] dislay is  **Code Value**
Render header: [- ] code (optional reference NameString) 
Prefix is [ -  ] dislay is  ***code***
Render header: [- ] description (optional reference RichText) 
Prefix is [ -  ] dislay is  ***description***
Render header: [_ ] Key (None) 
Prefix is [ _  ] dislay is  **Key**
WARNING: No render for type <class 'Literate_01.ClassName'>
Render header: [- ] keyAttributes (optional List of reference Attributes) 
Prefix is [ -  ] dislay is  ***keyAttributes***
Render header: [_ ] UniqueKey (None) 
Prefix is [ _  ] dislay is  **UniqueKey**
0  subjects coming in subject
Render header: [## ] Attributes () 
Prefix is [ ##  ] dislay is  Attributes
Render header: [_ ] Attribute Section (None) 
Prefix is [ _  ] dislay is  **Attribute Section**
WARNING: No render for type <class 'Literate_01.ClassName'>
Render header: [- ] isOptional (optional reference Boolean) 
Prefix is [ -  ] dislay is  ***isOptional***
Render header: [_ ] Attribute
A property or characteristic of a class (None) 
Prefix is [ _  ] dislay is  **Attribute
A property or characteristic of a class**
WARNING: No render for type <class 'Literate_01.ClassName'>
Render header: [- ] name (optional reference Lower Camel) 
Prefix is [ -  ] dislay is  ***name***
Render header: [- ] dataType (optional reference DataType) 
Prefix is [ -  ] dislay is  ***dataType***
Render header: [- ] List of Editions (None) 
Prefix is [ -  ] dislay is  ***List of Editions***
Render header: [- ] Set of Edition (None) 
Prefix is [ -  ] dislay is  ***Set of Edition***
Render header: [- ] ... and more complicated cases. (None) 
Prefix is [ -  ] dislay is  ***... and more complicated cases.***
Render header: [__ ] Cardinalities. () 
Prefix is [ __  ] dislay is  _Cardinalities._
WARNING: No render for type <class 'class_pom_token.IsOptional'>
Render header: [- ] isOptional (optional reference Boolean) 
Prefix is [ -  ] dislay is  ***isOptional***
Render header: [- ] cardinality (optional reference CardinalityCode) 
Prefix is [ -  ] dislay is  ***cardinality***
Render header: [- ] author (optional value Invented Name) 
Prefix is [ -  ] dislay is  ***author***
Render header: [- ] books (optional value Invented Name) 
Prefix is [ -  ] dislay is  ***books***
Render header: [__ ] Inverse Attributes () 
Prefix is [ __  ] dislay is  _Inverse Attributes_
WARNING: No render for type <class 'class_pom_token.IsOptional'>
Render header: [- ] isInvertible (optional reference Boolean) 
Prefix is [ -  ] dislay is  ***isInvertible***
Render header: [- ] inverseClass (optional reference Class) 
Prefix is [ -  ] dislay is  ***inverseClass***
Render header: [- ] inverseAttribute (optional reference Attribute) 
Prefix is [ -  ] dislay is  ***inverseAttribute***
Render header: [- ] inverseIsOptional (optional reference Attribute) 
Prefix is [ -  ] dislay is  ***inverseIsOptional***
Render header: [_ ] Formulas (None) 
Prefix is [ _  ] dislay is  **Formulas**
Render header: [- ] default (optional reference Derivation) 
Prefix is [ -  ] dislay is  ***default***
Render header: [- ] derivation (optional reference Derivation) 
Prefix is [ -  ] dislay is  ***derivation***
Render header: [- ] constraints (optional List of reference Constraints) 
Prefix is [ -  ] dislay is  ***constraints***
Render header: [__ ] Override Tracking () 
Prefix is [ __  ] dislay is  _Override Tracking_
WARNING: No render for type <class 'class_pom_token.IsOptional'>
Render header: [- ] Overrides (None) 
Prefix is [ -  ] dislay is  ***Overrides***
Render header: [_ ] ValueType Derivation
A rule or formula for deriving the value of an attribute (None) 
Prefix is [ _  ] dislay is  **ValueType Derivation
A rule or formula for deriving the value of an attribute**
Render header: [- ] statement (optional reference RichText) 
Prefix is [ -  ] dislay is  ***statement***
Render header: [- ] expression (optional reference CodeExpression) 
Prefix is [ -  ] dislay is  ***expression***
Render header: [_ ] ValueType Constraint
A rule, condition, or validation that must be satisfied by the model (None) 
Prefix is [ _  ] dislay is  **ValueType Constraint
A rule, condition, or validation that must be satisfied by the model**
Render header: [- ] statement (optional reference RichText) 
Prefix is [ -  ] dislay is  ***statement***
Render header: [- ] expression (optional value Invented Name) 
Prefix is [ -  ] dislay is  ***expression***
Render header: [- ] severity (optional reference Code) 
Prefix is [ -  ] dislay is  ***severity***
Render header: [- ] None (None) 
Prefix is [ -  ] dislay is  ***None***
Render header: [- ] None (None) 
Prefix is [ -  ] dislay is  ***None***
Render header: [- ] Message (optional reference Template) 
Prefix is [ -  ] dislay is  ***Message***
Render header: [_ ] Class Constraint (None) 
Prefix is [ _  ] dislay is  **Class Constraint**
WARNING: No render for type <class 'Literate_01.ClassName'>
Render header: [_ ] Attribute Constraint (None) 
Prefix is [ _  ] dislay is  **Attribute Constraint**
WARNING: No render for type <class 'Literate_01.ClassName'>
Render header: [_ ] CodeExpression (None) 
Prefix is [ _  ] dislay is  **CodeExpression**
Render header: [- ] Language (optional reference Code) 
Prefix is [ -  ] dislay is  ***Language***
Render header: [- ] None (None) 
Prefix is [ -  ] dislay is  ***None***
Render header: [- ] None (None) 
Prefix is [ -  ] dislay is  ***None***
Render header: [- ] Expression (optional reference String) 
Prefix is [ -  ] dislay is  ***Expression***
0  subjects coming in subject
Render header: [## ] Methods () 
Prefix is [ ##  ] dislay is  Methods
Render header: [_ ] Method
A behavior or operation associated with a class (None) 
Prefix is [ _  ] dislay is  **Method
A behavior or operation associated with a class**
Render header: [- ] parameters (optional List of reference Parameters) 
Prefix is [ -  ] dislay is  ***parameters***
Render header: [- ] returnType (optional reference DataType) 
Prefix is [ -  ] dislay is  ***returnType***
Render header: [_ ] Parameter
An input to a method (None) 
Prefix is [ _  ] dislay is  **Parameter
An input to a method**
Render header: [- ] type (optional reference DataType) 
Prefix is [ -  ] dislay is  ***type***
Render header: [- ] cardinality (optional value Invented Name) 
Prefix is [ -  ] dislay is  ***cardinality***
0  subjects coming in subject
Render header: [## ] Data Types () 
Prefix is [ ##  ] dislay is  Data Types
Render header: [_ ] Simple Data Type
SubtpeOf DataType (None) 
Prefix is [ _  ] dislay is  **Simple Data Type
SubtpeOf DataType**
Render header: [- ] coreClass (optional reference Class) 
Prefix is [ -  ] dislay is  ***coreClass***
Render header: [_ ] Complex Data Type (None) 
Prefix is [ _  ] dislay is  **Complex Data Type**
Render header: [- ] aggregation (optional reference Aggregating Operator) 
Prefix is [ -  ] dislay is  ***aggregation***
Render header: [- ] aggregatedTypes (optional List of reference DataTypes) 
Prefix is [ -  ] dislay is  ***aggregatedTypes***
Render header: [_ ] Aggregating Operator (None) 
Prefix is [ _  ] dislay is  **Aggregating Operator**
Render header: [- ] Name (optional reference Code) 
Prefix is [ -  ] dislay is  ***Name***
Render header: [- ] None (None) 
Prefix is [ -  ] dislay is  ***None***
Render header: [- ] None (None) 
Prefix is [ -  ] dislay is  ***None***
Render header: [- ] None (None) 
Prefix is [ -  ] dislay is  ***None***
Render header: [- ] arity (optional reference Integer) 
Prefix is [ -  ] dislay is  ***arity***
Render header: [- ] spelling (optional reference Template) 
Prefix is [ -  ] dislay is  ***spelling***
0  subjects coming in subject
Render header: [## ] Low level Data Types () 
Prefix is [ ##  ] dislay is  Low level Data Types
Render header: [_ ] ValueType CamelName (None) 
Prefix is [ _  ] dislay is  **ValueType CamelName**
Render header: [- ] value the string (optional reference String) 
Prefix is [ -  ] dislay is  ***value the string***
Render header: [_ ] UpperCamel (None) 
Prefix is [ _  ] dislay is  **UpperCamel**
Render header: [_ ] LowerCamel (None) 
Prefix is [ _  ] dislay is  **LowerCamel**
Render header: [_ ] Qualified Camel (None) 
Prefix is [ _  ] dislay is  **Qualified Camel**
Render header: [_ ] RichText.  A string with markup for block level formatting. (None) 
Prefix is [ _  ] dislay is  **RichText.  A string with markup for block level formatting.**
Render header: [- ] value (optional reference string) 
Prefix is [ -  ] dislay is  ***value***
Render header: [- ] format (optional reference Code) 
Prefix is [ -  ] dislay is  ***format***
Render header: [- ] HTML (None) 
Prefix is [ -  ] dislay is  ***HTML***
Render header: [- ] MarkDown (None) 
Prefix is [ -  ] dislay is  ***MarkDown***
Render header: [_ ] RichLine (None) 
Prefix is [ _  ] dislay is  **RichLine**
Render header: [- ] value (optional reference string) 
Prefix is [ -  ] dislay is  ***value***
Render header: [_ ] PrimitiveType (None) 
Prefix is [ _  ] dislay is  **PrimitiveType**
0  subjects coming in subject
Render header: [## ] Appendices
Insert More Sidebars.md
Insert Overrides.md
insert LDM Intro.md
Insert OCL.md
Insert Camel Case.md () 
Prefix is [ ##  ] dislay is  Appendices
Insert More Sidebars.md
Insert Overrides.md
insert LDM Intro.md
Insert OCL.md
Insert Camel Case.md
1  subjects coming in subject
Render header: [### ] Annotation Types Used () 
Prefix is [ ###  ] dislay is  Annotation Types Used
adding code block...
```typescript
interface AnnotationType {
label: string;
emoji: string;
emojiName: string;
emojiUnicode: string;
purpose: string;
}
// LINK: LiterateDataModel.annotationTypes
const annotationTypes: AnnotationType[] = [
{
label: "Error",
emoji: "",
emojiName: "cross_mark",
emojiUnicode: "U+274C",
purpose: "Indicates a critical error or failure in the model."
},
{
label: "Warning",
emoji: "",
emojiName: "warning",
emojiUnicode: "U+26A0",
purpose: "Indicates a potential issue or warning in the model."
},
{
label: "Note",
emoji: "",
emojiName: "blue_book",
emojiUnicode: "U+1F4D8",
purpose: "Provides additional context, explanations, or clarifications for the annotated element."
},
{
label: "Issue",
emoji: "",
emojiName: "warning",
emojiUnicode: "U+26A0",
purpose: "Highlights a potential issue or error that needs to be addressed or resolved."
},
{
label: "Question",
emoji: "",
emojiName: "question",
emojiUnicode: "U+2753",
purpose: "Raises a question or seeks further clarification about the annotated element."
},
{
label: "Suggestion",
emoji: "",
emojiName: "bulb",
emojiUnicode: "U+1F4A1",
purpose: "Provides a suggestion or recommendation for improving the model or the annotated element."
},
{
label: "Info",
emoji: "",
emojiName: "information_source",
emojiUnicode: "U+2139",
purpose: "Offers relevant information, facts, or details about the annotated element."
},
{
label: "Todo",
emoji: "",
emojiName: "pushpin",
emojiUnicode: "U+1F4CC",
purpose: "Indicates a pending task, action item, or future work related to the annotated element."
},
{
label: "Reference",
emoji: "",
emojiName: "globe_with_meridians",
emojiUnicode: "U+1F310",
purpose: "Provides a reference or link to an external resource or documentation."
},
{
label: "See",
emoji: "",
emojiName: "mag",
emojiUnicode: "U+1F50D",
purpose: "Indicates a cross-reference to another relevant element within the model."
}
];
```
0  subjects coming in subject
Render header: [## ] Appendices
Insert More Sidebars.md
Insert Overrides.md
insert LDM Intro.md
Insert OCL.md
Insert Camel Case.md () 
Prefix is [ ##  ] dislay is  Appendices
Insert More Sidebars.md
Insert Overrides.md
insert LDM Intro.md
Insert OCL.md
Insert Camel Case.md
0  subjects coming in subject

Phase: Creating HTML from model dict
All keys are: 
	 default
	 _type
	 one_liner
	 emoji
	 classes
	 label
	 dependent_of
	 data_type_clause
	 subjects
	 attribute_sections
	 plural
	 elaboration
	 prefix
	 annotations
	 parenthetical
	 data_type
	 derivation
	 t_value
	 constraints
	 where
	 class_name
	 based_on
	 element_type
	 attributes
	 subtype_of
	 attribute_name
	 as_value_type
	 is_optional_lit
	 name
	 content
	 overrides
	 inverse
	 abbreviation
Python type is  <class 'dict'>  type_label is  LiterateModel
Python type is  <class 'dict'>  type_label is  SubjectB
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Preliminaries', '_type': 'SubjectName'} the_name = Preliminaries
Adding simple: OneLiner with the basic structure
of the model
Python type is  <class 'dict'>  type_label is  Paragraph
Adding simple: Paragraph with In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.

Python type is  <class 'dict'>  type_label is  Paragraph
Adding simple: Paragraph with We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.

Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Component', '_type': 'ClassName'} the_name = Component
Adding simple: OneLiner with An element or building block of the literate data model
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'normalName', '_type': 'AttributeName'} the_name = normalName
Adding simple: OneLiner with the name of the component, not in camel case
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'String', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#String">String</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#String">String</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#String">String</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#String">String</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#String">String</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#String">String</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'name', '_type': 'AttributeName'} the_name = name
Adding simple: OneLiner with The name of the component
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'CamelName', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#CamelName">CamelName</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#CamelName">CamelName</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#CamelName">CamelName</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#CamelName">CamelName</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#CamelName">CamelName</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#CamelName">CamelName</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'qualifiedName', '_type': 'AttributeName'} the_name = qualifiedName
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'QualifiedCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'QualifiedCamel', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#QualifiedCamel">QualifiedCamel</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#QualifiedCamel">QualifiedCamel</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#QualifiedCamel">QualifiedCamel</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#QualifiedCamel">QualifiedCamel</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#QualifiedCamel">QualifiedCamel</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#QualifiedCamel">QualifiedCamel</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'abbreviatedName', '_type': 'AttributeName'} the_name = abbreviatedName
Adding simple: OneLiner with a short form of the component's name, used for cross references and improved readability.
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'CamelName', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#CamelName">CamelName</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#CamelName">CamelName</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#CamelName">CamelName</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#CamelName">CamelName</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#CamelName">CamelName</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#CamelName">CamelName</span>

<span class="as_value">value</span></span></span>
Orphaned dict:  default
Python type is  <class 'dict'>  type_label is  Default
Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>Example</span>', '<span class=content>"LDM" is the short form of "Literate Data Model".</span>']
Div returning:  <div class="Annotation">

<span class=label>Example</span>
<span class=content>"LDM" is the short form of "Literate Data Model".</span></div>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'oneLiner', '_type': 'AttributeName'} the_name = oneLiner
Adding simple: OneLiner with A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'RichLine', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'RichLine', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#RichLine">RichLine</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#RichLine">RichLine</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#RichLine">RichLine</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#RichLine">RichLine</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#RichLine">RichLine</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#RichLine">RichLine</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'elaboration', '_type': 'AttributeName'} the_name = elaboration
Adding simple: OneLiner with A more detailed explanation or discussion of the component _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'RichText', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#RichText">RichText</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#RichText">RichText</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#RichText">RichText</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#RichText">RichText</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#RichText">RichText</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#RichText">RichText</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  AttributeSection
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'For Machinery', '_type': 'AttributeSectionName'} the_name = For Machinery
Adding simple: OneLiner with mechanical attributes
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'isEmbellishment', '_type': 'AttributeName'} the_name = isEmbellishment
Adding simple: OneLiner with Indicates whether this component is an embellishment added during post-parsing processing _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Boolean', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Boolean">Boolean</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Boolean">Boolean</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Boolean">Boolean</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Boolean">Boolean</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Boolean">Boolean</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Boolean">Boolean</span>

<span class="as_value">value</span></span></span>
Orphaned dict:  default
Python type is  <class 'dict'>  type_label is  Default
Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>Note</span>', '<span class=content>This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.</span>']
Div returning:  <div class="Annotation">

<span class=label>Note</span>
<span class=content>This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.</span></div>
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'AnnotationType', '_type': 'ClassName'} the_name = AnnotationType
Adding simple: OneLiner with a kind of note, or aside, used to call attention to additional information about some Component.
For clause: based_on, seeking html for [ClassName(content='Literate Data Model', _type='ClassName')]
Python type is  <class 'list'>  type_label is  NoNonDictTypeLabel
Orphaned list:  [ClassName(content='Literate Data Model', _type='ClassName')]
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
And got html: <div class="list">
<span class="class_name_link" href="#Literate Data Model">Literate Data Model</span>

</div>
Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>Note</span>', '<span class=content>Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.</span>']
Div returning:  <div class="Annotation">

<span class=label>Note</span>
<span class=content>Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.</span></div>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'emoji', '_type': 'AttributeName'} the_name = emoji
Adding simple: OneLiner with an emoji
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Emoji', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Emoji">Emoji</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Emoji">Emoji</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Emoji">Emoji</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Emoji">Emoji</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Emoji">Emoji</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Emoji">Emoji</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'emojiName', '_type': 'AttributeName'} the_name = emojiName
Adding simple: OneLiner with an emoji
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'String', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#String">String</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#String">String</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#String">String</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#String">String</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#String">String</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#String">String</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'emojiUnicode', '_type': 'AttributeName'} the_name = emojiUnicode
Adding simple: OneLiner with the Unicode for the emoji
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Unicode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Unicode', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Unicode">Unicode</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Unicode">Unicode</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Unicode">Unicode</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Unicode">Unicode</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Unicode">Unicode</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Unicode">Unicode</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'label', '_type': 'AttributeName'} the_name = label
Adding simple: OneLiner with A short label to indicate the purpose of the annotation _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'CamelName', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#CamelName">CamelName</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#CamelName">CamelName</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#CamelName">CamelName</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#CamelName">CamelName</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#CamelName">CamelName</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#CamelName">CamelName</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'plural', '_type': 'AttributeName'} the_name = plural
Adding simple: OneLiner with the plural form of the label
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'UpperCamel', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#UpperCamel">UpperCamel</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#UpperCamel">UpperCamel</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#UpperCamel">UpperCamel</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#UpperCamel">UpperCamel</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#UpperCamel">UpperCamel</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#UpperCamel">UpperCamel</span>

<span class="as_value">value</span></span></span>
Orphaned dict:  default
Python type is  <class 'dict'>  type_label is  Default
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Purpose', '_type': 'AttributeName'} the_name = Purpose
Adding simple: OneLiner with the intended reason for the annotation.
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'ValueType Annotation\nA note or comment associated with a model element', '_type': 'ClassName'} the_name = ValueType Annotation
A note or comment associated with a model element
For clause: based_on, seeking html for [ClassName(content='Component', _type='ClassName')]
Python type is  <class 'list'>  type_label is  NoNonDictTypeLabel
Orphaned list:  [ClassName(content='Component', _type='ClassName')]
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
And got html: <div class="list">
<span class="class_name_link" href="#Component">Component</span>

</div>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'annotationType', '_type': 'AttributeName'} the_name = annotationType
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Annotation Type', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Annotation Type', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Annotation Type">Annotation Type</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Annotation Type">Annotation Type</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Annotation Type">Annotation Type</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Annotation Type">Annotation Type</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Annotation Type">Annotation Type</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Annotation Type">Annotation Type</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>Note</span>', '<span class=content>An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.</span>']
Div returning:  <div class="Annotation">

<span class=label>Note</span>
<span class=content>An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.</span></div>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'label', '_type': 'AttributeName'} the_name = label
Adding simple: OneLiner with A short label to indicate the purpose of the annotation _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'CamelName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'CamelName', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#CamelName">CamelName</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#CamelName">CamelName</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#CamelName">CamelName</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#CamelName">CamelName</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#CamelName">CamelName</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#CamelName">CamelName</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Paragraph
Adding simple: Paragraph with But any short label is valid.

Orphaned dict:  default
Python type is  <class 'dict'>  type_label is  Default
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Emoji', '_type': 'AttributeName'} the_name = Emoji
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Emoji', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Emoji', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Emoji">Emoji</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Emoji">Emoji</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Emoji">Emoji</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Emoji">Emoji</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Emoji">Emoji</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Emoji">Emoji</span>

<span class="as_value">value</span></span></span>
Orphaned dict:  default
Python type is  <class 'dict'>  type_label is  Default
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'content', '_type': 'AttributeName'} the_name = content
Adding simple: OneLiner with The content or body of the annotation
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'RichText', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#RichText">RichText</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#RichText">RichText</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#RichText">RichText</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#RichText">RichText</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#RichText">RichText</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#RichText">RichText</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  AttributeSection
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'For Machinery', '_type': 'AttributeSectionName'} the_name = For Machinery
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'isEmbellishment', '_type': 'AttributeName'} the_name = isEmbellishment
Adding simple: OneLiner with Indicates whether this annotation is an embellishment added during post-parsing processing _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Boolean', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Boolean">Boolean</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Boolean">Boolean</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Boolean">Boolean</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Boolean">Boolean</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Boolean">Boolean</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Boolean">Boolean</span>

<span class="as_value">value</span></span></span>
Orphaned dict:  default
Python type is  <class 'dict'>  type_label is  Default
Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>Note</span>', '<span class=content>This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.</span>']
Div returning:  <div class="Annotation">

<span class=label>Note</span>
<span class=content>This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.</span></div>
Python type is  <class 'dict'>  type_label is  SubjectB
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'The Model and its Subjects', '_type': 'SubjectName'} the_name = The Model and its Subjects
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'LiterateDataModel', '_type': 'ClassName'} the_name = LiterateDataModel
Adding simple: OneLiner with A representation of a domain's entities, attributes, and relationships,
along with explanatory text and examples
Orphaned dict:  abbreviation
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Orphaned dict:  plural
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Subtyping pair is:  (ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#Component">Component</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#Component">Component</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'name', '_type': 'AttributeName'} the_name = name
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'UpperCamel', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#UpperCamel">UpperCamel</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#UpperCamel">UpperCamel</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#UpperCamel">UpperCamel</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#UpperCamel">UpperCamel</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#UpperCamel">UpperCamel</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#UpperCamel">UpperCamel</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'allSubjects', '_type': 'AttributeName'} the_name = allSubjects
Adding simple: OneLiner with list of all classes in the model, as ordered in the
definition of the model.
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  ListDataType
ldt. dict is  {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}
ldt. element_type is  {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Classes', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Classes">Classes</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Classes">Classes</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Classes">Classes</span>

<span class="as_value">value</span></span>
htmls are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Classes">Classes</span>

<span class="as_value">value</span></span></span>
htmls are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span></span>']
Pieces are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span></span>']
span returning:  <span class="DataTypeClause">

<span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Classes">Classes</span>

<span class="as_value">value</span></span></span></span>
Orphaned dict:  derivation
Python type is  <class 'dict'>  type_label is  Derivation
Python type is  <class 'dict'>  type_label is  Constraint
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'allClasses', '_type': 'AttributeName'} the_name = allClasses
Adding simple: OneLiner with list of all classes in the model, as ordered in the definition of the model.
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  ListDataType
ldt. dict is  {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}
ldt. element_type is  {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Classes', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Classes">Classes</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Classes">Classes</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Classes">Classes</span>

<span class="as_value">value</span></span>
htmls are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Classes">Classes</span>

<span class="as_value">value</span></span></span>
htmls are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span></span>']
Pieces are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span></span>']
span returning:  <span class="DataTypeClause">

<span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Classes">Classes</span>

<span class="as_value">value</span></span></span></span>
Orphaned dict:  derivation
Python type is  <class 'dict'>  type_label is  Derivation
Python type is  <class 'dict'>  type_label is  Constraint
Python type is  <class 'dict'>  type_label is  AttributeSection
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Modeling Configuration', '_type': 'AttributeSectionName'} the_name = Modeling Configuration
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'annotationTypes', '_type': 'AttributeName'} the_name = annotationTypes
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  ListDataType
ldt. dict is  {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}
ldt. element_type is  {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'AnnotationTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'AnnotationTypes', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#AnnotationTypes">AnnotationTypes</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#AnnotationTypes">AnnotationTypes</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#AnnotationTypes">AnnotationTypes</span>

<span class="as_value">value</span></span>
htmls are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#AnnotationTypes">AnnotationTypes</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#AnnotationTypes">AnnotationTypes</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#AnnotationTypes">AnnotationTypes</span>

<span class="as_value">value</span></span></span>
htmls are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#AnnotationTypes">AnnotationTypes</span>\n\n<span class="as_value">value</span></span></span>']
Pieces are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#AnnotationTypes">AnnotationTypes</span>\n\n<span class="as_value">value</span></span></span>']
span returning:  <span class="DataTypeClause">

<span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#AnnotationTypes">AnnotationTypes</span>

<span class="as_value">value</span></span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Preferred Coding Language', '_type': 'AttributeName'} the_name = Preferred Coding Language
Adding simple: OneLiner with the recommended lanquage  for expressing derivation, defaults, and constraints
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Coding Language', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Coding Language">Coding Language</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Coding Language">Coding Language</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Coding Language">Coding Language</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Coding Language">Coding Language</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Coding Language">Coding Language</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Coding Language">Coding Language</span>

<span class="as_value">value</span></span></span>
Orphaned dict:  default
Python type is  <class 'dict'>  type_label is  Default
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'alternate Coding Languages', '_type': 'AttributeName'} the_name = alternate Coding Languages
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  ListDataType
ldt. dict is  {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}
ldt. element_type is  {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Coding Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Coding Languages', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Coding Languages">Coding Languages</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Coding Languages">Coding Languages</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Coding Languages">Coding Languages</span>

<span class="as_value">value</span></span>
htmls are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Coding Languages">Coding Languages</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Coding Languages">Coding Languages</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Coding Languages">Coding Languages</span>

<span class="as_value">value</span></span></span>
htmls are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Coding Languages">Coding Languages</span>\n\n<span class="as_value">value</span></span></span>']
Pieces are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Coding Languages">Coding Languages</span>\n\n<span class="as_value">value</span></span></span>']
span returning:  <span class="DataTypeClause">

<span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Coding Languages">Coding Languages</span>

<span class="as_value">value</span></span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Preferred Template Language', '_type': 'AttributeName'} the_name = Preferred Template Language
Adding simple: OneLiner with the recommended lanquage  for expressing derivation, defaults, and constraints
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Template Language', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Template Language', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Template Language">Template Language</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Template Language">Template Language</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Template Language">Template Language</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Template Language">Template Language</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Template Language">Template Language</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Template Language">Template Language</span>

<span class="as_value">value</span></span></span>
Orphaned dict:  default
Python type is  <class 'dict'>  type_label is  Default
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'alternate Template Languages', '_type': 'AttributeName'} the_name = alternate Template Languages
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  ListDataType
ldt. dict is  {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}
ldt. element_type is  {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Template Languages', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Template Languages', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Template Languages">Template Languages</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Template Languages">Template Languages</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Template Languages">Template Languages</span>

<span class="as_value">value</span></span>
htmls are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Template Languages">Template Languages</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Template Languages">Template Languages</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Template Languages">Template Languages</span>

<span class="as_value">value</span></span></span>
htmls are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Template Languages">Template Languages</span>\n\n<span class="as_value">value</span></span></span>']
Pieces are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Template Languages">Template Languages</span>\n\n<span class="as_value">value</span></span></span>']
span returning:  <span class="DataTypeClause">

<span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Template Languages">Template Languages</span>

<span class="as_value">value</span></span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'aiFunctions', '_type': 'AttributeName'} the_name = aiFunctions
Adding simple: OneLiner with A list of functions that require sophisticated AI-powered implementation *
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  ListDataType
ldt. dict is  {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}
ldt. element_type is  {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'String', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#String">String</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#String">String</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#String">String</span>

<span class="as_value">value</span></span>
htmls are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#String">String</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#String">String</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#String">String</span>

<span class="as_value">value</span></span></span>
htmls are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#String">String</span>\n\n<span class="as_value">value</span></span></span>']
Pieces are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#String">String</span>\n\n<span class="as_value">value</span></span></span>']
span returning:  <span class="DataTypeClause">

<span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#String">String</span>

<span class="as_value">value</span></span></span></span>
Orphaned dict:  derivation
Python type is  <class 'dict'>  type_label is  Derivation
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Subject\nA specific topic or theme within the model', '_type': 'ClassName'} the_name = Subject
A specific topic or theme within the model
Orphaned dict:  plural
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Subtyping pair is:  (ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#Component">Component</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#Component">Component</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
For clause: dependent_of, seeking html for [ClassName(content='LiterateDataModel', _type='ClassName')]
Python type is  <class 'list'>  type_label is  NoNonDictTypeLabel
Orphaned list:  [ClassName(content='LiterateDataModel', _type='ClassName')]
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
And got html: <div class="list">
<span class="class_name_link" href="#LiterateDataModel">LiterateDataModel</span>

</div>
Python type is  <class 'dict'>  type_label is  Paragraph
Adding simple: Paragraph with Subjects are the chapters an sections of the model.
 
+ A subject need not contain any Classes if it’s just expository.

Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'name', '_type': 'AttributeName'} the_name = name
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'UpperCamel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'UpperCamel', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#UpperCamel">UpperCamel</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#UpperCamel">UpperCamel</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#UpperCamel">UpperCamel</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#UpperCamel">UpperCamel</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#UpperCamel">UpperCamel</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#UpperCamel">UpperCamel</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'parentSubject', '_type': 'AttributeName'} the_name = parentSubject
Adding simple: OneLiner with The parent subject, if any, under which this subject is nested _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Subject', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Subject', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Subject">Subject</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Subject">Subject</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Subject">Subject</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Subject">Subject</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Subject">Subject</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Subject">Subject</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Classes', '_type': 'AttributeName'} the_name = Classes
Adding simple: OneLiner with The major classes related to this subject, in the order in which they should be presented _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  ListDataType
ldt. dict is  {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}
ldt. element_type is  {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Classes', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Classes">Classes</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Classes">Classes</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Classes">Classes</span>

<span class="as_value">value</span></span>
htmls are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Classes">Classes</span>

<span class="as_value">value</span></span></span>
htmls are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span></span>']
Pieces are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span></span>']
span returning:  <span class="DataTypeClause">

<span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Classes">Classes</span>

<span class="as_value">value</span></span></span></span>
Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>Issue</span>', '<span class=content>define chapter, section, subsection as levels?</span>']
Div returning:  <div class="Annotation">

<span class=label>Issue</span>
<span class=content>define chapter, section, subsection as levels?</span></div>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Each Class should be followed first by the classes that are dependent on it, and then', '_type': 'AttributeName'} the_name = Each Class should be followed first by the classes that are dependent on it, and then
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'By its subtype classes.', '_type': 'AttributeName'} the_name = By its subtype classes.
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'childSubjects', '_type': 'AttributeName'} the_name = childSubjects
Adding simple: OneLiner with Any child subjects nested under this subject, in the order in which they should be presented _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  ListDataType
ldt. dict is  {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}
ldt. element_type is  {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Subjects', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Subjects', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Subjects">Subjects</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Subjects">Subjects</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Subjects">Subjects</span>

<span class="as_value">value</span></span>
htmls are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Subjects">Subjects</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Subjects">Subjects</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Subjects">Subjects</span>

<span class="as_value">value</span></span></span>
htmls are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Subjects">Subjects</span>\n\n<span class="as_value">value</span></span></span>']
Pieces are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Subjects">Subjects</span>\n\n<span class="as_value">value</span></span></span>']
span returning:  <span class="DataTypeClause">

<span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Subjects">Subjects</span>

<span class="as_value">value</span></span></span></span>
Orphaned dict:  inverse
Python type is  <class 'dict'>  type_label is  AttributeReference
Orphaned dict:  class_name
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Orphaned dict:  attribute_name
Python type is  <class 'Literate_01.AttributeName'>  type_label is  AttributeName
Python type is  <class 'dict'>  type_label is  Paragraph
Adding simple: Paragraph with ***DSL***:  the Classes within a Subject are always displayed before the childSubjects.

Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'SubjectArea\nA main topic or area of focus within the model, containing related subjects and classes', '_type': 'ClassName'} the_name = SubjectArea
A main topic or area of focus within the model, containing related subjects and classes
Orphaned dict:  plural
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Subtyping pair is:  (ClassName(content='Subject', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#Subject">Subject</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#Subject">Subject</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Orphaned dict:  where
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  SubjectC
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Classes', '_type': 'SubjectName'} the_name = Classes
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Class', '_type': 'ClassName'} the_name = Class
Adding simple: OneLiner with A key entity or object type in the model, often corresponding to a real-world concept
Orphaned dict:  plural
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Subtyping pair is:  (ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#Component">Component</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#Component">Component</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  Constraint
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'pluralForm', '_type': 'AttributeName'} the_name = pluralForm
Adding simple: OneLiner with the normal English plural form of the name of the Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'UpperName', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'UpperName', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#UpperName">UpperName</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#UpperName">UpperName</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#UpperName">UpperName</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#UpperName">UpperName</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#UpperName">UpperName</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#UpperName">UpperName</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Paragraph
Adding simple: Paragraph with Might be Books for the Book class or other regular plurals.
 
+ But also might be People for Person.

Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>Note</span>', '<span class=content>When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.</span>']
Div returning:  <div class="Annotation">

<span class=label>Note</span>
<span class=content>When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.</span></div>
Orphaned dict:  default
Python type is  <class 'dict'>  type_label is  Default
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'basedOn', '_type': 'AttributeName'} the_name = basedOn
Adding simple: OneLiner with the Class or Classes on which this class is dependent
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  SetDataType
Orphaned dict:  element_type
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Classes', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Classes">Classes</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Classes">Classes</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Classes">Classes</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<div class="SetDataType">\n<div class="dict">\n  <span class="key">element_type:</span>\n  <span class="value"><span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span></span>\n</div>\n</div>']
Pieces are:  ['', '<div class="SetDataType">\n<div class="dict">\n  <span class="key">element_type:</span>\n  <span class="value"><span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span></span>\n</div>\n</div>']
span returning:  <span class="DataTypeClause">

<div class="SetDataType">
<div class="dict">
  <span class="key">element_type:</span>
  <span class="value"><span class="BaseDataType">
<span class="class_name_link" href="#Classes">Classes</span>

<span class="as_value">value</span></span></span>
</div>
</div></span>
Python type is  <class 'dict'>  type_label is  Paragraph
Adding simple: Paragraph with This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.

Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>Note</span>', '<span class=content>that basedOn and dependentOf are being used synonymousle in this metamodel.</span>']
Div returning:  <div class="Annotation">

<span class=label>Note</span>
<span class=content>that basedOn and dependentOf are being used synonymousle in this metamodel.</span></div>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'supertypes', '_type': 'AttributeName'} the_name = supertypes
Adding simple: OneLiner with The parent class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'es', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'es', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#es">es</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#es">es</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#es">es</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#es">es</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#es">es</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#es">es</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'subtypings', '_type': 'AttributeName'} the_name = subtypings
Adding simple: OneLiner with the criteria, or dimensions, by which the class can be divided into subtypes
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  ListDataType
ldt. dict is  {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}
ldt. element_type is  {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Subtypings', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Subtypings', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Subtypings">Subtypings</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Subtypings">Subtypings</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Subtypings">Subtypings</span>

<span class="as_value">value</span></span>
htmls are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Subtypings">Subtypings</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Subtypings">Subtypings</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Subtypings">Subtypings</span>

<span class="as_value">value</span></span></span>
htmls are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Subtypings">Subtypings</span>\n\n<span class="as_value">value</span></span></span>']
Pieces are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Subtypings">Subtypings</span>\n\n<span class="as_value">value</span></span></span>']
span returning:  <span class="DataTypeClause">

<span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Subtypings">Subtypings</span>

<span class="as_value">value</span></span></span></span>
Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>Example</span>', '<span class=content>in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).</span>']
Div returning:  <div class="Annotation">

<span class=label>Example</span>
<span class=content>in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).</span></div>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'subtypes', '_type': 'AttributeName'} the_name = subtypes
Adding simple: OneLiner with Any subtypes or specializations of this class based on it’s subtypings. _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  ListDataType
ldt. dict is  {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}
ldt. element_type is  {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Classes', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Classes">Classes</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Classes">Classes</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Classes">Classes</span>

<span class="as_value">value</span></span>
htmls are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Classes">Classes</span>

<span class="as_value">value</span></span></span>
htmls are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span></span>']
Pieces are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span></span>']
span returning:  <span class="DataTypeClause">

<span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Classes">Classes</span>

<span class="as_value">value</span></span></span></span>
Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>Example</span>', '<span class=content>For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.</span>']
Div returning:  <div class="Annotation">

<span class=label>Example</span>
<span class=content>For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.</span></div>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'attributes', '_type': 'AttributeName'} the_name = attributes
Adding simple: OneLiner with The attributes or properties of the class, in the order in which they should be presented _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  ListDataType
ldt. dict is  {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}
ldt. element_type is  {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Attributes', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Attributes">Attributes</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Attributes">Attributes</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Attributes">Attributes</span>

<span class="as_value">value</span></span>
htmls are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Attributes">Attributes</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Attributes">Attributes</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Attributes">Attributes</span>

<span class="as_value">value</span></span></span>
htmls are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Attributes">Attributes</span>\n\n<span class="as_value">value</span></span></span>']
Pieces are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Attributes">Attributes</span>\n\n<span class="as_value">value</span></span></span>']
span returning:  <span class="DataTypeClause">

<span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Attributes">Attributes</span>

<span class="as_value">value</span></span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'attributeSections', '_type': 'AttributeName'} the_name = attributeSections
Adding simple: OneLiner with additional attributes or properties of the class, grouped for clarity and elaboration.  _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  ListDataType
ldt. dict is  {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}
ldt. element_type is  {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'AttributeSections', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'AttributeSections', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#AttributeSections">AttributeSections</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#AttributeSections">AttributeSections</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#AttributeSections">AttributeSections</span>

<span class="as_value">value</span></span>
htmls are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#AttributeSections">AttributeSections</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#AttributeSections">AttributeSections</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#AttributeSections">AttributeSections</span>

<span class="as_value">value</span></span></span>
htmls are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#AttributeSections">AttributeSections</span>\n\n<span class="as_value">value</span></span></span>']
Pieces are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#AttributeSections">AttributeSections</span>\n\n<span class="as_value">value</span></span></span>']
span returning:  <span class="DataTypeClause">

<span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#AttributeSections">AttributeSections</span>

<span class="as_value">value</span></span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'constraints', '_type': 'AttributeName'} the_name = constraints
Adding simple: OneLiner with Any constraints, rules, or validations specific to this class _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  ListDataType
ldt. dict is  {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}
ldt. element_type is  {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Constraints', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Constraints">Constraints</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Constraints">Constraints</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Constraints">Constraints</span>

<span class="as_value">value</span></span>
htmls are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Constraints">Constraints</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Constraints">Constraints</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Constraints">Constraints</span>

<span class="as_value">value</span></span></span>
htmls are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Constraints">Constraints</span>\n\n<span class="as_value">value</span></span></span>']
Pieces are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Constraints">Constraints</span>\n\n<span class="as_value">value</span></span></span>']
span returning:  <span class="DataTypeClause">

<span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Constraints">Constraints</span>

<span class="as_value">value</span></span></span></span>
Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>Note</span>', '<span class=content>Constraints may be expressed on either the Class or the Attribute. Always?</span>']
Div returning:  <div class="Annotation">

<span class=label>Note</span>
<span class=content>Constraints may be expressed on either the Class or the Attribute. Always?</span></div>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'methods', '_type': 'AttributeName'} the_name = methods
Adding simple: OneLiner with Any behaviors or operations associated with this class _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  ListDataType
ldt. dict is  {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}
ldt. element_type is  {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Methods', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Methods', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Methods">Methods</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Methods">Methods</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Methods">Methods</span>

<span class="as_value">value</span></span>
htmls are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Methods">Methods</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Methods">Methods</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Methods">Methods</span>

<span class="as_value">value</span></span></span>
htmls are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Methods">Methods</span>\n\n<span class="as_value">value</span></span></span>']
Pieces are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Methods">Methods</span>\n\n<span class="as_value">value</span></span></span>']
span returning:  <span class="DataTypeClause">

<span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Methods">Methods</span>

<span class="as_value">value</span></span></span></span>
Python type is  <class 'dict'>  type_label is  AttributeSection
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Implied Attributes', '_type': 'AttributeSectionName'} the_name = Implied Attributes
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'dependents', '_type': 'AttributeName'} the_name = dependents
Adding simple: OneLiner with the Classes which are basedOn this Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  SetDataType
Orphaned dict:  element_type
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Classes', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Classes">Classes</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Classes">Classes</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Classes">Classes</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<div class="SetDataType">\n<div class="dict">\n  <span class="key">element_type:</span>\n  <span class="value"><span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span></span>\n</div>\n</div>']
Pieces are:  ['', '<div class="SetDataType">\n<div class="dict">\n  <span class="key">element_type:</span>\n  <span class="value"><span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span></span>\n</div>\n</div>']
span returning:  <span class="DataTypeClause">

<div class="SetDataType">
<div class="dict">
  <span class="key">element_type:</span>
  <span class="value"><span class="BaseDataType">
<span class="class_name_link" href="#Classes">Classes</span>

<span class="as_value">value</span></span></span>
</div>
</div></span>
Orphaned dict:  inverse
Python type is  <class 'dict'>  type_label is  AttributeReference
Orphaned dict:  class_name
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Orphaned dict:  attribute_name
Python type is  <class 'Literate_01.AttributeName'>  type_label is  AttributeName
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'UniqueKeys', '_type': 'AttributeName'} the_name = UniqueKeys
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  SetDataType
Orphaned dict:  element_type
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'UniqueKeys', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'UniqueKeys', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#UniqueKeys">UniqueKeys</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#UniqueKeys">UniqueKeys</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#UniqueKeys">UniqueKeys</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<div class="SetDataType">\n<div class="dict">\n  <span class="key">element_type:</span>\n  <span class="value"><span class="BaseDataType">\n<span class="class_name_link" href="#UniqueKeys">UniqueKeys</span>\n\n<span class="as_value">value</span></span></span>\n</div>\n</div>']
Pieces are:  ['', '<div class="SetDataType">\n<div class="dict">\n  <span class="key">element_type:</span>\n  <span class="value"><span class="BaseDataType">\n<span class="class_name_link" href="#UniqueKeys">UniqueKeys</span>\n\n<span class="as_value">value</span></span></span>\n</div>\n</div>']
span returning:  <span class="DataTypeClause">

<div class="SetDataType">
<div class="dict">
  <span class="key">element_type:</span>
  <span class="value"><span class="BaseDataType">
<span class="class_name_link" href="#UniqueKeys">UniqueKeys</span>

<span class="as_value">value</span></span></span>
</div>
</div></span>
Orphaned dict:  inverse
Python type is  <class 'dict'>  type_label is  AttributeReference
Orphaned dict:  class_name
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Orphaned dict:  attribute_name
Python type is  <class 'Literate_01.AttributeName'>  type_label is  AttributeName
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Subtyping', '_type': 'ClassName'} the_name = Subtyping
Adding simple: OneLiner with a way in which subtypes of a Class may be classified
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
For clause: dependent_of, seeking html for [ClassName(content='Class', _type='ClassName')]
Python type is  <class 'list'>  type_label is  NoNonDictTypeLabel
Orphaned list:  [ClassName(content='Class', _type='ClassName')]
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
And got html: <div class="list">
<span class="class_name_link" href="#Class">Class</span>

</div>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'name', '_type': 'AttributeName'} the_name = name
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Upper Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Upper Name', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Upper Name">Upper Name</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Upper Name">Upper Name</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Upper Name">Upper Name</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Upper Name">Upper Name</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Upper Name">Upper Name</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Upper Name">Upper Name</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'is exclusive', '_type': 'AttributeName'} the_name = is exclusive
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Boolean', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Boolean">Boolean</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Boolean">Boolean</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Boolean">Boolean</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Boolean">Boolean</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Boolean">Boolean</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Boolean">Boolean</span>

<span class="as_value">value</span></span></span>
Orphaned dict:  default
Python type is  <class 'dict'>  type_label is  Default
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'is exhaustive', '_type': 'AttributeName'} the_name = is exhaustive
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Boolean', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Boolean">Boolean</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Boolean">Boolean</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Boolean">Boolean</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Boolean">Boolean</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Boolean">Boolean</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Boolean">Boolean</span>

<span class="as_value">value</span></span></span>
Orphaned dict:  default
Python type is  <class 'dict'>  type_label is  Default
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'classes', '_type': 'AttributeName'} the_name = classes
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  ListDataType
ldt. dict is  {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}
ldt. element_type is  {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Classes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Classes', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Classes">Classes</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Classes">Classes</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Classes">Classes</span>

<span class="as_value">value</span></span>
htmls are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Classes">Classes</span>

<span class="as_value">value</span></span></span>
htmls are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span></span>']
Pieces are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Classes">Classes</span>\n\n<span class="as_value">value</span></span></span>']
span returning:  <span class="DataTypeClause">

<span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Classes">Classes</span>

<span class="as_value">value</span></span></span></span>
Python type is  <class 'dict'>  type_label is  Paragraph
Adding simple: Paragraph with ***DSL***:  Shown in the DSL as
 
+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)
 
+ on the super class. And as
 
+ > Subtype of: SuperClass byBrand
 
+ on the subclass.

Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>Note</span>', '<span class=content>every class can have an unnamed subtyping.</span>']
Div returning:  <div class="Annotation">

<span class=label>Note</span>
<span class=content>every class can have an unnamed subtyping.</span></div>
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'ValueType', '_type': 'ClassName'} the_name = ValueType
Subtyping pair is:  (ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#Class.">Class.</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#Class.">Class.</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Reference Type', '_type': 'ClassName'} the_name = Reference Type
Subtyping pair is:  (ClassName(content='Class.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#Class.">Class.</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#Class.">Class.</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'CodeType\nA data type or enumeration used in the model', '_type': 'ClassName'} the_name = CodeType
A data type or enumeration used in the model
Subtyping pair is:  (ClassName(content='ValueType.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#ValueType.">ValueType.</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#ValueType.">ValueType.</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>Note</span>', "<span class=content>Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:</span>"]
Div returning:  <div class="Annotation">

<span class=label>Note</span>
<span class=content>Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:</span></div>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'List the code values as a bulletted list inside the description of the attribute in the form\n‘code description’', '_type': 'AttributeName'} the_name = List the code values as a bulletted list inside the description of the attribute in the form
‘code description’
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', '_type': 'AttributeName'} the_name = A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'isCaptive', '_type': 'AttributeName'} the_name = isCaptive
Adding simple: OneLiner with the code type was implied by use in an attribute and is only used for that attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Boolean', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Boolean">Boolean</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Boolean">Boolean</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Boolean">Boolean</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Boolean">Boolean</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Boolean">Boolean</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Boolean">Boolean</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Code Value', '_type': 'ClassName'} the_name = Code Value
Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>A possible value for an enumerated data class  DependentOf</span>', '<span class=content>CodeType</span>']
Div returning:  <div class="Annotation">

<span class=label>A possible value for an enumerated data class  DependentOf</span>
<span class=content>CodeType</span></div>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'code', '_type': 'AttributeName'} the_name = code
Adding simple: OneLiner with A short code or abbreviationi for the value _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'NameString', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'NameString', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#NameString">NameString</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#NameString">NameString</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#NameString">NameString</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#NameString">NameString</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#NameString">NameString</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#NameString">NameString</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'description', '_type': 'AttributeName'} the_name = description
Adding simple: OneLiner with an explanation of what the code means
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'RichText', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#RichText">RichText</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#RichText">RichText</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#RichText">RichText</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#RichText">RichText</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#RichText">RichText</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#RichText">RichText</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Key', '_type': 'ClassName'} the_name = Key
Adding simple: OneLiner with a list of attributes of a class
Subtyping pair is:  (ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#Component">Component</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#Component">Component</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
For clause: dependent_of, seeking html for [ClassName(content='Class', _type='ClassName')]
Python type is  <class 'list'>  type_label is  NoNonDictTypeLabel
Orphaned list:  [ClassName(content='Class', _type='ClassName')]
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
And got html: <div class="list">
<span class="class_name_link" href="#Class">Class</span>

</div>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'keyAttributes', '_type': 'AttributeName'} the_name = keyAttributes
Adding simple: OneLiner with the attributes of the base Class.
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  ListDataType
ldt. dict is  {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}
ldt. element_type is  {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Attributes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Attributes', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Attributes">Attributes</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Attributes">Attributes</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Attributes">Attributes</span>

<span class="as_value">value</span></span>
htmls are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Attributes">Attributes</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Attributes">Attributes</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Attributes">Attributes</span>

<span class="as_value">value</span></span></span>
htmls are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Attributes">Attributes</span>\n\n<span class="as_value">value</span></span></span>']
Pieces are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Attributes">Attributes</span>\n\n<span class="as_value">value</span></span></span>']
span returning:  <span class="DataTypeClause">

<span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Attributes">Attributes</span>

<span class="as_value">value</span></span></span></span>
Python type is  <class 'dict'>  type_label is  Constraint
Python type is  <class 'dict'>  type_label is  Constraint
Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>Issue</span>', '<span class=content>need ascending descending to support index keys or ordering keys.</span>']
Div returning:  <div class="Annotation">

<span class=label>Issue</span>
<span class=content>need ascending descending to support index keys or ordering keys.</span></div>
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'UniqueKey', '_type': 'ClassName'} the_name = UniqueKey
Adding simple: OneLiner with a list of attributes on which instances of the base class may be keyed.
Subtyping pair is:  (ClassName(content='Key', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#Key">Key</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#Key">Key</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>Note</span>', '<span class=content>order unimportant for Unique Keys.</span>']
Div returning:  <div class="Annotation">

<span class=label>Note</span>
<span class=content>order unimportant for Unique Keys.</span></div>
Python type is  <class 'dict'>  type_label is  SubjectB
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Attributes', '_type': 'SubjectName'} the_name = Attributes
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Attribute Section', '_type': 'ClassName'} the_name = Attribute Section
Adding simple: OneLiner with a group of attributes for a class that merit a shared explanation.
Subtyping pair is:  (ClassName(content='Component.', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#Component.">Component.</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#Component.">Component.</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
For clause: based_on, seeking html for [ClassName(content='Class', _type='ClassName')]
Python type is  <class 'list'>  type_label is  NoNonDictTypeLabel
Orphaned list:  [ClassName(content='Class', _type='ClassName')]
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
And got html: <div class="list">
<span class="class_name_link" href="#Class">Class</span>

</div>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'isOptional', '_type': 'AttributeName'} the_name = isOptional
Adding simple: OneLiner with whether the attributes in this section, taken together, are optional.
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Boolean', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Boolean">Boolean</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Boolean">Boolean</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Boolean">Boolean</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Boolean">Boolean</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Boolean">Boolean</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Boolean">Boolean</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Paragraph
Adding simple: Paragraph with If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.
 
+ &nbsp;
 
+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.

Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Attribute\nA property or characteristic of a class', '_type': 'ClassName'} the_name = Attribute
A property or characteristic of a class
Orphaned dict:  plural
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Subtyping pair is:  (ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#Component">Component</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#Component">Component</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
For clause: based_on, seeking html for [ClassName(content='AttributeSection', _type='ClassName')]
Python type is  <class 'list'>  type_label is  NoNonDictTypeLabel
Orphaned list:  [ClassName(content='AttributeSection', _type='ClassName')]
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
And got html: <div class="list">
<span class="class_name_link" href="#AttributeSection">AttributeSection</span>

</div>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'name', '_type': 'AttributeName'} the_name = name
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Lower Camel', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Lower Camel', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Lower Camel">Lower Camel</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Lower Camel">Lower Camel</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Lower Camel">Lower Camel</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Lower Camel">Lower Camel</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Lower Camel">Lower Camel</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Lower Camel">Lower Camel</span>

<span class="as_value">value</span></span></span>
Orphaned dict:  overrides
Python type is  <class 'dict'>  type_label is  AttributeReference
Orphaned dict:  class_name
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Orphaned dict:  attribute_name
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'dataType', '_type': 'AttributeName'} the_name = dataType
Adding simple: OneLiner with The kind of object to which the attribute refers.  _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'DataType', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#DataType">DataType</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#DataType">DataType</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#DataType">DataType</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#DataType">DataType</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#DataType">DataType</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#DataType">DataType</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Paragraph
Adding simple: Paragraph with But,

Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'List of Editions', '_type': 'AttributeName'} the_name = List of Editions
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Set of Edition', '_type': 'AttributeName'} the_name = Set of Edition
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': '... and more complicated cases.', '_type': 'AttributeName'} the_name = ... and more complicated cases.
Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>See</span>', '<span class=content>the section below on Data Type Specifiers.</span>']
Div returning:  <div class="Annotation">

<span class=label>See</span>
<span class=content>the section below on Data Type Specifiers.</span></div>
Python type is  <class 'dict'>  type_label is  AttributeSection
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Cardinalities.', '_type': 'AttributeSectionName'} the_name = Cardinalities.
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'isOptional', '_type': 'AttributeName'} the_name = isOptional
Adding simple: OneLiner with Indicates whether the attribute must have a value for every instance of the class _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Boolean', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Boolean">Boolean</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Boolean">Boolean</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Boolean">Boolean</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Boolean">Boolean</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Boolean">Boolean</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Boolean">Boolean</span>

<span class="as_value">value</span></span></span>
Orphaned dict:  default
Python type is  <class 'dict'>  type_label is  Default
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'cardinality', '_type': 'AttributeName'} the_name = cardinality
Adding simple: OneLiner with The cardinality of the relationship represented by the attribute _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'CardinalityCode', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'CardinalityCode', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#CardinalityCode">CardinalityCode</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#CardinalityCode">CardinalityCode</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#CardinalityCode">CardinalityCode</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#CardinalityCode">CardinalityCode</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#CardinalityCode">CardinalityCode</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#CardinalityCode">CardinalityCode</span>

<span class="as_value">value</span></span></span>
Orphaned dict:  default
Python type is  <class 'dict'>  type_label is  Default
Python type is  <class 'dict'>  type_label is  Paragraph
Adding simple: Paragraph with ***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.

Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>For example</span>', '']
Div returning:  <div class="Annotation">

<span class=label>For example</span>
</div>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'author', '_type': 'AttributeName'} the_name = author
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Invented Name', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': True, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Invented Name">Invented Name</span>\n', '<span class="as_value"></span>']
Pieces are:  ['<span class="class_name_link" href="#Invented Name">Invented Name</span>\n', '<span class="as_value"></span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Invented Name">Invented Name</span>

<span class="as_value"></span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Invented Name">Invented Name</span>\n\n<span class="as_value"></span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Invented Name">Invented Name</span>\n\n<span class="as_value"></span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Invented Name">Invented Name</span>

<span class="as_value"></span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'books', '_type': 'AttributeName'} the_name = books
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Invented Name', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': True, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Invented Name">Invented Name</span>\n', '<span class="as_value"></span>']
Pieces are:  ['<span class="class_name_link" href="#Invented Name">Invented Name</span>\n', '<span class="as_value"></span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Invented Name">Invented Name</span>

<span class="as_value"></span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Invented Name">Invented Name</span>\n\n<span class="as_value"></span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Invented Name">Invented Name</span>\n\n<span class="as_value"></span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Invented Name">Invented Name</span>

<span class="as_value"></span></span></span>
Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>Note</span>', '<span class=content>how this works with optionality</span>']
Div returning:  <div class="Annotation">

<span class=label>Note</span>
<span class=content>how this works with optionality</span></div>
Python type is  <class 'dict'>  type_label is  AttributeSection
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Inverse Attributes', '_type': 'AttributeSectionName'} the_name = Inverse Attributes
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'isInvertible', '_type': 'AttributeName'} the_name = isInvertible
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Boolean', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Boolean', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Boolean">Boolean</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Boolean">Boolean</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Boolean">Boolean</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Boolean">Boolean</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Boolean">Boolean</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Boolean">Boolean</span>

<span class="as_value">value</span></span></span>
Orphaned dict:  derivation
Python type is  <class 'dict'>  type_label is  Derivation
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'inverseClass', '_type': 'AttributeName'} the_name = inverseClass
Adding simple: OneLiner with the class which contains, or would contain the inverse attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Class', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Class">Class</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Class">Class</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Class">Class</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Class">Class</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Class">Class</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Class">Class</span>

<span class="as_value">value</span></span></span>
Orphaned dict:  derivation
Python type is  <class 'dict'>  type_label is  Derivation
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'inverseAttribute', '_type': 'AttributeName'} the_name = inverseAttribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Attribute', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Attribute">Attribute</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Attribute">Attribute</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Attribute">Attribute</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Attribute">Attribute</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Attribute">Attribute</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Attribute">Attribute</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'inverseIsOptional', '_type': 'AttributeName'} the_name = inverseIsOptional
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Attribute', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Attribute', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Attribute">Attribute</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Attribute">Attribute</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Attribute">Attribute</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Attribute">Attribute</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Attribute">Attribute</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Attribute">Attribute</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Formulas', '_type': 'ClassName'} the_name = Formulas
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'default', '_type': 'AttributeName'} the_name = default
Adding simple: OneLiner with The rule or formula for calculating the value, if no value is supplied
Now running to a second line with the parenthentical on yet a third line
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Derivation', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Derivation">Derivation</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Derivation">Derivation</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Derivation">Derivation</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Derivation">Derivation</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Derivation">Derivation</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Derivation">Derivation</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>Note</span>', '<span class=content>even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.</span>']
Div returning:  <div class="Annotation">

<span class=label>Note</span>
<span class=content>even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.</span></div>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'derivation', '_type': 'AttributeName'} the_name = derivation
Adding simple: OneLiner with For derived attributes, the rule or formula for calculating the value _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Derivation', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Derivation', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Derivation">Derivation</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Derivation">Derivation</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Derivation">Derivation</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Derivation">Derivation</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Derivation">Derivation</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Derivation">Derivation</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>Issue</span>', '<span class=content>on insert vs on access?</span>']
Div returning:  <div class="Annotation">

<span class=label>Issue</span>
<span class=content>on insert vs on access?</span></div>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'constraints', '_type': 'AttributeName'} the_name = constraints
Adding simple: OneLiner with Any validation rules specific to this attribute _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  ListDataType
ldt. dict is  {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}
ldt. element_type is  {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Constraints', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Constraints', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Constraints">Constraints</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Constraints">Constraints</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Constraints">Constraints</span>

<span class="as_value">value</span></span>
htmls are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Constraints">Constraints</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Constraints">Constraints</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Constraints">Constraints</span>

<span class="as_value">value</span></span></span>
htmls are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Constraints">Constraints</span>\n\n<span class="as_value">value</span></span></span>']
Pieces are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Constraints">Constraints</span>\n\n<span class="as_value">value</span></span></span>']
span returning:  <span class="DataTypeClause">

<span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Constraints">Constraints</span>

<span class="as_value">value</span></span></span></span>
Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>Note</span>', '<span class=content>from Class.constraints</span>']
Div returning:  <div class="Annotation">

<span class=label>Note</span>
<span class=content>from Class.constraints</span></div>
Python type is  <class 'dict'>  type_label is  AttributeSection
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Override Tracking', '_type': 'AttributeSectionName'} the_name = Override Tracking
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Overrides', '_type': 'AttributeName'} the_name = Overrides
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'ValueType Derivation\nA rule or formula for deriving the value of an attribute', '_type': 'ClassName'} the_name = ValueType Derivation
A rule or formula for deriving the value of an attribute
Orphaned dict:  plural
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'statement', '_type': 'AttributeName'} the_name = statement
Adding simple: OneLiner with An English language statement of the derivation rule _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'RichText', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#RichText">RichText</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#RichText">RichText</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#RichText">RichText</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#RichText">RichText</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#RichText">RichText</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#RichText">RichText</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'expression', '_type': 'AttributeName'} the_name = expression
Adding simple: OneLiner with The formal expression of the derivation in a programming language _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'CodeExpression', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'CodeExpression', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#CodeExpression">CodeExpression</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#CodeExpression">CodeExpression</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#CodeExpression">CodeExpression</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#CodeExpression">CodeExpression</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#CodeExpression">CodeExpression</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#CodeExpression">CodeExpression</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'ValueType Constraint\nA rule, condition, or validation that must be satisfied by the model', '_type': 'ClassName'} the_name = ValueType Constraint
A rule, condition, or validation that must be satisfied by the model
Orphaned dict:  plural
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Subtyping pair is:  (ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#Component">Component</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#Component">Component</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'statement', '_type': 'AttributeName'} the_name = statement
Adding simple: OneLiner with An English language statement of the constraint _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'RichText', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'RichText', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#RichText">RichText</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#RichText">RichText</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#RichText">RichText</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#RichText">RichText</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#RichText">RichText</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#RichText">RichText</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'expression', '_type': 'AttributeName'} the_name = expression
Adding simple: OneLiner with The formal expression of the constraint in a programming language
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Invented Name', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': True, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Invented Name">Invented Name</span>\n', '<span class="as_value"></span>']
Pieces are:  ['<span class="class_name_link" href="#Invented Name">Invented Name</span>\n', '<span class="as_value"></span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Invented Name">Invented Name</span>

<span class="as_value"></span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Invented Name">Invented Name</span>\n\n<span class="as_value"></span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Invented Name">Invented Name</span>\n\n<span class="as_value"></span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Invented Name">Invented Name</span>

<span class="as_value"></span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'severity', '_type': 'AttributeName'} the_name = severity
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Code', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Code">Code</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Code">Code</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Code">Code</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Code">Code</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Code">Code</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Code">Code</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Adding simple: OneLiner with **Warning** - nothing fatal; just a caution
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Adding simple: OneLiner with **Error** - serious. Fix now
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Message', '_type': 'AttributeName'} the_name = Message
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Template', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Template">Template</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Template">Template</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Template">Template</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Template">Template</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Template">Template</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Template">Template</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Class Constraint', '_type': 'ClassName'} the_name = Class Constraint
Subtyping pair is:  (ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#Constraint">Constraint</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#Constraint">Constraint</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
For clause: based_on, seeking html for [ClassName(content='Class.', _type='ClassName')]
Python type is  <class 'list'>  type_label is  NoNonDictTypeLabel
Orphaned list:  [ClassName(content='Class.', _type='ClassName')]
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
And got html: <div class="list">
<span class="class_name_link" href="#Class.">Class.</span>

</div>
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Attribute Constraint', '_type': 'ClassName'} the_name = Attribute Constraint
Subtyping pair is:  (ClassName(content='Constraint', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#Constraint">Constraint</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#Constraint">Constraint</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
For clause: based_on, seeking html for [ClassName(content='Attribute', _type='ClassName')]
Python type is  <class 'list'>  type_label is  NoNonDictTypeLabel
Orphaned list:  [ClassName(content='Attribute', _type='ClassName')]
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
And got html: <div class="list">
<span class="class_name_link" href="#Attribute">Attribute</span>

</div>
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'CodeExpression', '_type': 'ClassName'} the_name = CodeExpression
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Language', '_type': 'AttributeName'} the_name = Language
Adding simple: OneLiner with the programming language
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Code', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Code">Code</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Code">Code</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Code">Code</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Code">Code</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Code">Code</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Code">Code</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Adding simple: OneLiner with OCL: Object Constraint Language
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Adding simple: OneLiner with Java: Java
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Expression', '_type': 'AttributeName'} the_name = Expression
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'String', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#String">String</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#String">String</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#String">String</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#String">String</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#String">String</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#String">String</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  SubjectB
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Methods', '_type': 'SubjectName'} the_name = Methods
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Method\nA behavior or operation associated with a class', '_type': 'ClassName'} the_name = Method
A behavior or operation associated with a class
Orphaned dict:  plural
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Subtyping pair is:  (ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#Component">Component</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#Component">Component</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'parameters', '_type': 'AttributeName'} the_name = parameters
Adding simple: OneLiner with The input parameters of the method _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  ListDataType
ldt. dict is  {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}
ldt. element_type is  {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Parameters', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Parameters', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Parameters">Parameters</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Parameters">Parameters</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Parameters">Parameters</span>

<span class="as_value">value</span></span>
htmls are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Parameters">Parameters</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#Parameters">Parameters</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Parameters">Parameters</span>

<span class="as_value">value</span></span></span>
htmls are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Parameters">Parameters</span>\n\n<span class="as_value">value</span></span></span>']
Pieces are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#Parameters">Parameters</span>\n\n<span class="as_value">value</span></span></span>']
span returning:  <span class="DataTypeClause">

<span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#Parameters">Parameters</span>

<span class="as_value">value</span></span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'returnType', '_type': 'AttributeName'} the_name = returnType
Adding simple: OneLiner with The data type of the value returned by the method _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'DataType', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#DataType">DataType</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#DataType">DataType</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#DataType">DataType</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#DataType">DataType</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#DataType">DataType</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#DataType">DataType</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Parameter\nAn input to a method', '_type': 'ClassName'} the_name = Parameter
An input to a method
Orphaned dict:  plural
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Subtyping pair is:  (ClassName(content='Component', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#Component">Component</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#Component">Component</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'type', '_type': 'AttributeName'} the_name = type
Adding simple: OneLiner with The data type of the parameter _
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'DataType', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'DataType', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#DataType">DataType</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#DataType">DataType</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#DataType">DataType</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#DataType">DataType</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#DataType">DataType</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#DataType">DataType</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'cardinality', '_type': 'AttributeName'} the_name = cardinality
Adding simple: OneLiner with The cardinality of the parameter
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Invented Name', '_type': 'ClassName'}, 'as_value_type': {'t_value': True, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Invented Name', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': True, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Invented Name">Invented Name</span>\n', '<span class="as_value"></span>']
Pieces are:  ['<span class="class_name_link" href="#Invented Name">Invented Name</span>\n', '<span class="as_value"></span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Invented Name">Invented Name</span>

<span class="as_value"></span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Invented Name">Invented Name</span>\n\n<span class="as_value"></span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Invented Name">Invented Name</span>\n\n<span class="as_value"></span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Invented Name">Invented Name</span>

<span class="as_value"></span></span></span>
Python type is  <class 'dict'>  type_label is  SubjectB
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Data Types', '_type': 'SubjectName'} the_name = Data Types
Python type is  <class 'dict'>  type_label is  Paragraph
Adding simple: Paragraph with *ValueType*:**Data Type**

Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Simple Data Type\nSubtpeOf DataType', '_type': 'ClassName'} the_name = Simple Data Type
SubtpeOf DataType
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'coreClass', '_type': 'AttributeName'} the_name = coreClass
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Class', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Class', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Class">Class</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Class">Class</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Class">Class</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Class">Class</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Class">Class</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Class">Class</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Complex Data Type', '_type': 'ClassName'} the_name = Complex Data Type
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'aggregation', '_type': 'AttributeName'} the_name = aggregation
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Aggregating Operator', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Aggregating Operator', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Aggregating Operator">Aggregating Operator</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Aggregating Operator">Aggregating Operator</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Aggregating Operator">Aggregating Operator</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Aggregating Operator">Aggregating Operator</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Aggregating Operator">Aggregating Operator</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Aggregating Operator">Aggregating Operator</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'aggregatedTypes', '_type': 'AttributeName'} the_name = aggregatedTypes
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  ListDataType
ldt. dict is  {'_type': 'ListDataType', 'element_type': {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}}
ldt. element_type is  {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'DataTypes', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'DataTypes', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#DataTypes">DataTypes</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#DataTypes">DataTypes</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#DataTypes">DataTypes</span>

<span class="as_value">value</span></span>
htmls are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#DataTypes">DataTypes</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['<span class="BaseDataType">\n<span class="class_name_link" href="#DataTypes">DataTypes</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#DataTypes">DataTypes</span>

<span class="as_value">value</span></span></span>
htmls are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#DataTypes">DataTypes</span>\n\n<span class="as_value">value</span></span></span>']
Pieces are:  ['', '<span class="ListDataType">\n<span class="BaseDataType">\n<span class="class_name_link" href="#DataTypes">DataTypes</span>\n\n<span class="as_value">value</span></span></span>']
span returning:  <span class="DataTypeClause">

<span class="ListDataType">
<span class="BaseDataType">
<span class="class_name_link" href="#DataTypes">DataTypes</span>

<span class="as_value">value</span></span></span></span>
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Aggregating Operator', '_type': 'ClassName'} the_name = Aggregating Operator
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Name', '_type': 'AttributeName'} the_name = Name
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Code', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Code">Code</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Code">Code</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Code">Code</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Code">Code</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Code">Code</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Code">Code</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Adding simple: OneLiner with **SetOf**
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Adding simple: OneLiner with **ListOf**
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Adding simple: OneLiner with **Mapping**
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'arity', '_type': 'AttributeName'} the_name = arity
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Integer', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Integer', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Integer">Integer</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Integer">Integer</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Integer">Integer</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Integer">Integer</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Integer">Integer</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Integer">Integer</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'spelling', '_type': 'AttributeName'} the_name = spelling
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Template', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Template', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Template">Template</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Template">Template</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Template">Template</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Template">Template</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Template">Template</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Template">Template</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  SubjectB
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Low level Data Types', '_type': 'SubjectName'} the_name = Low level Data Types
Python type is  <class 'dict'>  type_label is  Paragraph
Adding simple: Paragraph with insert Camel Case.md

Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'ValueType CamelName', '_type': 'ClassName'} the_name = ValueType CamelName
Python type is  <class 'dict'>  type_label is  Paragraph
Adding simple: Paragraph with A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.

Subtyping pair is:  (ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#String">String</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#String">String</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'value the string', '_type': 'AttributeName'} the_name = value the string
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'String', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'String', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#String">String</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#String">String</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#String">String</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#String">String</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#String">String</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#String">String</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Constraint
Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>Example</span>', '<span class=content>"firstName", "orderDate", "customerID"</span>']
Div returning:  <div class="Annotation">

<span class=label>Example</span>
<span class=content>"firstName", "orderDate", "customerID"</span></div>
Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>ModelingNote</span>', '<span class=content>* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.</span>']
Div returning:  <div class="Annotation">

<span class=label>ModelingNote</span>
<span class=content>* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.</span></div>
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'UpperCamel', '_type': 'ClassName'} the_name = UpperCamel
Adding simple: OneLiner with a CamelName that begins with a capital letter
Subtyping pair is:  (ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#CamelName">CamelName</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#CamelName">CamelName</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Orphaned dict:  where
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>Example</span>', '<span class=content>_ "Customer", "ProductCategory", "PaymentMethod"</span>']
Div returning:  <div class="Annotation">

<span class=label>Example</span>
<span class=content>_ "Customer", "ProductCategory", "PaymentMethod"</span></div>
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'LowerCamel', '_type': 'ClassName'} the_name = LowerCamel
Adding simple: OneLiner with a CamelName that begins with a lower case letter
Subtyping pair is:  (ClassName(content='CamelName', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#CamelName">CamelName</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#CamelName">CamelName</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Orphaned dict:  where
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>Example</span>', '<span class=content>"firstName", "orderTotal", "shippingAddress"</span>']
Div returning:  <div class="Annotation">

<span class=label>Example</span>
<span class=content>"firstName", "orderTotal", "shippingAddress"</span></div>
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Qualified Camel', '_type': 'ClassName'} the_name = Qualified Camel
Adding simple: OneLiner with an expression consisting of Camel Names separated by periods
Subtyping pair is:  (ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#String">String</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#String">String</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  Constraint
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'RichText.  A string with markup for block level formatting.', '_type': 'ClassName'} the_name = RichText.  A string with markup for block level formatting.
Subtyping pair is:  (ClassName(content='String', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#String">String</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#String">String</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'value', '_type': 'AttributeName'} the_name = value
Adding simple: OneLiner with the string content
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'string', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#string">string</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#string">string</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#string">string</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#string">string</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#string">string</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#string">string</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'format', '_type': 'AttributeName'} the_name = format
Adding simple: OneLiner with the rich text coding language used
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'Code', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'Code', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#Code">Code</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#Code">Code</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#Code">Code</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Code">Code</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#Code">Code</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#Code">Code</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'HTML', '_type': 'AttributeName'} the_name = HTML
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'MarkDown', '_type': 'AttributeName'} the_name = MarkDown
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'RichLine', '_type': 'ClassName'} the_name = RichLine
Adding simple: OneLiner with String with markup for line level formatting.
Subtyping pair is:  (ClassName(content='RichText', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#RichText">RichText</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#RichText">RichText</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  Attribute
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'value', '_type': 'AttributeName'} the_name = value
Adding simple: OneLiner with the string content
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  DataTypeClause
Python type is  <class 'dict'>  type_label is  IsOptional
opt value is  
Python type is  <class 'dict'>  type_label is  BaseDataType
bdt. dict is  {'_type': 'BaseDataType', 'class_name': {'content': 'string', '_type': 'ClassName'}, 'as_value_type': {'t_value': False, '_type': 'AsValue'}}
bdt. classname is  {'content': 'string', '_type': 'ClassName'}
Python type is  <class 'dict'>  type_label is  ClassName
Python type is  <class 'dict'>  type_label is  AsValue
Found ASVALUE dict {'t_value': False, '_type': 'AsValue'}
htmls are:  ['<span class="class_name_link" href="#string">string</span>\n', '<span class="as_value">value</span>']
Pieces are:  ['<span class="class_name_link" href="#string">string</span>\n', '<span class="as_value">value</span>']
span returning:  <span class="BaseDataType">
<span class="class_name_link" href="#string">string</span>

<span class="as_value">value</span></span>
htmls are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#string">string</span>\n\n<span class="as_value">value</span></span>']
Pieces are:  ['', '<span class="BaseDataType">\n<span class="class_name_link" href="#string">string</span>\n\n<span class="as_value">value</span></span>']
span returning:  <span class="DataTypeClause">

<span class="BaseDataType">
<span class="class_name_link" href="#string">string</span>

<span class="as_value">value</span></span></span>
Python type is  <class 'dict'>  type_label is  Constraint
Python type is  <class 'dict'>  type_label is  Class
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'PrimitiveType', '_type': 'ClassName'} the_name = PrimitiveType
Subtyping pair is:  (ClassName(content='ValueType\nA basic', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#ValueType\nA basic">ValueType\nA basic</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#ValueType
A basic">ValueType
A basic</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Subtyping pair is:  (ClassName(content='built-in data type', _type='ClassName'), SubtypingName(content='Subtypes', _type='SubtypingName'))
Python type is  <class 'Literate_01.ClassName'>  type_label is  ClassName
Subtyping element is :  Subtypes
Pieces are:  ['<span class="class_name_link" href="#built-in data type">built-in data type</span>\n', 'bySomething']
Div returning:  <div class="subtype_pair">
<span class="class_name_link" href="#built-in data type">built-in data type</span>

bySomething</div>
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
Python type is  <class 'dict'>  type_label is  Annotation
Pieces are:  ['', '<span class=label>Values</span>', '']
Div returning:  <div class="Annotation">

<span class=label>Values</span>
</div>
Python type is  <class 'dict'>  type_label is  SubjectB
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'} the_name = Appendices
Insert More Sidebars.md
Insert Overrides.md
insert LDM Intro.md
Insert OCL.md
Insert Camel Case.md
Python type is  <class 'dict'>  type_label is  SubjectC
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Annotation Types Used', '_type': 'SubjectName'} the_name = Annotation Types Used
Python type is  <class 'dict'>  type_label is  Paragraph
Adding simple: Paragraph with These are the recognized Annotation Types for the LDM model.

Python type is  <class 'dict'>  type_label is  Paragraph
Adding simple: Paragraph with And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.

Python type is  <class 'dict'>  type_label is  CodeBlock
Adding simple: CodeBlock with ```typescript
interface AnnotationType {
label: string;
emoji: string;
emojiName: string;
emojiUnicode: string;
purpose: string;
}
// LINK: LiterateDataModel.annotationTypes
const annotationTypes: AnnotationType[] = [
{
label: "Error",
emoji: "",
emojiName: "cross_mark",
emojiUnicode: "U+274C",
purpose: "Indicates a critical error or failure in the model."
},
{
label: "Warning",
emoji: "",
emojiName: "warning",
emojiUnicode: "U+26A0",
purpose: "Indicates a potential issue or warning in the model."
},
{
label: "Note",
emoji: "",
emojiName: "blue_book",
emojiUnicode: "U+1F4D8",
purpose: "Provides additional context, explanations, or clarifications for the annotated element."
},
{
label: "Issue",
emoji: "",
emojiName: "warning",
emojiUnicode: "U+26A0",
purpose: "Highlights a potential issue or error that needs to be addressed or resolved."
},
{
label: "Question",
emoji: "",
emojiName: "question",
emojiUnicode: "U+2753",
purpose: "Raises a question or seeks further clarification about the annotated element."
},
{
label: "Suggestion",
emoji: "",
emojiName: "bulb",
emojiUnicode: "U+1F4A1",
purpose: "Provides a suggestion or recommendation for improving the model or the annotated element."
},
{
label: "Info",
emoji: "",
emojiName: "information_source",
emojiUnicode: "U+2139",
purpose: "Offers relevant information, facts, or details about the annotated element."
},
{
label: "Todo",
emoji: "",
emojiName: "pushpin",
emojiUnicode: "U+1F4CC",
purpose: "Indicates a pending task, action item, or future work related to the annotated element."
},
{
label: "Reference",
emoji: "",
emojiName: "globe_with_meridians",
emojiUnicode: "U+1F310",
purpose: "Provides a reference or link to an external resource or documentation."
},
{
label: "See",
emoji: "",
emojiName: "mag",
emojiUnicode: "U+1F50D",
purpose: "Indicates a cross-reference to another relevant element within the model."
}
];
```
Python type is  <class 'dict'>  type_label is  Paragraph
Adding simple: Paragraph with ===

Python type is  <class 'dict'>  type_label is  SubjectB
Python type is  <class 'str'>  type_label is  NoNonDictTypeLabel
add anchor called for key_name = name, value = {'content': 'Appendices\nInsert More Sidebars.md\nInsert Overrides.md\ninsert LDM Intro.md\nInsert OCL.md\nInsert Camel Case.md', '_type': 'SubjectName'} the_name = Appendices
Insert More Sidebars.md
Insert Overrides.md
insert LDM Intro.md
Insert OCL.md
Insert Camel Case.md
Python type is  <class 'dict'>  type_label is  Paragraph
Adding simple: Paragraph with == content to add

Saved styled dictionary to ldm/ldm_models/Literate_results/Literate.html

Phase: Skipping PDF creation

Phase: Creating PDF from html and css
PDFing for ldm/ldm_models/Literate_results/Literate.html written to ldm/ldm_models/Literate_results/Literate.pdf
PDF for ldm/ldm_models/Literate_results/Literate.html written to ldm/ldm_models/Literate_results/Literate.pdf
