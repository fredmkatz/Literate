parts needed:  {'Constraint', 'SubjectB', 'Class', 'SubjectC', 'Attribute', 'AttributeSection', 'SubjectE', 'SubjectD', 'Annotation', 'Default', 'Derivation', 'LDM'}
Model dir:  ldm
Model doc:  LDMMeta.md
Model name:  LDMMeta
Model doc path:  ldm/LDMMeta.md
Model module:  Literate01.py
Model module path:  ldm/Literate01.py
Results dir:  ldm/LDMMeta_results
PARSING ldm/LDMMeta.md
Starting code bock - for label CODE_FENCE
Starting code bock - for label CODE_FENCE
Starting code bock - for label CODE_FENCE
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='This is a section with no real content, except for these intro words and other sections.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='And this is the elaboration', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='This is a section with no real content, except for these intro words and other sections.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='And this is the elaboration', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "This is a section with no real content, except for these intro words and other sections."
    },
    {
      "type_label": "TEXT_LINE",
      "content": "And this is the elaboration"
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='This is a section with no real content, except for these intro words and other sections.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='And this is the elaboration', extra_text=[])]
	 x is  TEXT_LINE: This is a section with no real content, except for these intro words and other sections.
	 and full text is  This is a section with no real content, except for these intro words and other sections.
	 x is  TEXT_LINE: And this is the elaboration
	 and full text is  And this is the elaboration
ReturningElaboration:  [{'_type': 'Paragraph', 'content': 'This is a section with no real content, except for these intro words and other sections. \n+ And this is the elaboration'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': 'This is a section with no real content, except for these intro words and other sections. \n+ And this is the elaboration'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.', extra_text=[])], extra_text=[]), TypedLine(type_label='CODE_FENCE', line_Type=None, content='```', extra_text=['Sample code block between paragraphs', 'x <  y and y > z', '```']), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.', extra_text=[])], extra_text=[]), TypedLine(type_label='CODE_FENCE', line_Type=None, content='```', extra_text=['Sample code block between paragraphs', 'x <  y and y > z', '```']), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model."
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.', extra_text=[])]
	 x is  TEXT_LINE: In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.
	 and full text is  In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.
Subitem:  {
  "type_label": "CODE_FENCE",
  "content": "```",
  "extra_text": [
    "Sample code block between paragraphs",
    "x <  y and y > z",
    "```"
  ]
}
CodeContent:  ```
CodeFullText:  ```Sample code block between paragraphs
 - x <  y and y > z
 - ```
PieceContent:  {'_type': 'CodeBlock', 'content': '```Sample code block between paragraphs\n - x <  y and y > z\n - ```'}
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component."
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.', extra_text=[])]
	 x is  TEXT_LINE: We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.
	 and full text is  We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.
ReturningElaboration:  [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.'}, {'_type': 'CodeBlock', 'content': '```Sample code block between paragraphs\n - x <  y and y > z\n - ```'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.'}, {'_type': 'CodeBlock', 'content': '```Sample code block between paragraphs\n - x <  y and y > z\n - ```'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.', extra_text=[])], extra_text=[]), TypedLine(type_label='CODE_FENCE', line_Type=None, content='```', extra_text=['Sample code block between paragraphs', 'x <  y and y > z', '```']), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.', extra_text=[])], extra_text=[]), TypedLine(type_label='CODE_FENCE', line_Type=None, content='```', extra_text=['Sample code block between paragraphs', 'x <  y and y > z', '```']), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model."
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.', extra_text=[])]
	 x is  TEXT_LINE: In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.
	 and full text is  In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.
Subitem:  {
  "type_label": "CODE_FENCE",
  "content": "```",
  "extra_text": [
    "Sample code block between paragraphs",
    "x <  y and y > z",
    "```"
  ]
}
CodeContent:  ```
CodeFullText:  ```Sample code block between paragraphs
 - x <  y and y > z
 - ```
PieceContent:  {'_type': 'CodeBlock', 'content': '```Sample code block between paragraphs\n - x <  y and y > z\n - ```'}
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component."
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.', extra_text=[])]
	 x is  TEXT_LINE: We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.
	 and full text is  We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.
ReturningElaboration:  [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.'}, {'_type': 'CodeBlock', 'content': '```Sample code block between paragraphs\n - x <  y and y > z\n - ```'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.'}, {'_type': 'CodeBlock', 'content': '```Sample code block between paragraphs\n - x <  y and y > z\n - ```'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.'}]
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for ABBREVIATION: abbreviation: COMPT
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'abbreviation': 'COMPT'}
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Further elaboration for a Component.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of last paragraph.', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Further elaboration for a Component.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of last paragraph.', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "Further elaboration for a Component."
    },
    {
      "type_label": "TEXT_LINE",
      "content": "End of first paragraph"
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='Further elaboration for a Component.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])]
	 x is  TEXT_LINE: Further elaboration for a Component.
	 and full text is  Further elaboration for a Component.
	 x is  TEXT_LINE: End of first paragraph
	 and full text is  End of first paragraph
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "Start of last paragraph."
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of last paragraph.', extra_text=[])]
	 x is  TEXT_LINE: Start of last paragraph.
	 and full text is  Start of last paragraph.
ReturningElaboration:  [{'_type': 'Paragraph', 'content': 'Further elaboration for a Component. \n+ End of first paragraph'}, {'_type': 'Paragraph', 'content': 'Start of last paragraph.'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': 'Further elaboration for a Component. \n+ End of first paragraph'}, {'_type': 'Paragraph', 'content': 'Start of last paragraph.'}]
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'This is an annotation for the Component class, with extra text onextra lines with extra text on extra lines'}
.. revised Annotation dict:  {'emoji': '', 'label': 'Note', 'content': 'This is an annotation for the Component class, with extra text onextra lines with extra text on extra lines'}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPES: Subtypes: ComponentA, ComponentB, ComponentC
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtypes': ['ComponentA', 'ComponentB', 'ComponentC']}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for BASED_ON: BasedOn: ComponentA, ComponentB, ComponentC
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'based_on': ['ComponentA', 'ComponentB', 'ComponentC']}
Using plural atttribute name:  annotations
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Trying an elaboration for an Attribute declaration clauses.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of second paragraph.', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Trying an elaboration for an Attribute declaration clauses.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of second paragraph.', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "Trying an elaboration for an Attribute declaration clauses."
    },
    {
      "type_label": "TEXT_LINE",
      "content": "End of first paragraph"
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='Trying an elaboration for an Attribute declaration clauses.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])]
	 x is  TEXT_LINE: Trying an elaboration for an Attribute declaration clauses.
	 and full text is  Trying an elaboration for an Attribute declaration clauses.
	 x is  TEXT_LINE: End of first paragraph
	 and full text is  End of first paragraph
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "Start of second paragraph."
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of second paragraph.', extra_text=[])]
	 x is  TEXT_LINE: Start of second paragraph.
	 and full text is  Start of second paragraph.
ReturningElaboration:  [{'_type': 'Paragraph', 'content': 'Trying an elaboration for an Attribute declaration clauses. \n+ End of first paragraph'}, {'_type': 'Paragraph', 'content': 'Start of second paragraph.'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': 'Trying an elaboration for an Attribute declaration clauses. \n+ End of first paragraph'}, {'_type': 'Paragraph', 'content': 'Start of second paragraph.'}]
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for INVERSE: inverseOf: Class.child_class
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'inverse': {'_type': 'AttributeReference', 'class_name': 'Class', 'attribute_name': 'childclass'}}
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Trying an elaboration for an InverseOf clause on an attribute declaration clauses.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of second paragraph.', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Trying an elaboration for an InverseOf clause on an attribute declaration clauses.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of second paragraph.', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "Trying an elaboration for an InverseOf clause on an attribute declaration clauses."
    },
    {
      "type_label": "TEXT_LINE",
      "content": "End of first paragraph"
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='Trying an elaboration for an InverseOf clause on an attribute declaration clauses.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])]
	 x is  TEXT_LINE: Trying an elaboration for an InverseOf clause on an attribute declaration clauses.
	 and full text is  Trying an elaboration for an InverseOf clause on an attribute declaration clauses.
	 x is  TEXT_LINE: End of first paragraph
	 and full text is  End of first paragraph
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "Start of second paragraph."
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of second paragraph.', extra_text=[])]
	 x is  TEXT_LINE: Start of second paragraph.
	 and full text is  Start of second paragraph.
ReturningElaboration:  [{'_type': 'Paragraph', 'content': 'Trying an elaboration for an InverseOf clause on an attribute declaration clauses. \n+ End of first paragraph'}, {'_type': 'Paragraph', 'content': 'Start of second paragraph.'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': 'Trying an elaboration for an InverseOf clause on an attribute declaration clauses. \n+ End of first paragraph'}, {'_type': 'Paragraph', 'content': 'Start of second paragraph.'}]
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for INVERSE: inverse: Class.child_class2
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'inverse': {'_type': 'AttributeReference', 'class_name': 'Class', 'attribute_name': 'childclass2'}}
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: ***Default***: name
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' name'}
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Trying an elaboration for a Default declaration clause - ie first part of a Default Formuka object', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of second paragraph.', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Trying an elaboration for a Default declaration clause - ie first part of a Default Formuka object', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of second paragraph.', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "Trying an elaboration for a Default declaration clause - ie first part of a Default Formuka object"
    },
    {
      "type_label": "TEXT_LINE",
      "content": "End of first paragraph"
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='Trying an elaboration for a Default declaration clause - ie first part of a Default Formuka object', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])]
	 x is  TEXT_LINE: Trying an elaboration for a Default declaration clause - ie first part of a Default Formuka object
	 and full text is  Trying an elaboration for a Default declaration clause - ie first part of a Default Formuka object
	 x is  TEXT_LINE: End of first paragraph
	 and full text is  End of first paragraph
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "Start of second paragraph."
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of second paragraph.', extra_text=[])]
	 x is  TEXT_LINE: Start of second paragraph.
	 and full text is  Start of second paragraph.
ReturningElaboration:  [{'_type': 'Paragraph', 'content': 'Trying an elaboration for a Default declaration clause - ie first part of a Default Formuka object \n+ End of first paragraph'}, {'_type': 'Paragraph', 'content': 'Start of second paragraph.'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': 'Trying an elaboration for a Default declaration clause - ie first part of a Default Formuka object \n+ End of first paragraph'}, {'_type': 'Paragraph', 'content': 'Start of second paragraph.'}]
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for CODE: code: This is the OCL code for calculating the name
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'code': ' This is the OCL code for calculating the name'}
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Trying an elaboration for a Default code clause - ie subsequent  part of a Default Formuka object', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of second paragraph.', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Trying an elaboration for a Default code clause - ie subsequent  part of a Default Formuka object', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of second paragraph.', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "Trying an elaboration for a Default code clause - ie subsequent  part of a Default Formuka object"
    },
    {
      "type_label": "TEXT_LINE",
      "content": "End of first paragraph"
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='Trying an elaboration for a Default code clause - ie subsequent  part of a Default Formuka object', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])]
	 x is  TEXT_LINE: Trying an elaboration for a Default code clause - ie subsequent  part of a Default Formuka object
	 and full text is  Trying an elaboration for a Default code clause - ie subsequent  part of a Default Formuka object
	 x is  TEXT_LINE: End of first paragraph
	 and full text is  End of first paragraph
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "Start of second paragraph."
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of second paragraph.', extra_text=[])]
	 x is  TEXT_LINE: Start of second paragraph.
	 and full text is  Start of second paragraph.
ReturningElaboration:  [{'_type': 'Paragraph', 'content': 'Trying an elaboration for a Default code clause - ie subsequent  part of a Default Formuka object \n+ End of first paragraph'}, {'_type': 'Paragraph', 'content': 'Start of second paragraph.'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': 'Trying an elaboration for a Default code clause - ie subsequent  part of a Default Formuka object \n+ End of first paragraph'}, {'_type': 'Paragraph', 'content': 'Start of second paragraph.'}]
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for ENGLISH: English: And thii is an english language rendering
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'english': ' And thii is an english language rendering'}
Using singular atttribute name:  default
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Noting', 'value': 'And this is trying an annotation on a formula clause'}
.. revised Annotation dict:  {'emoji': '', 'label': 'Noting', 'content': 'And this is trying an annotation on a formula clause'}
Using plural atttribute name:  annotations
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for CONSTRAINT: constraint: this is the first constraint for name in Component
Patched att_name is as_entered for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is as_entered
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' this is the first constraint for name in Component'}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for CODE: code: OCL for first constraint
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'code': ' OCL for first constraint'}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for ENGLISH: english: English for first constraint
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'english': ' English for first constraint'}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SEVERITY: Severity: Harsh
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'severity': ' Harsh'}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for MESSAGE: Message: {name} is all wrong - first
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'message': ' {name} is all wrong - first'}
Using plural atttribute name:  constraints
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for CONSTRAINT: constraint: this is the second constraint for name in Component
Patched att_name is as_entered for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is as_entered
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' this is the second constraint for name in Component'}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for CODE: code: OCL for second constraint
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'code': ' OCL for second constraint'}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for ENGLISH: english: English for second constraint
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'english': ' English for second constraint'}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SEVERITY: Severity: Harsh second
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'severity': ' Harsh second'}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for MESSAGE: Message: {name} is all wrong - second
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'message': ' {name} is all wrong - second'}
Using plural atttribute name:  constraints
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Example', 'value': '"LDM" is the short form of "Literate Data Model".'}
.. revised Annotation dict:  {'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}
Using plural atttribute name:  annotations
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: ***Default***: false
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' false'}
Using singular atttribute name:  default
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}
.. revised Annotation dict:  {'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content="And after that very long onelner on the Note, here's additional elaboration on  it", extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='With a second line in the first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='And another paragraph, too.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='Also with a second line', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content="And after that very long onelner on the Note, here's additional elaboration on  it", extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='With a second line in the first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='And another paragraph, too.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='Also with a second line', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "And after that very long onelner on the Note, here's additional elaboration on  it"
    },
    {
      "type_label": "TEXT_LINE",
      "content": "With a second line in the first paragraph"
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content="And after that very long onelner on the Note, here's additional elaboration on  it", extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='With a second line in the first paragraph', extra_text=[])]
	 x is  TEXT_LINE: And after that very long onelner on the Note, here's additional elaboration on  it
	 and full text is  And after that very long onelner on the Note, here's additional elaboration on  it
	 x is  TEXT_LINE: With a second line in the first paragraph
	 and full text is  With a second line in the first paragraph
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "And another paragraph, too."
    },
    {
      "type_label": "TEXT_LINE",
      "content": "Also with a second line"
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='And another paragraph, too.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='Also with a second line', extra_text=[])]
	 x is  TEXT_LINE: And another paragraph, too.
	 and full text is  And another paragraph, too.
	 x is  TEXT_LINE: Also with a second line
	 and full text is  Also with a second line
ReturningElaboration:  [{'_type': 'Paragraph', 'content': "And after that very long onelner on the Note, here's additional elaboration on  it \n+ With a second line in the first paragraph"}, {'_type': 'Paragraph', 'content': 'And another paragraph, too. \n+ Also with a second line'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': "And after that very long onelner on the Note, here's additional elaboration on  it \n+ With a second line in the first paragraph"}, {'_type': 'Paragraph', 'content': 'And another paragraph, too. \n+ Also with a second line'}]
Using plural atttribute name:  annotations
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'wildly', 'value': 'This is an unregistered annotation'}
.. revised Annotation dict:  {'emoji': '', 'label': 'wildly', 'content': 'This is an unregistered annotation'}
Using plural atttribute name:  annotations
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'minorNote', 'value': 'This is a minor note'}
.. revised Annotation dict:  {'emoji': '', 'label': 'minorNote', 'content': 'This is a minor note'}
Using plural atttribute name:  annotations
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'majorNote', 'value': 'And this is a major note. Both should be annotations'}
.. revised Annotation dict:  {'emoji': '', 'label': 'majorNote', 'content': 'And this is a major note. Both should be annotations'}
Using plural atttribute name:  annotations
Using plural atttribute name:  attributes
Using plural atttribute name:  attribute_sections
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DERIVATION: ***Derivation***: ""
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' ""'}
Using singular atttribute name:  derivation
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DERIVATION: ***Derivation***: ""
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' ""'}
Using singular atttribute name:  derivation
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DERIVATION: ***Derivation***: mdPrefix + name + " - " + oneLiner + mdSuffix
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' mdPrefix + name + " - " + oneLiner + mdSuffix'}
Using singular atttribute name:  derivation
Using plural atttribute name:  attributes
Using plural atttribute name:  attribute_sections
Using plural atttribute name:  classes
Annotation dict:  {'line_type': 'text', 'content': 'See. this is not included in the extra text.'}
.. revised Annotation dict:  {'content': None}
Using plural atttribute name:  annotations
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.'}
.. revised Annotation dict:  {'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.'}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for BASED_ON: ***Based on*** : Literate Data Model
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'based_on': ['Literate Data Model']}
Using plural atttribute name:  annotations
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: Default: based on label
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' based on label'}
Using singular atttribute name:  default
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  classes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for BASED_ON: ***Based on***: Component
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'based_on': ['Component']}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}
.. revised Annotation dict:  {'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}
Using plural atttribute name:  annotations
Using plural atttribute name:  attributes
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='But any short label is valid.', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='But any short label is valid.', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "But any short label is valid."
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='But any short label is valid.', extra_text=[])]
	 x is  TEXT_LINE: But any short label is valid.
	 and full text is  But any short label is valid.
ReturningElaboration:  [{'_type': 'Paragraph', 'content': 'But any short label is valid.'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': 'But any short label is valid.'}]
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: Default: from annotationType
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' from annotationType'}
Using singular atttribute name:  default
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: Default: from annotation type
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' from annotation type'}
Using singular atttribute name:  default
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: ***Default***: false
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' false'}
Using singular atttribute name:  default
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}
.. revised Annotation dict:  {'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}
Using plural atttribute name:  annotations
Using plural atttribute name:  attributes
Using plural atttribute name:  attribute_sections
Using plural atttribute name:  classes
Using plural atttribute name:  subject_bs
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for ABBREVIATION: ***Abbreviation***: LDM
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'abbreviation': 'LDM'}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for PLURAL: Plural: LiterateDataModels
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'plural': ' LiterateDataModels'}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Component
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtype_of': ['Component']}
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DERIVATION: Derivation: gathering s.allSubjects over s in subjectAreas
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' gathering s.allSubjects over s in subjectAreas'}
Using singular atttribute name:  derivation
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for CONSTRAINT: ***Constraint***: Subject names must be unique across the model.
Patched att_name is as_entered for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is as_entered
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' Subject names must be unique across the model.'}
Using plural atttribute name:  constraints
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DERIVATION: Derivation: gathering s.allClasses over s in allSubjects.
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' gathering s.allClasses over s in allSubjects.'}
Using singular atttribute name:  derivation
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for CONSTRAINT: ***Constraint***: Class names must be unique across the model.
Patched att_name is as_entered for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is as_entered
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' Class names must be unique across the model.'}
Using plural atttribute name:  constraints
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: Default: OCL
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' OCL'}
Using singular atttribute name:  default
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: Default: Handlebars
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' Handlebars'}
Using singular atttribute name:  default
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DERIVATION: Derivation: ['aiEnglishPlural()']
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': " ['aiEnglishPlural()']"}
Using singular atttribute name:  derivation
Using plural atttribute name:  attributes
Using plural atttribute name:  attribute_sections
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DERIVATION: ***Derivation***: "# "
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' "# "'}
Using singular atttribute name:  derivation
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DERIVATION: ***Derivation***: mdPrefix + name
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' mdPrefix + name'}
Using singular atttribute name:  derivation
Using plural atttribute name:  attributes
Using plural atttribute name:  attribute_sections
Using plural atttribute name:  classes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for PLURAL: Plural: Subjects
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'plural': ' Subjects'}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Component
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtype_of': ['Component']}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEPENDENT_OF: Dependent of: LiterateDataModel
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'dependent_of': ['LiterateDataModel']}
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Subjects are the chapters an sections of the model.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='A subject need not contain any Classes if it’s just expository.', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Subjects are the chapters an sections of the model.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='A subject need not contain any Classes if it’s just expository.', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "Subjects are the chapters an sections of the model."
    },
    {
      "type_label": "TEXT_LINE",
      "content": "A subject need not contain any Classes if it\u2019s just expository."
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='Subjects are the chapters an sections of the model.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='A subject need not contain any Classes if it’s just expository.', extra_text=[])]
	 x is  TEXT_LINE: Subjects are the chapters an sections of the model.
	 and full text is  Subjects are the chapters an sections of the model.
	 x is  TEXT_LINE: A subject need not contain any Classes if it’s just expository.
	 and full text is  A subject need not contain any Classes if it’s just expository.
ReturningElaboration:  [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model. \n+ A subject need not contain any Classes if it’s just expository.'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model. \n+ A subject need not contain any Classes if it’s just expository.'}]
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Issue', 'value': 'define chapter, section, subsection as levels?***DSL***: Generally, it is best to present the classes within a Subject in top down order:'}
.. revised Annotation dict:  {'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?***DSL***: Generally, it is best to present the classes within a Subject in top down order:'}
Using plural atttribute name:  annotations
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for INVERSE: inverse of: Subject.parentSubject.
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'inverse': {'_type': 'AttributeReference', 'class_name': 'Subject', 'attribute_name': 'parentSubject.'}}
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='***DSL***:  the Classes within a Subject are always displayed before the childSubjects.', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='***DSL***:  the Classes within a Subject are always displayed before the childSubjects.', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "***DSL***:  the Classes within a Subject are always displayed before the childSubjects."
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='***DSL***:  the Classes within a Subject are always displayed before the childSubjects.', extra_text=[])]
	 x is  TEXT_LINE: ***DSL***:  the Classes within a Subject are always displayed before the childSubjects.
	 and full text is  ***DSL***:  the Classes within a Subject are always displayed before the childSubjects.
ReturningElaboration:  [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.'}]
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DERIVATION: ***Derivation***: levelIndicator + " "
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' levelIndicator + " "'}
Using singular atttribute name:  derivation
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DERIVATION: ***Derivation***: mdPrefix + name.
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' mdPrefix + name.'}
Using singular atttribute name:  derivation
Using plural atttribute name:  attributes
Using plural atttribute name:  attribute_sections
Using plural atttribute name:  classes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for PLURAL: Plural: SubjectAreas
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'plural': ' SubjectAreas'}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Subject
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtype_of': ['Subject']}
Using plural atttribute name:  classes
Using plural atttribute name:  classes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for PLURAL: Plural: Classes
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'plural': ' Classes'}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Component
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtype_of': ['Component']}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for CONSTRAINT: ***Constraint***: Within each Class, attribute names must be unique.
Patched att_name is as_entered for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is as_entered
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' Within each Class, attribute names must be unique.'}
Using plural atttribute name:  constraints
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Might be Books for the Book class or other regular plurals.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='But also might be People for Person.', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Might be Books for the Book class or other regular plurals.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='But also might be People for Person.', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "Might be Books for the Book class or other regular plurals."
    },
    {
      "type_label": "TEXT_LINE",
      "content": "But also might be People for Person."
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='Might be Books for the Book class or other regular plurals.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='But also might be People for Person.', extra_text=[])]
	 x is  TEXT_LINE: Might be Books for the Book class or other regular plurals.
	 and full text is  Might be Books for the Book class or other regular plurals.
	 x is  TEXT_LINE: But also might be People for Person.
	 and full text is  But also might be People for Person.
ReturningElaboration:  [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals. \n+ But also might be People for Person.'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals. \n+ But also might be People for Person.'}]
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.'}
.. revised Annotation dict:  {'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.'}
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "The exception is when a common noun has two plural forms, like People and Persons. But this is unusual."
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.', extra_text=[])]
	 x is  TEXT_LINE: The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.
	 and full text is  The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.
ReturningElaboration:  [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.'}]
Using plural atttribute name:  annotations
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: ***Default***: the regular plural, formed by adding "s" or "es".
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' the regular plural, formed by adding "s" or "es".'}
Using singular atttribute name:  default
Using plural atttribute name:  attributes
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity."
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.', extra_text=[])]
	 x is  TEXT_LINE: This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.
	 and full text is  This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.
ReturningElaboration:  [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.'}]
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'that basedOn and dependentOf are being used synonymousle in this metamodel.ToDo - fix that'}
.. revised Annotation dict:  {'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.ToDo - fix that'}
Using plural atttribute name:  annotations
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Example', 'value': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}
.. revised Annotation dict:  {'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}
Using plural atttribute name:  annotations
Using plural atttribute name:  attributes
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Example', 'value': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}
.. revised Annotation dict:  {'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}
Using plural atttribute name:  annotations
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'Constraints may be expressed on either the Class or the Attribute. Always?Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.'}
.. revised Annotation dict:  {'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.'}
Using plural atttribute name:  annotations
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for INVERSE: ***Inverse of***: Class.basedOn
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'inverse': {'_type': 'AttributeReference', 'class_name': 'Class', 'attribute_name': 'basedOn'}}
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for INVERSE: ***Inverse of***:UniqueKey.basedOn
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'inverse': {'_type': 'AttributeReference', 'class_name': 'UniqueKey', 'attribute_name': 'basedOn'}}
Using plural atttribute name:  attributes
Using plural atttribute name:  attribute_sections
Using plural atttribute name:  classes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEPENDENT_OF: ***Dependent of:*** Class
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'dependent_of': ['Class']}
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: Default: true
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' true'}
Using singular atttribute name:  default
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: Default: true
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' true'}
Using singular atttribute name:  default
Using plural atttribute name:  attributes
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='***DSL***:  Shown in the DSL as', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='> Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='on the super class. And as', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='> Subtype of: SuperClass byBrand', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='on the subclass.', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='***DSL***:  Shown in the DSL as', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='> Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='on the super class. And as', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='> Subtype of: SuperClass byBrand', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='on the subclass.', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "***DSL***:  Shown in the DSL as"
    },
    {
      "type_label": "TEXT_LINE",
      "content": "> Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)"
    },
    {
      "type_label": "TEXT_LINE",
      "content": "on the super class. And as"
    },
    {
      "type_label": "TEXT_LINE",
      "content": "> Subtype of: SuperClass byBrand"
    },
    {
      "type_label": "TEXT_LINE",
      "content": "on the subclass."
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='***DSL***:  Shown in the DSL as', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='> Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='on the super class. And as', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='> Subtype of: SuperClass byBrand', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='on the subclass.', extra_text=[])]
	 x is  TEXT_LINE: ***DSL***:  Shown in the DSL as
	 and full text is  ***DSL***:  Shown in the DSL as
	 x is  TEXT_LINE: > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)
	 and full text is  > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)
	 x is  TEXT_LINE: on the super class. And as
	 and full text is  on the super class. And as
	 x is  TEXT_LINE: > Subtype of: SuperClass byBrand
	 and full text is  > Subtype of: SuperClass byBrand
	 x is  TEXT_LINE: on the subclass.
	 and full text is  on the subclass.
ReturningElaboration:  [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive) \n+ on the super class. And as \n+ > Subtype of: SuperClass byBrand \n+ on the subclass.'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive) \n+ on the super class. And as \n+ > Subtype of: SuperClass byBrand \n+ on the subclass.'}]
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'every class can have an unnamed subtyping.Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.'}
.. revised Annotation dict:  {'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.'}
Using plural atttribute name:  annotations
Using plural atttribute name:  attributes
Using plural atttribute name:  classes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Class.
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtype_of': ['Class.']}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DERIVATION: ***Derivation***: "ValueType: ".
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' "ValueType: ".'}
Using singular atttribute name:  derivation
Using plural atttribute name:  attributes
Using plural atttribute name:  attribute_sections
Using plural atttribute name:  classes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Class.
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtype_of': ['Class.']}
Using plural atttribute name:  classes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: ValueType.
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtype_of': ['ValueType.']}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}
.. revised Annotation dict:  {'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}
Using plural atttribute name:  annotations
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  classes
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'value': 'CodeType'}
.. revised Annotation dict:  {'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}
Using plural atttribute name:  annotations
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  classes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Component
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtype_of': ['Component']}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEPENDENT_OF: DependentOf: Class
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'dependent_of': ['Class']}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for CONSTRAINT: Constraint: each attribute must be a direct or inherited of the base class.
Patched att_name is as_entered for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is as_entered
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' each attribute must be a direct or inherited of the base class.'}
Using plural atttribute name:  constraints
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for CONSTRAINT: Constraint: no repetitions allowed in keyAttributes> 👍 **Issue**: introduce PureLists?
Patched att_name is as_entered for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is as_entered
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' no repetitions allowed in keyAttributes> 👍 **Issue**: introduce PureLists?'}
Using plural atttribute name:  constraints
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Issue', 'value': 'need ascending descending to support index keys or ordering keys.'}
.. revised Annotation dict:  {'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}
Using plural atttribute name:  annotations
Using plural atttribute name:  attributes
Using plural atttribute name:  classes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Key
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtype_of': ['Key']}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'order unimportant for Unique Keys.'}
.. revised Annotation dict:  {'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}
Using plural atttribute name:  annotations
Using plural atttribute name:  classes
Using plural atttribute name:  subject_cs
Using plural atttribute name:  subject_bs
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: ***SubtypeOf***: Component.
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtype_of': ['Component.']}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for BASED_ON: ***Based on***: Class
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'based_on': ['Class']}
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='&nbsp;', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='&nbsp;', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked."
    },
    {
      "type_label": "TEXT_LINE",
      "content": "&nbsp;"
    },
    {
      "type_label": "TEXT_LINE",
      "content": "But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent."
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='&nbsp;', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.', extra_text=[])]
	 x is  TEXT_LINE: If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.
	 and full text is  If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.
	 x is  TEXT_LINE: &nbsp;
	 and full text is  &nbsp;
	 x is  TEXT_LINE: But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.
	 and full text is  But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.
ReturningElaboration:  [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked. \n+ &nbsp; \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked. \n+ &nbsp; \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.'}]
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: ***Default***: "_ "
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' "_ "'}
Using singular atttribute name:  default
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attribute_sections
Using plural atttribute name:  classes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for PLURAL: Plural: Attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'plural': ' Attributes'}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Component
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtype_of': ['Component']}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for BASED_ON: *Based on*: AttributeSection
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'based_on': ['AttributeSection']}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for OVERRIDES: Overrides: CamelName
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}
Using plural atttribute name:  attributes
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='But,', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='But,', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "But,"
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='But,', extra_text=[])]
	 x is  TEXT_LINE: But,
	 and full text is  But,
ReturningElaboration:  [{'_type': 'Paragraph', 'content': 'But,'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': 'But,'}]
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'See', 'value': 'the section below on Data Type Specifiers.'}
.. revised Annotation dict:  {'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}
Using plural atttribute name:  annotations
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: ***Default:*** False
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': '*** False'}
Using singular atttribute name:  default
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DEFAULT: ***Default:***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': '***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.'}
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner."
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.', extra_text=[])]
	 x is  TEXT_LINE: ***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.
	 and full text is  ***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.
ReturningElaboration:  [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.'}]
Using singular atttribute name:  default
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'For example', 'value': ''}
.. revised Annotation dict:  {'emoji': '', 'label': 'For example', 'content': ''}
Using plural atttribute name:  annotations
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'how this works with optionality'}
.. revised Annotation dict:  {'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}
Using plural atttribute name:  annotations
Using plural atttribute name:  attributes
Using plural atttribute name:  attribute_sections
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DERIVATION: ***Derivation***: true if the data type is a class or a simple collection of members of a class.
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' true if the data type is a class or a simple collection of members of a class.'}
Using singular atttribute name:  derivation
Using plural atttribute name:  attributes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for DERIVATION: ***Derivation***: from the data type. Null unless arrribute is invertible.
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' from the data type. Null unless arrribute is invertible.'}
Using singular atttribute name:  derivation
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attribute_sections
Using plural atttribute name:  classes
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': "even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.And let's see if the note can span extra lines, too"}
.. revised Annotation dict:  {'emoji': '', 'label': 'Note', 'content': "even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.And let's see if the note can span extra lines, too"}
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content="Yes, it handled extra lines.  Let's see about additional paras for an annotation", extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Last paragraph here', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content="Yes, it handled extra lines.  Let's see about additional paras for an annotation", extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Last paragraph here', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "Yes, it handled extra lines.  Let's see about additional paras for an annotation"
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content="Yes, it handled extra lines.  Let's see about additional paras for an annotation", extra_text=[])]
	 x is  TEXT_LINE: Yes, it handled extra lines.  Let's see about additional paras for an annotation
	 and full text is  Yes, it handled extra lines.  Let's see about additional paras for an annotation
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "Last paragraph here"
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='Last paragraph here', extra_text=[])]
	 x is  TEXT_LINE: Last paragraph here
	 and full text is  Last paragraph here
ReturningElaboration:  [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation"}, {'_type': 'Paragraph', 'content': 'Last paragraph here'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation"}, {'_type': 'Paragraph', 'content': 'Last paragraph here'}]
Using plural atttribute name:  annotations
Using plural atttribute name:  attributes
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Issue', 'value': 'on insert vs on access?'}
.. revised Annotation dict:  {'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}
Using plural atttribute name:  annotations
Using plural atttribute name:  attributes
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'from Class.constraints'}
.. revised Annotation dict:  {'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}
Using plural atttribute name:  annotations
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attribute_sections
Using plural atttribute name:  classes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for PLURAL: Plural: Derivations
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'plural': ' Derivations'}
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  classes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for PLURAL: Plural: Constraints
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'plural': ' Constraints'}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Component
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtype_of': ['Component']}
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  classes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: **Subtype of**: Constraint
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtype_of': ['Constraint']}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for BASED_ON: ***Based on***: Class.
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'based_on': ['Class.']}
Using plural atttribute name:  classes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: ***Subtype of***: Constraint
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtype_of': ['Constraint']}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for BASED_ON: ***Based on***: Attribute
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'based_on': ['Attribute']}
Using plural atttribute name:  classes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  classes
Using plural atttribute name:  subject_bs
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for PLURAL: Plural: Methods
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'plural': ' Methods'}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Component
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtype_of': ['Component']}
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  classes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for PLURAL: Plural: Parameters
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'plural': ' Parameters'}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: Component
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtype_of': ['Component']}
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  classes
Using plural atttribute name:  subject_bs
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='*ValueType*:**Data Type**', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='*ValueType*:**Data Type**', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "*ValueType*:**Data Type**"
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='*ValueType*:**Data Type**', extra_text=[])]
	 x is  TEXT_LINE: *ValueType*:**Data Type**
	 and full text is  *ValueType*:**Data Type**
ReturningElaboration:  [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**'}]
Using plural atttribute name:  attributes
Using plural atttribute name:  classes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  classes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  classes
Using plural atttribute name:  subject_bs
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='insert Camel Case.md', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='insert Camel Case.md', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "insert Camel Case.md"
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='insert Camel Case.md', extra_text=[])]
	 x is  TEXT_LINE: insert Camel Case.md
	 and full text is  insert Camel Case.md
ReturningElaboration:  [{'_type': 'Paragraph', 'content': 'insert Camel Case.md'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': 'insert Camel Case.md'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case."
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.', extra_text=[])]
	 x is  TEXT_LINE: A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.
	 and full text is  A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.
ReturningElaboration:  [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.'}]
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: ***Subtype of***: String
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtype_of': ['String']}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for CONSTRAINT: ***Constraint***: Must follow the camel case naming convention and not be empty.
Patched att_name is as_entered for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is as_entered
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' Must follow the camel case naming convention and not be empty.'}
Using plural atttribute name:  constraints
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Example', 'value': '"firstName", "orderDate", "customerID"'}
.. revised Annotation dict:  {'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"'}
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "> \ud83d\udcdd ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute."
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.', extra_text=[])]
	 x is  TEXT_LINE: > 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.
	 and full text is  > 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.
ReturningElaboration:  [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.'}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.'}]
Using plural atttribute name:  annotations
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'ModelingNote', 'value': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}
.. revised Annotation dict:  {'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}
Using plural atttribute name:  annotations
Using plural atttribute name:  attributes
Using plural atttribute name:  classes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: **Subtype of**: CamelName
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtype_of': ['CamelName']}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for WHERE: **Where**: content begins with an upper case letter.
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'where': ' content begins with an upper case letter.'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Example', 'value': '_ "Customer", "ProductCategory", "PaymentMethod"'}
.. revised Annotation dict:  {'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}
Using plural atttribute name:  annotations
Using plural atttribute name:  classes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: **Subtype of**: CamelName
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtype_of': ['CamelName']}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for WHERE: **Where**: content begins with a lower case letter.
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'where': ' content begins with a lower case letter.'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Example', 'value': '"firstName", "orderTotal", "shippingAddress"'}
.. revised Annotation dict:  {'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}
Using plural atttribute name:  annotations
Using plural atttribute name:  classes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: ***Subtype of***: String
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtype_of': ['String']}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for CONSTRAINT: ***Constraint***: content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.
Patched att_name is as_entered for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is as_entered
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.'}
Using plural atttribute name:  constraints
Using plural atttribute name:  classes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: ***SubtypeOf***: String
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtype_of': ['String']}
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  attributes
Using plural atttribute name:  classes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: ***SubtypeOf***: RichText
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtype_of': ['RichText']}
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for CONSTRAINT: ***Constraint***: must not containa line break or new line character
Patched att_name is as_entered for MajorClause(line_label='CONSTRAINT', priority=1, class_started='Constraint', word='constraint', attribute_name='constraint', is_list=False, is_cum=True, special_pattern='', plural='constraintes', handlers=ParseTrivial(), kw_pattern='[_\\*]*constraint[_\\*:]*') is as_entered
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'as_entered': ' must not containa line break or new line character'}
Using plural atttribute name:  constraints
Using plural atttribute name:  attributes
Using plural atttribute name:  classes
[dull_parser_core.py:168 -                  derive_clause_dict()] <  Called by derive_dict_for_part with args (0,) {}
derive_clause_dict for SUBTYPE_OF: Subtype of: ValueTypeA basic, built-in data type
[dull_parser_core.py:168 -                  derive_clause_dict()] >  Returned {'subtype_of': ['ValueTypeA basic', 'built-in data type']}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Values', 'value': '**String**'}
.. revised Annotation dict:  {'emoji': '', 'label': 'Values', 'content': '**String**'}
[dull_parser_core.py:118 -               convert_to_paragraphs()] <  Called by derive_dict_for_part with args (TypedLine(type_label='ELABORATION', line_Type=None, content=[TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='===', extra_text=[])], extra_text=[])], extra_text=[]),) {}
Converting to paragraphs:  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='===', extra_text=[])], extra_text=[])]
Subitem:  {
  "type_label": "PARAGRAPH",
  "content": [
    {
      "type_label": "TEXT_LINE",
      "content": "==="
    }
  ]
}
PieceContent:  [TypedLine(type_label='TEXT_LINE', line_Type=None, content='===', extra_text=[])]
	 x is  TEXT_LINE: ===
	 and full text is  ===
ReturningElaboration:  [{'_type': 'Paragraph', 'content': '==='}]
[dull_parser_core.py:118 -               convert_to_paragraphs()] >  Returned [{'_type': 'Paragraph', 'content': '==='}]
Using plural atttribute name:  annotations
Using plural atttribute name:  classes
Using plural atttribute name:  subject_bs
Using plural atttribute name:  subject_cs
Using plural atttribute name:  subject_bs
Using plural atttribute name:  ld_ms
Returned from dict creation
Building class map for module: ldm.Literate_01
[ldm_object_creator.py:38 -                    _build_class_map()] Building class map for module: ldm.Literate_01
Creating model from dictionary: {'_type': 'LDM', 'prefix': '#', 'name': 'Literate Data Model', 'one_liner': 'a detailed descriptionof the contents', 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'This is a section with no real content, except for these intro words and other sections. \n+ And this is the elaboration'}], 'subjects': [{'_type': 'SubjectB', 'prefix': '##', 'name': 'Preliminaries', 'one_liner': 'the basic structureof the model', 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.'}, {'_type': 'CodeBlock', 'content': '```Sample code block between paragraphs\n - x <  y and y > z\n - ```'}, {'_type': 'Paragraph', 'content': 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': 'Component', 'one_liner': 'An element or building block of the literate data model with an extendedOneLiner', 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'Further elaboration for a Component. \n+ End of first paragraph'}, {'_type': 'Paragraph', 'content': 'Start of last paragraph.'}], 'abbreviation': 'COMPT', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This is an annotation for the Component class, with extra text onextra lines with extra text on extra lines', 'subtypes': ['ComponentA', 'ComponentB', 'ComponentC'], 'based_on': ['ComponentA', 'ComponentB', 'ComponentC']}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'parentClass', 'one_liner': 'the supertype - just here to test parser', 'parenthetical': 'Class', 'elaboration': [{'_type': 'Paragraph', 'content': 'Trying an elaboration for an InverseOf clause on an attribute declaration clauses. \n+ End of first paragraph'}, {'_type': 'Paragraph', 'content': 'Start of second paragraph.'}], 'inverse': {'_type': 'AttributeReference', 'class_name': 'Class', 'attribute_name': 'childclass2'}}, {'_type': 'Attribute', 'prefix': '-', 'name': 'normalName', 'one_liner': 'the name of the component, not in camel case', 'parenthetical': '*String*'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'name', 'one_liner': 'The name of the component', 'parenthetical': 'CamelName'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'qualifiedName', 'one_liner': '', 'parenthetical': '*QualifiedCamel*'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'abbreviatedName', 'one_liner': "a short form of the component's name, used for cross references and improved readability.", 'parenthetical': '*CamelName*', 'default': {'_type': 'Default', 'as_entered': ' name', 'elaboration': [{'_type': 'Paragraph', 'content': 'Trying an elaboration for a Default code clause - ie subsequent  part of a Default Formuka object \n+ End of first paragraph'}, {'_type': 'Paragraph', 'content': 'Start of second paragraph.'}], 'code': ' This is the OCL code for calculating the name', 'english': ' And thii is an english language rendering'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Noting', 'content': 'And this is trying an annotation on a formula clause'}, {'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"LDM" is the short form of "Literate Data Model".'}], 'constraints': [{'_type': 'Constraint', 'as_entered': [' this is the first constraint for name in Component'], 'code': ' OCL for first constraint', 'english': ' English for first constraint', 'severity': ' Harsh', 'message': ' {name} is all wrong - first'}, {'_type': 'Constraint', 'as_entered': [' this is the second constraint for name in Component'], 'code': ' OCL for second constraint', 'english': ' English for second constraint', 'severity': ' Harsh second', 'message': ' {name} is all wrong - second'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': 'oneLiner', 'one_liner': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _', 'parenthetical': 'RichLine'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'elaboration', 'one_liner': 'A more detailed explanation or discussion of the component _', 'parenthetical': 'RichText'}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': 'For Machinery', 'one_liner': 'mechanical attributes', 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'isEmbellishment', 'one_liner': 'Indicates whether this component is an embellishment added during post-parsing processing _', 'parenthetical': 'Boolean', 'default': {'_type': 'Default', 'as_entered': ' false'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.', 'elaboration': [{'_type': 'Paragraph', 'content': "And after that very long onelner on the Note, here's additional elaboration on  it \n+ With a second line in the first paragraph"}, {'_type': 'Paragraph', 'content': 'And another paragraph, too. \n+ Also with a second line'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'wildly', 'content': 'This is an unregistered annotation'}, {'_type': 'Annotation', 'emoji': '', 'label': 'minorNote', 'content': 'This is a minor note'}, {'_type': 'Annotation', 'emoji': '', 'label': 'majorNote', 'content': 'And this is a major note. Both should be annotations'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': 'Markdown Support', 'one_liner': '', 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'mdPrefix', 'one_liner': '', 'parenthetical': '*[String](#string', 'derivation': {'_type': 'Derivation', 'as_entered': ' ""'}}, {'_type': 'Attribute', 'prefix': '-', 'name': 'mdSuffix', 'one_liner': '', 'parenthetical': '*[String](#string', 'derivation': {'_type': 'Derivation', 'as_entered': ' ""'}}, {'_type': 'Attribute', 'prefix': '-', 'name': 'mdTopLine', 'one_liner': '', 'parenthetical': '*[String](#string', 'derivation': {'_type': 'Derivation', 'as_entered': ' mdPrefix + name + " - " + oneLiner + mdSuffix'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': 'AnnotationType', 'one_liner': 'a kind of note, or aside, used to call attention to additional information about some Component.And it can be continued on fresh lines.\n - However many you want.\n - But only up to a blank line or other clause', 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'content': None}, {'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.', 'based_on': ['Literate Data Model']}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'emoji', 'one_liner': 'an emoji', 'parenthetical': 'Emoji'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'emojiName', 'one_liner': 'an emoji', 'parenthetical': 'String'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'emojiUnicode', 'one_liner': 'the Unicode for the emoji', 'parenthetical': 'Unicode'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'label', 'one_liner': 'A short label to indicate the purpose of the annotation _', 'parenthetical': 'CamelName'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'plural', 'one_liner': 'the plural form of the label', 'parenthetical': '*UpperCamel*', 'default': {'_type': 'Default', 'as_entered': ' based on label'}}, {'_type': 'Attribute', 'prefix': '-', 'name': 'Purpose', 'one_liner': 'the intended reason for the annotation.', 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': 'ValueType: AnnotationA note or comment associated with a model element', 'one_liner': '', 'parenthetical': '', 'based_on': ['Component'], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'annotationType', 'one_liner': '', 'parenthetical': 'optional Annotation Type', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': 'label', 'one_liner': 'A short label to indicate the purpose of the annotation _', 'parenthetical': 'CamelName', 'elaboration': [{'_type': 'Paragraph', 'content': 'But any short label is valid.'}], 'default': {'_type': 'Default', 'as_entered': ' from annotationType'}}, {'_type': 'Attribute', 'prefix': '-', 'name': 'Emoji', 'one_liner': '', 'parenthetical': 'optional Emoji', 'default': {'_type': 'Default', 'as_entered': ' from annotation type'}}, {'_type': 'Attribute', 'prefix': '-', 'name': 'content', 'one_liner': 'The content or body of the annotation', 'parenthetical': '*RichText*'}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': 'For Machinery', 'one_liner': '', 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'isEmbellishment', 'one_liner': 'Indicates whether this annotation is an embellishment added during post-parsing processing _', 'parenthetical': 'Boolean', 'default': {'_type': 'Default', 'as_entered': ' false'}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}]}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': 'The Model and its Subjects', 'one_liner': '', 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': 'LiterateDataModel', 'one_liner': "A representation of a domain's entities, attributes, and relationships,along with explanatory text and examples", 'parenthetical': '', 'abbreviation': 'LDM', 'plural': ' LiterateDataModels', 'subtype_of': ['Component'], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'name', 'one_liner': '', 'parenthetical': 'UpperCamel'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'allSubjects', 'one_liner': 'list of all classes in the model, as ordered in thedefinition of the model.', 'parenthetical': 'List of Classes', 'derivation': {'_type': 'Derivation', 'as_entered': ' gathering s.allSubjects over s in subjectAreas'}, 'constraints': [{'_type': 'Constraint', 'as_entered': [' Subject names must be unique across the model.']}]}, {'_type': 'Attribute', 'prefix': '-', 'name': 'allClasses', 'one_liner': 'list of all classes in the model, as ordered in the definition of the model.', 'parenthetical': 'List of Classes', 'derivation': {'_type': 'Derivation', 'as_entered': ' gathering s.allClasses over s in allSubjects.'}, 'constraints': [{'_type': 'Constraint', 'as_entered': [' Class names must be unique across the model.']}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': 'Modeling Configuration', 'one_liner': '', 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'annotationTypes', 'one_liner': '', 'parenthetical': 'List of AnnotationTypes'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'Preferred Coding Language', 'one_liner': 'the recommended lanquage  for expressing derivation, defaults, and constraints', 'parenthetical': 'Coding Language', 'default': {'_type': 'Default', 'as_entered': ' OCL'}}, {'_type': 'Attribute', 'prefix': '-', 'name': 'alternate Coding Languages', 'one_liner': '', 'parenthetical': 'optional List of Coding Languages'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'Preferred Template Language', 'one_liner': 'the recommended lanquage  for expressing derivation, defaults, and constraints', 'parenthetical': 'Template Language', 'default': {'_type': 'Default', 'as_entered': ' Handlebars'}}, {'_type': 'Attribute', 'prefix': '-', 'name': 'alternate Template Languages', 'one_liner': '', 'parenthetical': 'optional List of Template Languages'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'aiFunctions', 'one_liner': 'A list of functions that require sophisticated AI-powered implementation *', 'parenthetical': 'List of String', 'derivation': {'_type': 'Derivation', 'as_entered': " ['aiEnglishPlural()']"}}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': 'Markdown Support', 'one_liner': '', 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'mdPrefix', 'one_liner': '', 'parenthetical': '*[String](#string', 'derivation': {'_type': 'Derivation', 'as_entered': ' "# "'}}, {'_type': 'Attribute', 'prefix': '-', 'name': 'mdTopLine', 'one_liner': '', 'parenthetical': '*[String](#string', 'derivation': {'_type': 'Derivation', 'as_entered': ' mdPrefix + name'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': 'SubjectA specific topic or theme within the model', 'one_liner': '', 'parenthetical': '', 'plural': ' Subjects', 'subtype_of': ['Component'], 'dependent_of': ['LiterateDataModel'], 'elaboration': [{'_type': 'Paragraph', 'content': 'Subjects are the chapters an sections of the model. \n+ A subject need not contain any Classes if it’s just expository.'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'name', 'one_liner': '', 'parenthetical': 'UpperCamel'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'parentSubject', 'one_liner': 'The parent subject, if any, under which this subject is nested _', 'parenthetical': 'Subject, optional'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'Classes', 'one_liner': 'The major classes related to this subject, in the order in which they should be presented _', 'parenthetical': 'ListOf Classes', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'define chapter, section, subsection as levels?***DSL***: Generally, it is best to present the classes within a Subject in top down order:'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': 'Each Class should be followed first by the classes that are dependent on it, and then', 'one_liner': '', 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': 'By its subtype classes.', 'one_liner': '', 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': 'childSubjects', 'one_liner': 'Any child subjects nested under this subject, in the order in which they should be presented _', 'parenthetical': 'ListOf Subjects', 'inverse': {'_type': 'AttributeReference', 'class_name': 'Subject', 'attribute_name': 'parentSubject.'}, 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': 'Markdown Support', 'one_liner': '', 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'mdPrefix', 'one_liner': '', 'parenthetical': '*[String](#string', 'derivation': {'_type': 'Derivation', 'as_entered': ' levelIndicator + " "'}}, {'_type': 'Attribute', 'prefix': '-', 'name': 'mdTopLine', 'one_liner': '', 'parenthetical': '*[String](#string', 'derivation': {'_type': 'Derivation', 'as_entered': ' mdPrefix + name.'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': 'SubjectAreaA main topic or area of focus within the model, containing related subjects and classes', 'one_liner': '', 'parenthetical': '', 'plural': ' SubjectAreas', 'subtype_of': ['Subject']}, {'_type': 'Class', 'prefix': '_', 'name': 'Where: parentSubject is absent', 'one_liner': '', 'parenthetical': ''}], 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': 'Classes', 'one_liner': '', 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': 'Class', 'one_liner': 'A key entity or object type in the model, often corresponding to a real-world concept', 'parenthetical': '', 'plural': ' Classes', 'subtype_of': ['Component'], 'constraints': [{'_type': 'Constraint', 'as_entered': [' Within each Class, attribute names must be unique.']}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'pluralForm', 'one_liner': 'the normal English plural form of the name of the Class', 'parenthetical': 'UpperName', 'elaboration': [{'_type': 'Paragraph', 'content': 'Might be Books for the Book class or other regular plurals. \n+ But also might be People for Person.'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.', 'elaboration': [{'_type': 'Paragraph', 'content': 'The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.'}]}], 'default': {'_type': 'Default', 'as_entered': ' the regular plural, formed by adding "s" or "es".'}}, {'_type': 'Attribute', 'prefix': '-', 'name': 'basedOn', 'one_liner': 'the Class or Classes on which this class is dependent', 'parenthetical': 'SetOf Classes', 'elaboration': [{'_type': 'Paragraph', 'content': 'This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'that basedOn and dependentOf are being used synonymousle in this metamodel.ToDo - fix that'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': 'supertypes', 'one_liner': 'The parent class', 'parenthetical': 'es'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'subtypings', 'one_liner': 'the criteria, or dimensions, by which the class can be divided into subtypes', 'parenthetical': 'list of Subtypings', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': 'subtypes', 'one_liner': 'Any subtypes or specializations of this class based on it’s subtypings. _', 'parenthetical': 'ListOf Classes', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': 'attributes', 'one_liner': 'The attributes or properties of the class, in the order in which they should be presented _', 'parenthetical': 'ListOf Attributes'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'attributeSections', 'one_liner': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _', 'parenthetical': 'ListOf AttributeSections'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'constraints', 'one_liner': 'Any constraints, rules, or validations specific to this class _', 'parenthetical': 'ListOf Constraints', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'Constraints may be expressed on either the Class or the Attribute. Always?Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': 'methods', 'one_liner': 'Any behaviors or operations associated with this class _', 'parenthetical': 'ListOf Methods'}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': 'Implied Attributes', 'one_liner': '', 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'dependents', 'one_liner': 'the Classes which are basedOn this Class', 'parenthetical': 'optional SetOf Classes', 'inverse': {'_type': 'AttributeReference', 'class_name': 'Class', 'attribute_name': 'basedOn'}}, {'_type': 'Attribute', 'prefix': '-', 'name': 'UniqueKeys', 'one_liner': '', 'parenthetical': 'optional Set of UniqueKeys', 'inverse': {'_type': 'AttributeReference', 'class_name': 'UniqueKey', 'attribute_name': 'basedOn'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': 'Subtyping', 'one_liner': 'a way in which subtypes of a Class may be classified', 'parenthetical': 'Subtype of Component', 'dependent_of': ['Class'], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'name', 'one_liner': '', 'parenthetical': 'Upper Name'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'is exclusive', 'one_liner': '', 'parenthetical': 'Boolean', 'default': {'_type': 'Default', 'as_entered': ' true'}}, {'_type': 'Attribute', 'prefix': '-', 'name': 'is exhaustive', 'one_liner': '', 'parenthetical': 'Boolean', 'default': {'_type': 'Default', 'as_entered': ' true'}}, {'_type': 'Attribute', 'prefix': '-', 'name': 'classes', 'one_liner': '', 'parenthetical': 'List of Classes', 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***:  Shown in the DSL as \n+ > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive) \n+ on the super class. And as \n+ > Subtype of: SuperClass byBrand \n+ on the subclass.'}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'every class can have an unnamed subtyping.Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': 'ValueType', 'one_liner': '', 'parenthetical': '', 'subtype_of': ['Class.'], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': 'Markdown Support', 'one_liner': '', 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'mdPrefix', 'one_liner': '', 'parenthetical': '*[String](#string', 'derivation': {'_type': 'Derivation', 'as_entered': ' "ValueType: ".'}}]}]}, {'_type': 'Class', 'prefix': '_', 'name': 'Reference Type', 'one_liner': '', 'parenthetical': '', 'subtype_of': ['Class.']}, {'_type': 'Class', 'prefix': '_', 'name': 'CodeTypeA data type or enumeration used in the model', 'one_liner': '', 'parenthetical': '', 'subtype_of': ['ValueType.'], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'List the code values as a bulletted list inside the description of the attribute in the form:‘code: description’', 'one_liner': '', 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.', 'one_liner': '', 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': 'isCaptive', 'one_liner': 'the code type was implied by use in an attribute and is only used for that attribute', 'parenthetical': 'Boolean'}]}, {'_type': 'Class', 'prefix': '_', 'name': 'Code Value', 'one_liner': '', 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'content': 'CodeType'}], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'code', 'one_liner': 'A short code or abbreviationi for the value _', 'parenthetical': 'NameString'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'description', 'one_liner': 'an explanation of what the code means', 'parenthetical': '*RichText*'}]}, {'_type': 'Class', 'prefix': '_', 'name': 'Key', 'one_liner': 'a list of attributes of a class', 'parenthetical': '', 'subtype_of': ['Component'], 'dependent_of': ['Class'], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'keyAttributes', 'one_liner': 'the attributes of the base Class.', 'parenthetical': 'List of Attributes', 'constraints': [{'_type': 'Constraint', 'as_entered': [' each attribute must be a direct or inherited of the base class.']}, {'_type': 'Constraint', 'as_entered': [' no repetitions allowed in keyAttributes> 👍 **Issue**: introduce PureLists?']}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'need ascending descending to support index keys or ordering keys.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': 'UniqueKey', 'one_liner': 'a list of attributes on which instances of the base class may be keyed.', 'parenthetical': '', 'subtype_of': ['Key'], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'order unimportant for Unique Keys.'}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': 'Attributes', 'one_liner': '', 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': 'Attribute Section', 'one_liner': 'a group of attributes for a class that merit a shared explanation.', 'parenthetical': '', 'subtype_of': ['Component.'], 'based_on': ['Class'], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'isOptional', 'one_liner': 'whether the attributes in this section, taken together, are optional.', 'parenthetical': 'Boolean', 'elaboration': [{'_type': 'Paragraph', 'content': 'If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked. \n+ &nbsp; \n+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': 'Markdown Support', 'one_liner': '', 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'mdPrefix', 'one_liner': '', 'parenthetical': '*[String](#string', 'default': {'_type': 'Default', 'as_entered': ' "_ "'}}, {'_type': 'Attribute', 'prefix': '-', 'name': 'mdTopLine', 'one_liner': '', 'parenthetical': '*[String](#string'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': 'AttributeA property or characteristic of a class', 'one_liner': '', 'parenthetical': '', 'plural': ' Attributes', 'subtype_of': ['Component'], 'based_on': ['AttributeSection'], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'name', 'one_liner': '', 'parenthetical': 'Lower Camel', 'overrides': {'_type': 'AttributeReference', 'class_name': 'CamelName', 'attribute_name': ''}}, {'_type': 'Attribute', 'prefix': '-', 'name': 'dataType', 'one_liner': 'The kind of object to which the attribute refers.  _', 'parenthetical': 'DataType', 'elaboration': [{'_type': 'Paragraph', 'content': 'But,'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': 'List of Editions', 'one_liner': '', 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': 'Set of Edition', 'one_liner': '', 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': '... and more complicated cases.', 'one_liner': '', 'parenthetical': '', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'See', 'content': 'the section below on Data Type Specifiers.'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': 'Cardinalities.', 'one_liner': '', 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'isOptional', 'one_liner': 'Indicates whether the attribute must have a value for every instance of the class _', 'parenthetical': 'Boolean', 'default': {'_type': 'Default', 'as_entered': '*** False'}}, {'_type': 'Attribute', 'prefix': '-', 'name': 'cardinality', 'one_liner': 'The cardinality of the relationship represented by the attribute _', 'parenthetical': 'CardinalityCode', 'default': {'_type': 'Default', 'as_entered': '***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.', 'elaboration': [{'_type': 'Paragraph', 'content': '***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.'}]}, 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'For example', 'content': ''}]}, {'_type': 'Attribute', 'prefix': '-', 'name': 'author', 'one_liner': '', 'parenthetical': '1:1 Author'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'books', 'one_liner': '', 'parenthetical': 'optional N:M Set of Books', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'how this works with optionality'}]}]}, {'_type': 'AttributeSection', 'prefix': '__', 'name': 'Inverse Attributes', 'one_liner': '', 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'isInvertible', 'one_liner': '', 'parenthetical': 'Boolean', 'derivation': {'_type': 'Derivation', 'as_entered': ' true if the data type is a class or a simple collection of members of a class.'}}, {'_type': 'Attribute', 'prefix': '-', 'name': 'inverseClass', 'one_liner': 'the class which contains, or would contain the inverse attribute', 'parenthetical': 'optional Class', 'derivation': {'_type': 'Derivation', 'as_entered': ' from the data type. Null unless arrribute is invertible.'}}, {'_type': 'Attribute', 'prefix': '-', 'name': 'inverseAttribute', 'one_liner': '', 'parenthetical': 'optional Attribute'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'inverseIsOptional', 'one_liner': '', 'parenthetical': 'optional Attribute'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': 'Formulas', 'one_liner': '', 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'default', 'one_liner': 'The rule or formula for calculating the value, if no value is suppliedNow running to a second line with the parenthentical on yet a third line\n -', 'parenthetical': 'Derivation, optional', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': "even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.And let's see if the note can span extra lines, too", 'elaboration': [{'_type': 'Paragraph', 'content': "Yes, it handled extra lines.  Let's see about additional paras for an annotation"}, {'_type': 'Paragraph', 'content': 'Last paragraph here'}]}]}, {'_type': 'Attribute', 'prefix': '-', 'name': 'derivation', 'one_liner': 'For derived attributes, the rule or formula for calculating the value _', 'parenthetical': 'Derivation, optional', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Issue', 'content': 'on insert vs on access?'}]}, {'_type': 'Attribute', 'prefix': '-', 'name': 'constraints', 'one_liner': 'Any validation rules specific to this attribute _', 'parenthetical': 'ListOf Constraints', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Note', 'content': 'from Class.constraints'}]}], 'attribute_sections': [{'_type': 'AttributeSection', 'prefix': '__', 'name': 'Override Tracking', 'one_liner': '', 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'Overrides', 'one_liner': '', 'parenthetical': ''}]}]}, {'_type': 'Class', 'prefix': '_', 'name': 'ValueType: DerivationA rule or formula for deriving the value of an attribute', 'one_liner': '', 'parenthetical': '', 'plural': ' Derivations', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'statement', 'one_liner': 'An English language statement of the derivation rule _', 'parenthetical': 'RichText'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'expression', 'one_liner': 'The formal expression of the derivation in a programming language _', 'parenthetical': 'CodeExpression'}]}, {'_type': 'Class', 'prefix': '_', 'name': 'ValueType: ConstraintA rule, condition, or validation that must be satisfied by the model', 'one_liner': '', 'parenthetical': '', 'plural': ' Constraints', 'subtype_of': ['Component'], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'statement', 'one_liner': 'An English language statement of the constraint _', 'parenthetical': 'RichText'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'expression', 'one_liner': 'The formal expression of the constraint in a programming language', 'parenthetical': 'e.g., OCL _(CodeExpression'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'severity', 'one_liner': '', 'parenthetical': 'Code'}, {'_type': 'Attribute', 'prefix': '-', 'name': '', 'one_liner': '**Warning** - nothing fatal; just a caution', 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': '', 'one_liner': '**Error** - serious. Fix now', 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': 'Message', 'one_liner': '', 'parenthetical': 'Template'}]}, {'_type': 'Class', 'prefix': '_', 'name': 'Class Constraint', 'one_liner': '', 'parenthetical': '', 'subtype_of': ['Constraint'], 'based_on': ['Class.']}, {'_type': 'Class', 'prefix': '_', 'name': 'Attribute Constraint', 'one_liner': '', 'parenthetical': '', 'subtype_of': ['Constraint'], 'based_on': ['Attribute']}, {'_type': 'Class', 'prefix': '_', 'name': 'CodeExpression', 'one_liner': '', 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'Language', 'one_liner': 'the programming language', 'parenthetical': 'Code'}, {'_type': 'Attribute', 'prefix': '-', 'name': '', 'one_liner': 'OCL: Object Constraint Language', 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': '', 'one_liner': 'Java: Java', 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': 'Expression', 'one_liner': '', 'parenthetical': 'String'}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': 'Methods', 'one_liner': '', 'parenthetical': '', 'classes': [{'_type': 'Class', 'prefix': '_', 'name': 'MethodA behavior or operation associated with a class', 'one_liner': '', 'parenthetical': '', 'plural': ' Methods', 'subtype_of': ['Component'], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'parameters', 'one_liner': 'The input parameters of the method _', 'parenthetical': 'ListOf Parameters'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'returnType', 'one_liner': 'The data type of the value returned by the method _', 'parenthetical': 'DataType'}]}, {'_type': 'Class', 'prefix': '_', 'name': 'ParameterAn input to a method', 'one_liner': '', 'parenthetical': '', 'plural': ' Parameters', 'subtype_of': ['Component'], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'type', 'one_liner': 'The data type of the parameter _', 'parenthetical': 'DataType'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'cardinality', 'one_liner': 'The cardinality of the parameter', 'parenthetical': 'e.g., optional, required'}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': 'Data Types', 'one_liner': '', 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': '*ValueType*:**Data Type**'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': 'Simple Data TypeSubtpeOf: DataType', 'one_liner': '', 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'coreClass', 'one_liner': '', 'parenthetical': 'Class'}]}, {'_type': 'Class', 'prefix': '_', 'name': 'Complex Data Type', 'one_liner': '', 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'aggregation', 'one_liner': '', 'parenthetical': 'Aggregating Operator'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'aggregatedTypes', 'one_liner': '', 'parenthetical': 'List of DataTypes'}]}, {'_type': 'Class', 'prefix': '_', 'name': 'Aggregating Operator', 'one_liner': '', 'parenthetical': '', 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'Name', 'one_liner': '', 'parenthetical': 'Code'}, {'_type': 'Attribute', 'prefix': '-', 'name': '', 'one_liner': '**SetOf**', 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': '', 'one_liner': '**ListOf**', 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': '', 'one_liner': '**Mapping**', 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': 'arity', 'one_liner': '', 'parenthetical': 'Integer'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'spelling', 'one_liner': '', 'parenthetical': 'Template'}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': 'Low level Data Types', 'one_liner': '', 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'insert Camel Case.md'}], 'classes': [{'_type': 'Class', 'prefix': '_', 'name': 'ValueType: CamelName', 'one_liner': '', 'parenthetical': '', 'elaboration': [{'_type': 'Paragraph', 'content': 'A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.'}], 'subtype_of': ['String'], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'value: the string', 'one_liner': '', 'parenthetical': 'String', 'constraints': [{'_type': 'Constraint', 'as_entered': [' Must follow the camel case naming convention and not be empty.']}], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderDate", "customerID"', 'elaboration': [{'_type': 'Paragraph', 'content': '> 📝 ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.'}]}, {'_type': 'Annotation', 'emoji': '', 'label': 'ModelingNote', 'content': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}]}]}, {'_type': 'Class', 'prefix': '_', 'name': 'UpperCamel', 'one_liner': 'a CamelName that begins with a capital letter', 'parenthetical': '', 'subtype_of': ['CamelName'], 'where': ' content begins with an upper case letter.', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '_ "Customer", "ProductCategory", "PaymentMethod"'}]}, {'_type': 'Class', 'prefix': '_', 'name': 'LowerCamel', 'one_liner': 'a CamelName that begins with a lower case letter', 'parenthetical': '', 'subtype_of': ['CamelName'], 'where': ' content begins with a lower case letter.', 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Example', 'content': '"firstName", "orderTotal", "shippingAddress"'}]}, {'_type': 'Class', 'prefix': '_', 'name': 'Qualified Camel', 'one_liner': 'an expression consisting of Camel Names separated by periods', 'parenthetical': '', 'subtype_of': ['String'], 'constraints': [{'_type': 'Constraint', 'as_entered': [' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.']}]}, {'_type': 'Class', 'prefix': '_', 'name': 'RichText.  A string with markup for block level formatting.', 'one_liner': '', 'parenthetical': '', 'subtype_of': ['String'], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'value', 'one_liner': 'the string content', 'parenthetical': 'string'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'format', 'one_liner': 'the rich text coding language used', 'parenthetical': 'Code'}, {'_type': 'Attribute', 'prefix': '-', 'name': 'HTML', 'one_liner': '', 'parenthetical': ''}, {'_type': 'Attribute', 'prefix': '-', 'name': 'MarkDown', 'one_liner': '', 'parenthetical': ''}]}, {'_type': 'Class', 'prefix': '_', 'name': 'RichLine', 'one_liner': 'String with markup for line level formatting.', 'parenthetical': '', 'subtype_of': ['RichText'], 'attributes': [{'_type': 'Attribute', 'prefix': '-', 'name': 'value', 'one_liner': 'the string content', 'parenthetical': 'string', 'constraints': [{'_type': 'Constraint', 'as_entered': [' must not containa line break or new line character']}]}]}, {'_type': 'Class', 'prefix': '_', 'name': 'PrimitiveType', 'one_liner': '', 'parenthetical': '', 'subtype_of': ['ValueTypeA basic', 'built-in data type'], 'annotations': [{'_type': 'Annotation', 'emoji': '', 'label': 'Values', 'content': '**String**', 'elaboration': [{'_type': 'Paragraph', 'content': '==='}]}]}]}, {'_type': 'SubjectB', 'prefix': '##', 'name': 'AppendicesInsert More Sidebars.md', 'one_liner': 'Insert Overrides.md\n - insert LDM Intro.md\n - Insert OCL.md\n - Insert Camel Case.md', 'parenthetical': '', 'subjects': [{'_type': 'SubjectC', 'prefix': '###', 'name': 'Annotation Types Used', 'one_liner': '', 'parenthetical': ''}]}]}
Creating object of type: LDM
Creating object of type: Paragraph
...Creatied object of type: Paragraph
Creating object of type: SubjectB
Creating object of type: Paragraph
...Creatied object of type: Paragraph
Creating object of type: CodeBlock
...Creatied object of type: CodeBlock
Creating object of type: Paragraph
...Creatied object of type: Paragraph
Creating object of type: Class
Creating object of type: Paragraph
...Creatied object of type: Paragraph
Creating object of type: Paragraph
...Creatied object of type: Paragraph
Creating object of type: Annotation
[ldm_object_creator.py:126 -                     _prepare_kwargs()] Field subtypes not found in class Annotation
[ldm_object_creator.py:126 -                     _prepare_kwargs()] Field based_on not found in class Annotation
...Creatied object of type: Annotation
Creating object of type: Attribute
Creating object of type: Paragraph
...Creatied object of type: Paragraph
Creating object of type: Paragraph
...Creatied object of type: Paragraph
Creating object of type: AttributeReference
...Creatied object of type: AttributeReference
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Default
Creating object of type: Paragraph
...Creatied object of type: Paragraph
Creating object of type: Paragraph
...Creatied object of type: Paragraph
...Creatied object of type: Default
Creating object of type: Annotation
...Creatied object of type: Annotation
Creating object of type: Annotation
...Creatied object of type: Annotation
Creating object of type: Constraint
...Creatied object of type: Constraint
Creating object of type: Constraint
...Creatied object of type: Constraint
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: AttributeSection
Creating object of type: Attribute
Creating object of type: Default
...Creatied object of type: Default
Creating object of type: Annotation
Creating object of type: Paragraph
...Creatied object of type: Paragraph
Creating object of type: Paragraph
...Creatied object of type: Paragraph
...Creatied object of type: Annotation
Creating object of type: Annotation
...Creatied object of type: Annotation
Creating object of type: Annotation
...Creatied object of type: Annotation
Creating object of type: Annotation
...Creatied object of type: Annotation
...Creatied object of type: Attribute
...Creatied object of type: AttributeSection
Creating object of type: AttributeSection
Creating object of type: Attribute
Creating object of type: Derivation
...Creatied object of type: Derivation
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Derivation
...Creatied object of type: Derivation
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Derivation
...Creatied object of type: Derivation
...Creatied object of type: Attribute
...Creatied object of type: AttributeSection
...Creatied object of type: Class
Creating object of type: Class
Creating object of type: Annotation
[ldm_object_creator.py:94 -                              create()] Error creating Annotation: Annotation.__init__() missing 1 required positional argument: 'label'
Traceback (most recent call last):
  File "C:\Users\fmkat\OneDrive\AllFMKFIles\AllVSCode\FMKProjects\Presentable\ldm_object_creator.py", line 89, in create
    the_obj = cls(**kwargs)
TypeError: Annotation.__init__() missing 1 required positional argument: 'label'
[ldm_object_creator.py:95 -                              create()] Using kwargs: ['content']
Creating object of type: Annotation
[ldm_object_creator.py:126 -                     _prepare_kwargs()] Field based_on not found in class Annotation
...Creatied object of type: Annotation
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Default
...Creatied object of type: Default
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
...Creatied object of type: Class
Creating object of type: Class
Creating object of type: Attribute
Creating object of type: Annotation
...Creatied object of type: Annotation
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Paragraph
...Creatied object of type: Paragraph
Creating object of type: Default
...Creatied object of type: Default
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Default
...Creatied object of type: Default
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: AttributeSection
Creating object of type: Attribute
Creating object of type: Default
...Creatied object of type: Default
Creating object of type: Annotation
...Creatied object of type: Annotation
...Creatied object of type: Attribute
...Creatied object of type: AttributeSection
...Creatied object of type: Class
...Creatied object of type: SubjectB
Creating object of type: SubjectB
Creating object of type: Class
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Derivation
...Creatied object of type: Derivation
Creating object of type: Constraint
...Creatied object of type: Constraint
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Derivation
...Creatied object of type: Derivation
Creating object of type: Constraint
...Creatied object of type: Constraint
...Creatied object of type: Attribute
Creating object of type: AttributeSection
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Default
...Creatied object of type: Default
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Default
...Creatied object of type: Default
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Derivation
...Creatied object of type: Derivation
...Creatied object of type: Attribute
...Creatied object of type: AttributeSection
Creating object of type: AttributeSection
Creating object of type: Attribute
Creating object of type: Derivation
...Creatied object of type: Derivation
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Derivation
...Creatied object of type: Derivation
...Creatied object of type: Attribute
...Creatied object of type: AttributeSection
...Creatied object of type: Class
Creating object of type: Class
Creating object of type: Paragraph
...Creatied object of type: Paragraph
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Annotation
...Creatied object of type: Annotation
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: AttributeReference
...Creatied object of type: AttributeReference
Creating object of type: Paragraph
...Creatied object of type: Paragraph
...Creatied object of type: Attribute
Creating object of type: AttributeSection
Creating object of type: Attribute
Creating object of type: Derivation
...Creatied object of type: Derivation
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Derivation
...Creatied object of type: Derivation
...Creatied object of type: Attribute
...Creatied object of type: AttributeSection
...Creatied object of type: Class
Creating object of type: Class
...Creatied object of type: Class
Creating object of type: Class
...Creatied object of type: Class
Creating object of type: SubjectC
Creating object of type: Class
Creating object of type: Constraint
...Creatied object of type: Constraint
Creating object of type: Attribute
Creating object of type: Paragraph
...Creatied object of type: Paragraph
Creating object of type: Annotation
Creating object of type: Paragraph
...Creatied object of type: Paragraph
...Creatied object of type: Annotation
Creating object of type: Default
...Creatied object of type: Default
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Paragraph
...Creatied object of type: Paragraph
Creating object of type: Annotation
...Creatied object of type: Annotation
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Annotation
...Creatied object of type: Annotation
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Annotation
...Creatied object of type: Annotation
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Annotation
...Creatied object of type: Annotation
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: AttributeSection
Creating object of type: Attribute
Creating object of type: AttributeReference
...Creatied object of type: AttributeReference
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: AttributeReference
...Creatied object of type: AttributeReference
...Creatied object of type: Attribute
...Creatied object of type: AttributeSection
...Creatied object of type: Class
Creating object of type: Class
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Default
...Creatied object of type: Default
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Default
...Creatied object of type: Default
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Paragraph
...Creatied object of type: Paragraph
Creating object of type: Annotation
...Creatied object of type: Annotation
...Creatied object of type: Attribute
...Creatied object of type: Class
Creating object of type: Class
Creating object of type: AttributeSection
Creating object of type: Attribute
Creating object of type: Derivation
...Creatied object of type: Derivation
...Creatied object of type: Attribute
...Creatied object of type: AttributeSection
...Creatied object of type: Class
Creating object of type: Class
...Creatied object of type: Class
Creating object of type: Class
Creating object of type: Annotation
...Creatied object of type: Annotation
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
...Creatied object of type: Class
Creating object of type: Class
Creating object of type: Annotation
...Creatied object of type: Annotation
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
...Creatied object of type: Class
Creating object of type: Class
Creating object of type: Attribute
Creating object of type: Constraint
...Creatied object of type: Constraint
Creating object of type: Constraint
...Creatied object of type: Constraint
Creating object of type: Annotation
...Creatied object of type: Annotation
...Creatied object of type: Attribute
...Creatied object of type: Class
Creating object of type: Class
Creating object of type: Annotation
...Creatied object of type: Annotation
...Creatied object of type: Class
...Creatied object of type: SubjectC
...Creatied object of type: SubjectB
Creating object of type: SubjectB
Creating object of type: Class
Creating object of type: Attribute
Creating object of type: Paragraph
...Creatied object of type: Paragraph
...Creatied object of type: Attribute
Creating object of type: AttributeSection
Creating object of type: Attribute
Creating object of type: Default
...Creatied object of type: Default
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
...Creatied object of type: AttributeSection
...Creatied object of type: Class
Creating object of type: Class
Creating object of type: Attribute
Creating object of type: AttributeReference
...Creatied object of type: AttributeReference
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Paragraph
...Creatied object of type: Paragraph
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Annotation
...Creatied object of type: Annotation
...Creatied object of type: Attribute
Creating object of type: AttributeSection
Creating object of type: Attribute
Creating object of type: Default
...Creatied object of type: Default
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Default
Creating object of type: Paragraph
...Creatied object of type: Paragraph
...Creatied object of type: Default
Creating object of type: Annotation
...Creatied object of type: Annotation
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Annotation
...Creatied object of type: Annotation
...Creatied object of type: Attribute
...Creatied object of type: AttributeSection
Creating object of type: AttributeSection
Creating object of type: Attribute
Creating object of type: Derivation
...Creatied object of type: Derivation
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Derivation
...Creatied object of type: Derivation
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
...Creatied object of type: AttributeSection
...Creatied object of type: Class
Creating object of type: Class
Creating object of type: Attribute
Creating object of type: Annotation
Creating object of type: Paragraph
...Creatied object of type: Paragraph
Creating object of type: Paragraph
...Creatied object of type: Paragraph
...Creatied object of type: Annotation
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Annotation
...Creatied object of type: Annotation
...Creatied object of type: Attribute
Creating object of type: Attribute
Creating object of type: Annotation
...Creatied object of type: Annotation
...Creatied object of type: Attribute
Creating object of type: AttributeSection
Creating object of type: Attribute
...Creatied object of type: Attribute
...Creatied object of type: AttributeSection
...Creatied object of type: Class
Creating object of type: Class
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
...Creatied object of type: Class
Creating object of type: Class
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
...Creatied object of type: Class
Creating object of type: Class
...Creatied object of type: Class
Creating object of type: Class
...Creatied object of type: Class
Creating object of type: Class
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
...Creatied object of type: Class
...Creatied object of type: SubjectB
Creating object of type: SubjectB
Creating object of type: Class
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
...Creatied object of type: Class
Creating object of type: Class
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
...Creatied object of type: Class
...Creatied object of type: SubjectB
Creating object of type: SubjectB
Creating object of type: Paragraph
...Creatied object of type: Paragraph
Creating object of type: Class
Creating object of type: Attribute
...Creatied object of type: Attribute
...Creatied object of type: Class
Creating object of type: Class
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
...Creatied object of type: Class
Creating object of type: Class
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
...Creatied object of type: Class
...Creatied object of type: SubjectB
Creating object of type: SubjectB
Creating object of type: Paragraph
...Creatied object of type: Paragraph
Creating object of type: Class
Creating object of type: Paragraph
...Creatied object of type: Paragraph
Creating object of type: Attribute
Creating object of type: Constraint
...Creatied object of type: Constraint
Creating object of type: Annotation
Creating object of type: Paragraph
...Creatied object of type: Paragraph
...Creatied object of type: Annotation
Creating object of type: Annotation
...Creatied object of type: Annotation
...Creatied object of type: Attribute
...Creatied object of type: Class
Creating object of type: Class
Creating object of type: Annotation
...Creatied object of type: Annotation
...Creatied object of type: Class
Creating object of type: Class
Creating object of type: Annotation
...Creatied object of type: Annotation
...Creatied object of type: Class
Creating object of type: Class
Creating object of type: Constraint
...Creatied object of type: Constraint
...Creatied object of type: Class
Creating object of type: Class
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
Creating object of type: Attribute
...Creatied object of type: Attribute
...Creatied object of type: Class
Creating object of type: Class
Creating object of type: Attribute
Creating object of type: Constraint
...Creatied object of type: Constraint
...Creatied object of type: Attribute
...Creatied object of type: Class
Creating object of type: Class
Creating object of type: Annotation
Creating object of type: Paragraph
...Creatied object of type: Paragraph
...Creatied object of type: Annotation
...Creatied object of type: Class
...Creatied object of type: SubjectB
Creating object of type: SubjectB
Creating object of type: SubjectC
...Creatied object of type: SubjectC
...Creatied object of type: SubjectB
...Creatied object of type: LDM
Created model: <class 'ldm.Literate_01.LDM'>
Model serialized to ldm/LDMMeta_results/LDMMeta.model.json
Model serialized to ldm/LDMMeta_results/LDMMeta.model.yaml
Created model JSON and YAML files
