final pattern for abbreviation = [_\*]*abbreviation[_\*:]*
final pattern for name = [_\*]*name[_\*:]*
final pattern for plural = [_\*]*plural[_\*:]*
final pattern for note = [_\*]*note[_\*:]*
final pattern for issue = [_\*]*issue[_\*:]*
final pattern for example = [_\*]*example[_\*:]*
final pattern for see = [_\*]*see[_\*:]*
final pattern for subtype of = [_\*]*subtype\s?of[_\*:]*
final pattern for subtypes = [_\*]*subtypes[_\*:]*
final pattern for based on = [_\*]*based\s?on[_\*:]*
final pattern for dependents = [_\*]*dependents[_\*:]*
final pattern for Constraint = [_\*]*Constraint[_\*:]*
final pattern for dependent of = [_\*]*dependent\s?of[_\*:]*
final pattern for where = [_\*]*where[_\*:]*
final pattern for plural = [_\*]*plural[_\*:]*
final pattern for data type = [_\*]*data\s?type[_\*:]*
final pattern for inverse = [_\*]*inverse[_\*:]*
final pattern for inverse of = [_\*]*inverse\s?of[_\*:]*
final pattern for overrides = [_\*]*overrides[_\*:]*
final pattern for Derivation = [_\*]*Derivation[_\*:]*
final pattern for Default = [_\*]*Default[_\*:]*
final pattern for code = [_\*]*code[_\*:]*
final pattern for english = [_\*]*english[_\*:]*
final pattern for message = [_\*]*message[_\*:]*
final pattern for severity = [_\*]*severity[_\*:]*
final pattern for value type = [_\*]*value\s?type[_\*:]*
parse_name_list: **Item1**, *Item2*, Item3
All tests passed!
final pattern for abbreviation = [_\*]*abbreviation[_\*:]*
final pattern for name = [_\*]*name[_\*:]*
final pattern for plural = [_\*]*plural[_\*:]*
final pattern for note = [_\*]*note[_\*:]*
final pattern for issue = [_\*]*issue[_\*:]*
final pattern for example = [_\*]*example[_\*:]*
final pattern for see = [_\*]*see[_\*:]*
final pattern for subtype of = [_\*]*subtype\s?of[_\*:]*
final pattern for subtypes = [_\*]*subtypes[_\*:]*
final pattern for based on = [_\*]*based\s?on[_\*:]*
final pattern for dependents = [_\*]*dependents[_\*:]*
final pattern for Constraint = [_\*]*Constraint[_\*:]*
final pattern for dependent of = [_\*]*dependent\s?of[_\*:]*
final pattern for where = [_\*]*where[_\*:]*
final pattern for data type = [_\*]*data\s?type[_\*:]*
final pattern for inverse = [_\*]*inverse[_\*:]*
final pattern for inverse of = [_\*]*inverse\s?of[_\*:]*
final pattern for overrides = [_\*]*overrides[_\*:]*
final pattern for Derivation = [_\*]*Derivation[_\*:]*
final pattern for Default = [_\*]*Default[_\*:]*
final pattern for Constraint = [_\*]*Constraint[_\*:]*
final pattern for code = [_\*]*code[_\*:]*
final pattern for english = [_\*]*english[_\*:]*
final pattern for message = [_\*]*message[_\*:]*
final pattern for severity = [_\*]*severity[_\*:]*
BY PRI
Section5_Head -- 10
Section4_Head -- 9
Section3_Head -- 8
Section2_Head -- 7
AttributeSection_Head -- 2
ABBREVIATION -- 1
NAME -- 1
PLURAL -- 1
NOTE -- 1
ISSUE -- 1
EXAMPLE -- 1
SEE -- 1
LDM_Head -- 1
Class_Head -- 1
ABBREVIATION -- 1
NAME -- 1
PLURAL -- 1
NOTE -- 1
ISSUE -- 1
EXAMPLE -- 1
SEE -- 1
AttributeSection_Head -- 1
Attribute_Head -- 1
ABBREVIATION -- 1
NAME -- 1
PLURAL -- 1
NOTE -- 1
ISSUE -- 1
EXAMPLE -- 1
SEE -- 1
Class_Head -- 1
SUBTYPE_OF -- 1
SUBTYPES -- 1
BASED_ON -- 1
DEPENDENTS -- 1
CONSTRAINT -- 1
DEPENDENT_OF -- 1
WHERE -- 1
Attribute_Head -- 1
ABBREVIATION -- 1
NAME -- 1
PLURAL -- 1
NOTE -- 1
ISSUE -- 1
EXAMPLE -- 1
SEE -- 1
Attribute_Head -- 1
DATA_TYPE -- 1
INVERSE -- 1
INVERSE_OF -- 1
OVERRIDES -- 1
DERIVATION -- 1
DEFAULT -- 1
CONSTRAINT -- 1
CODE -- 1
ENGLISH -- 1
MESSAGE -- 1
SEVERITY -- 1
All clauses: 58:
 [
  {
    "line_label": "ABBREVIATION",
    "priority": 1,
    "word": "abbreviation",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*abbreviation[_\\*:]*"
  },
  {
    "line_label": "NAME",
    "priority": 1,
    "word": "name",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*name[_\\*:]*"
  },
  {
    "line_label": "PLURAL",
    "priority": 1,
    "word": "plural",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*plural[_\\*:]*"
  },
  {
    "line_label": "NOTE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "note",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*note[_\\*:]*"
  },
  {
    "line_label": "ISSUE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "issue",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*issue[_\\*:]*"
  },
  {
    "line_label": "EXAMPLE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "example",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*example[_\\*:]*"
  },
  {
    "line_label": "SEE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "see",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*see[_\\*:]*"
  },
  {
    "line_label": "Section5_Head",
    "priority": 10,
    "class_started": "Section5",
    "starter_pattern": "#####",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "Section4_Head",
    "priority": 9,
    "class_started": "Section4",
    "starter_pattern": "####",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "Section3_Head",
    "priority": 8,
    "class_started": "Section3",
    "starter_pattern": "###",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "Section2_Head",
    "priority": 7,
    "class_started": "Section2",
    "starter_pattern": "##",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "LDM_Head",
    "priority": 1,
    "class_started": "LDM",
    "starter_pattern": "#",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "Class_Head",
    "priority": 1,
    "class_started": "Class",
    "starter_pattern": "_",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "ABBREVIATION",
    "priority": 1,
    "word": "abbreviation",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*abbreviation[_\\*:]*"
  },
  {
    "line_label": "NAME",
    "priority": 1,
    "word": "name",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*name[_\\*:]*"
  },
  {
    "line_label": "PLURAL",
    "priority": 1,
    "word": "plural",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*plural[_\\*:]*"
  },
  {
    "line_label": "NOTE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "note",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*note[_\\*:]*"
  },
  {
    "line_label": "ISSUE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "issue",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*issue[_\\*:]*"
  },
  {
    "line_label": "EXAMPLE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "example",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*example[_\\*:]*"
  },
  {
    "line_label": "SEE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "see",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*see[_\\*:]*"
  },
  {
    "line_label": "AttributeSection_Head",
    "priority": 1,
    "class_started": "AttributeSection",
    "starter_pattern": "__",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "Attribute_Head",
    "priority": 1,
    "class_started": "Attribute",
    "starter_pattern": "-",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "ABBREVIATION",
    "priority": 1,
    "word": "abbreviation",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*abbreviation[_\\*:]*"
  },
  {
    "line_label": "NAME",
    "priority": 1,
    "word": "name",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*name[_\\*:]*"
  },
  {
    "line_label": "PLURAL",
    "priority": 1,
    "word": "plural",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*plural[_\\*:]*"
  },
  {
    "line_label": "NOTE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "note",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*note[_\\*:]*"
  },
  {
    "line_label": "ISSUE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "issue",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*issue[_\\*:]*"
  },
  {
    "line_label": "EXAMPLE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "example",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*example[_\\*:]*"
  },
  {
    "line_label": "SEE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "see",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*see[_\\*:]*"
  },
  {
    "line_label": "Class_Head",
    "priority": 1,
    "class_started": "Class",
    "starter_pattern": "_",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "SUBTYPE_OF",
    "priority": 1,
    "word": "subtype of",
    "is_list": true,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*subtype\\s?of[_\\*:]*"
  },
  {
    "line_label": "SUBTYPES",
    "priority": 1,
    "word": "subtypes",
    "is_list": true,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*subtypes[_\\*:]*"
  },
  {
    "line_label": "BASED_ON",
    "priority": 1,
    "word": "based on",
    "is_list": true,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*based\\s?on[_\\*:]*"
  },
  {
    "line_label": "DEPENDENTS",
    "priority": 1,
    "word": "dependents",
    "is_list": true,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*dependents[_\\*:]*"
  },
  {
    "line_label": "CONSTRAINT",
    "priority": 1,
    "class_started": "Constraint",
    "word": "Constraint",
    "is_list": true,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*Constraint[_\\*:]*"
  },
  {
    "line_label": "DEPENDENT_OF",
    "priority": 1,
    "word": "dependent of",
    "is_list": true,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*dependent\\s?of[_\\*:]*"
  },
  {
    "line_label": "WHERE",
    "priority": 1,
    "word": "where",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*where[_\\*:]*"
  },
  {
    "line_label": "AttributeSection_Head",
    "priority": 2,
    "class_started": "AttributeSection",
    "starter_pattern": "__",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "Attribute_Head",
    "priority": 1,
    "class_started": "Attribute",
    "starter_pattern": "-",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "ABBREVIATION",
    "priority": 1,
    "word": "abbreviation",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*abbreviation[_\\*:]*"
  },
  {
    "line_label": "NAME",
    "priority": 1,
    "word": "name",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*name[_\\*:]*"
  },
  {
    "line_label": "PLURAL",
    "priority": 1,
    "word": "plural",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*plural[_\\*:]*"
  },
  {
    "line_label": "NOTE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "note",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*note[_\\*:]*"
  },
  {
    "line_label": "ISSUE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "issue",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*issue[_\\*:]*"
  },
  {
    "line_label": "EXAMPLE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "example",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*example[_\\*:]*"
  },
  {
    "line_label": "SEE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "see",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*see[_\\*:]*"
  },
  {
    "line_label": "Attribute_Head",
    "priority": 1,
    "class_started": "Attribute",
    "starter_pattern": "-",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "DATA_TYPE",
    "priority": 1,
    "word": "data type",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*data\\s?type[_\\*:]*"
  },
  {
    "line_label": "INVERSE",
    "priority": 1,
    "word": "inverse",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*inverse[_\\*:]*"
  },
  {
    "line_label": "INVERSE_OF",
    "priority": 1,
    "word": "inverse of",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*inverse\\s?of[_\\*:]*"
  },
  {
    "line_label": "OVERRIDES",
    "priority": 1,
    "word": "overrides",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*overrides[_\\*:]*"
  },
  {
    "line_label": "DERIVATION",
    "priority": 1,
    "class_started": "Derivation",
    "word": "Derivation",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*Derivation[_\\*:]*"
  },
  {
    "line_label": "DEFAULT",
    "priority": 1,
    "class_started": "Default",
    "word": "Default",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*Default[_\\*:]*"
  },
  {
    "line_label": "CONSTRAINT",
    "priority": 1,
    "class_started": "Constraint",
    "word": "Constraint",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*Constraint[_\\*:]*"
  },
  {
    "line_label": "CODE",
    "priority": 1,
    "word": "code",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*code[_\\*:]*"
  },
  {
    "line_label": "ENGLISH",
    "priority": 1,
    "word": "english",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*english[_\\*:]*"
  },
  {
    "line_label": "MESSAGE",
    "priority": 1,
    "word": "message",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*message[_\\*:]*"
  },
  {
    "line_label": "SEVERITY",
    "priority": 1,
    "word": "severity",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*severity[_\\*:]*"
  }
]
All clauses by Priority: 58:
 [
  {
    "line_label": "Section5_Head",
    "priority": 10,
    "class_started": "Section5",
    "starter_pattern": "#####",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "Section4_Head",
    "priority": 9,
    "class_started": "Section4",
    "starter_pattern": "####",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "Section3_Head",
    "priority": 8,
    "class_started": "Section3",
    "starter_pattern": "###",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "Section2_Head",
    "priority": 7,
    "class_started": "Section2",
    "starter_pattern": "##",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "AttributeSection_Head",
    "priority": 2,
    "class_started": "AttributeSection",
    "starter_pattern": "__",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "ABBREVIATION",
    "priority": 1,
    "word": "abbreviation",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*abbreviation[_\\*:]*"
  },
  {
    "line_label": "NAME",
    "priority": 1,
    "word": "name",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*name[_\\*:]*"
  },
  {
    "line_label": "PLURAL",
    "priority": 1,
    "word": "plural",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*plural[_\\*:]*"
  },
  {
    "line_label": "NOTE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "note",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*note[_\\*:]*"
  },
  {
    "line_label": "ISSUE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "issue",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*issue[_\\*:]*"
  },
  {
    "line_label": "EXAMPLE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "example",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*example[_\\*:]*"
  },
  {
    "line_label": "SEE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "see",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*see[_\\*:]*"
  },
  {
    "line_label": "LDM_Head",
    "priority": 1,
    "class_started": "LDM",
    "starter_pattern": "#",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "Class_Head",
    "priority": 1,
    "class_started": "Class",
    "starter_pattern": "_",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "ABBREVIATION",
    "priority": 1,
    "word": "abbreviation",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*abbreviation[_\\*:]*"
  },
  {
    "line_label": "NAME",
    "priority": 1,
    "word": "name",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*name[_\\*:]*"
  },
  {
    "line_label": "PLURAL",
    "priority": 1,
    "word": "plural",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*plural[_\\*:]*"
  },
  {
    "line_label": "NOTE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "note",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*note[_\\*:]*"
  },
  {
    "line_label": "ISSUE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "issue",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*issue[_\\*:]*"
  },
  {
    "line_label": "EXAMPLE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "example",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*example[_\\*:]*"
  },
  {
    "line_label": "SEE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "see",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*see[_\\*:]*"
  },
  {
    "line_label": "AttributeSection_Head",
    "priority": 1,
    "class_started": "AttributeSection",
    "starter_pattern": "__",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "Attribute_Head",
    "priority": 1,
    "class_started": "Attribute",
    "starter_pattern": "-",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "ABBREVIATION",
    "priority": 1,
    "word": "abbreviation",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*abbreviation[_\\*:]*"
  },
  {
    "line_label": "NAME",
    "priority": 1,
    "word": "name",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*name[_\\*:]*"
  },
  {
    "line_label": "PLURAL",
    "priority": 1,
    "word": "plural",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*plural[_\\*:]*"
  },
  {
    "line_label": "NOTE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "note",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*note[_\\*:]*"
  },
  {
    "line_label": "ISSUE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "issue",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*issue[_\\*:]*"
  },
  {
    "line_label": "EXAMPLE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "example",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*example[_\\*:]*"
  },
  {
    "line_label": "SEE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "see",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*see[_\\*:]*"
  },
  {
    "line_label": "Class_Head",
    "priority": 1,
    "class_started": "Class",
    "starter_pattern": "_",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "SUBTYPE_OF",
    "priority": 1,
    "word": "subtype of",
    "is_list": true,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*subtype\\s?of[_\\*:]*"
  },
  {
    "line_label": "SUBTYPES",
    "priority": 1,
    "word": "subtypes",
    "is_list": true,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*subtypes[_\\*:]*"
  },
  {
    "line_label": "BASED_ON",
    "priority": 1,
    "word": "based on",
    "is_list": true,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*based\\s?on[_\\*:]*"
  },
  {
    "line_label": "DEPENDENTS",
    "priority": 1,
    "word": "dependents",
    "is_list": true,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*dependents[_\\*:]*"
  },
  {
    "line_label": "CONSTRAINT",
    "priority": 1,
    "class_started": "Constraint",
    "word": "Constraint",
    "is_list": true,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*Constraint[_\\*:]*"
  },
  {
    "line_label": "DEPENDENT_OF",
    "priority": 1,
    "word": "dependent of",
    "is_list": true,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*dependent\\s?of[_\\*:]*"
  },
  {
    "line_label": "WHERE",
    "priority": 1,
    "word": "where",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*where[_\\*:]*"
  },
  {
    "line_label": "Attribute_Head",
    "priority": 1,
    "class_started": "Attribute",
    "starter_pattern": "-",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "ABBREVIATION",
    "priority": 1,
    "word": "abbreviation",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*abbreviation[_\\*:]*"
  },
  {
    "line_label": "NAME",
    "priority": 1,
    "word": "name",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*name[_\\*:]*"
  },
  {
    "line_label": "PLURAL",
    "priority": 1,
    "word": "plural",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*plural[_\\*:]*"
  },
  {
    "line_label": "NOTE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "note",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*note[_\\*:]*"
  },
  {
    "line_label": "ISSUE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "issue",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*issue[_\\*:]*"
  },
  {
    "line_label": "EXAMPLE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "example",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*example[_\\*:]*"
  },
  {
    "line_label": "SEE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "see",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*see[_\\*:]*"
  },
  {
    "line_label": "Attribute_Head",
    "priority": 1,
    "class_started": "Attribute",
    "starter_pattern": "-",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  {
    "line_label": "DATA_TYPE",
    "priority": 1,
    "word": "data type",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*data\\s?type[_\\*:]*"
  },
  {
    "line_label": "INVERSE",
    "priority": 1,
    "word": "inverse",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*inverse[_\\*:]*"
  },
  {
    "line_label": "INVERSE_OF",
    "priority": 1,
    "word": "inverse of",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*inverse\\s?of[_\\*:]*"
  },
  {
    "line_label": "OVERRIDES",
    "priority": 1,
    "word": "overrides",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*overrides[_\\*:]*"
  },
  {
    "line_label": "DERIVATION",
    "priority": 1,
    "class_started": "Derivation",
    "word": "Derivation",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*Derivation[_\\*:]*"
  },
  {
    "line_label": "DEFAULT",
    "priority": 1,
    "class_started": "Default",
    "word": "Default",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*Default[_\\*:]*"
  },
  {
    "line_label": "CONSTRAINT",
    "priority": 1,
    "class_started": "Constraint",
    "word": "Constraint",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*Constraint[_\\*:]*"
  },
  {
    "line_label": "CODE",
    "priority": 1,
    "word": "code",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*code[_\\*:]*"
  },
  {
    "line_label": "ENGLISH",
    "priority": 1,
    "word": "english",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*english[_\\*:]*"
  },
  {
    "line_label": "MESSAGE",
    "priority": 1,
    "word": "message",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*message[_\\*:]*"
  },
  {
    "line_label": "SEVERITY",
    "priority": 1,
    "word": "severity",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*severity[_\\*:]*"
  }
]
All clause specs: 32:
 {
  "Section5_Head": {
    "line_label": "Section5_Head",
    "priority": 10,
    "class_started": "Section5",
    "starter_pattern": "#####",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  "Section4_Head": {
    "line_label": "Section4_Head",
    "priority": 9,
    "class_started": "Section4",
    "starter_pattern": "####",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  "Section3_Head": {
    "line_label": "Section3_Head",
    "priority": 8,
    "class_started": "Section3",
    "starter_pattern": "###",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  "Section2_Head": {
    "line_label": "Section2_Head",
    "priority": 7,
    "class_started": "Section2",
    "starter_pattern": "##",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  "AttributeSection_Head": {
    "line_label": "AttributeSection_Head",
    "priority": 1,
    "class_started": "AttributeSection",
    "starter_pattern": "__",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  "ABBREVIATION": {
    "line_label": "ABBREVIATION",
    "priority": 1,
    "word": "abbreviation",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*abbreviation[_\\*:]*"
  },
  "NAME": {
    "line_label": "NAME",
    "priority": 1,
    "word": "name",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*name[_\\*:]*"
  },
  "PLURAL": {
    "line_label": "PLURAL",
    "priority": 1,
    "word": "plural",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*plural[_\\*:]*"
  },
  "NOTE": {
    "line_label": "NOTE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "note",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*note[_\\*:]*"
  },
  "ISSUE": {
    "line_label": "ISSUE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "issue",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*issue[_\\*:]*"
  },
  "EXAMPLE": {
    "line_label": "EXAMPLE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "example",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*example[_\\*:]*"
  },
  "SEE": {
    "line_label": "SEE",
    "priority": 1,
    "class_started": "Annotation",
    "word": "see",
    "is_list": false,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*see[_\\*:]*"
  },
  "LDM_Head": {
    "line_label": "LDM_Head",
    "priority": 1,
    "class_started": "LDM",
    "starter_pattern": "#",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  "Class_Head": {
    "line_label": "Class_Head",
    "priority": 1,
    "class_started": "Class",
    "starter_pattern": "_",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  "Attribute_Head": {
    "line_label": "Attribute_Head",
    "priority": 1,
    "class_started": "Attribute",
    "starter_pattern": "-",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    }
  },
  "SUBTYPE_OF": {
    "line_label": "SUBTYPE_OF",
    "priority": 1,
    "word": "subtype of",
    "is_list": true,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*subtype\\s?of[_\\*:]*"
  },
  "SUBTYPES": {
    "line_label": "SUBTYPES",
    "priority": 1,
    "word": "subtypes",
    "is_list": true,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*subtypes[_\\*:]*"
  },
  "BASED_ON": {
    "line_label": "BASED_ON",
    "priority": 1,
    "word": "based on",
    "is_list": true,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*based\\s?on[_\\*:]*"
  },
  "DEPENDENTS": {
    "line_label": "DEPENDENTS",
    "priority": 1,
    "word": "dependents",
    "is_list": true,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*dependents[_\\*:]*"
  },
  "CONSTRAINT": {
    "line_label": "CONSTRAINT",
    "priority": 1,
    "class_started": "Constraint",
    "word": "Constraint",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*Constraint[_\\*:]*"
  },
  "DEPENDENT_OF": {
    "line_label": "DEPENDENT_OF",
    "priority": 1,
    "word": "dependent of",
    "is_list": true,
    "is_cum": true,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*dependent\\s?of[_\\*:]*"
  },
  "WHERE": {
    "line_label": "WHERE",
    "priority": 1,
    "word": "where",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*where[_\\*:]*"
  },
  "DATA_TYPE": {
    "line_label": "DATA_TYPE",
    "priority": 1,
    "word": "data type",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*data\\s?type[_\\*:]*"
  },
  "INVERSE": {
    "line_label": "INVERSE",
    "priority": 1,
    "word": "inverse",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*inverse[_\\*:]*"
  },
  "INVERSE_OF": {
    "line_label": "INVERSE_OF",
    "priority": 1,
    "word": "inverse of",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*inverse\\s?of[_\\*:]*"
  },
  "OVERRIDES": {
    "line_label": "OVERRIDES",
    "priority": 1,
    "word": "overrides",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*overrides[_\\*:]*"
  },
  "DERIVATION": {
    "line_label": "DERIVATION",
    "priority": 1,
    "class_started": "Derivation",
    "word": "Derivation",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*Derivation[_\\*:]*"
  },
  "DEFAULT": {
    "line_label": "DEFAULT",
    "priority": 1,
    "class_started": "Default",
    "word": "Default",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*Default[_\\*:]*"
  },
  "CODE": {
    "line_label": "CODE",
    "priority": 1,
    "word": "code",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*code[_\\*:]*"
  },
  "ENGLISH": {
    "line_label": "ENGLISH",
    "priority": 1,
    "word": "english",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*english[_\\*:]*"
  },
  "MESSAGE": {
    "line_label": "MESSAGE",
    "priority": 1,
    "word": "message",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*message[_\\*:]*"
  },
  "SEVERITY": {
    "line_label": "SEVERITY",
    "priority": 1,
    "word": "severity",
    "is_list": false,
    "is_cum": false,
    "special_pattern": "",
    "handlers": {
      "parse": "UnserializablePiece",
      "render": "UnserializablePiece",
      "validate": "UnserializablePiece"
    },
    "kw_pattern": "[_\\*]*severity[_\\*:]*"
  }
}
parts needed:  {'Attribute', 'LDM', 'AttributeSection', 'Annotation', 'Derivation', 'Constraint', 'Section2', 'Section5', 'Class', 'Default', 'Section3', 'Section4'}
final pattern for value type = [_\*]*value\s?type[_\*:]*
final pattern for Annotation = [_\*]*Annotation[_\*:]*
Part Parts:
 {
  "Document": [
    "Annotation",
    "LDM",
    "Class",
    "Section2",
    "Section3",
    "Section4",
    "Section5"
  ],
  "LDM": [
    "Annotation",
    "Class",
    "Section2",
    "Section3",
    "Section4",
    "Section5"
  ],
  "Section2": [
    "Annotation",
    "Class",
    "Section3",
    "Section4",
    "Section5"
  ],
  "Section3": [
    "Annotation",
    "Class",
    "Section4",
    "Section5"
  ],
  "Section4": [
    "Annotation",
    "Class",
    "Section5"
  ],
  "Section5": [
    "Annotation",
    "Class"
  ],
  "Class": [
    "Annotation",
    "AttributeSection",
    "Attribute",
    "Constraint"
  ],
  "AttributeSection": [
    "Annotation",
    "Attribute"
  ],
  "Attribute": [
    "Annotation",
    "Derivation",
    "Default",
    "Constraint"
  ]
}
Part Labels:
 {
  "Document": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "Section5_Head",
    "Section4_Head",
    "Section3_Head",
    "Section2_Head",
    "LDM_Head",
    "Class_Head"
  ],
  "LDM": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "Section5_Head",
    "Section4_Head",
    "Section3_Head",
    "Section2_Head",
    "LDM_Head",
    "Class_Head"
  ],
  "Section2": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "Section5_Head",
    "Section4_Head",
    "Section3_Head",
    "Section2_Head",
    "LDM_Head",
    "Class_Head"
  ],
  "Section3": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "Section5_Head",
    "Section4_Head",
    "Section3_Head",
    "Section2_Head",
    "LDM_Head",
    "Class_Head"
  ],
  "Section4": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "Section5_Head",
    "Section4_Head",
    "Section3_Head",
    "Section2_Head",
    "LDM_Head",
    "Class_Head"
  ],
  "Section5": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "Section5_Head",
    "Section4_Head",
    "Section3_Head",
    "Section2_Head",
    "LDM_Head",
    "Class_Head"
  ],
  "Class": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "Class_Head",
    "SUBTYPE_OF",
    "SUBTYPES",
    "BASED_ON",
    "DEPENDENTS",
    "CONSTRAINT",
    "DEPENDENT_OF",
    "WHERE",
    "AttributeSection_Head",
    "Attribute_Head"
  ],
  "AttributeSection": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "AttributeSection_Head",
    "Attribute_Head"
  ],
  "Attribute": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "Attribute_Head",
    "DATA_TYPE",
    "INVERSE",
    "INVERSE_OF",
    "OVERRIDES",
    "DERIVATION",
    "DEFAULT",
    "CONSTRAINT"
  ],
  "Derivation": [
    "CODE",
    "ENGLISH",
    "MESSAGE",
    "SEVERITY"
  ],
  "Default": [
    "CODE",
    "ENGLISH",
    "MESSAGE",
    "SEVERITY"
  ],
  "Constraint": [
    "CODE",
    "ENGLISH",
    "MESSAGE",
    "SEVERITY"
  ]
}
For LDM_Head: # Literate Data Model
  new: LDM
Found new part: LDM
... LDM does fit into Document; creating subpart
For Section2_Head: ## Preliminaries
  new: Section2
Found new part: Section2
... Section2 does fit into LDM; creating subpart
Starting code bock - for label CODE_FENCE
Consumed through  CODE_FENCE:  TEXT_LINE: Sample code block between paragraphs
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: x <  y and y > z
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  CODE_FENCE: ```
FOUND CODE BLOCK: ['Sample code block between paragraphs', 'x <  y and y > z', '```']
For Class_Head: _ **Component** - An element or building block of the literate data model with an extendedOneLiner
  new: Class
Found new part: Class
... Class does fit into Section2; creating subpart
Starting code bock - for label CODE_FENCE
Consumed through  CODE_FENCE:  TEXT_LINE: Sample code block between paragraphs
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: x <  y and y > z
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  CODE_FENCE: ```
FOUND CODE BLOCK: ['Sample code block between paragraphs', 'x <  y and y > z', '```']
For Attribute_Head: - parentClass - the supertype - just here to test parser (Class)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **normalName** - the name of the component, not in camel case (*String*)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **name** - The name of the component (CamelName)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **qualifiedName** - (*QualifiedCamel*)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **abbreviatedName** - a short form of the component's name, used for cross references and improved readability. (*CamelName*)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For DEFAULT: ***Default***: name
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
For CONSTRAINT: constraint: this is the first constraint for name in Component
  new: Constraint
Found new part: Constraint
..But Constraint not eligible for Default
... Constraint does fit into Attribute; creating subpart
For CONSTRAINT: constraint: this is the second constraint for name in Component
  new: Constraint
Found new part: Constraint
..But Constraint not eligible for Constraint
... Constraint does fit into Attribute; creating subpart
For EXAMPLE: ***Example***: "LDM" is the short form of "Literate Data Model".
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Constraint
... Annotation does fit into Attribute; creating subpart
For Attribute_Head: - **oneLiner** - A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _(RichLine)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Annotation
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **elaboration** - A more detailed explanation or discussion of the component _(RichText)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For AttributeSection_Head: __***For Machinery*** - mechanical attributes
  new: AttributeSection
Found new part: AttributeSection
..But AttributeSection not eligible for Attribute
... AttributeSection does fit into Class; creating subpart
For Attribute_Head: - **isEmbellishment** - Indicates whether this component is an embellishment added during post-parsing processing _(Boolean)_
  new: Attribute
Found new part: Attribute
... Attribute does fit into AttributeSection; creating subpart
For DEFAULT: ***Default***: false
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
For NOTE: ***Note***: This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Default
... Annotation does fit into Attribute; creating subpart
For AttributeSection_Head: __***Markdown Support***
  new: AttributeSection
Found new part: AttributeSection
..But AttributeSection not eligible for Annotation
..But AttributeSection not eligible for Attribute
..But AttributeSection not eligible for AttributeSection
... AttributeSection does fit into Class; creating subpart
For Attribute_Head: - **mdPrefix** (*[String](#string)*)
  new: Attribute
Found new part: Attribute
... Attribute does fit into AttributeSection; creating subpart
For DERIVATION: ***Derivation***: ""
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
For Attribute_Head: - **mdSuffix** (*[String](#string)*)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Derivation
..But Attribute not eligible for Attribute
... Attribute does fit into AttributeSection; creating subpart
For DERIVATION: ***Derivation***: ""
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
For Attribute_Head: - **mdTopLine** (*[String](#string)*)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Derivation
..But Attribute not eligible for Attribute
... Attribute does fit into AttributeSection; creating subpart
For DERIVATION: ***Derivation***: mdPrefix + name + " - " + oneLiner + mdSuffix
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
For Class_Head: _ **AnnotationType** - a kind of note, or aside, used to call attention to additional information about some Component.And it can be continued on fresh lines. + However many you want. + But only up to a blank line or other clause
  new: Class
Found new part: Class
..But Class not eligible for Derivation
..But Class not eligible for Attribute
..But Class not eligible for AttributeSection
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For SEE: See. this is not included in the extra text.
  new: Annotation
Found new part: Annotation
... Annotation does fit into Class; creating subpart
For NOTE: ***Note***: Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Annotation
... Annotation does fit into Class; creating subpart
For Attribute_Head: - **emoji** - an emoji (Emoji)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Annotation
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **emojiName** - an emoji (String)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **emojiUnicode** - the Unicode for the emoji (Unicode)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **plural** - the plural form of the label (*UpperCamel*).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For DEFAULT: Default: based on label
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
For Attribute_Head: - **Purpose** - the intended reason for the annotation.
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Default
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Class_Head: _ ValueType: **Annotation**A note or comment associated with a model element
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Attribute_Head: - **annotationType** - (optional Annotation Type)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
For NOTE: Note: An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.
  new: Annotation
Found new part: Annotation
... Annotation does fit into Attribute; creating subpart
For Attribute_Head: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Annotation
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For DEFAULT: Default: from annotationType
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
For Attribute_Head: - **Emoji** - (optional Emoji)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Default
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For DEFAULT: Default: from annotation type
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
For Attribute_Head: - **content** - The content or body of the annotation (*RichText*)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Default
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For AttributeSection_Head: __***For Machinery***
  new: AttributeSection
Found new part: AttributeSection
..But AttributeSection not eligible for Attribute
... AttributeSection does fit into Class; creating subpart
For Attribute_Head: - **isEmbellishment** - Indicates whether this annotation is an embellishment added during post-parsing processing _(Boolean)_
  new: Attribute
Found new part: Attribute
... Attribute does fit into AttributeSection; creating subpart
For DEFAULT: ***Default***: false
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
For NOTE: ***Note***: This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Default
... Annotation does fit into Attribute; creating subpart
For Section3_Head: ### Annotation Types Used
  new: Section3
Found new part: Section3
..But Section3 not eligible for Annotation
..But Section3 not eligible for Attribute
..But Section3 not eligible for AttributeSection
..But Section3 not eligible for Class
... Section3 does fit into Section2; creating subpart
Starting code bock - for label CODE_FENCE
Consumed through  CODE_FENCE:  TEXT_LINE: interface AnnotationType {
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: label: string;
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emoji: string;
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emojiName: string;
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emojiUnicode: string;
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: purpose: string;
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: }
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: // LINK: LiterateDataModel.annotationTypes
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: const annotationTypes: AnnotationType[] = [
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: {
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: label: "Error",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emoji: "",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emojiName: "cross_mark",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emojiUnicode: "U+274C",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: purpose: "Indicates a critical error or failure in the model."
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: },
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: {
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: label: "Warning",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emoji: "",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emojiName: "warning",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emojiUnicode: "U+26A0",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: purpose: "Indicates a potential issue or warning in the model."
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: },
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: {
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: label: "Note",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emoji: "",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emojiName: "blue_book",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emojiUnicode: "U+1F4D8",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: purpose: "Provides additional context, explanations, or clarifications for the annotated element."
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: },
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: {
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: label: "Issue",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emoji: "",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emojiName: "warning",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emojiUnicode: "U+26A0",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: purpose: "Highlights a potential issue or error that needs to be addressed or resolved."
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: },
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: {
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: label: "Question",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emoji: "",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emojiName: "question",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emojiUnicode: "U+2753",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: purpose: "Raises a question or seeks further clarification about the annotated element."
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: },
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: {
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: label: "Suggestion",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emoji: "",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emojiName: "bulb",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emojiUnicode: "U+1F4A1",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: purpose: "Provides a suggestion or recommendation for improving the model or the annotated element."
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: },
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: {
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: label: "Info",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emoji: "",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emojiName: "information_source",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emojiUnicode: "U+2139",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: purpose: "Offers relevant information, facts, or details about the annotated element."
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: },
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: {
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: label: "Todo",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emoji: "",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emojiName: "pushpin",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emojiUnicode: "U+1F4CC",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: purpose: "Indicates a pending task, action item, or future work related to the annotated element."
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: },
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: {
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: label: "Reference",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emoji: "",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emojiName: "globe_with_meridians",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emojiUnicode: "U+1F310",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: purpose: "Provides a reference or link to an external resource or documentation."
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: },
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: {
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: label: "See",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emoji: "",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emojiName: "mag",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: emojiUnicode: "U+1F50D",
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: purpose: "Indicates a cross-reference to another relevant element within the model."
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: }
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  TEXT_LINE: ];
TEXT_LINE != CODE_FENCE. continuing
Consumed through  CODE_FENCE:  CODE_FENCE: ```
FOUND CODE BLOCK: ['interface AnnotationType {', 'label: string;', 'emoji: string;', 'emojiName: string;', 'emojiUnicode: string;', 'purpose: string;', '}', '// LINK: LiterateDataModel.annotationTypes', 'const annotationTypes: AnnotationType[] = [', '{', 'label: "Error",', 'emoji: "",', 'emojiName: "cross_mark",', 'emojiUnicode: "U+274C",', 'purpose: "Indicates a critical error or failure in the model."', '},', '{', 'label: "Warning",', 'emoji: "",', 'emojiName: "warning",', 'emojiUnicode: "U+26A0",', 'purpose: "Indicates a potential issue or warning in the model."', '},', '{', 'label: "Note",', 'emoji: "",', 'emojiName: "blue_book",', 'emojiUnicode: "U+1F4D8",', 'purpose: "Provides additional context, explanations, or clarifications for the annotated element."', '},', '{', 'label: "Issue",', 'emoji: "",', 'emojiName: "warning",', 'emojiUnicode: "U+26A0",', 'purpose: "Highlights a potential issue or error that needs to be addressed or resolved."', '},', '{', 'label: "Question",', 'emoji: "",', 'emojiName: "question",', 'emojiUnicode: "U+2753",', 'purpose: "Raises a question or seeks further clarification about the annotated element."', '},', '{', 'label: "Suggestion",', 'emoji: "",', 'emojiName: "bulb",', 'emojiUnicode: "U+1F4A1",', 'purpose: "Provides a suggestion or recommendation for improving the model or the annotated element."', '},', '{', 'label: "Info",', 'emoji: "",', 'emojiName: "information_source",', 'emojiUnicode: "U+2139",', 'purpose: "Offers relevant information, facts, or details about the annotated element."', '},', '{', 'label: "Todo",', 'emoji: "",', 'emojiName: "pushpin",', 'emojiUnicode: "U+1F4CC",', 'purpose: "Indicates a pending task, action item, or future work related to the annotated element."', '},', '{', 'label: "Reference",', 'emoji: "",', 'emojiName: "globe_with_meridians",', 'emojiUnicode: "U+1F310",', 'purpose: "Provides a reference or link to an external resource or documentation."', '},', '{', 'label: "See",', 'emoji: "",', 'emojiName: "mag",', 'emojiUnicode: "U+1F50D",', 'purpose: "Indicates a cross-reference to another relevant element within the model."', '}', '];', '```']
For Section2_Head: ## The Model and its Subjects
  new: Section2
Found new part: Section2
..But Section2 not eligible for Section3
..But Section2 not eligible for Section2
... Section2 does fit into LDM; creating subpart
For Class_Head: _ **LiterateDataModel** - A representation of a domain's entities, attributes, and relationships,along with explanatory text and examples
  new: Class
Found new part: Class
... Class does fit into Section2; creating subpart
For Class_Head: _Subtype of:_ Component
  new: Class
Found new part: Class
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Attribute_Head: - name (UpperCamel )
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - allSubjects - list of all classes in the model, as ordered in thedefinition of the model. (List of Classes)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For DERIVATION: Derivation: gathering s.allSubjects over s in subjectAreas
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
For CONSTRAINT: ***Constraint***: Subject names must be unique across the model.
  new: Constraint
Found new part: Constraint
..But Constraint not eligible for Derivation
... Constraint does fit into Attribute; creating subpart
For Attribute_Head: - allClasses - list of all classes in the model, as ordered in the definition of the model. (List of Classes)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Constraint
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For DERIVATION: Derivation: gathering s.allClasses over s in allSubjects.
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
For CONSTRAINT: ***Constraint***: Class names must be unique across the model.
  new: Constraint
Found new part: Constraint
..But Constraint not eligible for Derivation
... Constraint does fit into Attribute; creating subpart
For AttributeSection_Head: __ 	***Modeling Configuration***
  new: AttributeSection
Found new part: AttributeSection
..But AttributeSection not eligible for Constraint
..But AttributeSection not eligible for Attribute
... AttributeSection does fit into Class; creating subpart
For Attribute_Head: - **annotationTypes** - (List of AnnotationTypes)
  new: Attribute
Found new part: Attribute
... Attribute does fit into AttributeSection; creating subpart
For Attribute_Head: - **Preferred Coding Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Coding Language).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into AttributeSection; creating subpart
For DEFAULT: Default: OCL
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
For Attribute_Head: - **alternate Coding Languages** -  (optional List of Coding Languages).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Default
..But Attribute not eligible for Attribute
... Attribute does fit into AttributeSection; creating subpart
For Attribute_Head: - **Preferred Template Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Template Language).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into AttributeSection; creating subpart
For DEFAULT: Default: Handlebars
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
For Attribute_Head: - **alternate Template Languages** -  (optional List of Template Languages).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Default
..But Attribute not eligible for Attribute
... Attribute does fit into AttributeSection; creating subpart
For Attribute_Head: - **aiFunctions** - A list of functions that require sophisticated AI-powered implementation *(List of String)*
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into AttributeSection; creating subpart
For DERIVATION: Derivation: ['aiEnglishPlural()']
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
For AttributeSection_Head: __***Markdown Support***
  new: AttributeSection
Found new part: AttributeSection
..But AttributeSection not eligible for Derivation
..But AttributeSection not eligible for Attribute
..But AttributeSection not eligible for AttributeSection
... AttributeSection does fit into Class; creating subpart
For Attribute_Head: - **mdPrefix** (*[String](#string)*)
  new: Attribute
Found new part: Attribute
... Attribute does fit into AttributeSection; creating subpart
For DERIVATION: ***Derivation***: "# "
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
For Attribute_Head: - **mdTopLine** (*[String](#string)*)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Derivation
..But Attribute not eligible for Attribute
... Attribute does fit into AttributeSection; creating subpart
For DERIVATION: ***Derivation***: mdPrefix + name
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
For Class_Head: _ **Subject**A specific topic or theme within the model
  new: Class
Found new part: Class
..But Class not eligible for Derivation
..But Class not eligible for Attribute
..But Class not eligible for AttributeSection
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Class_Head: _Subtype of:_ Component
  new: Class
Found new part: Class
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Attribute_Head: - name (UpperCamel )
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **parentSubject** - The parent subject, if any, under which this subject is nested _(Subject, optional)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **Classes** - The major classes related to this subject, in the order in which they should be presented _(ListOf Classes)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For ISSUE: ***Issue***: define chapter, section, subsection as levels?***DSL***: Generally, it is best to present the classes within a Subject in top down order:
  new: Annotation
Found new part: Annotation
... Annotation does fit into Attribute; creating subpart
For Attribute_Head: - Each Class should be followed first by the classes that are dependent on it, and then
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Annotation
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - By its subtype classes.
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **childSubjects** - Any child subjects nested under this subject, in the order in which they should be presented _(ListOf Subjects)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For AttributeSection_Head: __***Markdown Support***
  new: AttributeSection
Found new part: AttributeSection
..But AttributeSection not eligible for Attribute
... AttributeSection does fit into Class; creating subpart
For Attribute_Head: - **mdPrefix** (*[String](#string)*)
  new: Attribute
Found new part: Attribute
... Attribute does fit into AttributeSection; creating subpart
For DERIVATION: ***Derivation***: levelIndicator + " "
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
For Attribute_Head: - **mdTopLine** (*[String](#string)*)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Derivation
..But Attribute not eligible for Attribute
... Attribute does fit into AttributeSection; creating subpart
For DERIVATION: ***Derivation***: mdPrefix + name.
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
For Class_Head: _ **SubjectArea**A main topic or area of focus within the model, containing related subjects and classes
  new: Class
Found new part: Class
..But Class not eligible for Derivation
..But Class not eligible for Attribute
..But Class not eligible for AttributeSection
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Class_Head: _Subtype of:_ Subject
  new: Class
Found new part: Class
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Class_Head: _Where:_ parentSubject is absent
  new: Class
Found new part: Class
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Section3_Head: ### Classes
  new: Section3
Found new part: Section3
..But Section3 not eligible for Class
... Section3 does fit into Section2; creating subpart
For Class_Head: _ **Class** - A key entity or object type in the model, often corresponding to a real-world concept
  new: Class
Found new part: Class
... Class does fit into Section3; creating subpart
For Class_Head: _Subtype of:_ Component
  new: Class
Found new part: Class
..But Class not eligible for Class
... Class does fit into Section3; creating subpart
For CONSTRAINT: ***Constraint***: Within each Class, attribute names must be unique.
  new: Constraint
Found new part: Constraint
... Constraint does fit into Class; creating subpart
For Attribute_Head: - **pluralForm** - the normal English plural form of the name of the Class (UpperName)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Constraint
... Attribute does fit into Class; creating subpart
For NOTE: Note: When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.
  new: Annotation
Found new part: Annotation
... Annotation does fit into Attribute; creating subpart
For DEFAULT: ***Default***: the regular plural, formed by adding "s" or "es".
  new: Default
Found new part: Default
..But Default not eligible for Annotation
... Default does fit into Attribute; creating subpart
For Attribute_Head: - **basedOn** - the Class or Classes on which this class is dependent (SetOf Classes).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Default
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For NOTE: Note: basedOn and dependentOf are being used synonymousle in this metamodel.
  new: Annotation
Found new part: Annotation
... Annotation does fit into Attribute; creating subpart
For ISSUE: issue: fix that
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Annotation
... Annotation does fit into Attribute; creating subpart
For Attribute_Head: - **supertypes** - The parent class(es) from which this class inherits attributes _(ListOf Classes)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Annotation
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **subtypings** - the criteria, or dimensions, by which the class can be divided into subtypes (list of Subtypings).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For EXAMPLE: Example: in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).
  new: Annotation
Found new part: Annotation
... Annotation does fit into Attribute; creating subpart
For Attribute_Head: - **subtypes** - Any subtypes or specializations of this class based on its subtypings. _(ListOf Classes)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Annotation
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For EXAMPLE: Example: For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.
  new: Annotation
Found new part: Annotation
... Annotation does fit into Attribute; creating subpart
For Attribute_Head: - **attributes** - The attributes or properties of the class, in the order in which they should be presented _(ListOf Attributes)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Annotation
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **attributeSections** - additional attributes or properties of the class, grouped for clarity and elaboration.  _(ListOf AttributeSections)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **constraints** - Any constraints, rules, or validations specific to this class _(ListOf Constraints)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For NOTE: Note: Constraints may be expressed on either the Class or the Attribute. Always?Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.
  new: Annotation
Found new part: Annotation
... Annotation does fit into Attribute; creating subpart
For Attribute_Head: - **methods** - Any behaviors or operations associated with this class _(ListOf Methods)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Annotation
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For AttributeSection_Head: __ ***Implied Attributes***
  new: AttributeSection
Found new part: AttributeSection
..But AttributeSection not eligible for Attribute
... AttributeSection does fit into Class; creating subpart
For Attribute_Head: - **dependents** - the Classes which are basedOn this Class (optional SetOf Classes).
  new: Attribute
Found new part: Attribute
... Attribute does fit into AttributeSection; creating subpart
For Attribute_Head: - UniqueKeys - (optional Set of UniqueKeys).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into AttributeSection; creating subpart
For Class_Head: _ **Subtyping** - a way in which subtypes of a Class may be classified (Subtype of Component).
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for AttributeSection
..But Class not eligible for Class
... Class does fit into Section3; creating subpart
For Attribute_Head: - **name** (Upper Name).Usually ByThis or ByThat
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **is exclusive** (Boolean).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For DEFAULT: Default: true
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
For Attribute_Head: - **is exhaustive** (Boolean).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Default
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For DEFAULT: Default: true
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
For Attribute_Head: - **classes** (List of Classes).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Default
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For NOTE: Note: every class can have an unnamed subtyping.Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.
  new: Annotation
Found new part: Annotation
... Annotation does fit into Attribute; creating subpart
For Class_Head: _ **ValueType** -
  new: Class
Found new part: Class
..But Class not eligible for Annotation
..But Class not eligible for Attribute
..But Class not eligible for Class
... Class does fit into Section3; creating subpart
For AttributeSection_Head: __***Markdown Support***
  new: AttributeSection
Found new part: AttributeSection
... AttributeSection does fit into Class; creating subpart
For Attribute_Head: - ***mdPrefix*** (*[String](#string)*)
  new: Attribute
Found new part: Attribute
... Attribute does fit into AttributeSection; creating subpart
For DERIVATION: ***Derivation***: "ValueType: ".
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
For Class_Head: _ **Reference Type**:
  new: Class
Found new part: Class
..But Class not eligible for Derivation
..But Class not eligible for Attribute
..But Class not eligible for AttributeSection
..But Class not eligible for Class
... Class does fit into Section3; creating subpart
For Class_Head: _ **CodeType**A data type or enumeration used in the model
  new: Class
Found new part: Class
..But Class not eligible for Class
... Class does fit into Section3; creating subpart
For Class_Head: _Subtype of:_ ValueType.
  new: Class
Found new part: Class
..But Class not eligible for Class
... Class does fit into Section3; creating subpart
For NOTE: Note: Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:
  new: Annotation
Found new part: Annotation
... Annotation does fit into Class; creating subpart
For Attribute_Head: - List the code values as a bulletted list inside the description of the attribute in the form:**code**: description
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Annotation
... Attribute does fit into Class; creating subpart
For Attribute_Head: - A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - isCaptive - the code type was implied by use in an attribute and is only used for that attribute (Boolean) as
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Class_Head: _ **Code Value**A possible value for an enumerated data class  DependentOf: CodeType
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Class
... Class does fit into Section3; creating subpart
For Attribute_Head: - **code** - A short code or abbreviationi for the value _(NameString)_
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **description** - an explanation of what the code means (*RichText*)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Class_Head: _ **Key** - a list of attributes of a class
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Class
... Class does fit into Section3; creating subpart
For Attribute_Head: - keyAttributes - the attributes of the base Class. (List of Attributes ).
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
For CONSTRAINT: Constraint: each attribute must be a direct or inherited of the base class.
  new: Constraint
Found new part: Constraint
... Constraint does fit into Attribute; creating subpart
For CONSTRAINT: Constraint: no repetitions allowed in keyAttributes>  **Issue**: introduce PureLists?
  new: Constraint
Found new part: Constraint
..But Constraint not eligible for Constraint
... Constraint does fit into Attribute; creating subpart
For ISSUE: Issue: need ascending descending to support index keys or ordering keys.
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Constraint
... Annotation does fit into Attribute; creating subpart
For Class_Head: _ **UniqueKey** - a list of attributes on which instances of the base class may be keyed.
  new: Class
Found new part: Class
..But Class not eligible for Annotation
..But Class not eligible for Attribute
..But Class not eligible for Class
... Class does fit into Section3; creating subpart
For NOTE: Note: order unimportant for Unique Keys.
  new: Annotation
Found new part: Annotation
... Annotation does fit into Class; creating subpart
For Section2_Head: ## Attributes
  new: Section2
Found new part: Section2
..But Section2 not eligible for Annotation
..But Section2 not eligible for Class
..But Section2 not eligible for Section3
..But Section2 not eligible for Section2
... Section2 does fit into LDM; creating subpart
For Class_Head: _ **Attribute Section** - a group of attributes for a class that merit a shared explanation.
  new: Class
Found new part: Class
... Class does fit into Section2; creating subpart
For Attribute_Head: -	isOptional - whether the attributes in this section, taken together, are optional. (Boolean)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
For Class_Head: _If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked. + &nbsp; + But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For AttributeSection_Head: __***Markdown Support***
  new: AttributeSection
Found new part: AttributeSection
... AttributeSection does fit into Class; creating subpart
For Attribute_Head: - **mdPrefix** (*[String](#string)*)
  new: Attribute
Found new part: Attribute
... Attribute does fit into AttributeSection; creating subpart
For DEFAULT: ***Default***: "_ "
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
For Attribute_Head: - **mdTopLine** (*[String](#string)*).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Default
..But Attribute not eligible for Attribute
... Attribute does fit into AttributeSection; creating subpart
For Class_Head: _ **Attribute**A property or characteristic of a class
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for AttributeSection
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Class_Head: _Subtype of:_ Component
  new: Class
Found new part: Class
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Attribute_Head: - **name** - (Lower Camel).
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **dataType** - The kind of object to which the attribute refers.  _(DataType)_H + In the simplest cases, the data type will be a class. And the specifier is the just the name of that class.
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - List of Editions
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - Set of Edition
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - ... and more complicated cases.
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For SEE: ***See***: the section below on Data Type Specifiers.
  new: Annotation
Found new part: Annotation
... Annotation does fit into Attribute; creating subpart
For AttributeSection_Head: __ **Cardinalities**.
  new: AttributeSection
Found new part: AttributeSection
..But AttributeSection not eligible for Annotation
..But AttributeSection not eligible for Attribute
... AttributeSection does fit into Class; creating subpart
For Attribute_Head: - **isOptional** - Indicates whether the attribute must have a value for every instance of the class _(Boolean)_
  new: Attribute
Found new part: Attribute
... Attribute does fit into AttributeSection; creating subpart
For DEFAULT: ***Default:*** False
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
For Attribute_Head: - **cardinality** - The cardinality of the relationship represented by the attribute _(CardinalityCode)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Default
..But Attribute not eligible for Attribute
... Attribute does fit into AttributeSection; creating subpart
For DEFAULT: ***Default:***
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
For Attribute_Head: - For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Default
..But Attribute not eligible for Attribute
... Attribute does fit into AttributeSection; creating subpart
For Attribute_Head: - For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into AttributeSection; creating subpart
For Attribute_Head: - author (1:1 Author)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into AttributeSection; creating subpart
For Attribute_Head: - books (optional N:M Set of Books)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into AttributeSection; creating subpart
For NOTE: ***Note***: how this works with optionality
  new: Annotation
Found new part: Annotation
... Annotation does fit into Attribute; creating subpart
For AttributeSection_Head: __ ***Inverse Attributes***
  new: AttributeSection
Found new part: AttributeSection
..But AttributeSection not eligible for Annotation
..But AttributeSection not eligible for Attribute
..But AttributeSection not eligible for AttributeSection
... AttributeSection does fit into Class; creating subpart
For Attribute_Head: - **isInvertible** - (Boolean)
  new: Attribute
Found new part: Attribute
... Attribute does fit into AttributeSection; creating subpart
For DERIVATION: ***Derivation***: true if the data type is a class or a simple collection of members of a class.
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
For Attribute_Head: - **inverseClass** - the class which contains, or would contain the inverse attribute (optional Class)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Derivation
..But Attribute not eligible for Attribute
... Attribute does fit into AttributeSection; creating subpart
For DERIVATION: ***Derivation***: from the data type. Null unless arrribute is invertible.
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
For Attribute_Head: - **inverseAttribute** - (optional Attribute)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Derivation
..But Attribute not eligible for Attribute
... Attribute does fit into AttributeSection; creating subpart
For Attribute_Head: - **inverseIsOptional** - (optional Attribute)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into AttributeSection; creating subpart
For Class_Head: _ ***Formulas***
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for AttributeSection
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Attribute_Head: - **default** - The rule or formula for calculating the value, if no value is supplied _(Derivation, optional)_
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
For NOTE: Note: even when an Attribute has a default derivation, theres no guarantee that every instance will have an assigned value. Example needed.
  new: Annotation
Found new part: Annotation
... Annotation does fit into Attribute; creating subpart
For Attribute_Head: - **derivation** - For derived attributes, the rule or formula for calculating the value _(Derivation, optional)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Annotation
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For ISSUE: ***Issue***: on insert vs on access?
  new: Annotation
Found new part: Annotation
... Annotation does fit into Attribute; creating subpart
For Attribute_Head: - **constraints** - Any validation rules specific to this attribute _(ListOf Constraints)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Annotation
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For NOTE: Note: from Class.constraints
  new: Annotation
Found new part: Annotation
... Annotation does fit into Attribute; creating subpart
For AttributeSection_Head: __Override Tracking
  new: AttributeSection
Found new part: AttributeSection
..But AttributeSection not eligible for Annotation
..But AttributeSection not eligible for Attribute
... AttributeSection does fit into Class; creating subpart
For Attribute_Head: - Overrides
  new: Attribute
Found new part: Attribute
... Attribute does fit into AttributeSection; creating subpart
For Class_Head: _ ***ValueType:*** **Derivation**A rule or formula for deriving the value of an attribute
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for AttributeSection
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Attribute_Head: - **statement** - An English language statement of the derivation rule _(RichText)_
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **expression** - The formal expression of the derivation in a programming language _(CodeExpression)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Class_Head: _ ***ValueType:*** **Constraint**A rule, condition, or validation that must be satisfied by the model
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Class_Head: _Subtype of:_ Component
  new: Class
Found new part: Class
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Attribute_Head: - **statement** - An English language statement of the constraint _(RichText)_
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **expression** - The formal expression of the constraint in a programming language (e.g., OCL _(CodeExpression)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **severity** -  (Code)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: -- **Warning** - nothing fatal; just a caution
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: -- **Error** - serious. Fix now
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **Message** - (Template)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Class_Head: _ **Class Constraint**
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Class_Head: _ **Attribute Constraint**
  new: Class
Found new part: Class
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Class_Head: _ **CodeExpression**
  new: Class
Found new part: Class
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Attribute_Head: - **Language** - the programming language (Code)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: -- OCL: Object Constraint Language
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: -- Java: Java
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **Expression** (String)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Section2_Head: ## Methods
  new: Section2
Found new part: Section2
..But Section2 not eligible for Attribute
..But Section2 not eligible for Class
..But Section2 not eligible for Section2
... Section2 does fit into LDM; creating subpart
For Class_Head: _ **Method**A behavior or operation associated with a class
  new: Class
Found new part: Class
... Class does fit into Section2; creating subpart
For Class_Head: _Subtype of:_ Component
  new: Class
Found new part: Class
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Attribute_Head: - **parameters** - The input parameters of the method _(ListOf Parameters)_
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **returnType** - The data type of the value returned by the method _(DataType )_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Class_Head: _ **Parameter**An input to a method
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Class_Head: _Subtype of:_ Component
  new: Class
Found new part: Class
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Attribute_Head: - **type** - The data type of the parameter _(DataType )_
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **cardinality** - The cardinality of the parameter (e.g., optional, required) _(AttributeCardinality)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Section2_Head: ## Data Types
  new: Section2
Found new part: Section2
..But Section2 not eligible for Attribute
..But Section2 not eligible for Class
..But Section2 not eligible for Section2
... Section2 does fit into LDM; creating subpart
For Class_Head: _ **Simple Data Type*****SubtpeOf***: DataType
  new: Class
Found new part: Class
... Class does fit into Section2; creating subpart
For Attribute_Head: - **coreClass** - (Class)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
For Class_Head: _ **Complex Data Type**
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Attribute_Head: - **aggregation** (Aggregating Operator)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **aggregatedTypes** (List of DataTypes)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Class_Head: _ **Aggregating Operator**
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Attribute_Head: - **Name**- (Code)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: -- **SetOf**
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: -- **ListOf**
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: -- **Mapping**
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **arity** - (Integer)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **spelling** - (Template)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Section2_Head: ## Low level Data Types
  new: Section2
Found new part: Section2
..But Section2 not eligible for Attribute
..But Section2 not eligible for Class
..But Section2 not eligible for Section2
... Section2 does fit into LDM; creating subpart
For Class_Head: _ ***ValueType***: **CamelName**
  new: Class
Found new part: Class
... Class does fit into Section2; creating subpart
For Attribute_Head: - value: the string (String)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
For CONSTRAINT: ***Constraint***: Must follow the camel case naming convention and not be empty.
  new: Constraint
Found new part: Constraint
... Constraint does fit into Attribute; creating subpart
For EXAMPLE: _Example:_ "firstName", "orderDate", "customerID"
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Constraint
... Annotation does fit into Attribute; creating subpart
For Class_Head: _ **UpperCamel**- a CamelName that begins with a capital letter
  new: Class
Found new part: Class
..But Class not eligible for Annotation
..But Class not eligible for Attribute
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For EXAMPLE: _Example:_ "Customer", "ProductCategory", "PaymentMethod"
  new: Annotation
Found new part: Annotation
... Annotation does fit into Class; creating subpart
For Class_Head: _ **LowerCamel** - a CamelName that begins with a lower case letter
  new: Class
Found new part: Class
..But Class not eligible for Annotation
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For EXAMPLE: _Example:_ "firstName", "orderTotal", "shippingAddress"
  new: Annotation
Found new part: Annotation
... Annotation does fit into Class; creating subpart
For Class_Head: _ **Qualified Camel** - an expression consisting of Camel Names separated by periods
  new: Class
Found new part: Class
..But Class not eligible for Annotation
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For CONSTRAINT: ***Constraint***: content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.
  new: Constraint
Found new part: Constraint
... Constraint does fit into Class; creating subpart
For Class_Head: _ **RichText**.  A string with markup for block level formatting.
  new: Class
Found new part: Class
..But Class not eligible for Constraint
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Attribute_Head: - **value** - the string content (string)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **format** - the rich text coding language used (Code)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **HTML**
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Attribute_Head: - **MarkDown**
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
For Class_Head: _  **RichLine**   - String with markup for line level formatting.
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Attribute_Head: - **value** - the string content (string)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
For CONSTRAINT: ***Constraint***: must not containa line break or new line character
  new: Constraint
Found new part: Constraint
... Constraint does fit into Attribute; creating subpart
For Class_Head: _ **PrimitiveType**
  new: Class
Found new part: Class
..But Class not eligible for Constraint
..But Class not eligible for Attribute
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Class_Head: _Values:_**String** + **Integer** + **Decimal** + **Boolean** + **Date** + **Time** + **DateTime**
  new: Class
Found new part: Class
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
For Section2_Head: ## AppendicesInsert More Sidebars.md + Insert Overrides.md + insert LDM Intro.md + Insert OCL.md + Insert Camel Case.md
  new: Section2
Found new part: Section2
..But Section2 not eligible for Class
..But Section2 not eligible for Section2
... Section2 does fit into LDM; creating subpart
Displaying parsed document
Document - <class 'ldm_parse_core.DocPart'> 
. LDM - <class 'ldm_parse_core.DocPart'> 
_ _ LDM_Head: # Literate Data Model
_ _ BLANK_LINE: 
_ _ BLANK_LINE: 
_ _ BLANK_LINE: 
. . Section2 - <class 'ldm_parse_core.DocPart'> 
_ _ _ Section2_Head: ## Preliminaries
_ _ _ BLANK_LINE: 
_ _ _ TEXT_LINE: In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.
_ _ _ BLANK_LINE: 
_ _ _ CODE_FENCE: ```Sample code block between paragraphs + x <  y and y > z + ```
_ _ _ BLANK_LINE: 
_ _ _ BLANK_LINE: 
_ _ _ TEXT_LINE: We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.
_ _ _ BLANK_LINE: 
_ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ **Component** - An element or building block of the literate data model with an extendedOneLiner
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
_ _ _ _ TEXT_LINE: In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
_ _ _ _ CODE_FENCE: ```Sample code block between paragraphs + x <  y and y > z + ```
_ _ _ _ BLANK_LINE: 
_ _ _ _ TEXT_LINE: We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.
_ _ _ _ ABBREVIATION: abbreviation: COMPT
_ _ _ _ BLANK_LINE: 
_ _ _ _ SUBTYPES: Subtypes: ComponentA, ComponentB, ComponentC
_ _ _ _ BASED_ON: BasedOn: ComponentA, ComponentB, ComponentC
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - parentClass - the supertype - just here to test parser (Class)
_ _ _ _ _ INVERSE: inverseOf: Class.child_class
_ _ _ _ _ INVERSE: inverse: Class.child_class2
_ _ _ _ _ BLANK_LINE: 
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **normalName** - the name of the component, not in camel case (*String*)
_ _ _ _ _ BLANK_LINE: 
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **name** - The name of the component (CamelName)
_ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ BLANK_LINE: 
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **qualifiedName** - (*QualifiedCamel*)
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **abbreviatedName** - a short form of the component's name, used for cross references and improved readability. (*CamelName*)
_ _ _ _ _ BLANK_LINE: 
. . . . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ DEFAULT: ***Default***: name
_ _ _ _ _ _ CODE: code: This is the OCL code for calculating the name
_ _ _ _ _ _ ENGLISH: English: And thii is an english language rendering
_ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ BLANK_LINE: 
. . . . . Constraint - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ CONSTRAINT: constraint: this is the first constraint for name in Component
_ _ _ _ _ _ CODE: code: OCL for first constraint
_ _ _ _ _ _ ENGLISH: english: English for first constraint
_ _ _ _ _ _ SEVERITY: Severity: Harsh
_ _ _ _ _ _ MESSAGE: Message: {name} is all wrong - first
_ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ BLANK_LINE: 
. . . . . Constraint - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ CONSTRAINT: constraint: this is the second constraint for name in Component
_ _ _ _ _ _ CODE: code: OCL for second constraint
_ _ _ _ _ _ ENGLISH: english: English for second constraint
_ _ _ _ _ _ SEVERITY: Severity: Harsh second
_ _ _ _ _ _ MESSAGE: Message: {name} is all wrong - second
_ _ _ _ _ _ BLANK_LINE: 
. . . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ EXAMPLE: ***Example***: "LDM" is the short form of "Literate Data Model".
_ _ _ _ _ _ BLANK_LINE: 
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **oneLiner** - A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _(RichLine)_
_ _ _ _ _ BLANK_LINE: 
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **elaboration** - A more detailed explanation or discussion of the component _(RichText)_
_ _ _ _ _ BLANK_LINE: 
. . . . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ AttributeSection_Head: __***For Machinery*** - mechanical attributes
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **isEmbellishment** - Indicates whether this component is an embellishment added during post-parsing processing _(Boolean)_
. . . . . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ DEFAULT: ***Default***: false
. . . . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ NOTE: ***Note***: This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.
. . . . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ AttributeSection_Head: __***Markdown Support***
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **mdPrefix** (*[String](#string)*)
. . . . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ DERIVATION: ***Derivation***: ""
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **mdSuffix** (*[String](#string)*)
. . . . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ DERIVATION: ***Derivation***: ""
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **mdTopLine** (*[String](#string)*)
. . . . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ DERIVATION: ***Derivation***: mdPrefix + name + " - " + oneLiner + mdSuffix
_ _ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ **AnnotationType** - a kind of note, or aside, used to call attention to additional information about some Component.And it can be continued on fresh lines. + However many you want. + But only up to a blank line or other clause
_ _ _ _ BLANK_LINE: 
. . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ SEE: See. this is not included in the extra text.
_ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ BASED_ON: ***Based on*** : Literate Data Model
. . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ NOTE: ***Note***: Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **emoji** - an emoji (Emoji)
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **emojiName** - an emoji (String)
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **emojiUnicode** - the Unicode for the emoji (Unicode)
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **plural** - the plural form of the label (*UpperCamel*).
. . . . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ DEFAULT: Default: based on label
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **Purpose** - the intended reason for the annotation.
_ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ ValueType: **Annotation**A note or comment associated with a model element
_ _ _ _ BASED_ON: ***Based on***: Component
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **annotationType** - (optional Annotation Type)
. . . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ NOTE: Note: An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_
_ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ TEXT_LINE: But any short label is valid.
. . . . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ DEFAULT: Default: from annotationType
_ _ _ _ _ _ BLANK_LINE: 
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **Emoji** - (optional Emoji)
. . . . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ DEFAULT: Default: from annotation type
_ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ BLANK_LINE: 
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **content** - The content or body of the annotation (*RichText*)
. . . . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ AttributeSection_Head: __***For Machinery***
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **isEmbellishment** - Indicates whether this annotation is an embellishment added during post-parsing processing _(Boolean)_
. . . . . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ DEFAULT: ***Default***: false
. . . . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ NOTE: ***Note***: This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.
_ _ _ _ _ _ _ BLANK_LINE: 
. . . Section3 - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Section3_Head: ### Annotation Types Used
_ _ _ _ BLANK_LINE: 
_ _ _ _ TEXT_LINE: These are the recognized Annotation Types for the LDM model.
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
_ _ _ _ TEXT_LINE: And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.
_ _ _ _ BLANK_LINE: 
_ _ _ _ CODE_FENCE: ```interface AnnotationType { + label: string; + emoji: string; + emojiName: string; + emojiUnicode: string; + purpose: string; + } + // LINK: LiterateDataModel.annotationTypes + const annotationTypes: AnnotationType[] = [ + { + label: "Error", + emoji: "", + emojiName: "cross_mark", + emojiUnicode: "U+274C", + purpose: "Indicates a critical error or failure in the model." + }, + { + label: "Warning", + emoji: "", + emojiName: "warning", + emojiUnicode: "U+26A0", + purpose: "Indicates a potential issue or warning in the model." + }, + { + label: "Note", + emoji: "", + emojiName: "blue_book", + emojiUnicode: "U+1F4D8", + purpose: "Provides additional context, explanations, or clarifications for the annotated element." + }, + { + label: "Issue", + emoji: "", + emojiName: "warning", + emojiUnicode: "U+26A0", + purpose: "Highlights a potential issue or error that needs to be addressed or resolved." + }, + { + label: "Question", + emoji: "", + emojiName: "question", + emojiUnicode: "U+2753", + purpose: "Raises a question or seeks further clarification about the annotated element." + }, + { + label: "Suggestion", + emoji: "", + emojiName: "bulb", + emojiUnicode: "U+1F4A1", + purpose: "Provides a suggestion or recommendation for improving the model or the annotated element." + }, + { + label: "Info", + emoji: "", + emojiName: "information_source", + emojiUnicode: "U+2139", + purpose: "Offers relevant information, facts, or details about the annotated element." + }, + { + label: "Todo", + emoji: "", + emojiName: "pushpin", + emojiUnicode: "U+1F4CC", + purpose: "Indicates a pending task, action item, or future work related to the annotated element." + }, + { + label: "Reference", + emoji: "", + emojiName: "globe_with_meridians", + emojiUnicode: "U+1F310", + purpose: "Provides a reference or link to an external resource or documentation." + }, + { + label: "See", + emoji: "", + emojiName: "mag", + emojiUnicode: "U+1F50D", + purpose: "Indicates a cross-reference to another relevant element within the model." + } + ]; + ```
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
. . Section2 - <class 'ldm_parse_core.DocPart'> 
_ _ _ Section2_Head: ## The Model and its Subjects
_ _ _ BLANK_LINE: 
_ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ **LiterateDataModel** - A representation of a domain's entities, attributes, and relationships,along with explanatory text and examples
_ _ _ _ ABBREVIATION: ***Abbreviation***: LDM
_ _ _ _ PLURAL: _Plural:_ LiterateDataModels
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _Subtype of:_ Component
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - name (UpperCamel )
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - allSubjects - list of all classes in the model, as ordered in thedefinition of the model. (List of Classes)
. . . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ DERIVATION: Derivation: gathering s.allSubjects over s in subjectAreas
_ _ _ _ _ _ BLANK_LINE: 
. . . . . Constraint - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ CONSTRAINT: ***Constraint***: Subject names must be unique across the model.
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - allClasses - list of all classes in the model, as ordered in the definition of the model. (List of Classes)
. . . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ DERIVATION: Derivation: gathering s.allClasses over s in allSubjects.
. . . . . Constraint - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ CONSTRAINT: ***Constraint***: Class names must be unique across the model.
_ _ _ _ _ _ BLANK_LINE: 
. . . . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ AttributeSection_Head: __ 	***Modeling Configuration***
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **annotationTypes** - (List of AnnotationTypes)
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **Preferred Coding Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Coding Language).
. . . . . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ DEFAULT: Default: OCL
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **alternate Coding Languages** -  (optional List of Coding Languages).
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **Preferred Template Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Template Language).
. . . . . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ DEFAULT: Default: Handlebars
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **alternate Template Languages** -  (optional List of Template Languages).
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **aiFunctions** - A list of functions that require sophisticated AI-powered implementation *(List of String)*
. . . . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ DERIVATION: Derivation: ['aiEnglishPlural()']
_ _ _ _ _ _ _ BLANK_LINE: 
. . . . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ AttributeSection_Head: __***Markdown Support***
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **mdPrefix** (*[String](#string)*)
. . . . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ DERIVATION: ***Derivation***: "# "
_ _ _ _ _ _ _ BLANK_LINE: 
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **mdTopLine** (*[String](#string)*)
. . . . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ DERIVATION: ***Derivation***: mdPrefix + name
_ _ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ **Subject**A specific topic or theme within the model
_ _ _ _ PLURAL: _Plural:_ Subjects
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _Subtype of:_ Component
_ _ _ _ DEPENDENT_OF: Dependent of: LiterateDataModel
_ _ _ _ BLANK_LINE: 
_ _ _ _ TEXT_LINE: Subjects are the chapters an sections of the model.
_ _ _ _ TEXT_LINE: A subject need not contain any Classes if its just expository.
_ _ _ _ BLANK_LINE: 
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - name (UpperCamel )
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **parentSubject** - The parent subject, if any, under which this subject is nested _(Subject, optional)_
_ _ _ _ _ BLANK_LINE: 
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **Classes** - The major classes related to this subject, in the order in which they should be presented _(ListOf Classes)_
. . . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ ISSUE: ***Issue***: define chapter, section, subsection as levels?***DSL***: Generally, it is best to present the classes within a Subject in top down order:
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - Each Class should be followed first by the classes that are dependent on it, and then
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - By its subtype classes.
_ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ BLANK_LINE: 
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **childSubjects** - Any child subjects nested under this subject, in the order in which they should be presented _(ListOf Subjects)_
_ _ _ _ _ INVERSE: inverse of: Subject.parentSubject.
_ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ TEXT_LINE: ***DSL***:  the Classes within a Subject are always displayed before the childSubjects.
_ _ _ _ _ BLANK_LINE: 
. . . . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ AttributeSection_Head: __***Markdown Support***
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **mdPrefix** (*[String](#string)*)
. . . . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ DERIVATION: ***Derivation***: levelIndicator + " "
_ _ _ _ _ _ _ BLANK_LINE: 
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **mdTopLine** (*[String](#string)*)
. . . . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ DERIVATION: ***Derivation***: mdPrefix + name.
_ _ _ _ _ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ **SubjectArea**A main topic or area of focus within the model, containing related subjects and classes
_ _ _ _ PLURAL: _Plural:_ SubjectAreas
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _Subtype of:_ Subject
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _Where:_ parentSubject is absent
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
. . . Section3 - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Section3_Head: ### Classes
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
. . . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Class_Head: _ **Class** - A key entity or object type in the model, often corresponding to a real-world concept
_ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ PLURAL: _Plural:_ Classes
. . . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Class_Head: _Subtype of:_ Component
. . . . . Constraint - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ CONSTRAINT: ***Constraint***: Within each Class, attribute names must be unique.
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **pluralForm** - the normal English plural form of the name of the Class (UpperName)
_ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ TEXT_LINE: Might be Books for the Book class or other regular plurals.
_ _ _ _ _ _ TEXT_LINE: But also might be People for Person.
_ _ _ _ _ _ BLANK_LINE: 
. . . . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ NOTE: Note: When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.
_ _ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ _ TEXT_LINE: The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.
. . . . . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ DEFAULT: ***Default***: the regular plural, formed by adding "s" or "es".
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **basedOn** - the Class or Classes on which this class is dependent (SetOf Classes).
_ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ TEXT_LINE: This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.
_ _ _ _ _ _ BLANK_LINE: 
. . . . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ NOTE: Note: basedOn and dependentOf are being used synonymousle in this metamodel.
. . . . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ ISSUE: issue: fix that
_ _ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ _ BLANK_LINE: 
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **supertypes** - The parent class(es) from which this class inherits attributes _(ListOf Classes)_
_ _ _ _ _ _ BLANK_LINE: 
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **subtypings** - the criteria, or dimensions, by which the class can be divided into subtypes (list of Subtypings).
_ _ _ _ _ _ BLANK_LINE: 
. . . . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ EXAMPLE: Example: in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).
_ _ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ _ BLANK_LINE: 
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **subtypes** - Any subtypes or specializations of this class based on its subtypings. _(ListOf Classes)_
_ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ BLANK_LINE: 
. . . . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ EXAMPLE: Example: For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.
_ _ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ _ BLANK_LINE: 
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **attributes** - The attributes or properties of the class, in the order in which they should be presented _(ListOf Attributes)_
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **attributeSections** - additional attributes or properties of the class, grouped for clarity and elaboration.  _(ListOf AttributeSections)_
_ _ _ _ _ _ BLANK_LINE: 
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **constraints** - Any constraints, rules, or validations specific to this class _(ListOf Constraints)_
. . . . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ NOTE: Note: Constraints may be expressed on either the Class or the Attribute. Always?Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **methods** - Any behaviors or operations associated with this class _(ListOf Methods)_
_ _ _ _ _ _ BLANK_LINE: 
. . . . . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ AttributeSection_Head: __ ***Implied Attributes***
. . . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ Attribute_Head: - **dependents** - the Classes which are basedOn this Class (optional SetOf Classes).
_ _ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ _ INVERSE: ***Inverse of***: Class.basedOn
. . . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ Attribute_Head: - UniqueKeys - (optional Set of UniqueKeys).
_ _ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ _ INVERSE: ***Inverse of***:UniqueKey.basedOn
_ _ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ _ BLANK_LINE: 
. . . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Class_Head: _ **Subtyping** - a way in which subtypes of a Class may be classified (Subtype of Component).
_ _ _ _ _ DEPENDENT_OF: ***Dependent of:*** Class
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **name** (Upper Name).Usually ByThis or ByThat
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **is exclusive** (Boolean).
. . . . . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ DEFAULT: Default: true
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **is exhaustive** (Boolean).
. . . . . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ DEFAULT: Default: true
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **classes** (List of Classes).
_ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ TEXT_LINE: ***DSL***:  Shown in the DSL as
_ _ _ _ _ _ TEXT_LINE: > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)
_ _ _ _ _ _ TEXT_LINE: on the super class. And as
_ _ _ _ _ _ TEXT_LINE: > Subtype of: SuperClass byBrand
_ _ _ _ _ _ TEXT_LINE: on the subclass.
_ _ _ _ _ _ BLANK_LINE: 
. . . . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ NOTE: Note: every class can have an unnamed subtyping.Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.
_ _ _ _ _ _ _ BLANK_LINE: 
. . . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Class_Head: _ **ValueType** -
_ _ _ _ _ SUBTYPE_OF: Subtype of: Class.
. . . . . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ AttributeSection_Head: __***Markdown Support***
. . . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ Attribute_Head: - ***mdPrefix*** (*[String](#string)*)
. . . . . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ _ DERIVATION: ***Derivation***: "ValueType: ".
_ _ _ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ _ _ BLANK_LINE: 
. . . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Class_Head: _ **Reference Type**:
_ _ _ _ _ SUBTYPE_OF: Subtype of: Class.
_ _ _ _ _ BLANK_LINE: 
. . . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Class_Head: _ **CodeType**A data type or enumeration used in the model
. . . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Class_Head: _Subtype of:_ ValueType.
. . . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ NOTE: Note: Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - List the code values as a bulletted list inside the description of the attribute in the form:**code**: description
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - isCaptive - the code type was implied by use in an attribute and is only used for that attribute (Boolean) as
. . . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Class_Head: _ **Code Value**A possible value for an enumerated data class  DependentOf: CodeType
_ _ _ _ _ BLANK_LINE: 
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **code** - A short code or abbreviationi for the value _(NameString)_
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **description** - an explanation of what the code means (*RichText*)
_ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ BLANK_LINE: 
. . . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Class_Head: _ **Key** - a list of attributes of a class
_ _ _ _ _ SUBTYPE_OF: Subtype of: Component
_ _ _ _ _ DEPENDENT_OF: DependentOf: Class
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - keyAttributes - the attributes of the base Class. (List of Attributes ).
_ _ _ _ _ _ BLANK_LINE: 
. . . . . . Constraint - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ CONSTRAINT: Constraint: each attribute must be a direct or inherited of the base class.
. . . . . . Constraint - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ CONSTRAINT: Constraint: no repetitions allowed in keyAttributes>  **Issue**: introduce PureLists?
_ _ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ _ BLANK_LINE: 
. . . . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ ISSUE: Issue: need ascending descending to support index keys or ordering keys.
_ _ _ _ _ _ _ BLANK_LINE: 
. . . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Class_Head: _ **UniqueKey** - a list of attributes on which instances of the base class may be keyed.
_ _ _ _ _ SUBTYPE_OF: Subtype of: Key
_ _ _ _ _ BLANK_LINE: 
. . . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ NOTE: Note: order unimportant for Unique Keys.
_ _ _ _ _ _ BLANK_LINE: 
. . Section2 - <class 'ldm_parse_core.DocPart'> 
_ _ _ Section2_Head: ## Attributes
_ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ **Attribute Section** - a group of attributes for a class that merit a shared explanation.
_ _ _ _ SUBTYPE_OF: ***SubtypeOf***: Component.
_ _ _ _ BASED_ON: ***Based on***: Class
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: -	isOptional - whether the attributes in this section, taken together, are optional. (Boolean)
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked. + &nbsp; + But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.
_ _ _ _ BLANK_LINE: 
. . . . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ AttributeSection_Head: __***Markdown Support***
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **mdPrefix** (*[String](#string)*)
. . . . . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ DEFAULT: ***Default***: "_ "
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **mdTopLine** (*[String](#string)*).
_ _ _ _ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ **Attribute**A property or characteristic of a class
_ _ _ _ PLURAL: _Plural:_ Attributes
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _Subtype of:_ Component
_ _ _ _ BASED_ON: *Based on*: AttributeSection
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **name** - (Lower Camel).
_ _ _ _ _ OVERRIDES: Overrides: CamelName
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **dataType** - The kind of object to which the attribute refers.  _(DataType)_H + In the simplest cases, the data type will be a class. And the specifier is the just the name of that class.
_ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ TEXT_LINE: But,
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - List of Editions
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - Set of Edition
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - ... and more complicated cases.
. . . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ SEE: ***See***: the section below on Data Type Specifiers.
_ _ _ _ _ _ BLANK_LINE: 
. . . . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ AttributeSection_Head: __ **Cardinalities**.
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **isOptional** - Indicates whether the attribute must have a value for every instance of the class _(Boolean)_
_ _ _ _ _ _ BLANK_LINE: 
. . . . . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ DEFAULT: ***Default:*** False
_ _ _ _ _ _ _ BLANK_LINE: 
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **cardinality** - The cardinality of the relationship represented by the attribute _(CardinalityCode)_
_ _ _ _ _ _ BLANK_LINE: 
. . . . . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ DEFAULT: ***Default:***
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.
_ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ TEXT_LINE: ***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.
_ _ _ _ _ _ TEXT_LINE: For example:
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - author (1:1 Author)
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - books (optional N:M Set of Books)
_ _ _ _ _ _ BLANK_LINE: 
. . . . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ NOTE: ***Note***: how this works with optionality
_ _ _ _ _ _ _ BLANK_LINE: 
. . . . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ AttributeSection_Head: __ ***Inverse Attributes***
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **isInvertible** - (Boolean)
. . . . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ DERIVATION: ***Derivation***: true if the data type is a class or a simple collection of members of a class.
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **inverseClass** - the class which contains, or would contain the inverse attribute (optional Class)
. . . . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ _ DERIVATION: ***Derivation***: from the data type. Null unless arrribute is invertible.
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **inverseAttribute** - (optional Attribute)
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - **inverseIsOptional** - (optional Attribute)
_ _ _ _ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ ***Formulas***
_ _ _ _ BLANK_LINE: 
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **default** - The rule or formula for calculating the value, if no value is supplied _(Derivation, optional)_
. . . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ NOTE: Note: even when an Attribute has a default derivation, theres no guarantee that every instance will have an assigned value. Example needed.
_ _ _ _ _ _ BLANK_LINE: 
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **derivation** - For derived attributes, the rule or formula for calculating the value _(Derivation, optional)_
. . . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ ISSUE: ***Issue***: on insert vs on access?
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **constraints** - Any validation rules specific to this attribute _(ListOf Constraints)_
. . . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ NOTE: Note: from Class.constraints
_ _ _ _ _ _ BLANK_LINE: 
. . . . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ AttributeSection_Head: __Override Tracking
. . . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ Attribute_Head: - Overrides
_ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ ***ValueType:*** **Derivation**A rule or formula for deriving the value of an attribute
_ _ _ _ PLURAL: _Plural:_ Derivations
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **statement** - An English language statement of the derivation rule _(RichText)_
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **expression** - The formal expression of the derivation in a programming language _(CodeExpression)_
_ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ ***ValueType:*** **Constraint**A rule, condition, or validation that must be satisfied by the model
_ _ _ _ PLURAL: _Plural:_ Constraints
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _Subtype of:_ Component
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **statement** - An English language statement of the constraint _(RichText)_
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **expression** - The formal expression of the constraint in a programming language (e.g., OCL _(CodeExpression)_
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **severity** -  (Code)
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: -- **Warning** - nothing fatal; just a caution
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: -- **Error** - serious. Fix now
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **Message** - (Template)
_ _ _ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ **Class Constraint**
_ _ _ _ SUBTYPE_OF: **Subtype of**: Constraint
_ _ _ _ BASED_ON: ***Based on***: Class.
_ _ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ **Attribute Constraint**
_ _ _ _ SUBTYPE_OF: ***Subtype of***: Constraint
_ _ _ _ BASED_ON: ***Based on***: Attribute
_ _ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ **CodeExpression**
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **Language** - the programming language (Code)
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: -- OCL: Object Constraint Language
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: -- Java: Java
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **Expression** (String)
. . Section2 - <class 'ldm_parse_core.DocPart'> 
_ _ _ Section2_Head: ## Methods
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ **Method**A behavior or operation associated with a class
_ _ _ _ PLURAL: _Plural:_ Methods
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _Subtype of:_ Component
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **parameters** - The input parameters of the method _(ListOf Parameters)_
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **returnType** - The data type of the value returned by the method _(DataType )_
_ _ _ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ **Parameter**An input to a method
_ _ _ _ PLURAL: _Plural:_ Parameters
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _Subtype of:_ Component
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **type** - The data type of the parameter _(DataType )_
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **cardinality** - The cardinality of the parameter (e.g., optional, required) _(AttributeCardinality)_
_ _ _ _ _ BLANK_LINE: 
. . Section2 - <class 'ldm_parse_core.DocPart'> 
_ _ _ Section2_Head: ## Data Types
_ _ _ BLANK_LINE: 
_ _ _ TEXT_LINE: *ValueType*:**Data Type**
_ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ **Simple Data Type*****SubtpeOf***: DataType
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **coreClass** - (Class)
_ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ **Complex Data Type**
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **aggregation** (Aggregating Operator)
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **aggregatedTypes** (List of DataTypes)
_ _ _ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ **Aggregating Operator**
_ _ _ _ BLANK_LINE: 
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **Name**- (Code)
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: -- **SetOf**
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: -- **ListOf**
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: -- **Mapping**
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **arity** - (Integer)
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **spelling** - (Template)
_ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ BLANK_LINE: 
. . Section2 - <class 'ldm_parse_core.DocPart'> 
_ _ _ Section2_Head: ## Low level Data Types
_ _ _ BLANK_LINE: 
_ _ _ TEXT_LINE: insert Camel Case.md
_ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ ***ValueType***: **CamelName**
_ _ _ _ BLANK_LINE: 
_ _ _ _ TEXT_LINE: A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.
_ _ _ _ SUBTYPE_OF: ***Subtype of***: String
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - value: the string (String)
. . . . . Constraint - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ CONSTRAINT: ***Constraint***: Must follow the camel case naming convention and not be empty.
. . . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ EXAMPLE: _Example:_ "firstName", "orderDate", "customerID"
_ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ TEXT_LINE: >  ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.
_ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ _ TEXT_LINE: *ModelingNote:* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.
_ _ _ _ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ **UpperCamel**- a CamelName that begins with a capital letter
_ _ _ _ SUBTYPE_OF: **Subtype of**: CamelName
_ _ _ _ WHERE: **Where**: content begins with an upper case letter.
. . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ EXAMPLE: _Example:_ "Customer", "ProductCategory", "PaymentMethod"
_ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ **LowerCamel** - a CamelName that begins with a lower case letter
_ _ _ _ SUBTYPE_OF: **Subtype of**: CamelName
_ _ _ _ WHERE: **Where**: content begins with a lower case letter.
_ _ _ _ BLANK_LINE: 
. . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ EXAMPLE: _Example:_ "firstName", "orderTotal", "shippingAddress"
_ _ _ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ **Qualified Camel** - an expression consisting of Camel Names separated by periods
_ _ _ _ SUBTYPE_OF: ***Subtype of***: String
. . . . Constraint - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ CONSTRAINT: ***Constraint***: content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.
_ _ _ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ **RichText**.  A string with markup for block level formatting.
_ _ _ _ SUBTYPE_OF: ***SubtypeOf***: String
_ _ _ _ BLANK_LINE: 
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **value** - the string content (string)
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **format** - the rich text coding language used (Code)
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **HTML**
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **MarkDown**
_ _ _ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _  **RichLine**   - String with markup for line level formatting.
_ _ _ _ SUBTYPE_OF: ***SubtypeOf***: RichText
_ _ _ _ BLANK_LINE: 
. . . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ Attribute_Head: - **value** - the string content (string)
. . . . . Constraint - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ _ CONSTRAINT: ***Constraint***: must not containa line break or new line character
_ _ _ _ _ _ BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _ **PrimitiveType**
_ _ _ _ SUBTYPE_OF: Subtype of: ValueTypeA basic, built-in data type
. . . Class - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Class_Head: _Values:_**String** + **Integer** + **Decimal** + **Boolean** + **Date** + **Time** + **DateTime**
_ _ _ _ BLANK_LINE: 
_ _ _ _ TEXT_LINE: ===
. . Section2 - <class 'ldm_parse_core.DocPart'> 
_ _ _ Section2_Head: ## AppendicesInsert More Sidebars.md + Insert Overrides.md + insert LDM Intro.md + Insert OCL.md + Insert Camel Case.md
_ _ _ BLANK_LINE: 
_ _ _ BLANK_LINE: 
_ _ _ BLANK_LINE: 
_ _ _ BLANK_LINE: 
Finished Displaying parsed document
DerivingDict for Part:  Document
DerivingDict for Part:  LDM
		Full header is: # Literate Data Model[]
RoundTrip LDM_Head: input is - '# Literate Data Model[]'
RoundTrip LDM_Head: value is - {'name': 'Literate Data Model[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Literate Data Model[]', 'one_liner': '', 'parenthetical': ''} ok for LDM_Head
RoundTrip LDM_Head: renders as - 'Literate Data Model[]'
RoundTrip LDM_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: # Literate Data Model[]
		=parse=> {'name': 'Literate Data Model[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Literate Data Model[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- skipping BLANK_LINE
--- skipping BLANK_LINE
DerivingDict for Part:  Section2
		Full header is: ## Preliminaries[]
RoundTrip Section2_Head: input is - '## Preliminaries[]'
RoundTrip Section2_Head: value is - {'name': 'Preliminaries[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Preliminaries[]', 'one_liner': '', 'parenthetical': ''} ok for Section2_Head
RoundTrip Section2_Head: renders as - 'Preliminaries[]'
RoundTrip Section2_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: ## Preliminaries[]
		=parse=> {'name': 'Preliminaries[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Preliminaries[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- adding TEXT para
--- skipping BLANK_LINE
--- adding CODE_FENCE para
--- skipping BLANK_LINE
--- skipping BLANK_LINE
--- adding TEXT para
--- skipping BLANK_LINE
--- skipping BLANK_LINE
DerivingDict for Part:  Class
		Full header is: _ **Component** - An element or building block of the literate data model with an extended['OneLiner']
RoundTrip Class_Head: input is - '_ **Component** - An element or building block of the literate data model with an extended['OneLiner']'
RoundTrip Class_Head: value is - {'name': 'Component', 'one_liner': "An element or building block of the literate data model with an extended['OneLiner']", 'parenthetical': ''}
OK. {'name': 'Component', 'one_liner': "An element or building block of the literate data model with an extended['OneLiner']", 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Component - An element or building block of the literate data model with an extended['OneLiner']'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **Component** - An element or building block of the literate data model with an extended['OneLiner']
		=parse=> {'name': 'Component', 'one_liner': "An element or building block of the literate data model with an extended['OneLiner']", 'parenthetical': ''} 
		=render=> Component - An element or building block of the literate data model with an extended['OneLiner'] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- skipping BLANK_LINE
--- adding TEXT para
--- skipping BLANK_LINE
--- skipping BLANK_LINE
--- adding CODE_FENCE para
--- skipping BLANK_LINE
--- adding TEXT para
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for ABBREVIATION: abbreviation: COMPT
RoundTrip ABBREVIATION: input is - ' COMPT[]'
RoundTrip ABBREVIATION: value is - COMPT[]
OK. COMPT[] ok for ABBREVIATION
RoundTrip ABBREVIATION: renders as - 'COMPT[]'
RoundTrip ABBREVIATION: reparses as - COMPT[]
RoundTrip SUCCESS:  COMPT[]
		=parse=> COMPT[] 
		=render=> COMPT[] 
		=parse=> COMPT[]
adding non raw value. abbreviation -. COMPT[]
{
  "abbreviation_raw": " COMPT[]",
  "abbreviation": "COMPT[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'abbreviation_raw': ' COMPT[]', 'abbreviation': 'COMPT[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
--- skipping BLANK_LINE
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for SUBTYPES: Subtypes: ComponentA, ComponentB, ComponentC
RoundTrip SUBTYPES: input is - ' ComponentA, ComponentB, ComponentC[]'
parse_name_list:  ComponentA, ComponentB, ComponentC[]
RoundTrip SUBTYPES: value is - ['ComponentA', 'ComponentB', 'ComponentC[]']
validating name list:  ['ComponentA', 'ComponentB', 'ComponentC[]']
OK. ['ComponentA', 'ComponentB', 'ComponentC[]'] ok for SUBTYPES
RoundTrip SUBTYPES: renders as - 'ComponentA, ComponentB, ComponentC[]'
parse_name_list: ComponentA, ComponentB, ComponentC[]
RoundTrip SUBTYPES: reparses as - ['ComponentA', 'ComponentB', 'ComponentC[]']
RoundTrip SUCCESS:  ComponentA, ComponentB, ComponentC[]
		=parse=> ['ComponentA', 'ComponentB', 'ComponentC[]'] 
		=render=> ComponentA, ComponentB, ComponentC[] 
		=parse=> ['ComponentA', 'ComponentB', 'ComponentC[]']
adding non raw value. Subtypes -. ['ComponentA', 'ComponentB', 'ComponentC[]']
{
  "Subtypes_raw": " ComponentA, ComponentB, ComponentC[]",
  "Subtypes": [
    "ComponentA",
    "ComponentB",
    "ComponentC[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Subtypes_raw': ' ComponentA, ComponentB, ComponentC[]', 'Subtypes': ['ComponentA', 'ComponentB', 'ComponentC[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for BASED_ON: BasedOn: ComponentA, ComponentB, ComponentC
RoundTrip BASED_ON: input is - ' ComponentA, ComponentB, ComponentC[]'
parse_name_list:  ComponentA, ComponentB, ComponentC[]
RoundTrip BASED_ON: value is - ['ComponentA', 'ComponentB', 'ComponentC[]']
validating name list:  ['ComponentA', 'ComponentB', 'ComponentC[]']
OK. ['ComponentA', 'ComponentB', 'ComponentC[]'] ok for BASED_ON
RoundTrip BASED_ON: renders as - 'ComponentA, ComponentB, ComponentC[]'
parse_name_list: ComponentA, ComponentB, ComponentC[]
RoundTrip BASED_ON: reparses as - ['ComponentA', 'ComponentB', 'ComponentC[]']
RoundTrip SUCCESS:  ComponentA, ComponentB, ComponentC[]
		=parse=> ['ComponentA', 'ComponentB', 'ComponentC[]'] 
		=render=> ComponentA, ComponentB, ComponentC[] 
		=parse=> ['ComponentA', 'ComponentB', 'ComponentC[]']
adding non raw value. BasedOn -. ['ComponentA', 'ComponentB', 'ComponentC[]']
{
  "BasedOn_raw": " ComponentA, ComponentB, ComponentC[]",
  "BasedOn": [
    "ComponentA",
    "ComponentB",
    "ComponentC[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'BasedOn_raw': ' ComponentA, ComponentB, ComponentC[]', 'BasedOn': ['ComponentA', 'ComponentB', 'ComponentC[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - parentClass - the supertype - just here to test parser (Class)[]
RoundTrip Attribute_Head: input is - '- parentClass - the supertype - just here to test parser (Class)[]'
RoundTrip Attribute_Head: value is - {'name': 'parentClass', 'one_liner': 'the supertype - just here to test parser', 'parenthetical': 'Class'}
OK. {'name': 'parentClass', 'one_liner': 'the supertype - just here to test parser', 'parenthetical': 'Class'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'parentClass - the supertype - just here to test parser (Class)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - parentClass - the supertype - just here to test parser (Class)[]
		=parse=> {'name': 'parentClass', 'one_liner': 'the supertype - just here to test parser', 'parenthetical': 'Class'} 
		=render=> parentClass - the supertype - just here to test parser (Class) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for INVERSE: inverseOf: Class.child_class
RoundTrip INVERSE: input is - ' Class.child_class[]'
RoundTrip INVERSE: value is - {'class_name': 'Class', 'attribute_name': 'childclass[]'}
OK. {'class_name': 'Class', 'attribute_name': 'childclass[]'} ok for INVERSE
RoundTrip INVERSE: renders as - 'Class.childclass[]'
RoundTrip INVERSE: reparses as - {'class_name': 'Class', 'attribute_name': 'childclass[]'}
RoundTrip SUCCESS:  Class.child_class[]
		=parse=> {'class_name': 'Class', 'attribute_name': 'childclass[]'} 
		=render=> Class.childclass[] 
		=parse=> {'class_name': 'Class', 'attribute_name': 'childclass[]'}
adding non raw value. inverseOf -. {'class_name': 'Class', 'attribute_name': 'childclass[]'}
{
  "inverseOf_raw": " Class.child_class[]",
  "inverseOf": {
    "class_name": "Class",
    "attribute_name": "childclass[]"
  }
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'inverseOf_raw': ' Class.child_class[]', 'inverseOf': {'class_name': 'Class', 'attribute_name': 'childclass[]'}}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for INVERSE: inverse: Class.child_class2
RoundTrip INVERSE: input is - ' Class.child_class2[]'
RoundTrip INVERSE: value is - {'class_name': 'Class', 'attribute_name': 'childclass2[]'}
OK. {'class_name': 'Class', 'attribute_name': 'childclass2[]'} ok for INVERSE
RoundTrip INVERSE: renders as - 'Class.childclass2[]'
RoundTrip INVERSE: reparses as - {'class_name': 'Class', 'attribute_name': 'childclass2[]'}
RoundTrip SUCCESS:  Class.child_class2[]
		=parse=> {'class_name': 'Class', 'attribute_name': 'childclass2[]'} 
		=render=> Class.childclass2[] 
		=parse=> {'class_name': 'Class', 'attribute_name': 'childclass2[]'}
adding non raw value. inverse -. {'class_name': 'Class', 'attribute_name': 'childclass2[]'}
{
  "inverse_raw": " Class.child_class2[]",
  "inverse": {
    "class_name": "Class",
    "attribute_name": "childclass2[]"
  }
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'inverse_raw': ' Class.child_class2[]', 'inverse': {'class_name': 'Class', 'attribute_name': 'childclass2[]'}}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **normalName** - the name of the component, not in camel case (*String*)[]
RoundTrip Attribute_Head: input is - '- **normalName** - the name of the component, not in camel case (*String*)[]'
RoundTrip Attribute_Head: value is - {'name': 'normalName', 'one_liner': 'the name of the component, not in camel case', 'parenthetical': '*String*'}
OK. {'name': 'normalName', 'one_liner': 'the name of the component, not in camel case', 'parenthetical': '*String*'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'normalName - the name of the component, not in camel case (*String*)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **normalName** - the name of the component, not in camel case (*String*)[]
		=parse=> {'name': 'normalName', 'one_liner': 'the name of the component, not in camel case', 'parenthetical': '*String*'} 
		=render=> normalName - the name of the component, not in camel case (*String*) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **name** - The name of the component (CamelName)[]
RoundTrip Attribute_Head: input is - '- **name** - The name of the component (CamelName)[]'
RoundTrip Attribute_Head: value is - {'name': 'name', 'one_liner': 'The name of the component', 'parenthetical': 'CamelName'}
OK. {'name': 'name', 'one_liner': 'The name of the component', 'parenthetical': 'CamelName'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'name - The name of the component (CamelName)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **name** - The name of the component (CamelName)[]
		=parse=> {'name': 'name', 'one_liner': 'The name of the component', 'parenthetical': 'CamelName'} 
		=render=> name - The name of the component (CamelName) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- skipping BLANK_LINE
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **qualifiedName** - (*QualifiedCamel*)[]
RoundTrip Attribute_Head: input is - '- **qualifiedName** - (*QualifiedCamel*)[]'
RoundTrip Attribute_Head: value is - {'name': 'qualifiedName', 'one_liner': '', 'parenthetical': '*QualifiedCamel*'}
OK. {'name': 'qualifiedName', 'one_liner': '', 'parenthetical': '*QualifiedCamel*'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'qualifiedName (*QualifiedCamel*)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **qualifiedName** - (*QualifiedCamel*)[]
		=parse=> {'name': 'qualifiedName', 'one_liner': '', 'parenthetical': '*QualifiedCamel*'} 
		=render=> qualifiedName (*QualifiedCamel*) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **abbreviatedName** - a short form of the component's name, used for cross references and improved readability. (*CamelName*)[]
RoundTrip Attribute_Head: input is - '- **abbreviatedName** - a short form of the component's name, used for cross references and improved readability. (*CamelName*)[]'
RoundTrip Attribute_Head: value is - {'name': 'abbreviatedName', 'one_liner': "a short form of the component's name, used for cross references and improved readability.", 'parenthetical': '*CamelName*'}
OK. {'name': 'abbreviatedName', 'one_liner': "a short form of the component's name, used for cross references and improved readability.", 'parenthetical': '*CamelName*'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'abbreviatedName - a short form of the component's name, used for cross references and improved readability. (*CamelName*)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **abbreviatedName** - a short form of the component's name, used for cross references and improved readability. (*CamelName*)[]
		=parse=> {'name': 'abbreviatedName', 'one_liner': "a short form of the component's name, used for cross references and improved readability.", 'parenthetical': '*CamelName*'} 
		=render=> abbreviatedName - a short form of the component's name, used for cross references and improved readability. (*CamelName*) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
DerivingDict for Part:  Default
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DEFAULT: ***Default***: name
RoundTrip DEFAULT: input is - ' name[]'
RoundTrip DEFAULT: value is -  name[]
OK.  name[] ok for DEFAULT
RoundTrip DEFAULT: renders as - ' name[]'
RoundTrip DEFAULT: reparses as -  name[]
RoundTrip SUCCESS:  name[]
		=parse=>  name[] 
		=render=>  name[] 
		=parse=>  name[]
adding non raw value. ***Default*** -.  name[]
{
  "***Default***_raw": " name[]",
  "***Default***": " name[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Default***_raw': ' name[]', '***Default***': ' name[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for CODE: code: This is the OCL code for calculating the name
RoundTrip CODE: input is - ' This is the OCL code for calculating the name[]'
RoundTrip CODE: value is -  This is the OCL code for calculating the name[]
OK.  This is the OCL code for calculating the name[] ok for CODE
RoundTrip CODE: renders as - ' This is the OCL code for calculating the name[]'
RoundTrip CODE: reparses as -  This is the OCL code for calculating the name[]
RoundTrip SUCCESS:  This is the OCL code for calculating the name[]
		=parse=>  This is the OCL code for calculating the name[] 
		=render=>  This is the OCL code for calculating the name[] 
		=parse=>  This is the OCL code for calculating the name[]
adding non raw value. code -.  This is the OCL code for calculating the name[]
{
  "code_raw": " This is the OCL code for calculating the name[]",
  "code": " This is the OCL code for calculating the name[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'code_raw': ' This is the OCL code for calculating the name[]', 'code': ' This is the OCL code for calculating the name[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for ENGLISH: English: And thii is an english language rendering
RoundTrip ENGLISH: input is - ' And thii is an english language rendering[]'
RoundTrip ENGLISH: value is -  And thii is an english language rendering[]
OK.  And thii is an english language rendering[] ok for ENGLISH
RoundTrip ENGLISH: renders as - ' And thii is an english language rendering[]'
RoundTrip ENGLISH: reparses as -  And thii is an english language rendering[]
RoundTrip SUCCESS:  And thii is an english language rendering[]
		=parse=>  And thii is an english language rendering[] 
		=render=>  And thii is an english language rendering[] 
		=parse=>  And thii is an english language rendering[]
adding non raw value. English -.  And thii is an english language rendering[]
{
  "English_raw": " And thii is an english language rendering[]",
  "English": " And thii is an english language rendering[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'English_raw': ' And thii is an english language rendering[]', 'English': ' And thii is an english language rendering[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
--- skipping BLANK_LINE
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
DerivingDict for Part:  Constraint
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for CONSTRAINT: constraint: this is the first constraint for name in Component
RoundTrip CONSTRAINT: input is - ' this is the first constraint for name in Component[]'
RoundTrip CONSTRAINT: value is -  this is the first constraint for name in Component[]
OK.  this is the first constraint for name in Component[] ok for CONSTRAINT
RoundTrip CONSTRAINT: renders as - ' this is the first constraint for name in Component[]'
RoundTrip CONSTRAINT: reparses as -  this is the first constraint for name in Component[]
RoundTrip SUCCESS:  this is the first constraint for name in Component[]
		=parse=>  this is the first constraint for name in Component[] 
		=render=>  this is the first constraint for name in Component[] 
		=parse=>  this is the first constraint for name in Component[]
adding non raw value. constraint -.  this is the first constraint for name in Component[]
{
  "constraint_raw": " this is the first constraint for name in Component[]",
  "constraint": " this is the first constraint for name in Component[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'constraint_raw': ' this is the first constraint for name in Component[]', 'constraint': ' this is the first constraint for name in Component[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for CODE: code: OCL for first constraint
RoundTrip CODE: input is - ' OCL for first constraint[]'
RoundTrip CODE: value is -  OCL for first constraint[]
OK.  OCL for first constraint[] ok for CODE
RoundTrip CODE: renders as - ' OCL for first constraint[]'
RoundTrip CODE: reparses as -  OCL for first constraint[]
RoundTrip SUCCESS:  OCL for first constraint[]
		=parse=>  OCL for first constraint[] 
		=render=>  OCL for first constraint[] 
		=parse=>  OCL for first constraint[]
adding non raw value. code -.  OCL for first constraint[]
{
  "code_raw": " OCL for first constraint[]",
  "code": " OCL for first constraint[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'code_raw': ' OCL for first constraint[]', 'code': ' OCL for first constraint[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for ENGLISH: english: English for first constraint
RoundTrip ENGLISH: input is - ' English for first constraint[]'
RoundTrip ENGLISH: value is -  English for first constraint[]
OK.  English for first constraint[] ok for ENGLISH
RoundTrip ENGLISH: renders as - ' English for first constraint[]'
RoundTrip ENGLISH: reparses as -  English for first constraint[]
RoundTrip SUCCESS:  English for first constraint[]
		=parse=>  English for first constraint[] 
		=render=>  English for first constraint[] 
		=parse=>  English for first constraint[]
adding non raw value. english -.  English for first constraint[]
{
  "english_raw": " English for first constraint[]",
  "english": " English for first constraint[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'english_raw': ' English for first constraint[]', 'english': ' English for first constraint[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for SEVERITY: Severity: Harsh
RoundTrip SEVERITY: input is - ' Harsh[]'
RoundTrip SEVERITY: value is -  Harsh[]
OK.  Harsh[] ok for SEVERITY
RoundTrip SEVERITY: renders as - ' Harsh[]'
RoundTrip SEVERITY: reparses as -  Harsh[]
RoundTrip SUCCESS:  Harsh[]
		=parse=>  Harsh[] 
		=render=>  Harsh[] 
		=parse=>  Harsh[]
adding non raw value. Severity -.  Harsh[]
{
  "Severity_raw": " Harsh[]",
  "Severity": " Harsh[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Severity_raw': ' Harsh[]', 'Severity': ' Harsh[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for MESSAGE: Message: {name} is all wrong - first
RoundTrip MESSAGE: input is - ' {name} is all wrong - first[]'
RoundTrip MESSAGE: value is -  {name} is all wrong - first[]
OK.  {name} is all wrong - first[] ok for MESSAGE
RoundTrip MESSAGE: renders as - ' {name} is all wrong - first[]'
RoundTrip MESSAGE: reparses as -  {name} is all wrong - first[]
RoundTrip SUCCESS:  {name} is all wrong - first[]
		=parse=>  {name} is all wrong - first[] 
		=render=>  {name} is all wrong - first[] 
		=parse=>  {name} is all wrong - first[]
adding non raw value. Message -.  {name} is all wrong - first[]
{
  "Message_raw": " {name} is all wrong - first[]",
  "Message": " {name} is all wrong - first[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Message_raw': ' {name} is all wrong - first[]', 'Message': ' {name} is all wrong - first[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
--- skipping BLANK_LINE
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
DerivingDict for Part:  Constraint
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for CONSTRAINT: constraint: this is the second constraint for name in Component
RoundTrip CONSTRAINT: input is - ' this is the second constraint for name in Component[]'
RoundTrip CONSTRAINT: value is -  this is the second constraint for name in Component[]
OK.  this is the second constraint for name in Component[] ok for CONSTRAINT
RoundTrip CONSTRAINT: renders as - ' this is the second constraint for name in Component[]'
RoundTrip CONSTRAINT: reparses as -  this is the second constraint for name in Component[]
RoundTrip SUCCESS:  this is the second constraint for name in Component[]
		=parse=>  this is the second constraint for name in Component[] 
		=render=>  this is the second constraint for name in Component[] 
		=parse=>  this is the second constraint for name in Component[]
adding non raw value. constraint -.  this is the second constraint for name in Component[]
{
  "constraint_raw": " this is the second constraint for name in Component[]",
  "constraint": " this is the second constraint for name in Component[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'constraint_raw': ' this is the second constraint for name in Component[]', 'constraint': ' this is the second constraint for name in Component[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for CODE: code: OCL for second constraint
RoundTrip CODE: input is - ' OCL for second constraint[]'
RoundTrip CODE: value is -  OCL for second constraint[]
OK.  OCL for second constraint[] ok for CODE
RoundTrip CODE: renders as - ' OCL for second constraint[]'
RoundTrip CODE: reparses as -  OCL for second constraint[]
RoundTrip SUCCESS:  OCL for second constraint[]
		=parse=>  OCL for second constraint[] 
		=render=>  OCL for second constraint[] 
		=parse=>  OCL for second constraint[]
adding non raw value. code -.  OCL for second constraint[]
{
  "code_raw": " OCL for second constraint[]",
  "code": " OCL for second constraint[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'code_raw': ' OCL for second constraint[]', 'code': ' OCL for second constraint[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for ENGLISH: english: English for second constraint
RoundTrip ENGLISH: input is - ' English for second constraint[]'
RoundTrip ENGLISH: value is -  English for second constraint[]
OK.  English for second constraint[] ok for ENGLISH
RoundTrip ENGLISH: renders as - ' English for second constraint[]'
RoundTrip ENGLISH: reparses as -  English for second constraint[]
RoundTrip SUCCESS:  English for second constraint[]
		=parse=>  English for second constraint[] 
		=render=>  English for second constraint[] 
		=parse=>  English for second constraint[]
adding non raw value. english -.  English for second constraint[]
{
  "english_raw": " English for second constraint[]",
  "english": " English for second constraint[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'english_raw': ' English for second constraint[]', 'english': ' English for second constraint[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for SEVERITY: Severity: Harsh second
RoundTrip SEVERITY: input is - ' Harsh second[]'
RoundTrip SEVERITY: value is -  Harsh second[]
OK.  Harsh second[] ok for SEVERITY
RoundTrip SEVERITY: renders as - ' Harsh second[]'
RoundTrip SEVERITY: reparses as -  Harsh second[]
RoundTrip SUCCESS:  Harsh second[]
		=parse=>  Harsh second[] 
		=render=>  Harsh second[] 
		=parse=>  Harsh second[]
adding non raw value. Severity -.  Harsh second[]
{
  "Severity_raw": " Harsh second[]",
  "Severity": " Harsh second[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Severity_raw': ' Harsh second[]', 'Severity': ' Harsh second[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for MESSAGE: Message: {name} is all wrong - second
RoundTrip MESSAGE: input is - ' {name} is all wrong - second[]'
RoundTrip MESSAGE: value is -  {name} is all wrong - second[]
OK.  {name} is all wrong - second[] ok for MESSAGE
RoundTrip MESSAGE: renders as - ' {name} is all wrong - second[]'
RoundTrip MESSAGE: reparses as -  {name} is all wrong - second[]
RoundTrip SUCCESS:  {name} is all wrong - second[]
		=parse=>  {name} is all wrong - second[] 
		=render=>  {name} is all wrong - second[] 
		=parse=>  {name} is all wrong - second[]
adding non raw value. Message -.  {name} is all wrong - second[]
{
  "Message_raw": " {name} is all wrong - second[]",
  "Message": " {name} is all wrong - second[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Message_raw': ' {name} is all wrong - second[]', 'Message': ' {name} is all wrong - second[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for EXAMPLE: ***Example***: "LDM" is the short form of "Literate Data Model".
RoundTrip EXAMPLE: input is - ' "LDM" is the short form of "Literate Data Model".[]'
RoundTrip EXAMPLE: value is -  "LDM" is the short form of "Literate Data Model".[]
OK.  "LDM" is the short form of "Literate Data Model".[] ok for EXAMPLE
RoundTrip EXAMPLE: renders as - ' "LDM" is the short form of "Literate Data Model".[]'
RoundTrip EXAMPLE: reparses as -  "LDM" is the short form of "Literate Data Model".[]
RoundTrip SUCCESS:  "LDM" is the short form of "Literate Data Model".[]
		=parse=>  "LDM" is the short form of "Literate Data Model".[] 
		=render=>  "LDM" is the short form of "Literate Data Model".[] 
		=parse=>  "LDM" is the short form of "Literate Data Model".[]
adding non raw value. ***Example*** -.  "LDM" is the short form of "Literate Data Model".[]
{
  "***Example***_raw": " \"LDM\" is the short form of \"Literate Data Model\".[]",
  "***Example***": " \"LDM\" is the short form of \"Literate Data Model\".[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Example***_raw': ' "LDM" is the short form of "Literate Data Model".[]', '***Example***': ' "LDM" is the short form of "Literate Data Model".[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **oneLiner** - A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _(RichLine)_[]
RoundTrip Attribute_Head: input is - '- **oneLiner** - A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _(RichLine)_[]'
RoundTrip Attribute_Head: value is - {'name': 'oneLiner', 'one_liner': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _', 'parenthetical': 'RichLine'}
OK. {'name': 'oneLiner', 'one_liner': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _', 'parenthetical': 'RichLine'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'oneLiner - A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _ (RichLine)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **oneLiner** - A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _(RichLine)_[]
		=parse=> {'name': 'oneLiner', 'one_liner': 'A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _', 'parenthetical': 'RichLine'} 
		=render=> oneLiner - A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _ (RichLine) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **elaboration** - A more detailed explanation or discussion of the component _(RichText)_[]
RoundTrip Attribute_Head: input is - '- **elaboration** - A more detailed explanation or discussion of the component _(RichText)_[]'
RoundTrip Attribute_Head: value is - {'name': 'elaboration', 'one_liner': 'A more detailed explanation or discussion of the component _', 'parenthetical': 'RichText'}
OK. {'name': 'elaboration', 'one_liner': 'A more detailed explanation or discussion of the component _', 'parenthetical': 'RichText'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'elaboration - A more detailed explanation or discussion of the component _ (RichText)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **elaboration** - A more detailed explanation or discussion of the component _(RichText)_[]
		=parse=> {'name': 'elaboration', 'one_liner': 'A more detailed explanation or discussion of the component _', 'parenthetical': 'RichText'} 
		=render=> elaboration - A more detailed explanation or discussion of the component _ (RichText) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
DerivingDict for Part:  AttributeSection
		Full header is: __***For Machinery*** - mechanical attributes[]
RoundTrip AttributeSection_Head: input is - '__***For Machinery*** - mechanical attributes[]'
RoundTrip AttributeSection_Head: value is - {'name': 'For Machinery', 'one_liner': 'mechanical attributes[]', 'parenthetical': ''}
OK. {'name': 'For Machinery', 'one_liner': 'mechanical attributes[]', 'parenthetical': ''} ok for AttributeSection_Head
RoundTrip AttributeSection_Head: renders as - 'For Machinery - mechanical attributes[]'
RoundTrip AttributeSection_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: __***For Machinery*** - mechanical attributes[]
		=parse=> {'name': 'For Machinery', 'one_liner': 'mechanical attributes[]', 'parenthetical': ''} 
		=render=> For Machinery - mechanical attributes[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Attribute
		Full header is: - **isEmbellishment** - Indicates whether this component is an embellishment added during post-parsing processing _(Boolean)_[]
RoundTrip Attribute_Head: input is - '- **isEmbellishment** - Indicates whether this component is an embellishment added during post-parsing processing _(Boolean)_[]'
RoundTrip Attribute_Head: value is - {'name': 'isEmbellishment', 'one_liner': 'Indicates whether this component is an embellishment added during post-parsing processing _', 'parenthetical': 'Boolean'}
OK. {'name': 'isEmbellishment', 'one_liner': 'Indicates whether this component is an embellishment added during post-parsing processing _', 'parenthetical': 'Boolean'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'isEmbellishment - Indicates whether this component is an embellishment added during post-parsing processing _ (Boolean)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **isEmbellishment** - Indicates whether this component is an embellishment added during post-parsing processing _(Boolean)_[]
		=parse=> {'name': 'isEmbellishment', 'one_liner': 'Indicates whether this component is an embellishment added during post-parsing processing _', 'parenthetical': 'Boolean'} 
		=render=> isEmbellishment - Indicates whether this component is an embellishment added during post-parsing processing _ (Boolean) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Default
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DEFAULT: ***Default***: false
RoundTrip DEFAULT: input is - ' false[]'
RoundTrip DEFAULT: value is -  false[]
OK.  false[] ok for DEFAULT
RoundTrip DEFAULT: renders as - ' false[]'
RoundTrip DEFAULT: reparses as -  false[]
RoundTrip SUCCESS:  false[]
		=parse=>  false[] 
		=render=>  false[] 
		=parse=>  false[]
adding non raw value. ***Default*** -.  false[]
{
  "***Default***_raw": " false[]",
  "***Default***": " false[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Default***_raw': ' false[]', '***Default***': ' false[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for NOTE: ***Note***: This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.
RoundTrip NOTE: input is - ' This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.[]'
RoundTrip NOTE: value is -  This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.[]
OK.  This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.[] ok for NOTE
RoundTrip NOTE: renders as - ' This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.[]'
RoundTrip NOTE: reparses as -  This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.[]
RoundTrip SUCCESS:  This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.[]
		=parse=>  This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.[] 
		=render=>  This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.[] 
		=parse=>  This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.[]
adding non raw value. ***Note*** -.  This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.[]
{
  "***Note***_raw": " This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.[]",
  "***Note***": " This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Note***_raw': ' This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.[]', '***Note***': ' This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  AttributeSection
		Full header is: __***Markdown Support***[]
RoundTrip AttributeSection_Head: input is - '__***Markdown Support***[]'
RoundTrip AttributeSection_Head: value is - {'name': 'Markdown Support[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Markdown Support[]', 'one_liner': '', 'parenthetical': ''} ok for AttributeSection_Head
RoundTrip AttributeSection_Head: renders as - 'Markdown Support[]'
RoundTrip AttributeSection_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: __***Markdown Support***[]
		=parse=> {'name': 'Markdown Support[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Markdown Support[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Attribute
		Full header is: - **mdPrefix** (*[String](#string)*)[]
RoundTrip Attribute_Head: input is - '- **mdPrefix** (*[String](#string)*)[]'
RoundTrip Attribute_Head: value is - {'name': 'mdPrefix', 'one_liner': '', 'parenthetical': '*[String](#string'}
OK. {'name': 'mdPrefix', 'one_liner': '', 'parenthetical': '*[String](#string'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'mdPrefix (*[String](#string)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **mdPrefix** (*[String](#string)*)[]
		=parse=> {'name': 'mdPrefix', 'one_liner': '', 'parenthetical': '*[String](#string'} 
		=render=> mdPrefix (*[String](#string) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Derivation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DERIVATION: ***Derivation***: ""
RoundTrip DERIVATION: input is - ' ""[]'
RoundTrip DERIVATION: value is -  ""[]
OK.  ""[] ok for DERIVATION
RoundTrip DERIVATION: renders as - ' ""[]'
RoundTrip DERIVATION: reparses as -  ""[]
RoundTrip SUCCESS:  ""[]
		=parse=>  ""[] 
		=render=>  ""[] 
		=parse=>  ""[]
adding non raw value. ***Derivation*** -.  ""[]
{
  "***Derivation***_raw": " \"\"[]",
  "***Derivation***": " \"\"[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Derivation***_raw': ' ""[]', '***Derivation***': ' ""[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **mdSuffix** (*[String](#string)*)[]
RoundTrip Attribute_Head: input is - '- **mdSuffix** (*[String](#string)*)[]'
RoundTrip Attribute_Head: value is - {'name': 'mdSuffix', 'one_liner': '', 'parenthetical': '*[String](#string'}
OK. {'name': 'mdSuffix', 'one_liner': '', 'parenthetical': '*[String](#string'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'mdSuffix (*[String](#string)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **mdSuffix** (*[String](#string)*)[]
		=parse=> {'name': 'mdSuffix', 'one_liner': '', 'parenthetical': '*[String](#string'} 
		=render=> mdSuffix (*[String](#string) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Derivation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DERIVATION: ***Derivation***: ""
RoundTrip DERIVATION: input is - ' ""[]'
RoundTrip DERIVATION: value is -  ""[]
OK.  ""[] ok for DERIVATION
RoundTrip DERIVATION: renders as - ' ""[]'
RoundTrip DERIVATION: reparses as -  ""[]
RoundTrip SUCCESS:  ""[]
		=parse=>  ""[] 
		=render=>  ""[] 
		=parse=>  ""[]
adding non raw value. ***Derivation*** -.  ""[]
{
  "***Derivation***_raw": " \"\"[]",
  "***Derivation***": " \"\"[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Derivation***_raw': ' ""[]', '***Derivation***': ' ""[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **mdTopLine** (*[String](#string)*)[]
RoundTrip Attribute_Head: input is - '- **mdTopLine** (*[String](#string)*)[]'
RoundTrip Attribute_Head: value is - {'name': 'mdTopLine', 'one_liner': '', 'parenthetical': '*[String](#string'}
OK. {'name': 'mdTopLine', 'one_liner': '', 'parenthetical': '*[String](#string'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'mdTopLine (*[String](#string)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **mdTopLine** (*[String](#string)*)[]
		=parse=> {'name': 'mdTopLine', 'one_liner': '', 'parenthetical': '*[String](#string'} 
		=render=> mdTopLine (*[String](#string) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Derivation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DERIVATION: ***Derivation***: mdPrefix + name + " - " + oneLiner + mdSuffix
RoundTrip DERIVATION: input is - ' mdPrefix + name + " - " + oneLiner + mdSuffix[]'
RoundTrip DERIVATION: value is -  mdPrefix + name + " - " + oneLiner + mdSuffix[]
OK.  mdPrefix + name + " - " + oneLiner + mdSuffix[] ok for DERIVATION
RoundTrip DERIVATION: renders as - ' mdPrefix + name + " - " + oneLiner + mdSuffix[]'
RoundTrip DERIVATION: reparses as -  mdPrefix + name + " - " + oneLiner + mdSuffix[]
RoundTrip SUCCESS:  mdPrefix + name + " - " + oneLiner + mdSuffix[]
		=parse=>  mdPrefix + name + " - " + oneLiner + mdSuffix[] 
		=render=>  mdPrefix + name + " - " + oneLiner + mdSuffix[] 
		=parse=>  mdPrefix + name + " - " + oneLiner + mdSuffix[]
adding non raw value. ***Derivation*** -.  mdPrefix + name + " - " + oneLiner + mdSuffix[]
{
  "***Derivation***_raw": " mdPrefix + name + \" - \" + oneLiner + mdSuffix[]",
  "***Derivation***": " mdPrefix + name + \" - \" + oneLiner + mdSuffix[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Derivation***_raw': ' mdPrefix + name + " - " + oneLiner + mdSuffix[]', '***Derivation***': ' mdPrefix + name + " - " + oneLiner + mdSuffix[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
--- skipping BLANK_LINE
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **Component** - An element or building block of the literate data model with an extendedOneLiner
_ _ BLANK_LINE: 
_ _ BLANK_LINE: 
_ _ TEXT_LINE: In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.
_ _ BLANK_LINE: 
_ _ BLANK_LINE: 
_ _ CODE_FENCE: ```Sample code block between paragraphs + x <  y and y > z + ```
_ _ BLANK_LINE: 
_ _ TEXT_LINE: We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.
_ _ ABBREVIATION: abbreviation: COMPT
_ _ BLANK_LINE: 
_ _ SUBTYPES: Subtypes: ComponentA, ComponentB, ComponentC
_ _ BASED_ON: BasedOn: ComponentA, ComponentB, ComponentC
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - parentClass - the supertype - just here to test parser (Class)
_ _ _ INVERSE: inverseOf: Class.child_class
_ _ _ INVERSE: inverse: Class.child_class2
_ _ _ BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **normalName** - the name of the component, not in camel case (*String*)
_ _ _ BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **name** - The name of the component (CamelName)
_ _ _ BLANK_LINE: 
_ _ _ BLANK_LINE: 
_ _ _ BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **qualifiedName** - (*QualifiedCamel*)
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **abbreviatedName** - a short form of the component's name, used for cross references and improved readability. (*CamelName*)
_ _ _ BLANK_LINE: 
. . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ DEFAULT: ***Default***: name
_ _ _ _ CODE: code: This is the OCL code for calculating the name
_ _ _ _ ENGLISH: English: And thii is an english language rendering
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
. . . Constraint - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ CONSTRAINT: constraint: this is the first constraint for name in Component
_ _ _ _ CODE: code: OCL for first constraint
_ _ _ _ ENGLISH: english: English for first constraint
_ _ _ _ SEVERITY: Severity: Harsh
_ _ _ _ MESSAGE: Message: {name} is all wrong - first
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
. . . Constraint - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ CONSTRAINT: constraint: this is the second constraint for name in Component
_ _ _ _ CODE: code: OCL for second constraint
_ _ _ _ ENGLISH: english: English for second constraint
_ _ _ _ SEVERITY: Severity: Harsh second
_ _ _ _ MESSAGE: Message: {name} is all wrong - second
_ _ _ _ BLANK_LINE: 
. . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ EXAMPLE: ***Example***: "LDM" is the short form of "Literate Data Model".
_ _ _ _ BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **oneLiner** - A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _(RichLine)_
_ _ _ BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **elaboration** - A more detailed explanation or discussion of the component _(RichText)_
_ _ _ BLANK_LINE: 
. . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ AttributeSection_Head: __***For Machinery*** - mechanical attributes
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **isEmbellishment** - Indicates whether this component is an embellishment added during post-parsing processing _(Boolean)_
. . . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ DEFAULT: ***Default***: false
. . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ NOTE: ***Note***: This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.
. . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ AttributeSection_Head: __***Markdown Support***
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **mdPrefix** (*[String](#string)*)
. . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ DERIVATION: ***Derivation***: ""
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **mdSuffix** (*[String](#string)*)
. . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ DERIVATION: ***Derivation***: ""
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **mdTopLine** (*[String](#string)*)
. . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ DERIVATION: ***Derivation***: mdPrefix + name + " - " + oneLiner + mdSuffix
_ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **Component** - An element or building block of the literate data model with an extended['OneLiner']",
  "name": "Component",
  "one_liner": "An element or building block of the literate data model with an extended['OneLiner']",
  "parenthetical": "",
  "elaboration": [
    {
      "type_label": "TEXT_LINE",
      "content": "In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model."
    },
    {
      "type_label": "CODE_FENCE",
      "content": "```",
      "extra_text": [
        "Sample code block between paragraphs",
        "x <  y and y > z",
        "```"
      ]
    },
    {
      "type_label": "TEXT_LINE",
      "content": "We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component."
    }
  ],
  "abbreviation_raw": [
    " COMPT[]"
  ],
  "abbreviation": "COMPT[]",
  "Subtypes_raw": [
    " ComponentA, ComponentB, ComponentC[]"
  ],
  "Subtypes": [
    "ComponentA",
    "ComponentB",
    "ComponentC[]"
  ],
  "BasedOn_raw": [
    " ComponentA, ComponentB, ComponentC[]"
  ],
  "BasedOn": [
    "ComponentA",
    "ComponentB",
    "ComponentC[]"
  ],
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "- parentClass - the supertype - just here to test parser (Class)[]",
      "name": "parentClass",
      "one_liner": "the supertype - just here to test parser",
      "parenthetical": "Class",
      "inverseOf_raw": [
        " Class.child_class[]"
      ],
      "inverseOf": {
        "class_name": "Class",
        "attribute_name": "childclass[]"
      },
      "inverse_raw": [
        " Class.child_class2[]"
      ],
      "inverse": {
        "class_name": "Class",
        "attribute_name": "childclass2[]"
      }
    },
    {
      "_type": "Attribute",
      "full_header": "- **normalName** - the name of the component, not in camel case (*String*)[]",
      "name": "normalName",
      "one_liner": "the name of the component, not in camel case",
      "parenthetical": "*String*"
    },
    {
      "_type": "Attribute",
      "full_header": "- **name** - The name of the component (CamelName)[]",
      "name": "name",
      "one_liner": "The name of the component",
      "parenthetical": "CamelName"
    },
    {
      "_type": "Attribute",
      "full_header": "- **qualifiedName** - (*QualifiedCamel*)[]",
      "name": "qualifiedName",
      "one_liner": "",
      "parenthetical": "*QualifiedCamel*"
    },
    {
      "_type": "Attribute",
      "full_header": "- **abbreviatedName** - a short form of the component's name, used for cross references and improved readability. (*CamelName*)[]",
      "name": "abbreviatedName",
      "one_liner": "a short form of the component's name, used for cross references and improved readability.",
      "parenthetical": "*CamelName*",
      "Default": [
        {
          "_type": "Default",
          "***Default***_raw": [
            " name[]"
          ],
          "***Default***": " name[]",
          "code_raw": [
            " This is the OCL code for calculating the name[]"
          ],
          "code": " This is the OCL code for calculating the name[]",
          "English_raw": [
            " And thii is an english language rendering[]"
          ],
          "English": " And thii is an english language rendering[]"
        }
      ],
      "Constraint": [
        {
          "_type": "Constraint",
          "constraint_raw": [
            " this is the first constraint for name in Component[]"
          ],
          "constraint": [
            " ",
            "t",
            "h",
            "i",
            "s",
            " ",
            "i",
            "s",
            " ",
            "t",
            "h",
            "e",
            " ",
            "f",
            "i",
            "r",
            "s",
            "t",
            " ",
            "c",
            "o",
            "n",
            "s",
            "t",
            "r",
            "a",
            "i",
            "n",
            "t",
            " ",
            "f",
            "o",
            "r",
            " ",
            "n",
            "a",
            "m",
            "e",
            " ",
            "i",
            "n",
            " ",
            "C",
            "o",
            "m",
            "p",
            "o",
            "n",
            "e",
            "n",
            "t",
            "[",
            "]"
          ],
          "code_raw": [
            " OCL for first constraint[]"
          ],
          "code": " OCL for first constraint[]",
          "english_raw": [
            " English for first constraint[]"
          ],
          "english": " English for first constraint[]",
          "Severity_raw": [
            " Harsh[]"
          ],
          "Severity": " Harsh[]",
          "Message_raw": [
            " {name} is all wrong - first[]"
          ],
          "Message": " {name} is all wrong - first[]"
        },
        {
          "_type": "Constraint",
          "constraint_raw": [
            " this is the second constraint for name in Component[]"
          ],
          "constraint": [
            " ",
            "t",
            "h",
            "i",
            "s",
            " ",
            "i",
            "s",
            " ",
            "t",
            "h",
            "e",
            " ",
            "s",
            "e",
            "c",
            "o",
            "n",
            "d",
            " ",
            "c",
            "o",
            "n",
            "s",
            "t",
            "r",
            "a",
            "i",
            "n",
            "t",
            " ",
            "f",
            "o",
            "r",
            " ",
            "n",
            "a",
            "m",
            "e",
            " ",
            "i",
            "n",
            " ",
            "C",
            "o",
            "m",
            "p",
            "o",
            "n",
            "e",
            "n",
            "t",
            "[",
            "]"
          ],
          "code_raw": [
            " OCL for second constraint[]"
          ],
          "code": " OCL for second constraint[]",
          "english_raw": [
            " English for second constraint[]"
          ],
          "english": " English for second constraint[]",
          "Severity_raw": [
            " Harsh second[]"
          ],
          "Severity": " Harsh second[]",
          "Message_raw": [
            " {name} is all wrong - second[]"
          ],
          "Message": " {name} is all wrong - second[]"
        }
      ],
      "Annotation": [
        {
          "_type": "Annotation",
          "***Example***_raw": [
            " \"LDM\" is the short form of \"Literate Data Model\".[]"
          ],
          "***Example***": [
            " \"LDM\" is the short form of \"Literate Data Model\".[]"
          ]
        }
      ]
    },
    {
      "_type": "Attribute",
      "full_header": "- **oneLiner** - A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _(RichLine)_[]",
      "name": "oneLiner",
      "one_liner": "A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _",
      "parenthetical": "RichLine"
    },
    {
      "_type": "Attribute",
      "full_header": "- **elaboration** - A more detailed explanation or discussion of the component _(RichText)_[]",
      "name": "elaboration",
      "one_liner": "A more detailed explanation or discussion of the component _",
      "parenthetical": "RichText"
    }
  ],
  "AttributeSection": [
    {
      "_type": "AttributeSection",
      "full_header": "__***For Machinery*** - mechanical attributes[]",
      "name": "For Machinery",
      "one_liner": "mechanical attributes[]",
      "parenthetical": "",
      "Attribute": [
        {
          "_type": "Attribute",
          "full_header": "- **isEmbellishment** - Indicates whether this component is an embellishment added during post-parsing processing _(Boolean)_[]",
          "name": "isEmbellishment",
          "one_liner": "Indicates whether this component is an embellishment added during post-parsing processing _",
          "parenthetical": "Boolean",
          "Default": [
            {
              "_type": "Default",
              "***Default***_raw": [
                " false[]"
              ],
              "***Default***": " false[]"
            }
          ],
          "Annotation": [
            {
              "_type": "Annotation",
              "***Note***_raw": [
                " This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.[]"
              ],
              "***Note***": [
                " This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.[]"
              ]
            }
          ]
        }
      ]
    },
    {
      "_type": "AttributeSection",
      "full_header": "__***Markdown Support***[]",
      "name": "Markdown Support[]",
      "one_liner": "",
      "parenthetical": "",
      "Attribute": [
        {
          "_type": "Attribute",
          "full_header": "- **mdPrefix** (*[String](#string)*)[]",
          "name": "mdPrefix",
          "one_liner": "",
          "parenthetical": "*[String](#string",
          "Derivation": [
            {
              "_type": "Derivation",
              "***Derivation***_raw": [
                " \"\"[]"
              ],
              "***Derivation***": " \"\"[]"
            }
          ]
        },
        {
          "_type": "Attribute",
          "full_header": "- **mdSuffix** (*[String](#string)*)[]",
          "name": "mdSuffix",
          "one_liner": "",
          "parenthetical": "*[String](#string",
          "Derivation": [
            {
              "_type": "Derivation",
              "***Derivation***_raw": [
                " \"\"[]"
              ],
              "***Derivation***": " \"\"[]"
            }
          ]
        },
        {
          "_type": "Attribute",
          "full_header": "- **mdTopLine** (*[String](#string)*)[]",
          "name": "mdTopLine",
          "one_liner": "",
          "parenthetical": "*[String](#string",
          "Derivation": [
            {
              "_type": "Derivation",
              "***Derivation***_raw": [
                " mdPrefix + name + \" - \" + oneLiner + mdSuffix[]"
              ],
              "***Derivation***": " mdPrefix + name + \" - \" + oneLiner + mdSuffix[]"
            }
          ]
        }
      ]
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ **AnnotationType** - a kind of note, or aside, used to call attention to additional information about some Component.['And it can be continued on fresh lines.', 'However many you want.', 'But only up to a blank line or other clause']
RoundTrip Class_Head: input is - '_ **AnnotationType** - a kind of note, or aside, used to call attention to additional information about some Component.['And it can be continued on fresh lines.', 'However many you want.', 'But only up to a blank line or other clause']'
RoundTrip Class_Head: value is - {'name': 'AnnotationType', 'one_liner': "a kind of note, or aside, used to call attention to additional information about some Component.['And it can be continued on fresh lines.', 'However many you want.', 'But only up to a blank line or other clause']", 'parenthetical': ''}
OK. {'name': 'AnnotationType', 'one_liner': "a kind of note, or aside, used to call attention to additional information about some Component.['And it can be continued on fresh lines.', 'However many you want.', 'But only up to a blank line or other clause']", 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'AnnotationType - a kind of note, or aside, used to call attention to additional information about some Component.['And it can be continued on fresh lines.', 'However many you want.', 'But only up to a blank line or other clause']'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **AnnotationType** - a kind of note, or aside, used to call attention to additional information about some Component.['And it can be continued on fresh lines.', 'However many you want.', 'But only up to a blank line or other clause']
		=parse=> {'name': 'AnnotationType', 'one_liner': "a kind of note, or aside, used to call attention to additional information about some Component.['And it can be continued on fresh lines.', 'However many you want.', 'But only up to a blank line or other clause']", 'parenthetical': ''} 
		=render=> AnnotationType - a kind of note, or aside, used to call attention to additional information about some Component.['And it can be continued on fresh lines.', 'However many you want.', 'But only up to a blank line or other clause'] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for SEE: See. this is not included in the extra text.
ERROR: No colon in clause?? - SEE: See. this is not included in the extra text., full_text is See. this is not included in the extra text.[]
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {}
--- skipping BLANK_LINE
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for BASED_ON: ***Based on*** : Literate Data Model
RoundTrip BASED_ON: input is - ' Literate Data Model[]'
parse_name_list:  Literate Data Model[]
RoundTrip BASED_ON: value is - ['Literate Data Model[]']
validating name list:  ['Literate Data Model[]']
OK. ['Literate Data Model[]'] ok for BASED_ON
RoundTrip BASED_ON: renders as - 'Literate Data Model[]'
parse_name_list: Literate Data Model[]
RoundTrip BASED_ON: reparses as - ['Literate Data Model[]']
RoundTrip SUCCESS:  Literate Data Model[]
		=parse=> ['Literate Data Model[]'] 
		=render=> Literate Data Model[] 
		=parse=> ['Literate Data Model[]']
adding non raw value. ***Based on***  -. ['Literate Data Model[]']
{
  "***Based on*** _raw": " Literate Data Model[]",
  "***Based on*** ": [
    "Literate Data Model[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Based on*** _raw': ' Literate Data Model[]', '***Based on*** ': ['Literate Data Model[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for NOTE: ***Note***: Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.
RoundTrip NOTE: input is - ' Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.['But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.']'
RoundTrip NOTE: value is -  Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.['But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.']
OK.  Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.['But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.'] ok for NOTE
RoundTrip NOTE: renders as - ' Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.['But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.']'
RoundTrip NOTE: reparses as -  Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.['But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.']
RoundTrip SUCCESS:  Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.['But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.']
		=parse=>  Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.['But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.'] 
		=render=>  Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.['But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.'] 
		=parse=>  Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.['But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.']
adding non raw value. ***Note*** -.  Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.['But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.']
{
  "***Note***_raw": " Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.['But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.']",
  "***Note***": " Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.['But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.']"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Note***_raw': " Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.['But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.']", '***Note***': " Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.['But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.']"}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **emoji** - an emoji (Emoji)[]
RoundTrip Attribute_Head: input is - '- **emoji** - an emoji (Emoji)[]'
RoundTrip Attribute_Head: value is - {'name': 'emoji', 'one_liner': 'an emoji', 'parenthetical': 'Emoji'}
OK. {'name': 'emoji', 'one_liner': 'an emoji', 'parenthetical': 'Emoji'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'emoji - an emoji (Emoji)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **emoji** - an emoji (Emoji)[]
		=parse=> {'name': 'emoji', 'one_liner': 'an emoji', 'parenthetical': 'Emoji'} 
		=render=> emoji - an emoji (Emoji) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **emojiName** - an emoji (String)[]
RoundTrip Attribute_Head: input is - '- **emojiName** - an emoji (String)[]'
RoundTrip Attribute_Head: value is - {'name': 'emojiName', 'one_liner': 'an emoji', 'parenthetical': 'String'}
OK. {'name': 'emojiName', 'one_liner': 'an emoji', 'parenthetical': 'String'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'emojiName - an emoji (String)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **emojiName** - an emoji (String)[]
		=parse=> {'name': 'emojiName', 'one_liner': 'an emoji', 'parenthetical': 'String'} 
		=render=> emojiName - an emoji (String) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **emojiUnicode** - the Unicode for the emoji (Unicode)[]
RoundTrip Attribute_Head: input is - '- **emojiUnicode** - the Unicode for the emoji (Unicode)[]'
RoundTrip Attribute_Head: value is - {'name': 'emojiUnicode', 'one_liner': 'the Unicode for the emoji', 'parenthetical': 'Unicode'}
OK. {'name': 'emojiUnicode', 'one_liner': 'the Unicode for the emoji', 'parenthetical': 'Unicode'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'emojiUnicode - the Unicode for the emoji (Unicode)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **emojiUnicode** - the Unicode for the emoji (Unicode)[]
		=parse=> {'name': 'emojiUnicode', 'one_liner': 'the Unicode for the emoji', 'parenthetical': 'Unicode'} 
		=render=> emojiUnicode - the Unicode for the emoji (Unicode) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_[]
RoundTrip Attribute_Head: input is - '- **label** - A short label to indicate the purpose of the annotation _(CamelName)_[]'
RoundTrip Attribute_Head: value is - {'name': 'label', 'one_liner': 'A short label to indicate the purpose of the annotation _', 'parenthetical': 'CamelName'}
OK. {'name': 'label', 'one_liner': 'A short label to indicate the purpose of the annotation _', 'parenthetical': 'CamelName'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'label - A short label to indicate the purpose of the annotation _ (CamelName)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_[]
		=parse=> {'name': 'label', 'one_liner': 'A short label to indicate the purpose of the annotation _', 'parenthetical': 'CamelName'} 
		=render=> label - A short label to indicate the purpose of the annotation _ (CamelName) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **plural** - the plural form of the label (*UpperCamel*).[]
RoundTrip Attribute_Head: input is - '- **plural** - the plural form of the label (*UpperCamel*).[]'
RoundTrip Attribute_Head: value is - {'name': 'plural', 'one_liner': 'the plural form of the label', 'parenthetical': '*UpperCamel*'}
OK. {'name': 'plural', 'one_liner': 'the plural form of the label', 'parenthetical': '*UpperCamel*'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'plural - the plural form of the label (*UpperCamel*)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **plural** - the plural form of the label (*UpperCamel*).[]
		=parse=> {'name': 'plural', 'one_liner': 'the plural form of the label', 'parenthetical': '*UpperCamel*'} 
		=render=> plural - the plural form of the label (*UpperCamel*) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Default
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DEFAULT: Default: based on label
RoundTrip DEFAULT: input is - ' based on label[]'
RoundTrip DEFAULT: value is -  based on label[]
OK.  based on label[] ok for DEFAULT
RoundTrip DEFAULT: renders as - ' based on label[]'
RoundTrip DEFAULT: reparses as -  based on label[]
RoundTrip SUCCESS:  based on label[]
		=parse=>  based on label[] 
		=render=>  based on label[] 
		=parse=>  based on label[]
adding non raw value. Default -.  based on label[]
{
  "Default_raw": " based on label[]",
  "Default": " based on label[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Default_raw': ' based on label[]', 'Default': ' based on label[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **Purpose** - the intended reason for the annotation.[]
RoundTrip Attribute_Head: input is - '- **Purpose** - the intended reason for the annotation.[]'
RoundTrip Attribute_Head: value is - {'name': 'Purpose', 'one_liner': 'the intended reason for the annotation.[]', 'parenthetical': ''}
OK. {'name': 'Purpose', 'one_liner': 'the intended reason for the annotation.[]', 'parenthetical': ''} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'Purpose - the intended reason for the annotation.[]'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **Purpose** - the intended reason for the annotation.[]
		=parse=> {'name': 'Purpose', 'one_liner': 'the intended reason for the annotation.[]', 'parenthetical': ''} 
		=render=> Purpose - the intended reason for the annotation.[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- skipping BLANK_LINE
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **AnnotationType** - a kind of note, or aside, used to call attention to additional information about some Component.And it can be continued on fresh lines. + However many you want. + But only up to a blank line or other clause
_ _ BLANK_LINE: 
. . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ SEE: See. this is not included in the extra text.
_ _ _ BLANK_LINE: 
_ _ _ BASED_ON: ***Based on*** : Literate Data Model
. . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ NOTE: ***Note***: Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **emoji** - an emoji (Emoji)
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **emojiName** - an emoji (String)
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **emojiUnicode** - the Unicode for the emoji (Unicode)
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **plural** - the plural form of the label (*UpperCamel*).
. . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ DEFAULT: Default: based on label
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **Purpose** - the intended reason for the annotation.
_ _ _ BLANK_LINE: 
_ _ _ BLANK_LINE: 
_ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **AnnotationType** - a kind of note, or aside, used to call attention to additional information about some Component.['And it can be continued on fresh lines.', 'However many you want.', 'But only up to a blank line or other clause']",
  "name": "AnnotationType",
  "one_liner": "a kind of note, or aside, used to call attention to additional information about some Component.['And it can be continued on fresh lines.', 'However many you want.', 'But only up to a blank line or other clause']",
  "parenthetical": "",
  "Annotation": [
    {
      "_type": "Annotation",
      "***Based on*** _raw": [
        " Literate Data Model[]"
      ],
      "***Based on*** ": [
        "Literate Data Model[]"
      ]
    },
    {
      "_type": "Annotation",
      "***Note***_raw": [
        " Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.['But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.']"
      ],
      "***Note***": [
        " Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.['But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.']"
      ]
    }
  ],
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "- **emoji** - an emoji (Emoji)[]",
      "name": "emoji",
      "one_liner": "an emoji",
      "parenthetical": "Emoji"
    },
    {
      "_type": "Attribute",
      "full_header": "- **emojiName** - an emoji (String)[]",
      "name": "emojiName",
      "one_liner": "an emoji",
      "parenthetical": "String"
    },
    {
      "_type": "Attribute",
      "full_header": "- **emojiUnicode** - the Unicode for the emoji (Unicode)[]",
      "name": "emojiUnicode",
      "one_liner": "the Unicode for the emoji",
      "parenthetical": "Unicode"
    },
    {
      "_type": "Attribute",
      "full_header": "- **label** - A short label to indicate the purpose of the annotation _(CamelName)_[]",
      "name": "label",
      "one_liner": "A short label to indicate the purpose of the annotation _",
      "parenthetical": "CamelName"
    },
    {
      "_type": "Attribute",
      "full_header": "- **plural** - the plural form of the label (*UpperCamel*).[]",
      "name": "plural",
      "one_liner": "the plural form of the label",
      "parenthetical": "*UpperCamel*",
      "Default": [
        {
          "_type": "Default",
          "Default_raw": [
            " based on label[]"
          ],
          "Default": " based on label[]"
        }
      ]
    },
    {
      "_type": "Attribute",
      "full_header": "- **Purpose** - the intended reason for the annotation.[]",
      "name": "Purpose",
      "one_liner": "the intended reason for the annotation.[]",
      "parenthetical": ""
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ ValueType: **Annotation**['A note or comment associated with a model element']
RoundTrip Class_Head: input is - '_ ValueType: **Annotation**['A note or comment associated with a model element']'
RoundTrip Class_Head: value is - {'name': "ValueType: Annotation['A note or comment associated with a model element']", 'one_liner': '', 'parenthetical': ''}
OK. {'name': "ValueType: Annotation['A note or comment associated with a model element']", 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'ValueType: Annotation['A note or comment associated with a model element']'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ ValueType: **Annotation**['A note or comment associated with a model element']
		=parse=> {'name': "ValueType: Annotation['A note or comment associated with a model element']", 'one_liner': '', 'parenthetical': ''} 
		=render=> ValueType: Annotation['A note or comment associated with a model element'] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for BASED_ON: ***Based on***: Component
RoundTrip BASED_ON: input is - ' Component[]'
parse_name_list:  Component[]
RoundTrip BASED_ON: value is - ['Component[]']
validating name list:  ['Component[]']
OK. ['Component[]'] ok for BASED_ON
RoundTrip BASED_ON: renders as - 'Component[]'
parse_name_list: Component[]
RoundTrip BASED_ON: reparses as - ['Component[]']
RoundTrip SUCCESS:  Component[]
		=parse=> ['Component[]'] 
		=render=> Component[] 
		=parse=> ['Component[]']
adding non raw value. ***Based on*** -. ['Component[]']
{
  "***Based on***_raw": " Component[]",
  "***Based on***": [
    "Component[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Based on***_raw': ' Component[]', '***Based on***': ['Component[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **annotationType** - (optional Annotation Type)[]
RoundTrip Attribute_Head: input is - '- **annotationType** - (optional Annotation Type)[]'
RoundTrip Attribute_Head: value is - {'name': 'annotationType', 'one_liner': '', 'parenthetical': 'optional Annotation Type'}
OK. {'name': 'annotationType', 'one_liner': '', 'parenthetical': 'optional Annotation Type'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'annotationType (optional Annotation Type)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **annotationType** - (optional Annotation Type)[]
		=parse=> {'name': 'annotationType', 'one_liner': '', 'parenthetical': 'optional Annotation Type'} 
		=render=> annotationType (optional Annotation Type) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for NOTE: Note: An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.
RoundTrip NOTE: input is - ' An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.[]'
RoundTrip NOTE: value is -  An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.[]
OK.  An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.[] ok for NOTE
RoundTrip NOTE: renders as - ' An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.[]'
RoundTrip NOTE: reparses as -  An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.[]
RoundTrip SUCCESS:  An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.[]
		=parse=>  An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.[] 
		=render=>  An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.[] 
		=parse=>  An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.[]
adding non raw value. Note -.  An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.[]
{
  "Note_raw": " An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.[]",
  "Note": " An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Note_raw': ' An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.[]', 'Note': ' An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_[]
RoundTrip Attribute_Head: input is - '- **label** - A short label to indicate the purpose of the annotation _(CamelName)_[]'
RoundTrip Attribute_Head: value is - {'name': 'label', 'one_liner': 'A short label to indicate the purpose of the annotation _', 'parenthetical': 'CamelName'}
OK. {'name': 'label', 'one_liner': 'A short label to indicate the purpose of the annotation _', 'parenthetical': 'CamelName'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'label - A short label to indicate the purpose of the annotation _ (CamelName)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_[]
		=parse=> {'name': 'label', 'one_liner': 'A short label to indicate the purpose of the annotation _', 'parenthetical': 'CamelName'} 
		=render=> label - A short label to indicate the purpose of the annotation _ (CamelName) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- adding TEXT para
DerivingDict for Part:  Default
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DEFAULT: Default: from annotationType
RoundTrip DEFAULT: input is - ' from annotationType[]'
RoundTrip DEFAULT: value is -  from annotationType[]
OK.  from annotationType[] ok for DEFAULT
RoundTrip DEFAULT: renders as - ' from annotationType[]'
RoundTrip DEFAULT: reparses as -  from annotationType[]
RoundTrip SUCCESS:  from annotationType[]
		=parse=>  from annotationType[] 
		=render=>  from annotationType[] 
		=parse=>  from annotationType[]
adding non raw value. Default -.  from annotationType[]
{
  "Default_raw": " from annotationType[]",
  "Default": " from annotationType[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Default_raw': ' from annotationType[]', 'Default': ' from annotationType[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **Emoji** - (optional Emoji)[]
RoundTrip Attribute_Head: input is - '- **Emoji** - (optional Emoji)[]'
RoundTrip Attribute_Head: value is - {'name': 'Emoji', 'one_liner': '', 'parenthetical': 'optional Emoji'}
OK. {'name': 'Emoji', 'one_liner': '', 'parenthetical': 'optional Emoji'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'Emoji (optional Emoji)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **Emoji** - (optional Emoji)[]
		=parse=> {'name': 'Emoji', 'one_liner': '', 'parenthetical': 'optional Emoji'} 
		=render=> Emoji (optional Emoji) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Default
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DEFAULT: Default: from annotation type
RoundTrip DEFAULT: input is - ' from annotation type[]'
RoundTrip DEFAULT: value is -  from annotation type[]
OK.  from annotation type[] ok for DEFAULT
RoundTrip DEFAULT: renders as - ' from annotation type[]'
RoundTrip DEFAULT: reparses as -  from annotation type[]
RoundTrip SUCCESS:  from annotation type[]
		=parse=>  from annotation type[] 
		=render=>  from annotation type[] 
		=parse=>  from annotation type[]
adding non raw value. Default -.  from annotation type[]
{
  "Default_raw": " from annotation type[]",
  "Default": " from annotation type[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Default_raw': ' from annotation type[]', 'Default': ' from annotation type[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
--- skipping BLANK_LINE
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **content** - The content or body of the annotation (*RichText*)[]
RoundTrip Attribute_Head: input is - '- **content** - The content or body of the annotation (*RichText*)[]'
RoundTrip Attribute_Head: value is - {'name': 'content', 'one_liner': 'The content or body of the annotation', 'parenthetical': '*RichText*'}
OK. {'name': 'content', 'one_liner': 'The content or body of the annotation', 'parenthetical': '*RichText*'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'content - The content or body of the annotation (*RichText*)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **content** - The content or body of the annotation (*RichText*)[]
		=parse=> {'name': 'content', 'one_liner': 'The content or body of the annotation', 'parenthetical': '*RichText*'} 
		=render=> content - The content or body of the annotation (*RichText*) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  AttributeSection
		Full header is: __***For Machinery***[]
RoundTrip AttributeSection_Head: input is - '__***For Machinery***[]'
RoundTrip AttributeSection_Head: value is - {'name': 'For Machinery[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'For Machinery[]', 'one_liner': '', 'parenthetical': ''} ok for AttributeSection_Head
RoundTrip AttributeSection_Head: renders as - 'For Machinery[]'
RoundTrip AttributeSection_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: __***For Machinery***[]
		=parse=> {'name': 'For Machinery[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> For Machinery[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Attribute
		Full header is: - **isEmbellishment** - Indicates whether this annotation is an embellishment added during post-parsing processing _(Boolean)_[]
RoundTrip Attribute_Head: input is - '- **isEmbellishment** - Indicates whether this annotation is an embellishment added during post-parsing processing _(Boolean)_[]'
RoundTrip Attribute_Head: value is - {'name': 'isEmbellishment', 'one_liner': 'Indicates whether this annotation is an embellishment added during post-parsing processing _', 'parenthetical': 'Boolean'}
OK. {'name': 'isEmbellishment', 'one_liner': 'Indicates whether this annotation is an embellishment added during post-parsing processing _', 'parenthetical': 'Boolean'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'isEmbellishment - Indicates whether this annotation is an embellishment added during post-parsing processing _ (Boolean)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **isEmbellishment** - Indicates whether this annotation is an embellishment added during post-parsing processing _(Boolean)_[]
		=parse=> {'name': 'isEmbellishment', 'one_liner': 'Indicates whether this annotation is an embellishment added during post-parsing processing _', 'parenthetical': 'Boolean'} 
		=render=> isEmbellishment - Indicates whether this annotation is an embellishment added during post-parsing processing _ (Boolean) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Default
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DEFAULT: ***Default***: false
RoundTrip DEFAULT: input is - ' false[]'
RoundTrip DEFAULT: value is -  false[]
OK.  false[] ok for DEFAULT
RoundTrip DEFAULT: renders as - ' false[]'
RoundTrip DEFAULT: reparses as -  false[]
RoundTrip SUCCESS:  false[]
		=parse=>  false[] 
		=render=>  false[] 
		=parse=>  false[]
adding non raw value. ***Default*** -.  false[]
{
  "***Default***_raw": " false[]",
  "***Default***": " false[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Default***_raw': ' false[]', '***Default***': ' false[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for NOTE: ***Note***: This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.
RoundTrip NOTE: input is - ' This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.[]'
RoundTrip NOTE: value is -  This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.[]
OK.  This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.[] ok for NOTE
RoundTrip NOTE: renders as - ' This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.[]'
RoundTrip NOTE: reparses as -  This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.[]
RoundTrip SUCCESS:  This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.[]
		=parse=>  This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.[] 
		=render=>  This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.[] 
		=parse=>  This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.[]
adding non raw value. ***Note*** -.  This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.[]
{
  "***Note***_raw": " This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.[]",
  "***Note***": " This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Note***_raw': ' This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.[]', '***Note***': ' This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ ValueType: **Annotation**A note or comment associated with a model element
_ _ BASED_ON: ***Based on***: Component
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **annotationType** - (optional Annotation Type)
. . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ NOTE: Note: An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_
_ _ _ BLANK_LINE: 
_ _ _ TEXT_LINE: But any short label is valid.
. . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ DEFAULT: Default: from annotationType
_ _ _ _ BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **Emoji** - (optional Emoji)
. . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ DEFAULT: Default: from annotation type
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **content** - The content or body of the annotation (*RichText*)
. . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ AttributeSection_Head: __***For Machinery***
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **isEmbellishment** - Indicates whether this annotation is an embellishment added during post-parsing processing _(Boolean)_
. . . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ DEFAULT: ***Default***: false
. . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ NOTE: ***Note***: This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.
_ _ _ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ ValueType: **Annotation**['A note or comment associated with a model element']",
  "name": "ValueType: Annotation['A note or comment associated with a model element']",
  "one_liner": "",
  "parenthetical": "",
  "***Based on***_raw": [
    " Component[]"
  ],
  "***Based on***": [
    "Component[]"
  ],
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "- **annotationType** - (optional Annotation Type)[]",
      "name": "annotationType",
      "one_liner": "",
      "parenthetical": "optional Annotation Type",
      "Annotation": [
        {
          "_type": "Annotation",
          "Note_raw": [
            " An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.[]"
          ],
          "Note": [
            " An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.[]"
          ]
        }
      ]
    },
    {
      "_type": "Attribute",
      "full_header": "- **label** - A short label to indicate the purpose of the annotation _(CamelName)_[]",
      "name": "label",
      "one_liner": "A short label to indicate the purpose of the annotation _",
      "parenthetical": "CamelName",
      "elaboration": [
        {
          "type_label": "TEXT_LINE",
          "content": "But any short label is valid."
        }
      ],
      "Default": [
        {
          "_type": "Default",
          "Default_raw": [
            " from annotationType[]"
          ],
          "Default": " from annotationType[]"
        }
      ]
    },
    {
      "_type": "Attribute",
      "full_header": "- **Emoji** - (optional Emoji)[]",
      "name": "Emoji",
      "one_liner": "",
      "parenthetical": "optional Emoji",
      "Default": [
        {
          "_type": "Default",
          "Default_raw": [
            " from annotation type[]"
          ],
          "Default": " from annotation type[]"
        }
      ]
    },
    {
      "_type": "Attribute",
      "full_header": "- **content** - The content or body of the annotation (*RichText*)\u200b\u200b\u200b\u200b\u200b\u200b\u200b[]",
      "name": "content",
      "one_liner": "The content or body of the annotation",
      "parenthetical": "*RichText*"
    }
  ],
  "AttributeSection": [
    {
      "_type": "AttributeSection",
      "full_header": "__***For Machinery***[]",
      "name": "For Machinery[]",
      "one_liner": "",
      "parenthetical": "",
      "Attribute": [
        {
          "_type": "Attribute",
          "full_header": "- **isEmbellishment** - Indicates whether this annotation is an embellishment added during post-parsing processing _(Boolean)_[]",
          "name": "isEmbellishment",
          "one_liner": "Indicates whether this annotation is an embellishment added during post-parsing processing _",
          "parenthetical": "Boolean",
          "Default": [
            {
              "_type": "Default",
              "***Default***_raw": [
                " false[]"
              ],
              "***Default***": " false[]"
            }
          ],
          "Annotation": [
            {
              "_type": "Annotation",
              "***Note***_raw": [
                " This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.[]"
              ],
              "***Note***": [
                " This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.[]"
              ]
            }
          ]
        }
      ]
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Section3
		Full header is: ### Annotation Types Used[]
RoundTrip Section3_Head: input is - '### Annotation Types Used[]'
RoundTrip Section3_Head: value is - {'name': 'Annotation Types Used[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Annotation Types Used[]', 'one_liner': '', 'parenthetical': ''} ok for Section3_Head
RoundTrip Section3_Head: renders as - 'Annotation Types Used[]'
RoundTrip Section3_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: ### Annotation Types Used[]
		=parse=> {'name': 'Annotation Types Used[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Annotation Types Used[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- adding TEXT para
--- skipping BLANK_LINE
--- skipping BLANK_LINE
--- adding TEXT para
--- skipping BLANK_LINE
--- adding CODE_FENCE para
--- skipping BLANK_LINE
--- skipping BLANK_LINE
--- skipping BLANK_LINE
--- skipping BLANK_LINE
--- skipping BLANK_LINE
--- skipping BLANK_LINE
--- skipping BLANK_LINE
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Section2
		Full header is: ## The Model and its Subjects[]
RoundTrip Section2_Head: input is - '## The Model and its Subjects[]'
RoundTrip Section2_Head: value is - {'name': 'The Model and its Subjects[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'The Model and its Subjects[]', 'one_liner': '', 'parenthetical': ''} ok for Section2_Head
RoundTrip Section2_Head: renders as - 'The Model and its Subjects[]'
RoundTrip Section2_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: ## The Model and its Subjects[]
		=parse=> {'name': 'The Model and its Subjects[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> The Model and its Subjects[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- skipping BLANK_LINE
DerivingDict for Part:  Class
		Full header is: _ **LiterateDataModel** - A representation of a domain's entities, attributes, and relationships,['along with explanatory text and examples']
RoundTrip Class_Head: input is - '_ **LiterateDataModel** - A representation of a domain's entities, attributes, and relationships,['along with explanatory text and examples']'
RoundTrip Class_Head: value is - {'name': 'LiterateDataModel', 'one_liner': "A representation of a domain's entities, attributes, and relationships,['along with explanatory text and examples']", 'parenthetical': ''}
OK. {'name': 'LiterateDataModel', 'one_liner': "A representation of a domain's entities, attributes, and relationships,['along with explanatory text and examples']", 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'LiterateDataModel - A representation of a domain's entities, attributes, and relationships,['along with explanatory text and examples']'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **LiterateDataModel** - A representation of a domain's entities, attributes, and relationships,['along with explanatory text and examples']
		=parse=> {'name': 'LiterateDataModel', 'one_liner': "A representation of a domain's entities, attributes, and relationships,['along with explanatory text and examples']", 'parenthetical': ''} 
		=render=> LiterateDataModel - A representation of a domain's entities, attributes, and relationships,['along with explanatory text and examples'] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for ABBREVIATION: ***Abbreviation***: LDM
RoundTrip ABBREVIATION: input is - ' LDM[]'
RoundTrip ABBREVIATION: value is - LDM[]
OK. LDM[] ok for ABBREVIATION
RoundTrip ABBREVIATION: renders as - 'LDM[]'
RoundTrip ABBREVIATION: reparses as - LDM[]
RoundTrip SUCCESS:  LDM[]
		=parse=> LDM[] 
		=render=> LDM[] 
		=parse=> LDM[]
adding non raw value. ***Abbreviation*** -. LDM[]
{
  "***Abbreviation***_raw": " LDM[]",
  "***Abbreviation***": "LDM[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Abbreviation***_raw': ' LDM[]', '***Abbreviation***': 'LDM[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for PLURAL: _Plural:_ LiterateDataModels
RoundTrip PLURAL: input is - '_ LiterateDataModels[]'
RoundTrip PLURAL: value is - _ LiterateDataModels[]
OK. _ LiterateDataModels[] ok for PLURAL
RoundTrip PLURAL: renders as - '_ LiterateDataModels[]'
RoundTrip PLURAL: reparses as - _ LiterateDataModels[]
RoundTrip SUCCESS: _ LiterateDataModels[]
		=parse=> _ LiterateDataModels[] 
		=render=> _ LiterateDataModels[] 
		=parse=> _ LiterateDataModels[]
adding non raw value. _Plural -. _ LiterateDataModels[]
{
  "_Plural_raw": "_ LiterateDataModels[]",
  "_Plural": "_ LiterateDataModels[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'_Plural_raw': '_ LiterateDataModels[]', '_Plural': '_ LiterateDataModels[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **LiterateDataModel** - A representation of a domain's entities, attributes, and relationships,along with explanatory text and examples
_ _ ABBREVIATION: ***Abbreviation***: LDM
_ _ PLURAL: _Plural:_ LiterateDataModels
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **LiterateDataModel** - A representation of a domain's entities, attributes, and relationships,['along with explanatory text and examples']",
  "name": "LiterateDataModel",
  "one_liner": "A representation of a domain's entities, attributes, and relationships,['along with explanatory text and examples']",
  "parenthetical": "",
  "***Abbreviation***_raw": [
    " LDM[]"
  ],
  "***Abbreviation***": "LDM[]",
  "_Plural_raw": [
    "_ LiterateDataModels[]"
  ],
  "_Plural": "_ LiterateDataModels[]"
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _Subtype of:_ Component[]
RoundTrip Class_Head: input is - '_Subtype of:_ Component[]'
RoundTrip Class_Head: value is - {'name': 'Subtype of: Component[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Subtype of: Component[]', 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Subtype of: Component[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _Subtype of:_ Component[]
		=parse=> {'name': 'Subtype of: Component[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Subtype of: Component[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- skipping BLANK_LINE
DerivingDict for Part:  Attribute
		Full header is: - name (UpperCamel )[]
RoundTrip Attribute_Head: input is - '- name (UpperCamel )[]'
RoundTrip Attribute_Head: value is - {'name': 'name', 'one_liner': '', 'parenthetical': 'UpperCamel'}
OK. {'name': 'name', 'one_liner': '', 'parenthetical': 'UpperCamel'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'name (UpperCamel)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - name (UpperCamel )[]
		=parse=> {'name': 'name', 'one_liner': '', 'parenthetical': 'UpperCamel'} 
		=render=> name (UpperCamel) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - allSubjects - list of all classes in the model, as ordered in the['definition of the model. (List of Classes)']
RoundTrip Attribute_Head: input is - '- allSubjects - list of all classes in the model, as ordered in the['definition of the model. (List of Classes)']'
RoundTrip Attribute_Head: value is - {'name': 'allSubjects', 'one_liner': "list of all classes in the model, as ordered in the['definition of the model.", 'parenthetical': 'List of Classes'}
OK. {'name': 'allSubjects', 'one_liner': "list of all classes in the model, as ordered in the['definition of the model.", 'parenthetical': 'List of Classes'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'allSubjects - list of all classes in the model, as ordered in the['definition of the model. (List of Classes)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - allSubjects - list of all classes in the model, as ordered in the['definition of the model. (List of Classes)']
		=parse=> {'name': 'allSubjects', 'one_liner': "list of all classes in the model, as ordered in the['definition of the model.", 'parenthetical': 'List of Classes'} 
		=render=> allSubjects - list of all classes in the model, as ordered in the['definition of the model. (List of Classes) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Derivation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DERIVATION: Derivation: gathering s.allSubjects over s in subjectAreas
RoundTrip DERIVATION: input is - ' gathering s.allSubjects over s in subjectAreas[]'
RoundTrip DERIVATION: value is -  gathering s.allSubjects over s in subjectAreas[]
OK.  gathering s.allSubjects over s in subjectAreas[] ok for DERIVATION
RoundTrip DERIVATION: renders as - ' gathering s.allSubjects over s in subjectAreas[]'
RoundTrip DERIVATION: reparses as -  gathering s.allSubjects over s in subjectAreas[]
RoundTrip SUCCESS:  gathering s.allSubjects over s in subjectAreas[]
		=parse=>  gathering s.allSubjects over s in subjectAreas[] 
		=render=>  gathering s.allSubjects over s in subjectAreas[] 
		=parse=>  gathering s.allSubjects over s in subjectAreas[]
adding non raw value. Derivation -.  gathering s.allSubjects over s in subjectAreas[]
{
  "Derivation_raw": " gathering s.allSubjects over s in subjectAreas[]",
  "Derivation": " gathering s.allSubjects over s in subjectAreas[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Derivation_raw': ' gathering s.allSubjects over s in subjectAreas[]', 'Derivation': ' gathering s.allSubjects over s in subjectAreas[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
DerivingDict for Part:  Constraint
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for CONSTRAINT: ***Constraint***: Subject names must be unique across the model.
RoundTrip CONSTRAINT: input is - ' Subject names must be unique across the model.[]'
RoundTrip CONSTRAINT: value is -  Subject names must be unique across the model.[]
OK.  Subject names must be unique across the model.[] ok for CONSTRAINT
RoundTrip CONSTRAINT: renders as - ' Subject names must be unique across the model.[]'
RoundTrip CONSTRAINT: reparses as -  Subject names must be unique across the model.[]
RoundTrip SUCCESS:  Subject names must be unique across the model.[]
		=parse=>  Subject names must be unique across the model.[] 
		=render=>  Subject names must be unique across the model.[] 
		=parse=>  Subject names must be unique across the model.[]
adding non raw value. ***Constraint*** -.  Subject names must be unique across the model.[]
{
  "***Constraint***_raw": " Subject names must be unique across the model.[]",
  "***Constraint***": " Subject names must be unique across the model.[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Constraint***_raw': ' Subject names must be unique across the model.[]', '***Constraint***': ' Subject names must be unique across the model.[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - allClasses - list of all classes in the model, as ordered in the definition of the model. (List of Classes)[]
RoundTrip Attribute_Head: input is - '- allClasses - list of all classes in the model, as ordered in the definition of the model. (List of Classes)[]'
RoundTrip Attribute_Head: value is - {'name': 'allClasses', 'one_liner': 'list of all classes in the model, as ordered in the definition of the model.', 'parenthetical': 'List of Classes'}
OK. {'name': 'allClasses', 'one_liner': 'list of all classes in the model, as ordered in the definition of the model.', 'parenthetical': 'List of Classes'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'allClasses - list of all classes in the model, as ordered in the definition of the model. (List of Classes)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - allClasses - list of all classes in the model, as ordered in the definition of the model. (List of Classes)[]
		=parse=> {'name': 'allClasses', 'one_liner': 'list of all classes in the model, as ordered in the definition of the model.', 'parenthetical': 'List of Classes'} 
		=render=> allClasses - list of all classes in the model, as ordered in the definition of the model. (List of Classes) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Derivation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DERIVATION: Derivation: gathering s.allClasses over s in allSubjects.
RoundTrip DERIVATION: input is - ' gathering s.allClasses over s in allSubjects.[]'
RoundTrip DERIVATION: value is -  gathering s.allClasses over s in allSubjects.[]
OK.  gathering s.allClasses over s in allSubjects.[] ok for DERIVATION
RoundTrip DERIVATION: renders as - ' gathering s.allClasses over s in allSubjects.[]'
RoundTrip DERIVATION: reparses as -  gathering s.allClasses over s in allSubjects.[]
RoundTrip SUCCESS:  gathering s.allClasses over s in allSubjects.[]
		=parse=>  gathering s.allClasses over s in allSubjects.[] 
		=render=>  gathering s.allClasses over s in allSubjects.[] 
		=parse=>  gathering s.allClasses over s in allSubjects.[]
adding non raw value. Derivation -.  gathering s.allClasses over s in allSubjects.[]
{
  "Derivation_raw": " gathering s.allClasses over s in allSubjects.[]",
  "Derivation": " gathering s.allClasses over s in allSubjects.[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Derivation_raw': ' gathering s.allClasses over s in allSubjects.[]', 'Derivation': ' gathering s.allClasses over s in allSubjects.[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Constraint
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for CONSTRAINT: ***Constraint***: Class names must be unique across the model.
RoundTrip CONSTRAINT: input is - ' Class names must be unique across the model.[]'
RoundTrip CONSTRAINT: value is -  Class names must be unique across the model.[]
OK.  Class names must be unique across the model.[] ok for CONSTRAINT
RoundTrip CONSTRAINT: renders as - ' Class names must be unique across the model.[]'
RoundTrip CONSTRAINT: reparses as -  Class names must be unique across the model.[]
RoundTrip SUCCESS:  Class names must be unique across the model.[]
		=parse=>  Class names must be unique across the model.[] 
		=render=>  Class names must be unique across the model.[] 
		=parse=>  Class names must be unique across the model.[]
adding non raw value. ***Constraint*** -.  Class names must be unique across the model.[]
{
  "***Constraint***_raw": " Class names must be unique across the model.[]",
  "***Constraint***": " Class names must be unique across the model.[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Constraint***_raw': ' Class names must be unique across the model.[]', '***Constraint***': ' Class names must be unique across the model.[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  AttributeSection
		Full header is: __ 	***Modeling Configuration***[]
RoundTrip AttributeSection_Head: input is - '__ 	***Modeling Configuration***[]'
RoundTrip AttributeSection_Head: value is - {'name': 'Modeling Configuration[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Modeling Configuration[]', 'one_liner': '', 'parenthetical': ''} ok for AttributeSection_Head
RoundTrip AttributeSection_Head: renders as - 'Modeling Configuration[]'
RoundTrip AttributeSection_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: __ 	***Modeling Configuration***[]
		=parse=> {'name': 'Modeling Configuration[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Modeling Configuration[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Attribute
		Full header is: - **annotationTypes** - (List of AnnotationTypes)[]
RoundTrip Attribute_Head: input is - '- **annotationTypes** - (List of AnnotationTypes)[]'
RoundTrip Attribute_Head: value is - {'name': 'annotationTypes', 'one_liner': '', 'parenthetical': 'List of AnnotationTypes'}
OK. {'name': 'annotationTypes', 'one_liner': '', 'parenthetical': 'List of AnnotationTypes'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'annotationTypes (List of AnnotationTypes)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **annotationTypes** - (List of AnnotationTypes)[]
		=parse=> {'name': 'annotationTypes', 'one_liner': '', 'parenthetical': 'List of AnnotationTypes'} 
		=render=> annotationTypes (List of AnnotationTypes) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **Preferred Coding Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Coding Language).[]
RoundTrip Attribute_Head: input is - '- **Preferred Coding Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Coding Language).[]'
RoundTrip Attribute_Head: value is - {'name': 'Preferred Coding Language', 'one_liner': 'the recommended lanquage  for expressing derivation, defaults, and constraints', 'parenthetical': 'Coding Language'}
OK. {'name': 'Preferred Coding Language', 'one_liner': 'the recommended lanquage  for expressing derivation, defaults, and constraints', 'parenthetical': 'Coding Language'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'Preferred Coding Language - the recommended lanquage  for expressing derivation, defaults, and constraints (Coding Language)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **Preferred Coding Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Coding Language).[]
		=parse=> {'name': 'Preferred Coding Language', 'one_liner': 'the recommended lanquage  for expressing derivation, defaults, and constraints', 'parenthetical': 'Coding Language'} 
		=render=> Preferred Coding Language - the recommended lanquage  for expressing derivation, defaults, and constraints (Coding Language) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Default
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DEFAULT: Default: OCL
RoundTrip DEFAULT: input is - ' OCL[]'
RoundTrip DEFAULT: value is -  OCL[]
OK.  OCL[] ok for DEFAULT
RoundTrip DEFAULT: renders as - ' OCL[]'
RoundTrip DEFAULT: reparses as -  OCL[]
RoundTrip SUCCESS:  OCL[]
		=parse=>  OCL[] 
		=render=>  OCL[] 
		=parse=>  OCL[]
adding non raw value. Default -.  OCL[]
{
  "Default_raw": " OCL[]",
  "Default": " OCL[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Default_raw': ' OCL[]', 'Default': ' OCL[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **alternate Coding Languages** -  (optional List of Coding Languages).[]
RoundTrip Attribute_Head: input is - '- **alternate Coding Languages** -  (optional List of Coding Languages).[]'
RoundTrip Attribute_Head: value is - {'name': 'alternate Coding Languages', 'one_liner': '', 'parenthetical': 'optional List of Coding Languages'}
OK. {'name': 'alternate Coding Languages', 'one_liner': '', 'parenthetical': 'optional List of Coding Languages'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'alternate Coding Languages (optional List of Coding Languages)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **alternate Coding Languages** -  (optional List of Coding Languages).[]
		=parse=> {'name': 'alternate Coding Languages', 'one_liner': '', 'parenthetical': 'optional List of Coding Languages'} 
		=render=> alternate Coding Languages (optional List of Coding Languages) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **Preferred Template Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Template Language).[]
RoundTrip Attribute_Head: input is - '- **Preferred Template Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Template Language).[]'
RoundTrip Attribute_Head: value is - {'name': 'Preferred Template Language', 'one_liner': 'the recommended lanquage  for expressing derivation, defaults, and constraints', 'parenthetical': 'Template Language'}
OK. {'name': 'Preferred Template Language', 'one_liner': 'the recommended lanquage  for expressing derivation, defaults, and constraints', 'parenthetical': 'Template Language'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'Preferred Template Language - the recommended lanquage  for expressing derivation, defaults, and constraints (Template Language)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **Preferred Template Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Template Language).[]
		=parse=> {'name': 'Preferred Template Language', 'one_liner': 'the recommended lanquage  for expressing derivation, defaults, and constraints', 'parenthetical': 'Template Language'} 
		=render=> Preferred Template Language - the recommended lanquage  for expressing derivation, defaults, and constraints (Template Language) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Default
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DEFAULT: Default: Handlebars
RoundTrip DEFAULT: input is - ' Handlebars[]'
RoundTrip DEFAULT: value is -  Handlebars[]
OK.  Handlebars[] ok for DEFAULT
RoundTrip DEFAULT: renders as - ' Handlebars[]'
RoundTrip DEFAULT: reparses as -  Handlebars[]
RoundTrip SUCCESS:  Handlebars[]
		=parse=>  Handlebars[] 
		=render=>  Handlebars[] 
		=parse=>  Handlebars[]
adding non raw value. Default -.  Handlebars[]
{
  "Default_raw": " Handlebars[]",
  "Default": " Handlebars[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Default_raw': ' Handlebars[]', 'Default': ' Handlebars[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **alternate Template Languages** -  (optional List of Template Languages).[]
RoundTrip Attribute_Head: input is - '- **alternate Template Languages** -  (optional List of Template Languages).[]'
RoundTrip Attribute_Head: value is - {'name': 'alternate Template Languages', 'one_liner': '', 'parenthetical': 'optional List of Template Languages'}
OK. {'name': 'alternate Template Languages', 'one_liner': '', 'parenthetical': 'optional List of Template Languages'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'alternate Template Languages (optional List of Template Languages)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **alternate Template Languages** -  (optional List of Template Languages).[]
		=parse=> {'name': 'alternate Template Languages', 'one_liner': '', 'parenthetical': 'optional List of Template Languages'} 
		=render=> alternate Template Languages (optional List of Template Languages) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **aiFunctions** - A list of functions that require sophisticated AI-powered implementation *(List of String)*[]
RoundTrip Attribute_Head: input is - '- **aiFunctions** - A list of functions that require sophisticated AI-powered implementation *(List of String)*[]'
RoundTrip Attribute_Head: value is - {'name': 'aiFunctions', 'one_liner': 'A list of functions that require sophisticated AI-powered implementation *', 'parenthetical': 'List of String'}
OK. {'name': 'aiFunctions', 'one_liner': 'A list of functions that require sophisticated AI-powered implementation *', 'parenthetical': 'List of String'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'aiFunctions - A list of functions that require sophisticated AI-powered implementation * (List of String)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **aiFunctions** - A list of functions that require sophisticated AI-powered implementation *(List of String)*[]
		=parse=> {'name': 'aiFunctions', 'one_liner': 'A list of functions that require sophisticated AI-powered implementation *', 'parenthetical': 'List of String'} 
		=render=> aiFunctions - A list of functions that require sophisticated AI-powered implementation * (List of String) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Derivation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DERIVATION: Derivation: ['aiEnglishPlural()']
RoundTrip DERIVATION: input is - ' ['aiEnglishPlural()'][]'
RoundTrip DERIVATION: value is -  ['aiEnglishPlural()'][]
OK.  ['aiEnglishPlural()'][] ok for DERIVATION
RoundTrip DERIVATION: renders as - ' ['aiEnglishPlural()'][]'
RoundTrip DERIVATION: reparses as -  ['aiEnglishPlural()'][]
RoundTrip SUCCESS:  ['aiEnglishPlural()'][]
		=parse=>  ['aiEnglishPlural()'][] 
		=render=>  ['aiEnglishPlural()'][] 
		=parse=>  ['aiEnglishPlural()'][]
adding non raw value. Derivation -.  ['aiEnglishPlural()'][]
{
  "Derivation_raw": " ['aiEnglishPlural()'][]",
  "Derivation": " ['aiEnglishPlural()'][]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Derivation_raw': " ['aiEnglishPlural()'][]", 'Derivation': " ['aiEnglishPlural()'][]"}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  AttributeSection
		Full header is: __***Markdown Support***[]
RoundTrip AttributeSection_Head: input is - '__***Markdown Support***[]'
RoundTrip AttributeSection_Head: value is - {'name': 'Markdown Support[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Markdown Support[]', 'one_liner': '', 'parenthetical': ''} ok for AttributeSection_Head
RoundTrip AttributeSection_Head: renders as - 'Markdown Support[]'
RoundTrip AttributeSection_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: __***Markdown Support***[]
		=parse=> {'name': 'Markdown Support[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Markdown Support[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Attribute
		Full header is: - **mdPrefix** (*[String](#string)*)[]
RoundTrip Attribute_Head: input is - '- **mdPrefix** (*[String](#string)*)[]'
RoundTrip Attribute_Head: value is - {'name': 'mdPrefix', 'one_liner': '', 'parenthetical': '*[String](#string'}
OK. {'name': 'mdPrefix', 'one_liner': '', 'parenthetical': '*[String](#string'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'mdPrefix (*[String](#string)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **mdPrefix** (*[String](#string)*)[]
		=parse=> {'name': 'mdPrefix', 'one_liner': '', 'parenthetical': '*[String](#string'} 
		=render=> mdPrefix (*[String](#string) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Derivation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DERIVATION: ***Derivation***: "# "
RoundTrip DERIVATION: input is - ' "# "[]'
RoundTrip DERIVATION: value is -  "# "[]
OK.  "# "[] ok for DERIVATION
RoundTrip DERIVATION: renders as - ' "# "[]'
RoundTrip DERIVATION: reparses as -  "# "[]
RoundTrip SUCCESS:  "# "[]
		=parse=>  "# "[] 
		=render=>  "# "[] 
		=parse=>  "# "[]
adding non raw value. ***Derivation*** -.  "# "[]
{
  "***Derivation***_raw": " \"# \"[]",
  "***Derivation***": " \"# \"[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Derivation***_raw': ' "# "[]', '***Derivation***': ' "# "[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **mdTopLine** (*[String](#string)*)[]
RoundTrip Attribute_Head: input is - '- **mdTopLine** (*[String](#string)*)[]'
RoundTrip Attribute_Head: value is - {'name': 'mdTopLine', 'one_liner': '', 'parenthetical': '*[String](#string'}
OK. {'name': 'mdTopLine', 'one_liner': '', 'parenthetical': '*[String](#string'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'mdTopLine (*[String](#string)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **mdTopLine** (*[String](#string)*)[]
		=parse=> {'name': 'mdTopLine', 'one_liner': '', 'parenthetical': '*[String](#string'} 
		=render=> mdTopLine (*[String](#string) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Derivation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DERIVATION: ***Derivation***: mdPrefix + name
RoundTrip DERIVATION: input is - ' mdPrefix + name[]'
RoundTrip DERIVATION: value is -  mdPrefix + name[]
OK.  mdPrefix + name[] ok for DERIVATION
RoundTrip DERIVATION: renders as - ' mdPrefix + name[]'
RoundTrip DERIVATION: reparses as -  mdPrefix + name[]
RoundTrip SUCCESS:  mdPrefix + name[]
		=parse=>  mdPrefix + name[] 
		=render=>  mdPrefix + name[] 
		=parse=>  mdPrefix + name[]
adding non raw value. ***Derivation*** -.  mdPrefix + name[]
{
  "***Derivation***_raw": " mdPrefix + name[]",
  "***Derivation***": " mdPrefix + name[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Derivation***_raw': ' mdPrefix + name[]', '***Derivation***': ' mdPrefix + name[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
--- skipping BLANK_LINE
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _Subtype of:_ Component
_ _ BLANK_LINE: 
_ _ BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - name (UpperCamel )
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - allSubjects - list of all classes in the model, as ordered in thedefinition of the model. (List of Classes)
. . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ DERIVATION: Derivation: gathering s.allSubjects over s in subjectAreas
_ _ _ _ BLANK_LINE: 
. . . Constraint - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ CONSTRAINT: ***Constraint***: Subject names must be unique across the model.
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - allClasses - list of all classes in the model, as ordered in the definition of the model. (List of Classes)
. . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ DERIVATION: Derivation: gathering s.allClasses over s in allSubjects.
. . . Constraint - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ CONSTRAINT: ***Constraint***: Class names must be unique across the model.
_ _ _ _ BLANK_LINE: 
. . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ AttributeSection_Head: __ 	***Modeling Configuration***
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **annotationTypes** - (List of AnnotationTypes)
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **Preferred Coding Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Coding Language).
. . . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ DEFAULT: Default: OCL
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **alternate Coding Languages** -  (optional List of Coding Languages).
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **Preferred Template Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Template Language).
. . . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ DEFAULT: Default: Handlebars
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **alternate Template Languages** -  (optional List of Template Languages).
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **aiFunctions** - A list of functions that require sophisticated AI-powered implementation *(List of String)*
. . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ DERIVATION: Derivation: ['aiEnglishPlural()']
_ _ _ _ _ BLANK_LINE: 
. . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ AttributeSection_Head: __***Markdown Support***
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **mdPrefix** (*[String](#string)*)
. . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ DERIVATION: ***Derivation***: "# "
_ _ _ _ _ BLANK_LINE: 
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **mdTopLine** (*[String](#string)*)
. . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ DERIVATION: ***Derivation***: mdPrefix + name
_ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_Subtype of:_ Component[]",
  "name": "Subtype of: Component[]",
  "one_liner": "",
  "parenthetical": "",
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "- name (UpperCamel )[]",
      "name": "name",
      "one_liner": "",
      "parenthetical": "UpperCamel"
    },
    {
      "_type": "Attribute",
      "full_header": "- allSubjects - list of all classes in the model, as ordered in the['definition of the model. (List of Classes)']",
      "name": "allSubjects",
      "one_liner": "list of all classes in the model, as ordered in the['definition of the model.",
      "parenthetical": "List of Classes",
      "Derivation": [
        {
          "_type": "Derivation",
          "Derivation_raw": [
            " gathering s.allSubjects over s in subjectAreas[]"
          ],
          "Derivation": " gathering s.allSubjects over s in subjectAreas[]"
        }
      ],
      "Constraint": [
        {
          "_type": "Constraint",
          "***Constraint***_raw": [
            " Subject names must be unique across the model.[]"
          ],
          "***Constraint***": [
            " ",
            "S",
            "u",
            "b",
            "j",
            "e",
            "c",
            "t",
            " ",
            "n",
            "a",
            "m",
            "e",
            "s",
            " ",
            "m",
            "u",
            "s",
            "t",
            " ",
            "b",
            "e",
            " ",
            "u",
            "n",
            "i",
            "q",
            "u",
            "e",
            " ",
            "a",
            "c",
            "r",
            "o",
            "s",
            "s",
            " ",
            "t",
            "h",
            "e",
            " ",
            "m",
            "o",
            "d",
            "e",
            "l",
            ".",
            "[",
            "]"
          ]
        }
      ]
    },
    {
      "_type": "Attribute",
      "full_header": "- allClasses - list of all classes in the model, as ordered in the definition of the model. (List of Classes)[]",
      "name": "allClasses",
      "one_liner": "list of all classes in the model, as ordered in the definition of the model.",
      "parenthetical": "List of Classes",
      "Derivation": [
        {
          "_type": "Derivation",
          "Derivation_raw": [
            " gathering s.allClasses over s in allSubjects.[]"
          ],
          "Derivation": " gathering s.allClasses over s in allSubjects.[]"
        }
      ],
      "Constraint": [
        {
          "_type": "Constraint",
          "***Constraint***_raw": [
            " Class names must be unique across the model.[]"
          ],
          "***Constraint***": [
            " ",
            "C",
            "l",
            "a",
            "s",
            "s",
            " ",
            "n",
            "a",
            "m",
            "e",
            "s",
            " ",
            "m",
            "u",
            "s",
            "t",
            " ",
            "b",
            "e",
            " ",
            "u",
            "n",
            "i",
            "q",
            "u",
            "e",
            " ",
            "a",
            "c",
            "r",
            "o",
            "s",
            "s",
            " ",
            "t",
            "h",
            "e",
            " ",
            "m",
            "o",
            "d",
            "e",
            "l",
            ".",
            "[",
            "]"
          ]
        }
      ]
    }
  ],
  "AttributeSection": [
    {
      "_type": "AttributeSection",
      "full_header": "__ \t***Modeling Configuration***[]",
      "name": "Modeling Configuration[]",
      "one_liner": "",
      "parenthetical": "",
      "Attribute": [
        {
          "_type": "Attribute",
          "full_header": "- **annotationTypes** - (List of AnnotationTypes)[]",
          "name": "annotationTypes",
          "one_liner": "",
          "parenthetical": "List of AnnotationTypes"
        },
        {
          "_type": "Attribute",
          "full_header": "- **Preferred Coding Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Coding Language).[]",
          "name": "Preferred Coding Language",
          "one_liner": "the recommended lanquage  for expressing derivation, defaults, and constraints",
          "parenthetical": "Coding Language",
          "Default": [
            {
              "_type": "Default",
              "Default_raw": [
                " OCL[]"
              ],
              "Default": " OCL[]"
            }
          ]
        },
        {
          "_type": "Attribute",
          "full_header": "- **alternate Coding Languages** -  (optional List of Coding Languages).[]",
          "name": "alternate Coding Languages",
          "one_liner": "",
          "parenthetical": "optional List of Coding Languages"
        },
        {
          "_type": "Attribute",
          "full_header": "- **Preferred Template Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Template Language).[]",
          "name": "Preferred Template Language",
          "one_liner": "the recommended lanquage  for expressing derivation, defaults, and constraints",
          "parenthetical": "Template Language",
          "Default": [
            {
              "_type": "Default",
              "Default_raw": [
                " Handlebars[]"
              ],
              "Default": " Handlebars[]"
            }
          ]
        },
        {
          "_type": "Attribute",
          "full_header": "- **alternate Template Languages** -  (optional List of Template Languages).[]",
          "name": "alternate Template Languages",
          "one_liner": "",
          "parenthetical": "optional List of Template Languages"
        },
        {
          "_type": "Attribute",
          "full_header": "- **aiFunctions** - A list of functions that require sophisticated AI-powered implementation *(List of String)*[]",
          "name": "aiFunctions",
          "one_liner": "A list of functions that require sophisticated AI-powered implementation *",
          "parenthetical": "List of String",
          "Derivation": [
            {
              "_type": "Derivation",
              "Derivation_raw": [
                " ['aiEnglishPlural()'][]"
              ],
              "Derivation": " ['aiEnglishPlural()'][]"
            }
          ]
        }
      ]
    },
    {
      "_type": "AttributeSection",
      "full_header": "__***Markdown Support***[]",
      "name": "Markdown Support[]",
      "one_liner": "",
      "parenthetical": "",
      "Attribute": [
        {
          "_type": "Attribute",
          "full_header": "- **mdPrefix** (*[String](#string)*)[]",
          "name": "mdPrefix",
          "one_liner": "",
          "parenthetical": "*[String](#string",
          "Derivation": [
            {
              "_type": "Derivation",
              "***Derivation***_raw": [
                " \"# \"[]"
              ],
              "***Derivation***": " \"# \"[]"
            }
          ]
        },
        {
          "_type": "Attribute",
          "full_header": "- **mdTopLine** (*[String](#string)*)[]",
          "name": "mdTopLine",
          "one_liner": "",
          "parenthetical": "*[String](#string",
          "Derivation": [
            {
              "_type": "Derivation",
              "***Derivation***_raw": [
                " mdPrefix + name[]"
              ],
              "***Derivation***": " mdPrefix + name[]"
            }
          ]
        }
      ]
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ **Subject**['A specific topic or theme within the model']
RoundTrip Class_Head: input is - '_ **Subject**['A specific topic or theme within the model']'
RoundTrip Class_Head: value is - {'name': "Subject['A specific topic or theme within the model']", 'one_liner': '', 'parenthetical': ''}
OK. {'name': "Subject['A specific topic or theme within the model']", 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Subject['A specific topic or theme within the model']'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **Subject**['A specific topic or theme within the model']
		=parse=> {'name': "Subject['A specific topic or theme within the model']", 'one_liner': '', 'parenthetical': ''} 
		=render=> Subject['A specific topic or theme within the model'] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for PLURAL: _Plural:_ Subjects
RoundTrip PLURAL: input is - '_ Subjects[]'
RoundTrip PLURAL: value is - _ Subjects[]
OK. _ Subjects[] ok for PLURAL
RoundTrip PLURAL: renders as - '_ Subjects[]'
RoundTrip PLURAL: reparses as - _ Subjects[]
RoundTrip SUCCESS: _ Subjects[]
		=parse=> _ Subjects[] 
		=render=> _ Subjects[] 
		=parse=> _ Subjects[]
adding non raw value. _Plural -. _ Subjects[]
{
  "_Plural_raw": "_ Subjects[]",
  "_Plural": "_ Subjects[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'_Plural_raw': '_ Subjects[]', '_Plural': '_ Subjects[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **Subject**A specific topic or theme within the model
_ _ PLURAL: _Plural:_ Subjects
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **Subject**['A specific topic or theme within the model']",
  "name": "Subject['A specific topic or theme within the model']",
  "one_liner": "",
  "parenthetical": "",
  "_Plural_raw": [
    "_ Subjects[]"
  ],
  "_Plural": "_ Subjects[]"
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _Subtype of:_ Component[]
RoundTrip Class_Head: input is - '_Subtype of:_ Component[]'
RoundTrip Class_Head: value is - {'name': 'Subtype of: Component[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Subtype of: Component[]', 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Subtype of: Component[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _Subtype of:_ Component[]
		=parse=> {'name': 'Subtype of: Component[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Subtype of: Component[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DEPENDENT_OF: Dependent of: LiterateDataModel
RoundTrip DEPENDENT_OF: input is - ' LiterateDataModel[]'
parse_name_list:  LiterateDataModel[]
RoundTrip DEPENDENT_OF: value is - ['LiterateDataModel[]']
validating name list:  ['LiterateDataModel[]']
OK. ['LiterateDataModel[]'] ok for DEPENDENT_OF
RoundTrip DEPENDENT_OF: renders as - 'LiterateDataModel[]'
parse_name_list: LiterateDataModel[]
RoundTrip DEPENDENT_OF: reparses as - ['LiterateDataModel[]']
RoundTrip SUCCESS:  LiterateDataModel[]
		=parse=> ['LiterateDataModel[]'] 
		=render=> LiterateDataModel[] 
		=parse=> ['LiterateDataModel[]']
adding non raw value. Dependent of -. ['LiterateDataModel[]']
{
  "Dependent of_raw": " LiterateDataModel[]",
  "Dependent of": [
    "LiterateDataModel[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Dependent of_raw': ' LiterateDataModel[]', 'Dependent of': ['LiterateDataModel[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
--- adding TEXT para
--- adding TEXT para
--- skipping BLANK_LINE
DerivingDict for Part:  Attribute
		Full header is: - name (UpperCamel )[]
RoundTrip Attribute_Head: input is - '- name (UpperCamel )[]'
RoundTrip Attribute_Head: value is - {'name': 'name', 'one_liner': '', 'parenthetical': 'UpperCamel'}
OK. {'name': 'name', 'one_liner': '', 'parenthetical': 'UpperCamel'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'name (UpperCamel)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - name (UpperCamel )[]
		=parse=> {'name': 'name', 'one_liner': '', 'parenthetical': 'UpperCamel'} 
		=render=> name (UpperCamel) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **parentSubject** - The parent subject, if any, under which this subject is nested _(Subject, optional)_[]
RoundTrip Attribute_Head: input is - '- **parentSubject** - The parent subject, if any, under which this subject is nested _(Subject, optional)_[]'
RoundTrip Attribute_Head: value is - {'name': 'parentSubject', 'one_liner': 'The parent subject, if any, under which this subject is nested _', 'parenthetical': 'Subject, optional'}
OK. {'name': 'parentSubject', 'one_liner': 'The parent subject, if any, under which this subject is nested _', 'parenthetical': 'Subject, optional'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'parentSubject - The parent subject, if any, under which this subject is nested _ (Subject, optional)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **parentSubject** - The parent subject, if any, under which this subject is nested _(Subject, optional)_[]
		=parse=> {'name': 'parentSubject', 'one_liner': 'The parent subject, if any, under which this subject is nested _', 'parenthetical': 'Subject, optional'} 
		=render=> parentSubject - The parent subject, if any, under which this subject is nested _ (Subject, optional) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **Classes** - The major classes related to this subject, in the order in which they should be presented _(ListOf Classes)_[]
RoundTrip Attribute_Head: input is - '- **Classes** - The major classes related to this subject, in the order in which they should be presented _(ListOf Classes)_[]'
RoundTrip Attribute_Head: value is - {'name': 'Classes', 'one_liner': 'The major classes related to this subject, in the order in which they should be presented _', 'parenthetical': 'ListOf Classes'}
OK. {'name': 'Classes', 'one_liner': 'The major classes related to this subject, in the order in which they should be presented _', 'parenthetical': 'ListOf Classes'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'Classes - The major classes related to this subject, in the order in which they should be presented _ (ListOf Classes)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **Classes** - The major classes related to this subject, in the order in which they should be presented _(ListOf Classes)_[]
		=parse=> {'name': 'Classes', 'one_liner': 'The major classes related to this subject, in the order in which they should be presented _', 'parenthetical': 'ListOf Classes'} 
		=render=> Classes - The major classes related to this subject, in the order in which they should be presented _ (ListOf Classes) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for ISSUE: ***Issue***: define chapter, section, subsection as levels?***DSL***: Generally, it is best to present the classes within a Subject in top down order:
RoundTrip ISSUE: input is - ' define chapter, section, subsection as levels?['***DSL***: Generally, it is best to present the classes within a Subject in top down order:']'
RoundTrip ISSUE: value is -  define chapter, section, subsection as levels?['***DSL***: Generally, it is best to present the classes within a Subject in top down order:']
OK.  define chapter, section, subsection as levels?['***DSL***: Generally, it is best to present the classes within a Subject in top down order:'] ok for ISSUE
RoundTrip ISSUE: renders as - ' define chapter, section, subsection as levels?['***DSL***: Generally, it is best to present the classes within a Subject in top down order:']'
RoundTrip ISSUE: reparses as -  define chapter, section, subsection as levels?['***DSL***: Generally, it is best to present the classes within a Subject in top down order:']
RoundTrip SUCCESS:  define chapter, section, subsection as levels?['***DSL***: Generally, it is best to present the classes within a Subject in top down order:']
		=parse=>  define chapter, section, subsection as levels?['***DSL***: Generally, it is best to present the classes within a Subject in top down order:'] 
		=render=>  define chapter, section, subsection as levels?['***DSL***: Generally, it is best to present the classes within a Subject in top down order:'] 
		=parse=>  define chapter, section, subsection as levels?['***DSL***: Generally, it is best to present the classes within a Subject in top down order:']
adding non raw value. ***Issue*** -.  define chapter, section, subsection as levels?['***DSL***: Generally, it is best to present the classes within a Subject in top down order:']
{
  "***Issue***_raw": " define chapter, section, subsection as levels?['***DSL***: Generally, it is best to present the classes within a Subject in top down order:']",
  "***Issue***": " define chapter, section, subsection as levels?['***DSL***: Generally, it is best to present the classes within a Subject in top down order:']"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Issue***_raw': " define chapter, section, subsection as levels?['***DSL***: Generally, it is best to present the classes within a Subject in top down order:']", '***Issue***': " define chapter, section, subsection as levels?['***DSL***: Generally, it is best to present the classes within a Subject in top down order:']"}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - Each Class should be followed first by the classes that are dependent on it, and then[]
RoundTrip Attribute_Head: input is - '- Each Class should be followed first by the classes that are dependent on it, and then[]'
RoundTrip Attribute_Head: value is - {'name': 'Each Class should be followed first by the classes that are dependent on it, and then[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Each Class should be followed first by the classes that are dependent on it, and then[]', 'one_liner': '', 'parenthetical': ''} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'Each Class should be followed first by the classes that are dependent on it, and then[]'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - Each Class should be followed first by the classes that are dependent on it, and then[]
		=parse=> {'name': 'Each Class should be followed first by the classes that are dependent on it, and then[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Each Class should be followed first by the classes that are dependent on it, and then[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - By its subtype classes.[]
RoundTrip Attribute_Head: input is - '- By its subtype classes.[]'
RoundTrip Attribute_Head: value is - {'name': 'By its subtype classes.[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'By its subtype classes.[]', 'one_liner': '', 'parenthetical': ''} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'By its subtype classes.[]'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - By its subtype classes.[]
		=parse=> {'name': 'By its subtype classes.[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> By its subtype classes.[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **childSubjects** - Any child subjects nested under this subject, in the order in which they should be presented _(ListOf Subjects)_[]
RoundTrip Attribute_Head: input is - '- **childSubjects** - Any child subjects nested under this subject, in the order in which they should be presented _(ListOf Subjects)_[]'
RoundTrip Attribute_Head: value is - {'name': 'childSubjects', 'one_liner': 'Any child subjects nested under this subject, in the order in which they should be presented _', 'parenthetical': 'ListOf Subjects'}
OK. {'name': 'childSubjects', 'one_liner': 'Any child subjects nested under this subject, in the order in which they should be presented _', 'parenthetical': 'ListOf Subjects'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'childSubjects - Any child subjects nested under this subject, in the order in which they should be presented _ (ListOf Subjects)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **childSubjects** - Any child subjects nested under this subject, in the order in which they should be presented _(ListOf Subjects)_[]
		=parse=> {'name': 'childSubjects', 'one_liner': 'Any child subjects nested under this subject, in the order in which they should be presented _', 'parenthetical': 'ListOf Subjects'} 
		=render=> childSubjects - Any child subjects nested under this subject, in the order in which they should be presented _ (ListOf Subjects) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for INVERSE: inverse of: Subject.parentSubject.
RoundTrip INVERSE: input is - ' Subject.parentSubject.[]'
RoundTrip INVERSE: value is - {'class_name': 'Subject', 'attribute_name': 'parentSubject.[]'}
OK. {'class_name': 'Subject', 'attribute_name': 'parentSubject.[]'} ok for INVERSE
RoundTrip INVERSE: renders as - 'Subject.parentSubject.[]'
RoundTrip INVERSE: reparses as - {'class_name': 'Subject', 'attribute_name': 'parentSubject.[]'}
RoundTrip SUCCESS:  Subject.parentSubject.[]
		=parse=> {'class_name': 'Subject', 'attribute_name': 'parentSubject.[]'} 
		=render=> Subject.parentSubject.[] 
		=parse=> {'class_name': 'Subject', 'attribute_name': 'parentSubject.[]'}
adding non raw value. inverse of -. {'class_name': 'Subject', 'attribute_name': 'parentSubject.[]'}
{
  "inverse of_raw": " Subject.parentSubject.[]",
  "inverse of": {
    "class_name": "Subject",
    "attribute_name": "parentSubject.[]"
  }
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'inverse of_raw': ' Subject.parentSubject.[]', 'inverse of': {'class_name': 'Subject', 'attribute_name': 'parentSubject.[]'}}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
--- skipping BLANK_LINE
--- adding TEXT para
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
DerivingDict for Part:  AttributeSection
		Full header is: __***Markdown Support***[]
RoundTrip AttributeSection_Head: input is - '__***Markdown Support***[]'
RoundTrip AttributeSection_Head: value is - {'name': 'Markdown Support[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Markdown Support[]', 'one_liner': '', 'parenthetical': ''} ok for AttributeSection_Head
RoundTrip AttributeSection_Head: renders as - 'Markdown Support[]'
RoundTrip AttributeSection_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: __***Markdown Support***[]
		=parse=> {'name': 'Markdown Support[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Markdown Support[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Attribute
		Full header is: - **mdPrefix** (*[String](#string)*)[]
RoundTrip Attribute_Head: input is - '- **mdPrefix** (*[String](#string)*)[]'
RoundTrip Attribute_Head: value is - {'name': 'mdPrefix', 'one_liner': '', 'parenthetical': '*[String](#string'}
OK. {'name': 'mdPrefix', 'one_liner': '', 'parenthetical': '*[String](#string'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'mdPrefix (*[String](#string)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **mdPrefix** (*[String](#string)*)[]
		=parse=> {'name': 'mdPrefix', 'one_liner': '', 'parenthetical': '*[String](#string'} 
		=render=> mdPrefix (*[String](#string) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Derivation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DERIVATION: ***Derivation***: levelIndicator + " "
RoundTrip DERIVATION: input is - ' levelIndicator + " "[]'
RoundTrip DERIVATION: value is -  levelIndicator + " "[]
OK.  levelIndicator + " "[] ok for DERIVATION
RoundTrip DERIVATION: renders as - ' levelIndicator + " "[]'
RoundTrip DERIVATION: reparses as -  levelIndicator + " "[]
RoundTrip SUCCESS:  levelIndicator + " "[]
		=parse=>  levelIndicator + " "[] 
		=render=>  levelIndicator + " "[] 
		=parse=>  levelIndicator + " "[]
adding non raw value. ***Derivation*** -.  levelIndicator + " "[]
{
  "***Derivation***_raw": " levelIndicator + \" \"[]",
  "***Derivation***": " levelIndicator + \" \"[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Derivation***_raw': ' levelIndicator + " "[]', '***Derivation***': ' levelIndicator + " "[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **mdTopLine** (*[String](#string)*)[]
RoundTrip Attribute_Head: input is - '- **mdTopLine** (*[String](#string)*)[]'
RoundTrip Attribute_Head: value is - {'name': 'mdTopLine', 'one_liner': '', 'parenthetical': '*[String](#string'}
OK. {'name': 'mdTopLine', 'one_liner': '', 'parenthetical': '*[String](#string'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'mdTopLine (*[String](#string)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **mdTopLine** (*[String](#string)*)[]
		=parse=> {'name': 'mdTopLine', 'one_liner': '', 'parenthetical': '*[String](#string'} 
		=render=> mdTopLine (*[String](#string) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Derivation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DERIVATION: ***Derivation***: mdPrefix + name.
RoundTrip DERIVATION: input is - ' mdPrefix + name.[]'
RoundTrip DERIVATION: value is -  mdPrefix + name.[]
OK.  mdPrefix + name.[] ok for DERIVATION
RoundTrip DERIVATION: renders as - ' mdPrefix + name.[]'
RoundTrip DERIVATION: reparses as -  mdPrefix + name.[]
RoundTrip SUCCESS:  mdPrefix + name.[]
		=parse=>  mdPrefix + name.[] 
		=render=>  mdPrefix + name.[] 
		=parse=>  mdPrefix + name.[]
adding non raw value. ***Derivation*** -.  mdPrefix + name.[]
{
  "***Derivation***_raw": " mdPrefix + name.[]",
  "***Derivation***": " mdPrefix + name.[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Derivation***_raw': ' mdPrefix + name.[]', '***Derivation***': ' mdPrefix + name.[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _Subtype of:_ Component
_ _ DEPENDENT_OF: Dependent of: LiterateDataModel
_ _ BLANK_LINE: 
_ _ TEXT_LINE: Subjects are the chapters an sections of the model.
_ _ TEXT_LINE: A subject need not contain any Classes if its just expository.
_ _ BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - name (UpperCamel )
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **parentSubject** - The parent subject, if any, under which this subject is nested _(Subject, optional)_
_ _ _ BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **Classes** - The major classes related to this subject, in the order in which they should be presented _(ListOf Classes)_
. . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ ISSUE: ***Issue***: define chapter, section, subsection as levels?***DSL***: Generally, it is best to present the classes within a Subject in top down order:
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - Each Class should be followed first by the classes that are dependent on it, and then
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - By its subtype classes.
_ _ _ BLANK_LINE: 
_ _ _ BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **childSubjects** - Any child subjects nested under this subject, in the order in which they should be presented _(ListOf Subjects)_
_ _ _ INVERSE: inverse of: Subject.parentSubject.
_ _ _ BLANK_LINE: 
_ _ _ TEXT_LINE: ***DSL***:  the Classes within a Subject are always displayed before the childSubjects.
_ _ _ BLANK_LINE: 
. . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ AttributeSection_Head: __***Markdown Support***
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **mdPrefix** (*[String](#string)*)
. . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ DERIVATION: ***Derivation***: levelIndicator + " "
_ _ _ _ _ BLANK_LINE: 
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **mdTopLine** (*[String](#string)*)
. . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ DERIVATION: ***Derivation***: mdPrefix + name.
_ _ _ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_Subtype of:_ Component[]",
  "name": "Subtype of: Component[]",
  "one_liner": "",
  "parenthetical": "",
  "Dependent of_raw": [
    " LiterateDataModel[]"
  ],
  "Dependent of": [
    "LiterateDataModel[]"
  ],
  "elaboration": [
    {
      "type_label": "TEXT_LINE",
      "content": "Subjects are the chapters an sections of the model."
    },
    {
      "type_label": "TEXT_LINE",
      "content": "A subject need not contain any Classes if it\u2019s just expository."
    }
  ],
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "- name (UpperCamel )[]",
      "name": "name",
      "one_liner": "",
      "parenthetical": "UpperCamel"
    },
    {
      "_type": "Attribute",
      "full_header": "- **parentSubject** - The parent subject, if any, under which this subject is nested _(Subject, optional)_[]",
      "name": "parentSubject",
      "one_liner": "The parent subject, if any, under which this subject is nested _",
      "parenthetical": "Subject, optional"
    },
    {
      "_type": "Attribute",
      "full_header": "- **Classes** - The major classes related to this subject, in the order in which they should be presented _(ListOf Classes)_[]",
      "name": "Classes",
      "one_liner": "The major classes related to this subject, in the order in which they should be presented _",
      "parenthetical": "ListOf Classes",
      "Annotation": [
        {
          "_type": "Annotation",
          "***Issue***_raw": [
            " define chapter, section, subsection as levels?['***DSL***: Generally, it is best to present the classes within a Subject in top down order:']"
          ],
          "***Issue***": [
            " define chapter, section, subsection as levels?['***DSL***: Generally, it is best to present the classes within a Subject in top down order:']"
          ]
        }
      ]
    },
    {
      "_type": "Attribute",
      "full_header": "- Each Class should be followed first by the classes that are dependent on it, and then[]",
      "name": "Each Class should be followed first by the classes that are dependent on it, and then[]",
      "one_liner": "",
      "parenthetical": ""
    },
    {
      "_type": "Attribute",
      "full_header": "- By its subtype classes.[]",
      "name": "By its subtype classes.[]",
      "one_liner": "",
      "parenthetical": ""
    },
    {
      "_type": "Attribute",
      "full_header": "- **childSubjects** - Any child subjects nested under this subject, in the order in which they should be presented _(ListOf Subjects)_[]",
      "name": "childSubjects",
      "one_liner": "Any child subjects nested under this subject, in the order in which they should be presented _",
      "parenthetical": "ListOf Subjects",
      "inverse of_raw": [
        " Subject.parentSubject.[]"
      ],
      "inverse of": {
        "class_name": "Subject",
        "attribute_name": "parentSubject.[]"
      }
    }
  ],
  "AttributeSection": [
    {
      "_type": "AttributeSection",
      "full_header": "__***Markdown Support***[]",
      "name": "Markdown Support[]",
      "one_liner": "",
      "parenthetical": "",
      "Attribute": [
        {
          "_type": "Attribute",
          "full_header": "- **mdPrefix** (*[String](#string)*)[]",
          "name": "mdPrefix",
          "one_liner": "",
          "parenthetical": "*[String](#string",
          "Derivation": [
            {
              "_type": "Derivation",
              "***Derivation***_raw": [
                " levelIndicator + \" \"[]"
              ],
              "***Derivation***": " levelIndicator + \" \"[]"
            }
          ]
        },
        {
          "_type": "Attribute",
          "full_header": "- **mdTopLine** (*[String](#string)*)[]",
          "name": "mdTopLine",
          "one_liner": "",
          "parenthetical": "*[String](#string",
          "Derivation": [
            {
              "_type": "Derivation",
              "***Derivation***_raw": [
                " mdPrefix + name.[]"
              ],
              "***Derivation***": " mdPrefix + name.[]"
            }
          ]
        }
      ]
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ **SubjectArea**['A main topic or area of focus within the model, containing related subjects and classes']
RoundTrip Class_Head: input is - '_ **SubjectArea**['A main topic or area of focus within the model, containing related subjects and classes']'
RoundTrip Class_Head: value is - {'name': "SubjectArea['A main topic or area of focus within the model, containing related subjects and classes']", 'one_liner': '', 'parenthetical': ''}
OK. {'name': "SubjectArea['A main topic or area of focus within the model, containing related subjects and classes']", 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'SubjectArea['A main topic or area of focus within the model, containing related subjects and classes']'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **SubjectArea**['A main topic or area of focus within the model, containing related subjects and classes']
		=parse=> {'name': "SubjectArea['A main topic or area of focus within the model, containing related subjects and classes']", 'one_liner': '', 'parenthetical': ''} 
		=render=> SubjectArea['A main topic or area of focus within the model, containing related subjects and classes'] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for PLURAL: _Plural:_ SubjectAreas
RoundTrip PLURAL: input is - '_ SubjectAreas[]'
RoundTrip PLURAL: value is - _ SubjectAreas[]
OK. _ SubjectAreas[] ok for PLURAL
RoundTrip PLURAL: renders as - '_ SubjectAreas[]'
RoundTrip PLURAL: reparses as - _ SubjectAreas[]
RoundTrip SUCCESS: _ SubjectAreas[]
		=parse=> _ SubjectAreas[] 
		=render=> _ SubjectAreas[] 
		=parse=> _ SubjectAreas[]
adding non raw value. _Plural -. _ SubjectAreas[]
{
  "_Plural_raw": "_ SubjectAreas[]",
  "_Plural": "_ SubjectAreas[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'_Plural_raw': '_ SubjectAreas[]', '_Plural': '_ SubjectAreas[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **SubjectArea**A main topic or area of focus within the model, containing related subjects and classes
_ _ PLURAL: _Plural:_ SubjectAreas
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **SubjectArea**['A main topic or area of focus within the model, containing related subjects and classes']",
  "name": "SubjectArea['A main topic or area of focus within the model, containing related subjects and classes']",
  "one_liner": "",
  "parenthetical": "",
  "_Plural_raw": [
    "_ SubjectAreas[]"
  ],
  "_Plural": "_ SubjectAreas[]"
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _Subtype of:_ Subject[]
RoundTrip Class_Head: input is - '_Subtype of:_ Subject[]'
RoundTrip Class_Head: value is - {'name': 'Subtype of: Subject[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Subtype of: Subject[]', 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Subtype of: Subject[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _Subtype of:_ Subject[]
		=parse=> {'name': 'Subtype of: Subject[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Subtype of: Subject[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _Subtype of:_ Subject
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_Subtype of:_ Subject[]",
  "name": "Subtype of: Subject[]",
  "one_liner": "",
  "parenthetical": ""
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _Where:_ parentSubject is absent[]
RoundTrip Class_Head: input is - '_Where:_ parentSubject is absent[]'
RoundTrip Class_Head: value is - {'name': 'Where: parentSubject is absent[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Where: parentSubject is absent[]', 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Where: parentSubject is absent[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _Where:_ parentSubject is absent[]
		=parse=> {'name': 'Where: parentSubject is absent[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Where: parentSubject is absent[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- skipping BLANK_LINE
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _Where:_ parentSubject is absent
_ _ BLANK_LINE: 
_ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_Where:_ parentSubject is absent[]",
  "name": "Where: parentSubject is absent[]",
  "one_liner": "",
  "parenthetical": ""
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Section3
		Full header is: ### Classes[]
RoundTrip Section3_Head: input is - '### Classes[]'
RoundTrip Section3_Head: value is - {'name': 'Classes[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Classes[]', 'one_liner': '', 'parenthetical': ''} ok for Section3_Head
RoundTrip Section3_Head: renders as - 'Classes[]'
RoundTrip Section3_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: ### Classes[]
		=parse=> {'name': 'Classes[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Classes[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- skipping BLANK_LINE
DerivingDict for Part:  Class
		Full header is: _ **Class** - A key entity or object type in the model, often corresponding to a real-world concept[]
RoundTrip Class_Head: input is - '_ **Class** - A key entity or object type in the model, often corresponding to a real-world concept[]'
RoundTrip Class_Head: value is - {'name': 'Class', 'one_liner': 'A key entity or object type in the model, often corresponding to a real-world concept[]', 'parenthetical': ''}
OK. {'name': 'Class', 'one_liner': 'A key entity or object type in the model, often corresponding to a real-world concept[]', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Class - A key entity or object type in the model, often corresponding to a real-world concept[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **Class** - A key entity or object type in the model, often corresponding to a real-world concept[]
		=parse=> {'name': 'Class', 'one_liner': 'A key entity or object type in the model, often corresponding to a real-world concept[]', 'parenthetical': ''} 
		=render=> Class - A key entity or object type in the model, often corresponding to a real-world concept[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for PLURAL: _Plural:_ Classes
RoundTrip PLURAL: input is - '_ Classes[]'
RoundTrip PLURAL: value is - _ Classes[]
OK. _ Classes[] ok for PLURAL
RoundTrip PLURAL: renders as - '_ Classes[]'
RoundTrip PLURAL: reparses as - _ Classes[]
RoundTrip SUCCESS: _ Classes[]
		=parse=> _ Classes[] 
		=render=> _ Classes[] 
		=parse=> _ Classes[]
adding non raw value. _Plural -. _ Classes[]
{
  "_Plural_raw": "_ Classes[]",
  "_Plural": "_ Classes[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'_Plural_raw': '_ Classes[]', '_Plural': '_ Classes[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **Class** - A key entity or object type in the model, often corresponding to a real-world concept
_ _ BLANK_LINE: 
_ _ PLURAL: _Plural:_ Classes
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **Class** - A key entity or object type in the model, often corresponding to a real-world concept[]",
  "name": "Class",
  "one_liner": "A key entity or object type in the model, often corresponding to a real-world concept[]",
  "parenthetical": "",
  "_Plural_raw": [
    "_ Classes[]"
  ],
  "_Plural": "_ Classes[]"
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _Subtype of:_ Component[]
RoundTrip Class_Head: input is - '_Subtype of:_ Component[]'
RoundTrip Class_Head: value is - {'name': 'Subtype of: Component[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Subtype of: Component[]', 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Subtype of: Component[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _Subtype of:_ Component[]
		=parse=> {'name': 'Subtype of: Component[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Subtype of: Component[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Constraint
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for CONSTRAINT: ***Constraint***: Within each Class, attribute names must be unique.
RoundTrip CONSTRAINT: input is - ' Within each Class, attribute names must be unique.[]'
RoundTrip CONSTRAINT: value is -  Within each Class, attribute names must be unique.[]
OK.  Within each Class, attribute names must be unique.[] ok for CONSTRAINT
RoundTrip CONSTRAINT: renders as - ' Within each Class, attribute names must be unique.[]'
RoundTrip CONSTRAINT: reparses as -  Within each Class, attribute names must be unique.[]
RoundTrip SUCCESS:  Within each Class, attribute names must be unique.[]
		=parse=>  Within each Class, attribute names must be unique.[] 
		=render=>  Within each Class, attribute names must be unique.[] 
		=parse=>  Within each Class, attribute names must be unique.[]
adding non raw value. ***Constraint*** -.  Within each Class, attribute names must be unique.[]
{
  "***Constraint***_raw": " Within each Class, attribute names must be unique.[]",
  "***Constraint***": " Within each Class, attribute names must be unique.[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Constraint***_raw': ' Within each Class, attribute names must be unique.[]', '***Constraint***': ' Within each Class, attribute names must be unique.[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **pluralForm** - the normal English plural form of the name of the Class (UpperName)[]
RoundTrip Attribute_Head: input is - '- **pluralForm** - the normal English plural form of the name of the Class (UpperName)[]'
RoundTrip Attribute_Head: value is - {'name': 'pluralForm', 'one_liner': 'the normal English plural form of the name of the Class', 'parenthetical': 'UpperName'}
OK. {'name': 'pluralForm', 'one_liner': 'the normal English plural form of the name of the Class', 'parenthetical': 'UpperName'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'pluralForm - the normal English plural form of the name of the Class (UpperName)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **pluralForm** - the normal English plural form of the name of the Class (UpperName)[]
		=parse=> {'name': 'pluralForm', 'one_liner': 'the normal English plural form of the name of the Class', 'parenthetical': 'UpperName'} 
		=render=> pluralForm - the normal English plural form of the name of the Class (UpperName) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- adding TEXT para
--- adding TEXT para
--- skipping BLANK_LINE
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for NOTE: Note: When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.
RoundTrip NOTE: input is - ' When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.[]'
RoundTrip NOTE: value is -  When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.[]
OK.  When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.[] ok for NOTE
RoundTrip NOTE: renders as - ' When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.[]'
RoundTrip NOTE: reparses as -  When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.[]
RoundTrip SUCCESS:  When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.[]
		=parse=>  When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.[] 
		=render=>  When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.[] 
		=parse=>  When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.[]
adding non raw value. Note -.  When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.[]
{
  "Note_raw": " When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.[]",
  "Note": " When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Note_raw': ' When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.[]', 'Note': ' When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
--- adding TEXT para
	Either is_list or is_cum; create list value
DerivingDict for Part:  Default
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DEFAULT: ***Default***: the regular plural, formed by adding "s" or "es".
RoundTrip DEFAULT: input is - ' the regular plural, formed by adding "s" or "es".[]'
RoundTrip DEFAULT: value is -  the regular plural, formed by adding "s" or "es".[]
OK.  the regular plural, formed by adding "s" or "es".[] ok for DEFAULT
RoundTrip DEFAULT: renders as - ' the regular plural, formed by adding "s" or "es".[]'
RoundTrip DEFAULT: reparses as -  the regular plural, formed by adding "s" or "es".[]
RoundTrip SUCCESS:  the regular plural, formed by adding "s" or "es".[]
		=parse=>  the regular plural, formed by adding "s" or "es".[] 
		=render=>  the regular plural, formed by adding "s" or "es".[] 
		=parse=>  the regular plural, formed by adding "s" or "es".[]
adding non raw value. ***Default*** -.  the regular plural, formed by adding "s" or "es".[]
{
  "***Default***_raw": " the regular plural, formed by adding \"s\" or \"es\".[]",
  "***Default***": " the regular plural, formed by adding \"s\" or \"es\".[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Default***_raw': ' the regular plural, formed by adding "s" or "es".[]', '***Default***': ' the regular plural, formed by adding "s" or "es".[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **basedOn** - the Class or Classes on which this class is dependent (SetOf Classes).[]
RoundTrip Attribute_Head: input is - '- **basedOn** - the Class or Classes on which this class is dependent (SetOf Classes).[]'
RoundTrip Attribute_Head: value is - {'name': 'basedOn', 'one_liner': 'the Class or Classes on which this class is dependent', 'parenthetical': 'SetOf Classes'}
OK. {'name': 'basedOn', 'one_liner': 'the Class or Classes on which this class is dependent', 'parenthetical': 'SetOf Classes'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'basedOn - the Class or Classes on which this class is dependent (SetOf Classes)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **basedOn** - the Class or Classes on which this class is dependent (SetOf Classes).[]
		=parse=> {'name': 'basedOn', 'one_liner': 'the Class or Classes on which this class is dependent', 'parenthetical': 'SetOf Classes'} 
		=render=> basedOn - the Class or Classes on which this class is dependent (SetOf Classes) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- skipping BLANK_LINE
--- adding TEXT para
--- skipping BLANK_LINE
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for NOTE: Note: basedOn and dependentOf are being used synonymousle in this metamodel.
RoundTrip NOTE: input is - ' basedOn and dependentOf are being used synonymousle in this metamodel.[]'
RoundTrip NOTE: value is -  basedOn and dependentOf are being used synonymousle in this metamodel.[]
OK.  basedOn and dependentOf are being used synonymousle in this metamodel.[] ok for NOTE
RoundTrip NOTE: renders as - ' basedOn and dependentOf are being used synonymousle in this metamodel.[]'
RoundTrip NOTE: reparses as -  basedOn and dependentOf are being used synonymousle in this metamodel.[]
RoundTrip SUCCESS:  basedOn and dependentOf are being used synonymousle in this metamodel.[]
		=parse=>  basedOn and dependentOf are being used synonymousle in this metamodel.[] 
		=render=>  basedOn and dependentOf are being used synonymousle in this metamodel.[] 
		=parse=>  basedOn and dependentOf are being used synonymousle in this metamodel.[]
adding non raw value. Note -.  basedOn and dependentOf are being used synonymousle in this metamodel.[]
{
  "Note_raw": " basedOn and dependentOf are being used synonymousle in this metamodel.[]",
  "Note": " basedOn and dependentOf are being used synonymousle in this metamodel.[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Note_raw': ' basedOn and dependentOf are being used synonymousle in this metamodel.[]', 'Note': ' basedOn and dependentOf are being used synonymousle in this metamodel.[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for ISSUE: issue: fix that
RoundTrip ISSUE: input is - ' fix that[]'
RoundTrip ISSUE: value is -  fix that[]
OK.  fix that[] ok for ISSUE
RoundTrip ISSUE: renders as - ' fix that[]'
RoundTrip ISSUE: reparses as -  fix that[]
RoundTrip SUCCESS:  fix that[]
		=parse=>  fix that[] 
		=render=>  fix that[] 
		=parse=>  fix that[]
adding non raw value. issue -.  fix that[]
{
  "issue_raw": " fix that[]",
  "issue": " fix that[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'issue_raw': ' fix that[]', 'issue': ' fix that[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **supertypes** - The parent class(es) from which this class inherits attributes _(ListOf Classes)_[]
RoundTrip Attribute_Head: input is - '- **supertypes** - The parent class(es) from which this class inherits attributes _(ListOf Classes)_[]'
RoundTrip Attribute_Head: value is - {'name': 'supertypes', 'one_liner': 'The parent class', 'parenthetical': 'es'}
OK. {'name': 'supertypes', 'one_liner': 'The parent class', 'parenthetical': 'es'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'supertypes - The parent class (es)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **supertypes** - The parent class(es) from which this class inherits attributes _(ListOf Classes)_[]
		=parse=> {'name': 'supertypes', 'one_liner': 'The parent class', 'parenthetical': 'es'} 
		=render=> supertypes - The parent class (es) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **subtypings** - the criteria, or dimensions, by which the class can be divided into subtypes (list of Subtypings).[]
RoundTrip Attribute_Head: input is - '- **subtypings** - the criteria, or dimensions, by which the class can be divided into subtypes (list of Subtypings).[]'
RoundTrip Attribute_Head: value is - {'name': 'subtypings', 'one_liner': 'the criteria, or dimensions, by which the class can be divided into subtypes', 'parenthetical': 'list of Subtypings'}
OK. {'name': 'subtypings', 'one_liner': 'the criteria, or dimensions, by which the class can be divided into subtypes', 'parenthetical': 'list of Subtypings'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'subtypings - the criteria, or dimensions, by which the class can be divided into subtypes (list of Subtypings)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **subtypings** - the criteria, or dimensions, by which the class can be divided into subtypes (list of Subtypings).[]
		=parse=> {'name': 'subtypings', 'one_liner': 'the criteria, or dimensions, by which the class can be divided into subtypes', 'parenthetical': 'list of Subtypings'} 
		=render=> subtypings - the criteria, or dimensions, by which the class can be divided into subtypes (list of Subtypings) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for EXAMPLE: Example: in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).
RoundTrip EXAMPLE: input is - ' in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).[]'
RoundTrip EXAMPLE: value is -  in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).[]
OK.  in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).[] ok for EXAMPLE
RoundTrip EXAMPLE: renders as - ' in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).[]'
RoundTrip EXAMPLE: reparses as -  in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).[]
RoundTrip SUCCESS:  in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).[]
		=parse=>  in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).[] 
		=render=>  in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).[] 
		=parse=>  in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).[]
adding non raw value. Example -.  in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).[]
{
  "Example_raw": " in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).[]",
  "Example": " in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Example_raw': ' in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).[]', 'Example': ' in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **subtypes** - Any subtypes or specializations of this class based on its subtypings. _(ListOf Classes)_[]
RoundTrip Attribute_Head: input is - '- **subtypes** - Any subtypes or specializations of this class based on its subtypings. _(ListOf Classes)_[]'
RoundTrip Attribute_Head: value is - {'name': 'subtypes', 'one_liner': 'Any subtypes or specializations of this class based on its subtypings. _', 'parenthetical': 'ListOf Classes'}
OK. {'name': 'subtypes', 'one_liner': 'Any subtypes or specializations of this class based on its subtypings. _', 'parenthetical': 'ListOf Classes'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'subtypes - Any subtypes or specializations of this class based on its subtypings. _ (ListOf Classes)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **subtypes** - Any subtypes or specializations of this class based on its subtypings. _(ListOf Classes)_[]
		=parse=> {'name': 'subtypes', 'one_liner': 'Any subtypes or specializations of this class based on its subtypings. _', 'parenthetical': 'ListOf Classes'} 
		=render=> subtypes - Any subtypes or specializations of this class based on its subtypings. _ (ListOf Classes) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- skipping BLANK_LINE
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for EXAMPLE: Example: For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.
RoundTrip EXAMPLE: input is - ' For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.[]'
RoundTrip EXAMPLE: value is -  For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.[]
OK.  For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.[] ok for EXAMPLE
RoundTrip EXAMPLE: renders as - ' For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.[]'
RoundTrip EXAMPLE: reparses as -  For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.[]
RoundTrip SUCCESS:  For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.[]
		=parse=>  For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.[] 
		=render=>  For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.[] 
		=parse=>  For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.[]
adding non raw value. Example -.  For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.[]
{
  "Example_raw": " For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.[]",
  "Example": " For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Example_raw': ' For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.[]', 'Example': ' For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
--- skipping BLANK_LINE
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **attributes** - The attributes or properties of the class, in the order in which they should be presented _(ListOf Attributes)_[]
RoundTrip Attribute_Head: input is - '- **attributes** - The attributes or properties of the class, in the order in which they should be presented _(ListOf Attributes)_[]'
RoundTrip Attribute_Head: value is - {'name': 'attributes', 'one_liner': 'The attributes or properties of the class, in the order in which they should be presented _', 'parenthetical': 'ListOf Attributes'}
OK. {'name': 'attributes', 'one_liner': 'The attributes or properties of the class, in the order in which they should be presented _', 'parenthetical': 'ListOf Attributes'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'attributes - The attributes or properties of the class, in the order in which they should be presented _ (ListOf Attributes)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **attributes** - The attributes or properties of the class, in the order in which they should be presented _(ListOf Attributes)_[]
		=parse=> {'name': 'attributes', 'one_liner': 'The attributes or properties of the class, in the order in which they should be presented _', 'parenthetical': 'ListOf Attributes'} 
		=render=> attributes - The attributes or properties of the class, in the order in which they should be presented _ (ListOf Attributes) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **attributeSections** - additional attributes or properties of the class, grouped for clarity and elaboration.  _(ListOf AttributeSections)_[]
RoundTrip Attribute_Head: input is - '- **attributeSections** - additional attributes or properties of the class, grouped for clarity and elaboration.  _(ListOf AttributeSections)_[]'
RoundTrip Attribute_Head: value is - {'name': 'attributeSections', 'one_liner': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _', 'parenthetical': 'ListOf AttributeSections'}
OK. {'name': 'attributeSections', 'one_liner': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _', 'parenthetical': 'ListOf AttributeSections'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'attributeSections - additional attributes or properties of the class, grouped for clarity and elaboration.  _ (ListOf AttributeSections)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **attributeSections** - additional attributes or properties of the class, grouped for clarity and elaboration.  _(ListOf AttributeSections)_[]
		=parse=> {'name': 'attributeSections', 'one_liner': 'additional attributes or properties of the class, grouped for clarity and elaboration.  _', 'parenthetical': 'ListOf AttributeSections'} 
		=render=> attributeSections - additional attributes or properties of the class, grouped for clarity and elaboration.  _ (ListOf AttributeSections) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **constraints** - Any constraints, rules, or validations specific to this class _(ListOf Constraints)_[]
RoundTrip Attribute_Head: input is - '- **constraints** - Any constraints, rules, or validations specific to this class _(ListOf Constraints)_[]'
RoundTrip Attribute_Head: value is - {'name': 'constraints', 'one_liner': 'Any constraints, rules, or validations specific to this class _', 'parenthetical': 'ListOf Constraints'}
OK. {'name': 'constraints', 'one_liner': 'Any constraints, rules, or validations specific to this class _', 'parenthetical': 'ListOf Constraints'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'constraints - Any constraints, rules, or validations specific to this class _ (ListOf Constraints)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **constraints** - Any constraints, rules, or validations specific to this class _(ListOf Constraints)_[]
		=parse=> {'name': 'constraints', 'one_liner': 'Any constraints, rules, or validations specific to this class _', 'parenthetical': 'ListOf Constraints'} 
		=render=> constraints - Any constraints, rules, or validations specific to this class _ (ListOf Constraints) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for NOTE: Note: Constraints may be expressed on either the Class or the Attribute. Always?Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.
RoundTrip NOTE: input is - ' Constraints may be expressed on either the Class or the Attribute. Always?['Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.']'
RoundTrip NOTE: value is -  Constraints may be expressed on either the Class or the Attribute. Always?['Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.']
OK.  Constraints may be expressed on either the Class or the Attribute. Always?['Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.'] ok for NOTE
RoundTrip NOTE: renders as - ' Constraints may be expressed on either the Class or the Attribute. Always?['Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.']'
RoundTrip NOTE: reparses as -  Constraints may be expressed on either the Class or the Attribute. Always?['Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.']
RoundTrip SUCCESS:  Constraints may be expressed on either the Class or the Attribute. Always?['Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.']
		=parse=>  Constraints may be expressed on either the Class or the Attribute. Always?['Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.'] 
		=render=>  Constraints may be expressed on either the Class or the Attribute. Always?['Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.'] 
		=parse=>  Constraints may be expressed on either the Class or the Attribute. Always?['Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.']
adding non raw value. Note -.  Constraints may be expressed on either the Class or the Attribute. Always?['Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.']
{
  "Note_raw": " Constraints may be expressed on either the Class or the Attribute. Always?['Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.']",
  "Note": " Constraints may be expressed on either the Class or the Attribute. Always?['Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.']"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Note_raw': " Constraints may be expressed on either the Class or the Attribute. Always?['Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.']", 'Note': " Constraints may be expressed on either the Class or the Attribute. Always?['Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.']"}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **methods** - Any behaviors or operations associated with this class _(ListOf Methods)_[]
RoundTrip Attribute_Head: input is - '- **methods** - Any behaviors or operations associated with this class _(ListOf Methods)_[]'
RoundTrip Attribute_Head: value is - {'name': 'methods', 'one_liner': 'Any behaviors or operations associated with this class _', 'parenthetical': 'ListOf Methods'}
OK. {'name': 'methods', 'one_liner': 'Any behaviors or operations associated with this class _', 'parenthetical': 'ListOf Methods'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'methods - Any behaviors or operations associated with this class _ (ListOf Methods)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **methods** - Any behaviors or operations associated with this class _(ListOf Methods)_[]
		=parse=> {'name': 'methods', 'one_liner': 'Any behaviors or operations associated with this class _', 'parenthetical': 'ListOf Methods'} 
		=render=> methods - Any behaviors or operations associated with this class _ (ListOf Methods) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
DerivingDict for Part:  AttributeSection
		Full header is: __ ***Implied Attributes***[]
RoundTrip AttributeSection_Head: input is - '__ ***Implied Attributes***[]'
RoundTrip AttributeSection_Head: value is - {'name': 'Implied Attributes[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Implied Attributes[]', 'one_liner': '', 'parenthetical': ''} ok for AttributeSection_Head
RoundTrip AttributeSection_Head: renders as - 'Implied Attributes[]'
RoundTrip AttributeSection_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: __ ***Implied Attributes***[]
		=parse=> {'name': 'Implied Attributes[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Implied Attributes[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Attribute
		Full header is: - **dependents** - the Classes which are basedOn this Class (optional SetOf Classes).[]
RoundTrip Attribute_Head: input is - '- **dependents** - the Classes which are basedOn this Class (optional SetOf Classes).[]'
RoundTrip Attribute_Head: value is - {'name': 'dependents', 'one_liner': 'the Classes which are basedOn this Class', 'parenthetical': 'optional SetOf Classes'}
OK. {'name': 'dependents', 'one_liner': 'the Classes which are basedOn this Class', 'parenthetical': 'optional SetOf Classes'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'dependents - the Classes which are basedOn this Class (optional SetOf Classes)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **dependents** - the Classes which are basedOn this Class (optional SetOf Classes).[]
		=parse=> {'name': 'dependents', 'one_liner': 'the Classes which are basedOn this Class', 'parenthetical': 'optional SetOf Classes'} 
		=render=> dependents - the Classes which are basedOn this Class (optional SetOf Classes) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for INVERSE: ***Inverse of***: Class.basedOn
RoundTrip INVERSE: input is - ' Class.basedOn[]'
RoundTrip INVERSE: value is - {'class_name': 'Class', 'attribute_name': 'basedOn[]'}
OK. {'class_name': 'Class', 'attribute_name': 'basedOn[]'} ok for INVERSE
RoundTrip INVERSE: renders as - 'Class.basedOn[]'
RoundTrip INVERSE: reparses as - {'class_name': 'Class', 'attribute_name': 'basedOn[]'}
RoundTrip SUCCESS:  Class.basedOn[]
		=parse=> {'class_name': 'Class', 'attribute_name': 'basedOn[]'} 
		=render=> Class.basedOn[] 
		=parse=> {'class_name': 'Class', 'attribute_name': 'basedOn[]'}
adding non raw value. ***Inverse of*** -. {'class_name': 'Class', 'attribute_name': 'basedOn[]'}
{
  "***Inverse of***_raw": " Class.basedOn[]",
  "***Inverse of***": {
    "class_name": "Class",
    "attribute_name": "basedOn[]"
  }
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Inverse of***_raw': ' Class.basedOn[]', '***Inverse of***': {'class_name': 'Class', 'attribute_name': 'basedOn[]'}}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - UniqueKeys - (optional Set of UniqueKeys).[]
RoundTrip Attribute_Head: input is - '- UniqueKeys - (optional Set of UniqueKeys).[]'
RoundTrip Attribute_Head: value is - {'name': 'UniqueKeys', 'one_liner': '', 'parenthetical': 'optional Set of UniqueKeys'}
OK. {'name': 'UniqueKeys', 'one_liner': '', 'parenthetical': 'optional Set of UniqueKeys'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'UniqueKeys (optional Set of UniqueKeys)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - UniqueKeys - (optional Set of UniqueKeys).[]
		=parse=> {'name': 'UniqueKeys', 'one_liner': '', 'parenthetical': 'optional Set of UniqueKeys'} 
		=render=> UniqueKeys (optional Set of UniqueKeys) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for INVERSE: ***Inverse of***:UniqueKey.basedOn
RoundTrip INVERSE: input is - '['UniqueKey.basedOn']'
RoundTrip INVERSE: value is - {'class_name': "['UniqueKey", 'attribute_name': "basedOn']"}
OK. {'class_name': "['UniqueKey", 'attribute_name': "basedOn']"} ok for INVERSE
RoundTrip INVERSE: renders as - '['UniqueKey.basedOn']'
RoundTrip INVERSE: reparses as - {'class_name': "['UniqueKey", 'attribute_name': "basedOn']"}
RoundTrip SUCCESS: ['UniqueKey.basedOn']
		=parse=> {'class_name': "['UniqueKey", 'attribute_name': "basedOn']"} 
		=render=> ['UniqueKey.basedOn'] 
		=parse=> {'class_name': "['UniqueKey", 'attribute_name': "basedOn']"}
adding non raw value. ***Inverse of*** -. {'class_name': "['UniqueKey", 'attribute_name': "basedOn']"}
{
  "***Inverse of***_raw": "['UniqueKey.basedOn']",
  "***Inverse of***": {
    "class_name": "['UniqueKey",
    "attribute_name": "basedOn']"
  }
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Inverse of***_raw': "['UniqueKey.basedOn']", '***Inverse of***': {'class_name': "['UniqueKey", 'attribute_name': "basedOn']"}}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
--- skipping BLANK_LINE
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _Subtype of:_ Component
. . Constraint - <class 'ldm_parse_core.DocPart'> 
_ _ _ CONSTRAINT: ***Constraint***: Within each Class, attribute names must be unique.
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **pluralForm** - the normal English plural form of the name of the Class (UpperName)
_ _ _ BLANK_LINE: 
_ _ _ TEXT_LINE: Might be Books for the Book class or other regular plurals.
_ _ _ TEXT_LINE: But also might be People for Person.
_ _ _ BLANK_LINE: 
. . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ NOTE: Note: When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.
_ _ _ _ BLANK_LINE: 
_ _ _ _ TEXT_LINE: The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.
. . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ DEFAULT: ***Default***: the regular plural, formed by adding "s" or "es".
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **basedOn** - the Class or Classes on which this class is dependent (SetOf Classes).
_ _ _ BLANK_LINE: 
_ _ _ BLANK_LINE: 
_ _ _ TEXT_LINE: This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.
_ _ _ BLANK_LINE: 
. . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ NOTE: Note: basedOn and dependentOf are being used synonymousle in this metamodel.
. . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ ISSUE: issue: fix that
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **supertypes** - The parent class(es) from which this class inherits attributes _(ListOf Classes)_
_ _ _ BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **subtypings** - the criteria, or dimensions, by which the class can be divided into subtypes (list of Subtypings).
_ _ _ BLANK_LINE: 
. . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ EXAMPLE: Example: in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **subtypes** - Any subtypes or specializations of this class based on its subtypings. _(ListOf Classes)_
_ _ _ BLANK_LINE: 
_ _ _ BLANK_LINE: 
. . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ EXAMPLE: Example: For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **attributes** - The attributes or properties of the class, in the order in which they should be presented _(ListOf Attributes)_
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **attributeSections** - additional attributes or properties of the class, grouped for clarity and elaboration.  _(ListOf AttributeSections)_
_ _ _ BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **constraints** - Any constraints, rules, or validations specific to this class _(ListOf Constraints)_
. . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ NOTE: Note: Constraints may be expressed on either the Class or the Attribute. Always?Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **methods** - Any behaviors or operations associated with this class _(ListOf Methods)_
_ _ _ BLANK_LINE: 
. . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ AttributeSection_Head: __ ***Implied Attributes***
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **dependents** - the Classes which are basedOn this Class (optional SetOf Classes).
_ _ _ _ BLANK_LINE: 
_ _ _ _ INVERSE: ***Inverse of***: Class.basedOn
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - UniqueKeys - (optional Set of UniqueKeys).
_ _ _ _ BLANK_LINE: 
_ _ _ _ INVERSE: ***Inverse of***:UniqueKey.basedOn
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_Subtype of:_ Component[]",
  "name": "Subtype of: Component[]",
  "one_liner": "",
  "parenthetical": "",
  "Constraint": [
    {
      "_type": "Constraint",
      "***Constraint***_raw": [
        " Within each Class, attribute names must be unique.[]"
      ],
      "***Constraint***": [
        " ",
        "W",
        "i",
        "t",
        "h",
        "i",
        "n",
        " ",
        "e",
        "a",
        "c",
        "h",
        " ",
        "C",
        "l",
        "a",
        "s",
        "s",
        ",",
        " ",
        "a",
        "t",
        "t",
        "r",
        "i",
        "b",
        "u",
        "t",
        "e",
        " ",
        "n",
        "a",
        "m",
        "e",
        "s",
        " ",
        "m",
        "u",
        "s",
        "t",
        " ",
        "b",
        "e",
        " ",
        "u",
        "n",
        "i",
        "q",
        "u",
        "e",
        ".",
        "[",
        "]"
      ]
    }
  ],
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "- **pluralForm** - the normal English plural form of the name of the Class (UpperName)[]",
      "name": "pluralForm",
      "one_liner": "the normal English plural form of the name of the Class",
      "parenthetical": "UpperName",
      "elaboration": [
        {
          "type_label": "TEXT_LINE",
          "content": "Might be Books for the Book class or other regular plurals."
        },
        {
          "type_label": "TEXT_LINE",
          "content": "But also might be People for Person."
        }
      ],
      "Annotation": [
        {
          "_type": "Annotation",
          "Note_raw": [
            " When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.[]"
          ],
          "Note": [
            " When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.[]"
          ]
        }
      ],
      "Default": [
        {
          "_type": "Default",
          "***Default***_raw": [
            " the regular plural, formed by adding \"s\" or \"es\".[]"
          ],
          "***Default***": " the regular plural, formed by adding \"s\" or \"es\".[]"
        }
      ]
    },
    {
      "_type": "Attribute",
      "full_header": "- **basedOn** - the Class or Classes on which this class is dependent (SetOf Classes).[]",
      "name": "basedOn",
      "one_liner": "the Class or Classes on which this class is dependent",
      "parenthetical": "SetOf Classes",
      "elaboration": [
        {
          "type_label": "TEXT_LINE",
          "content": "This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity."
        }
      ],
      "Annotation": [
        {
          "_type": "Annotation",
          "Note_raw": [
            " basedOn and dependentOf are being used synonymousle in this metamodel.[]"
          ],
          "Note": [
            " basedOn and dependentOf are being used synonymousle in this metamodel.[]"
          ]
        },
        {
          "_type": "Annotation",
          "issue_raw": [
            " fix that[]"
          ],
          "issue": [
            " fix that[]"
          ]
        }
      ]
    },
    {
      "_type": "Attribute",
      "full_header": "- **supertypes** - The parent class(es) from which this class inherits attributes _(ListOf Classes)_[]",
      "name": "supertypes",
      "one_liner": "The parent class",
      "parenthetical": "es"
    },
    {
      "_type": "Attribute",
      "full_header": "- **subtypings** - the criteria, or dimensions, by which the class can be divided into subtypes (list of Subtypings).[]",
      "name": "subtypings",
      "one_liner": "the criteria, or dimensions, by which the class can be divided into subtypes",
      "parenthetical": "list of Subtypings",
      "Annotation": [
        {
          "_type": "Annotation",
          "Example_raw": [
            " in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).[]"
          ],
          "Example": [
            " in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).[]"
          ]
        }
      ]
    },
    {
      "_type": "Attribute",
      "full_header": "- **subtypes** - Any subtypes or specializations of this class based on it\u2019s subtypings. _(ListOf Classes)_[]",
      "name": "subtypes",
      "one_liner": "Any subtypes or specializations of this class based on it\u2019s subtypings. _",
      "parenthetical": "ListOf Classes",
      "Annotation": [
        {
          "_type": "Annotation",
          "Example_raw": [
            " For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.[]"
          ],
          "Example": [
            " For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.[]"
          ]
        }
      ]
    },
    {
      "_type": "Attribute",
      "full_header": "- **attributes** - The attributes or properties of the class, in the order in which they should be presented _(ListOf Attributes)_[]",
      "name": "attributes",
      "one_liner": "The attributes or properties of the class, in the order in which they should be presented _",
      "parenthetical": "ListOf Attributes"
    },
    {
      "_type": "Attribute",
      "full_header": "- **attributeSections** - additional attributes or properties of the class, grouped for clarity and elaboration.  _(ListOf AttributeSections)_[]",
      "name": "attributeSections",
      "one_liner": "additional attributes or properties of the class, grouped for clarity and elaboration.  _",
      "parenthetical": "ListOf AttributeSections"
    },
    {
      "_type": "Attribute",
      "full_header": "- **constraints** - Any constraints, rules, or validations specific to this class _(ListOf Constraints)_[]",
      "name": "constraints",
      "one_liner": "Any constraints, rules, or validations specific to this class _",
      "parenthetical": "ListOf Constraints",
      "Annotation": [
        {
          "_type": "Annotation",
          "Note_raw": [
            " Constraints may be expressed on either the Class or the Attribute. Always?['Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.']"
          ],
          "Note": [
            " Constraints may be expressed on either the Class or the Attribute. Always?['Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.']"
          ]
        }
      ]
    },
    {
      "_type": "Attribute",
      "full_header": "- **methods** - Any behaviors or operations associated with this class _(ListOf Methods)_[]",
      "name": "methods",
      "one_liner": "Any behaviors or operations associated with this class _",
      "parenthetical": "ListOf Methods"
    }
  ],
  "AttributeSection": [
    {
      "_type": "AttributeSection",
      "full_header": "__ ***Implied Attributes***[]",
      "name": "Implied Attributes[]",
      "one_liner": "",
      "parenthetical": "",
      "Attribute": [
        {
          "_type": "Attribute",
          "full_header": "- **dependents** - the Classes which are basedOn this Class (optional SetOf Classes).[]",
          "name": "dependents",
          "one_liner": "the Classes which are basedOn this Class",
          "parenthetical": "optional SetOf Classes",
          "***Inverse of***_raw": [
            " Class.basedOn[]"
          ],
          "***Inverse of***": {
            "class_name": "Class",
            "attribute_name": "basedOn[]"
          }
        },
        {
          "_type": "Attribute",
          "full_header": "- UniqueKeys - (optional Set of UniqueKeys).[]",
          "name": "UniqueKeys",
          "one_liner": "",
          "parenthetical": "optional Set of UniqueKeys",
          "***Inverse of***_raw": [
            "['UniqueKey.basedOn']"
          ],
          "***Inverse of***": {
            "class_name": "['UniqueKey",
            "attribute_name": "basedOn']"
          }
        }
      ]
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ **Subtyping** - a way in which subtypes of a Class may be classified (Subtype of Component).[]
RoundTrip Class_Head: input is - '_ **Subtyping** - a way in which subtypes of a Class may be classified (Subtype of Component).[]'
RoundTrip Class_Head: value is - {'name': 'Subtyping', 'one_liner': 'a way in which subtypes of a Class may be classified', 'parenthetical': 'Subtype of Component'}
OK. {'name': 'Subtyping', 'one_liner': 'a way in which subtypes of a Class may be classified', 'parenthetical': 'Subtype of Component'} ok for Class_Head
RoundTrip Class_Head: renders as - 'Subtyping - a way in which subtypes of a Class may be classified (Subtype of Component)'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **Subtyping** - a way in which subtypes of a Class may be classified (Subtype of Component).[]
		=parse=> {'name': 'Subtyping', 'one_liner': 'a way in which subtypes of a Class may be classified', 'parenthetical': 'Subtype of Component'} 
		=render=> Subtyping - a way in which subtypes of a Class may be classified (Subtype of Component) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DEPENDENT_OF: ***Dependent of:*** Class
RoundTrip DEPENDENT_OF: input is - '*** Class[]'
parse_name_list: *** Class[]
RoundTrip DEPENDENT_OF: value is - ['Class[]']
validating name list:  ['Class[]']
OK. ['Class[]'] ok for DEPENDENT_OF
RoundTrip DEPENDENT_OF: renders as - 'Class[]'
parse_name_list: Class[]
RoundTrip DEPENDENT_OF: reparses as - ['Class[]']
RoundTrip SUCCESS: *** Class[]
		=parse=> ['Class[]'] 
		=render=> Class[] 
		=parse=> ['Class[]']
adding non raw value. ***Dependent of -. ['Class[]']
{
  "***Dependent of_raw": "*** Class[]",
  "***Dependent of": [
    "Class[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Dependent of_raw': '*** Class[]', '***Dependent of': ['Class[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **name** (Upper Name).['Usually ByThis or ByThat']
RoundTrip Attribute_Head: input is - '- **name** (Upper Name).['Usually ByThis or ByThat']'
RoundTrip Attribute_Head: value is - {'name': 'name', 'one_liner': '', 'parenthetical': 'Upper Name'}
OK. {'name': 'name', 'one_liner': '', 'parenthetical': 'Upper Name'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'name (Upper Name)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **name** (Upper Name).['Usually ByThis or ByThat']
		=parse=> {'name': 'name', 'one_liner': '', 'parenthetical': 'Upper Name'} 
		=render=> name (Upper Name) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **is exclusive** (Boolean).[]
RoundTrip Attribute_Head: input is - '- **is exclusive** (Boolean).[]'
RoundTrip Attribute_Head: value is - {'name': 'is exclusive', 'one_liner': '', 'parenthetical': 'Boolean'}
OK. {'name': 'is exclusive', 'one_liner': '', 'parenthetical': 'Boolean'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'is exclusive (Boolean)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **is exclusive** (Boolean).[]
		=parse=> {'name': 'is exclusive', 'one_liner': '', 'parenthetical': 'Boolean'} 
		=render=> is exclusive (Boolean) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Default
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DEFAULT: Default: true
RoundTrip DEFAULT: input is - ' true[]'
RoundTrip DEFAULT: value is -  true[]
OK.  true[] ok for DEFAULT
RoundTrip DEFAULT: renders as - ' true[]'
RoundTrip DEFAULT: reparses as -  true[]
RoundTrip SUCCESS:  true[]
		=parse=>  true[] 
		=render=>  true[] 
		=parse=>  true[]
adding non raw value. Default -.  true[]
{
  "Default_raw": " true[]",
  "Default": " true[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Default_raw': ' true[]', 'Default': ' true[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **is exhaustive** (Boolean).[]
RoundTrip Attribute_Head: input is - '- **is exhaustive** (Boolean).[]'
RoundTrip Attribute_Head: value is - {'name': 'is exhaustive', 'one_liner': '', 'parenthetical': 'Boolean'}
OK. {'name': 'is exhaustive', 'one_liner': '', 'parenthetical': 'Boolean'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'is exhaustive (Boolean)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **is exhaustive** (Boolean).[]
		=parse=> {'name': 'is exhaustive', 'one_liner': '', 'parenthetical': 'Boolean'} 
		=render=> is exhaustive (Boolean) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Default
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DEFAULT: Default: true
RoundTrip DEFAULT: input is - ' true[]'
RoundTrip DEFAULT: value is -  true[]
OK.  true[] ok for DEFAULT
RoundTrip DEFAULT: renders as - ' true[]'
RoundTrip DEFAULT: reparses as -  true[]
RoundTrip SUCCESS:  true[]
		=parse=>  true[] 
		=render=>  true[] 
		=parse=>  true[]
adding non raw value. Default -.  true[]
{
  "Default_raw": " true[]",
  "Default": " true[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Default_raw': ' true[]', 'Default': ' true[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **classes** (List of Classes).[]
RoundTrip Attribute_Head: input is - '- **classes** (List of Classes).[]'
RoundTrip Attribute_Head: value is - {'name': 'classes', 'one_liner': '', 'parenthetical': 'List of Classes'}
OK. {'name': 'classes', 'one_liner': '', 'parenthetical': 'List of Classes'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'classes (List of Classes)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **classes** (List of Classes).[]
		=parse=> {'name': 'classes', 'one_liner': '', 'parenthetical': 'List of Classes'} 
		=render=> classes (List of Classes) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- adding TEXT para
--- adding TEXT para
--- adding TEXT para
--- adding TEXT para
--- adding TEXT para
--- skipping BLANK_LINE
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for NOTE: Note: every class can have an unnamed subtyping.Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.
RoundTrip NOTE: input is - ' every class can have an unnamed subtyping.['Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.']'
RoundTrip NOTE: value is -  every class can have an unnamed subtyping.['Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.']
OK.  every class can have an unnamed subtyping.['Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.'] ok for NOTE
RoundTrip NOTE: renders as - ' every class can have an unnamed subtyping.['Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.']'
RoundTrip NOTE: reparses as -  every class can have an unnamed subtyping.['Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.']
RoundTrip SUCCESS:  every class can have an unnamed subtyping.['Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.']
		=parse=>  every class can have an unnamed subtyping.['Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.'] 
		=render=>  every class can have an unnamed subtyping.['Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.'] 
		=parse=>  every class can have an unnamed subtyping.['Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.']
adding non raw value. Note -.  every class can have an unnamed subtyping.['Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.']
{
  "Note_raw": " every class can have an unnamed subtyping.['Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.']",
  "Note": " every class can have an unnamed subtyping.['Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.']"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Note_raw': " every class can have an unnamed subtyping.['Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.']", 'Note': " every class can have an unnamed subtyping.['Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.']"}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **Subtyping** - a way in which subtypes of a Class may be classified (Subtype of Component).
_ _ DEPENDENT_OF: ***Dependent of:*** Class
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **name** (Upper Name).Usually ByThis or ByThat
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **is exclusive** (Boolean).
. . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ DEFAULT: Default: true
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **is exhaustive** (Boolean).
. . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ DEFAULT: Default: true
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **classes** (List of Classes).
_ _ _ BLANK_LINE: 
_ _ _ TEXT_LINE: ***DSL***:  Shown in the DSL as
_ _ _ TEXT_LINE: > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)
_ _ _ TEXT_LINE: on the super class. And as
_ _ _ TEXT_LINE: > Subtype of: SuperClass byBrand
_ _ _ TEXT_LINE: on the subclass.
_ _ _ BLANK_LINE: 
. . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ NOTE: Note: every class can have an unnamed subtyping.Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.
_ _ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **Subtyping** - a way in which subtypes of a Class may be classified (Subtype of Component).[]",
  "name": "Subtyping",
  "one_liner": "a way in which subtypes of a Class may be classified",
  "parenthetical": "Subtype of Component",
  "***Dependent of_raw": [
    "*** Class[]"
  ],
  "***Dependent of": [
    "Class[]"
  ],
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "- **name** (Upper Name).['Usually ByThis or ByThat']",
      "name": "name",
      "one_liner": "",
      "parenthetical": "Upper Name"
    },
    {
      "_type": "Attribute",
      "full_header": "- **is exclusive** (Boolean).[]",
      "name": "is exclusive",
      "one_liner": "",
      "parenthetical": "Boolean",
      "Default": [
        {
          "_type": "Default",
          "Default_raw": [
            " true[]"
          ],
          "Default": " true[]"
        }
      ]
    },
    {
      "_type": "Attribute",
      "full_header": "- **is exhaustive** (Boolean).[]",
      "name": "is exhaustive",
      "one_liner": "",
      "parenthetical": "Boolean",
      "Default": [
        {
          "_type": "Default",
          "Default_raw": [
            " true[]"
          ],
          "Default": " true[]"
        }
      ]
    },
    {
      "_type": "Attribute",
      "full_header": "- **classes** (List of Classes).[]",
      "name": "classes",
      "one_liner": "",
      "parenthetical": "List of Classes",
      "elaboration": [
        {
          "type_label": "TEXT_LINE",
          "content": "***DSL***:  Shown in the DSL as"
        },
        {
          "type_label": "TEXT_LINE",
          "content": "> Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)"
        },
        {
          "type_label": "TEXT_LINE",
          "content": "on the super class. And as"
        },
        {
          "type_label": "TEXT_LINE",
          "content": "> Subtype of: SuperClass byBrand"
        },
        {
          "type_label": "TEXT_LINE",
          "content": "on the subclass."
        }
      ],
      "Annotation": [
        {
          "_type": "Annotation",
          "Note_raw": [
            " every class can have an unnamed subtyping.['Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.']"
          ],
          "Note": [
            " every class can have an unnamed subtyping.['Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.']"
          ]
        }
      ]
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ **ValueType** -[]
RoundTrip Class_Head: input is - '_ **ValueType** -[]'
RoundTrip Class_Head: value is - {'name': 'ValueType', 'one_liner': '[]', 'parenthetical': ''}
OK. {'name': 'ValueType', 'one_liner': '[]', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'ValueType - []'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **ValueType** -[]
		=parse=> {'name': 'ValueType', 'one_liner': '[]', 'parenthetical': ''} 
		=render=> ValueType - [] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for SUBTYPE_OF: Subtype of: Class.
RoundTrip SUBTYPE_OF: input is - ' Class.[]'
parse_name_list:  Class.[]
RoundTrip SUBTYPE_OF: value is - ['Class.[]']
validating name list:  ['Class.[]']
OK. ['Class.[]'] ok for SUBTYPE_OF
RoundTrip SUBTYPE_OF: renders as - 'Class.[]'
parse_name_list: Class.[]
RoundTrip SUBTYPE_OF: reparses as - ['Class.[]']
RoundTrip SUCCESS:  Class.[]
		=parse=> ['Class.[]'] 
		=render=> Class.[] 
		=parse=> ['Class.[]']
adding non raw value. Subtype of -. ['Class.[]']
{
  "Subtype of_raw": " Class.[]",
  "Subtype of": [
    "Class.[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Subtype of_raw': ' Class.[]', 'Subtype of': ['Class.[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  AttributeSection
		Full header is: __***Markdown Support***[]
RoundTrip AttributeSection_Head: input is - '__***Markdown Support***[]'
RoundTrip AttributeSection_Head: value is - {'name': 'Markdown Support[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Markdown Support[]', 'one_liner': '', 'parenthetical': ''} ok for AttributeSection_Head
RoundTrip AttributeSection_Head: renders as - 'Markdown Support[]'
RoundTrip AttributeSection_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: __***Markdown Support***[]
		=parse=> {'name': 'Markdown Support[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Markdown Support[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Attribute
		Full header is: - ***mdPrefix*** (*[String](#string)*)[]
RoundTrip Attribute_Head: input is - '- ***mdPrefix*** (*[String](#string)*)[]'
RoundTrip Attribute_Head: value is - {'name': 'mdPrefix', 'one_liner': '', 'parenthetical': '*[String](#string'}
OK. {'name': 'mdPrefix', 'one_liner': '', 'parenthetical': '*[String](#string'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'mdPrefix (*[String](#string)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - ***mdPrefix*** (*[String](#string)*)[]
		=parse=> {'name': 'mdPrefix', 'one_liner': '', 'parenthetical': '*[String](#string'} 
		=render=> mdPrefix (*[String](#string) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Derivation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DERIVATION: ***Derivation***: "ValueType: ".
RoundTrip DERIVATION: input is - ' "ValueType: ".[]'
RoundTrip DERIVATION: value is -  "ValueType: ".[]
OK.  "ValueType: ".[] ok for DERIVATION
RoundTrip DERIVATION: renders as - ' "ValueType: ".[]'
RoundTrip DERIVATION: reparses as -  "ValueType: ".[]
RoundTrip SUCCESS:  "ValueType: ".[]
		=parse=>  "ValueType: ".[] 
		=render=>  "ValueType: ".[] 
		=parse=>  "ValueType: ".[]
adding non raw value. ***Derivation*** -.  "ValueType: ".[]
{
  "***Derivation***_raw": " \"ValueType: \".[]",
  "***Derivation***": " \"ValueType: \".[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Derivation***_raw': ' "ValueType: ".[]', '***Derivation***': ' "ValueType: ".[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
--- skipping BLANK_LINE
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **ValueType** -
_ _ SUBTYPE_OF: Subtype of: Class.
. . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ AttributeSection_Head: __***Markdown Support***
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - ***mdPrefix*** (*[String](#string)*)
. . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ DERIVATION: ***Derivation***: "ValueType: ".
_ _ _ _ _ BLANK_LINE: 
_ _ _ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **ValueType** -[]",
  "name": "ValueType",
  "one_liner": "[]",
  "parenthetical": "",
  "Subtype of_raw": [
    " Class.[]"
  ],
  "Subtype of": [
    "Class.[]"
  ],
  "AttributeSection": [
    {
      "_type": "AttributeSection",
      "full_header": "__***Markdown Support***[]",
      "name": "Markdown Support[]",
      "one_liner": "",
      "parenthetical": "",
      "Attribute": [
        {
          "_type": "Attribute",
          "full_header": "- ***mdPrefix*** (*[String](#string)*)[]",
          "name": "mdPrefix",
          "one_liner": "",
          "parenthetical": "*[String](#string",
          "Derivation": [
            {
              "_type": "Derivation",
              "***Derivation***_raw": [
                " \"ValueType: \".[]"
              ],
              "***Derivation***": " \"ValueType: \".[]"
            }
          ]
        }
      ]
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ **Reference Type**:[]
RoundTrip Class_Head: input is - '_ **Reference Type**:[]'
RoundTrip Class_Head: value is - {'name': 'Reference Type:[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Reference Type:[]', 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Reference Type:[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **Reference Type**:[]
		=parse=> {'name': 'Reference Type:[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Reference Type:[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for SUBTYPE_OF: Subtype of: Class.
RoundTrip SUBTYPE_OF: input is - ' Class.[]'
parse_name_list:  Class.[]
RoundTrip SUBTYPE_OF: value is - ['Class.[]']
validating name list:  ['Class.[]']
OK. ['Class.[]'] ok for SUBTYPE_OF
RoundTrip SUBTYPE_OF: renders as - 'Class.[]'
parse_name_list: Class.[]
RoundTrip SUBTYPE_OF: reparses as - ['Class.[]']
RoundTrip SUCCESS:  Class.[]
		=parse=> ['Class.[]'] 
		=render=> Class.[] 
		=parse=> ['Class.[]']
adding non raw value. Subtype of -. ['Class.[]']
{
  "Subtype of_raw": " Class.[]",
  "Subtype of": [
    "Class.[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Subtype of_raw': ' Class.[]', 'Subtype of': ['Class.[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **Reference Type**:
_ _ SUBTYPE_OF: Subtype of: Class.
_ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **Reference Type**:[]",
  "name": "Reference Type:[]",
  "one_liner": "",
  "parenthetical": "",
  "Subtype of_raw": [
    " Class.[]"
  ],
  "Subtype of": [
    "Class.[]"
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ **CodeType**['A data type or enumeration used in the model']
RoundTrip Class_Head: input is - '_ **CodeType**['A data type or enumeration used in the model']'
RoundTrip Class_Head: value is - {'name': "CodeType['A data type or enumeration used in the model']", 'one_liner': '', 'parenthetical': ''}
OK. {'name': "CodeType['A data type or enumeration used in the model']", 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'CodeType['A data type or enumeration used in the model']'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **CodeType**['A data type or enumeration used in the model']
		=parse=> {'name': "CodeType['A data type or enumeration used in the model']", 'one_liner': '', 'parenthetical': ''} 
		=render=> CodeType['A data type or enumeration used in the model'] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **CodeType**A data type or enumeration used in the model
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **CodeType**['A data type or enumeration used in the model']",
  "name": "CodeType['A data type or enumeration used in the model']",
  "one_liner": "",
  "parenthetical": ""
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _Subtype of:_ ValueType.[]
RoundTrip Class_Head: input is - '_Subtype of:_ ValueType.[]'
RoundTrip Class_Head: value is - {'name': 'Subtype of: ValueType.[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Subtype of: ValueType.[]', 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Subtype of: ValueType.[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _Subtype of:_ ValueType.[]
		=parse=> {'name': 'Subtype of: ValueType.[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Subtype of: ValueType.[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for NOTE: Note: Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:
RoundTrip NOTE: input is - ' Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:[]'
RoundTrip NOTE: value is -  Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:[]
OK.  Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:[] ok for NOTE
RoundTrip NOTE: renders as - ' Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:[]'
RoundTrip NOTE: reparses as -  Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:[]
RoundTrip SUCCESS:  Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:[]
		=parse=>  Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:[] 
		=render=>  Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:[] 
		=parse=>  Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:[]
adding non raw value. Note -.  Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:[]
{
  "Note_raw": " Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:[]",
  "Note": " Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Note_raw': " Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:[]", 'Note': " Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:[]"}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - List the code values as a bulletted list inside the description of the attribute in the form:['**code**: description']
RoundTrip Attribute_Head: input is - '- List the code values as a bulletted list inside the description of the attribute in the form:['**code**: description']'
RoundTrip Attribute_Head: value is - {'name': "List the code values as a bulletted list inside the description of the attribute in the form:['code: description']", 'one_liner': '', 'parenthetical': ''}
OK. {'name': "List the code values as a bulletted list inside the description of the attribute in the form:['code: description']", 'one_liner': '', 'parenthetical': ''} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'List the code values as a bulletted list inside the description of the attribute in the form:['code: description']'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - List the code values as a bulletted list inside the description of the attribute in the form:['**code**: description']
		=parse=> {'name': "List the code values as a bulletted list inside the description of the attribute in the form:['code: description']", 'one_liner': '', 'parenthetical': ''} 
		=render=> List the code values as a bulletted list inside the description of the attribute in the form:['code: description'] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.[]
RoundTrip Attribute_Head: input is - '- A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.[]'
RoundTrip Attribute_Head: value is - {'name': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.[]', 'one_liner': '', 'parenthetical': ''} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.[]'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.[]
		=parse=> {'name': 'A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - isCaptive - the code type was implied by use in an attribute and is only used for that attribute (Boolean) as[]
RoundTrip Attribute_Head: input is - '- isCaptive - the code type was implied by use in an attribute and is only used for that attribute (Boolean) as[]'
RoundTrip Attribute_Head: value is - {'name': 'isCaptive', 'one_liner': 'the code type was implied by use in an attribute and is only used for that attribute', 'parenthetical': 'Boolean'}
OK. {'name': 'isCaptive', 'one_liner': 'the code type was implied by use in an attribute and is only used for that attribute', 'parenthetical': 'Boolean'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'isCaptive - the code type was implied by use in an attribute and is only used for that attribute (Boolean)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - isCaptive - the code type was implied by use in an attribute and is only used for that attribute (Boolean) as[]
		=parse=> {'name': 'isCaptive', 'one_liner': 'the code type was implied by use in an attribute and is only used for that attribute', 'parenthetical': 'Boolean'} 
		=render=> isCaptive - the code type was implied by use in an attribute and is only used for that attribute (Boolean) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _Subtype of:_ ValueType.
. . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ NOTE: Note: Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - List the code values as a bulletted list inside the description of the attribute in the form:**code**: description
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - isCaptive - the code type was implied by use in an attribute and is only used for that attribute (Boolean) as
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_Subtype of:_ ValueType.[]",
  "name": "Subtype of: ValueType.[]",
  "one_liner": "",
  "parenthetical": "",
  "Annotation": [
    {
      "_type": "Annotation",
      "Note_raw": [
        " Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:[]"
      ],
      "Note": [
        " Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:[]"
      ]
    }
  ],
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "- List the code values as a bulletted list inside the description of the attribute in the form:['\u2018**code**: description\u2019']",
      "name": "List the code values as a bulletted list inside the description of the attribute in the form:['\u2018code: description\u2019']",
      "one_liner": "",
      "parenthetical": ""
    },
    {
      "_type": "Attribute",
      "full_header": "- A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.[]",
      "name": "A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.[]",
      "one_liner": "",
      "parenthetical": ""
    },
    {
      "_type": "Attribute",
      "full_header": "- isCaptive - the code type was implied by use in an attribute and is only used for that attribute (Boolean) as[]",
      "name": "isCaptive",
      "one_liner": "the code type was implied by use in an attribute and is only used for that attribute",
      "parenthetical": "Boolean"
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ **Code Value**['A possible value for an enumerated data class  DependentOf: CodeType']
RoundTrip Class_Head: input is - '_ **Code Value**['A possible value for an enumerated data class  DependentOf: CodeType']'
RoundTrip Class_Head: value is - {'name': "Code Value['A possible value for an enumerated data class  DependentOf: CodeType']", 'one_liner': '', 'parenthetical': ''}
OK. {'name': "Code Value['A possible value for an enumerated data class  DependentOf: CodeType']", 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Code Value['A possible value for an enumerated data class  DependentOf: CodeType']'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **Code Value**['A possible value for an enumerated data class  DependentOf: CodeType']
		=parse=> {'name': "Code Value['A possible value for an enumerated data class  DependentOf: CodeType']", 'one_liner': '', 'parenthetical': ''} 
		=render=> Code Value['A possible value for an enumerated data class  DependentOf: CodeType'] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
DerivingDict for Part:  Attribute
		Full header is: - **code** - A short code or abbreviationi for the value _(NameString)_[]
RoundTrip Attribute_Head: input is - '- **code** - A short code or abbreviationi for the value _(NameString)_[]'
RoundTrip Attribute_Head: value is - {'name': 'code', 'one_liner': 'A short code or abbreviationi for the value _', 'parenthetical': 'NameString'}
OK. {'name': 'code', 'one_liner': 'A short code or abbreviationi for the value _', 'parenthetical': 'NameString'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'code - A short code or abbreviationi for the value _ (NameString)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **code** - A short code or abbreviationi for the value _(NameString)_[]
		=parse=> {'name': 'code', 'one_liner': 'A short code or abbreviationi for the value _', 'parenthetical': 'NameString'} 
		=render=> code - A short code or abbreviationi for the value _ (NameString) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **description** - an explanation of what the code means (*RichText*)[]
RoundTrip Attribute_Head: input is - '- **description** - an explanation of what the code means (*RichText*)[]'
RoundTrip Attribute_Head: value is - {'name': 'description', 'one_liner': 'an explanation of what the code means', 'parenthetical': '*RichText*'}
OK. {'name': 'description', 'one_liner': 'an explanation of what the code means', 'parenthetical': '*RichText*'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'description - an explanation of what the code means (*RichText*)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **description** - an explanation of what the code means (*RichText*)[]
		=parse=> {'name': 'description', 'one_liner': 'an explanation of what the code means', 'parenthetical': '*RichText*'} 
		=render=> description - an explanation of what the code means (*RichText*) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **Code Value**A possible value for an enumerated data class  DependentOf: CodeType
_ _ BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **code** - A short code or abbreviationi for the value _(NameString)_
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **description** - an explanation of what the code means (*RichText*)
_ _ _ BLANK_LINE: 
_ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **Code Value**['A possible value for an enumerated data class  DependentOf: CodeType']",
  "name": "Code Value['A possible value for an enumerated data class  DependentOf: CodeType']",
  "one_liner": "",
  "parenthetical": "",
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "- **code** - A short code or abbreviationi for the value _(NameString)_[]",
      "name": "code",
      "one_liner": "A short code or abbreviationi for the value _",
      "parenthetical": "NameString"
    },
    {
      "_type": "Attribute",
      "full_header": "- **description** - an explanation of what the code means (*RichText*)[]",
      "name": "description",
      "one_liner": "an explanation of what the code means",
      "parenthetical": "*RichText*"
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ **Key** - a list of attributes of a class[]
RoundTrip Class_Head: input is - '_ **Key** - a list of attributes of a class[]'
RoundTrip Class_Head: value is - {'name': 'Key', 'one_liner': 'a list of attributes of a class[]', 'parenthetical': ''}
OK. {'name': 'Key', 'one_liner': 'a list of attributes of a class[]', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Key - a list of attributes of a class[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **Key** - a list of attributes of a class[]
		=parse=> {'name': 'Key', 'one_liner': 'a list of attributes of a class[]', 'parenthetical': ''} 
		=render=> Key - a list of attributes of a class[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for SUBTYPE_OF: Subtype of: Component
RoundTrip SUBTYPE_OF: input is - ' Component[]'
parse_name_list:  Component[]
RoundTrip SUBTYPE_OF: value is - ['Component[]']
validating name list:  ['Component[]']
OK. ['Component[]'] ok for SUBTYPE_OF
RoundTrip SUBTYPE_OF: renders as - 'Component[]'
parse_name_list: Component[]
RoundTrip SUBTYPE_OF: reparses as - ['Component[]']
RoundTrip SUCCESS:  Component[]
		=parse=> ['Component[]'] 
		=render=> Component[] 
		=parse=> ['Component[]']
adding non raw value. Subtype of -. ['Component[]']
{
  "Subtype of_raw": " Component[]",
  "Subtype of": [
    "Component[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Subtype of_raw': ' Component[]', 'Subtype of': ['Component[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DEPENDENT_OF: DependentOf: Class
RoundTrip DEPENDENT_OF: input is - ' Class[]'
parse_name_list:  Class[]
RoundTrip DEPENDENT_OF: value is - ['Class[]']
validating name list:  ['Class[]']
OK. ['Class[]'] ok for DEPENDENT_OF
RoundTrip DEPENDENT_OF: renders as - 'Class[]'
parse_name_list: Class[]
RoundTrip DEPENDENT_OF: reparses as - ['Class[]']
RoundTrip SUCCESS:  Class[]
		=parse=> ['Class[]'] 
		=render=> Class[] 
		=parse=> ['Class[]']
adding non raw value. DependentOf -. ['Class[]']
{
  "DependentOf_raw": " Class[]",
  "DependentOf": [
    "Class[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'DependentOf_raw': ' Class[]', 'DependentOf': ['Class[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - keyAttributes - the attributes of the base Class. (List of Attributes ).[]
RoundTrip Attribute_Head: input is - '- keyAttributes - the attributes of the base Class. (List of Attributes ).[]'
RoundTrip Attribute_Head: value is - {'name': 'keyAttributes', 'one_liner': 'the attributes of the base Class.', 'parenthetical': 'List of Attributes'}
OK. {'name': 'keyAttributes', 'one_liner': 'the attributes of the base Class.', 'parenthetical': 'List of Attributes'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'keyAttributes - the attributes of the base Class. (List of Attributes)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - keyAttributes - the attributes of the base Class. (List of Attributes ).[]
		=parse=> {'name': 'keyAttributes', 'one_liner': 'the attributes of the base Class.', 'parenthetical': 'List of Attributes'} 
		=render=> keyAttributes - the attributes of the base Class. (List of Attributes) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
DerivingDict for Part:  Constraint
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for CONSTRAINT: Constraint: each attribute must be a direct or inherited of the base class.
RoundTrip CONSTRAINT: input is - ' each attribute must be a direct or inherited of the base class.[]'
RoundTrip CONSTRAINT: value is -  each attribute must be a direct or inherited of the base class.[]
OK.  each attribute must be a direct or inherited of the base class.[] ok for CONSTRAINT
RoundTrip CONSTRAINT: renders as - ' each attribute must be a direct or inherited of the base class.[]'
RoundTrip CONSTRAINT: reparses as -  each attribute must be a direct or inherited of the base class.[]
RoundTrip SUCCESS:  each attribute must be a direct or inherited of the base class.[]
		=parse=>  each attribute must be a direct or inherited of the base class.[] 
		=render=>  each attribute must be a direct or inherited of the base class.[] 
		=parse=>  each attribute must be a direct or inherited of the base class.[]
adding non raw value. Constraint -.  each attribute must be a direct or inherited of the base class.[]
{
  "Constraint_raw": " each attribute must be a direct or inherited of the base class.[]",
  "Constraint": " each attribute must be a direct or inherited of the base class.[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Constraint_raw': ' each attribute must be a direct or inherited of the base class.[]', 'Constraint': ' each attribute must be a direct or inherited of the base class.[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Constraint
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for CONSTRAINT: Constraint: no repetitions allowed in keyAttributes>  **Issue**: introduce PureLists?
RoundTrip CONSTRAINT: input is - ' no repetitions allowed in keyAttributes['>  **Issue**: introduce PureLists?']'
RoundTrip CONSTRAINT: value is -  no repetitions allowed in keyAttributes['>  **Issue**: introduce PureLists?']
OK.  no repetitions allowed in keyAttributes['>  **Issue**: introduce PureLists?'] ok for CONSTRAINT
RoundTrip CONSTRAINT: renders as - ' no repetitions allowed in keyAttributes['>  **Issue**: introduce PureLists?']'
RoundTrip CONSTRAINT: reparses as -  no repetitions allowed in keyAttributes['>  **Issue**: introduce PureLists?']
RoundTrip SUCCESS:  no repetitions allowed in keyAttributes['>  **Issue**: introduce PureLists?']
		=parse=>  no repetitions allowed in keyAttributes['>  **Issue**: introduce PureLists?'] 
		=render=>  no repetitions allowed in keyAttributes['>  **Issue**: introduce PureLists?'] 
		=parse=>  no repetitions allowed in keyAttributes['>  **Issue**: introduce PureLists?']
adding non raw value. Constraint -.  no repetitions allowed in keyAttributes['>  **Issue**: introduce PureLists?']
{
  "Constraint_raw": " no repetitions allowed in keyAttributes['>  **Issue**: introduce PureLists?']",
  "Constraint": " no repetitions allowed in keyAttributes['>  **Issue**: introduce PureLists?']"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Constraint_raw': " no repetitions allowed in keyAttributes['>  **Issue**: introduce PureLists?']", 'Constraint': " no repetitions allowed in keyAttributes['>  **Issue**: introduce PureLists?']"}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for ISSUE: Issue: need ascending descending to support index keys or ordering keys.
RoundTrip ISSUE: input is - ' need ascending descending to support index keys or ordering keys.[]'
RoundTrip ISSUE: value is -  need ascending descending to support index keys or ordering keys.[]
OK.  need ascending descending to support index keys or ordering keys.[] ok for ISSUE
RoundTrip ISSUE: renders as - ' need ascending descending to support index keys or ordering keys.[]'
RoundTrip ISSUE: reparses as -  need ascending descending to support index keys or ordering keys.[]
RoundTrip SUCCESS:  need ascending descending to support index keys or ordering keys.[]
		=parse=>  need ascending descending to support index keys or ordering keys.[] 
		=render=>  need ascending descending to support index keys or ordering keys.[] 
		=parse=>  need ascending descending to support index keys or ordering keys.[]
adding non raw value. Issue -.  need ascending descending to support index keys or ordering keys.[]
{
  "Issue_raw": " need ascending descending to support index keys or ordering keys.[]",
  "Issue": " need ascending descending to support index keys or ordering keys.[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Issue_raw': ' need ascending descending to support index keys or ordering keys.[]', 'Issue': ' need ascending descending to support index keys or ordering keys.[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **Key** - a list of attributes of a class
_ _ SUBTYPE_OF: Subtype of: Component
_ _ DEPENDENT_OF: DependentOf: Class
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - keyAttributes - the attributes of the base Class. (List of Attributes ).
_ _ _ BLANK_LINE: 
. . . Constraint - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ CONSTRAINT: Constraint: each attribute must be a direct or inherited of the base class.
. . . Constraint - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ CONSTRAINT: Constraint: no repetitions allowed in keyAttributes>  **Issue**: introduce PureLists?
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
. . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ ISSUE: Issue: need ascending descending to support index keys or ordering keys.
_ _ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **Key** - a list of attributes of a class[]",
  "name": "Key",
  "one_liner": "a list of attributes of a class[]",
  "parenthetical": "",
  "Subtype of_raw": [
    " Component[]"
  ],
  "Subtype of": [
    "Component[]"
  ],
  "DependentOf_raw": [
    " Class[]"
  ],
  "DependentOf": [
    "Class[]"
  ],
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "- keyAttributes - the attributes of the base Class. (List of Attributes ).[]",
      "name": "keyAttributes",
      "one_liner": "the attributes of the base Class.",
      "parenthetical": "List of Attributes",
      "Constraint": [
        {
          "_type": "Constraint",
          "Constraint_raw": [
            " each attribute must be a direct or inherited of the base class.[]"
          ],
          "Constraint": [
            " ",
            "e",
            "a",
            "c",
            "h",
            " ",
            "a",
            "t",
            "t",
            "r",
            "i",
            "b",
            "u",
            "t",
            "e",
            " ",
            "m",
            "u",
            "s",
            "t",
            " ",
            "b",
            "e",
            " ",
            "a",
            " ",
            "d",
            "i",
            "r",
            "e",
            "c",
            "t",
            " ",
            "o",
            "r",
            " ",
            "i",
            "n",
            "h",
            "e",
            "r",
            "i",
            "t",
            "e",
            "d",
            " ",
            "o",
            "f",
            " ",
            "t",
            "h",
            "e",
            " ",
            "b",
            "a",
            "s",
            "e",
            " ",
            "c",
            "l",
            "a",
            "s",
            "s",
            ".",
            "[",
            "]"
          ]
        },
        {
          "_type": "Constraint",
          "Constraint_raw": [
            " no repetitions allowed in keyAttributes['>  **Issue**: introduce PureLists?']"
          ],
          "Constraint": [
            " ",
            "n",
            "o",
            " ",
            "r",
            "e",
            "p",
            "e",
            "t",
            "i",
            "t",
            "i",
            "o",
            "n",
            "s",
            " ",
            "a",
            "l",
            "l",
            "o",
            "w",
            "e",
            "d",
            " ",
            "i",
            "n",
            " ",
            "k",
            "e",
            "y",
            "A",
            "t",
            "t",
            "r",
            "i",
            "b",
            "u",
            "t",
            "e",
            "s",
            "[",
            "'",
            ">",
            " ",
            " ",
            "*",
            "*",
            "I",
            "s",
            "s",
            "u",
            "e",
            "*",
            "*",
            ":",
            " ",
            "i",
            "n",
            "t",
            "r",
            "o",
            "d",
            "u",
            "c",
            "e",
            " ",
            "P",
            "u",
            "r",
            "e",
            "L",
            "i",
            "s",
            "t",
            "s",
            "?",
            "'",
            "]"
          ]
        }
      ],
      "Annotation": [
        {
          "_type": "Annotation",
          "Issue_raw": [
            " need ascending descending to support index keys or ordering keys.[]"
          ],
          "Issue": [
            " need ascending descending to support index keys or ordering keys.[]"
          ]
        }
      ]
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ **UniqueKey** - a list of attributes on which instances of the base class may be keyed.[]
RoundTrip Class_Head: input is - '_ **UniqueKey** - a list of attributes on which instances of the base class may be keyed.[]'
RoundTrip Class_Head: value is - {'name': 'UniqueKey', 'one_liner': 'a list of attributes on which instances of the base class may be keyed.[]', 'parenthetical': ''}
OK. {'name': 'UniqueKey', 'one_liner': 'a list of attributes on which instances of the base class may be keyed.[]', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'UniqueKey - a list of attributes on which instances of the base class may be keyed.[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **UniqueKey** - a list of attributes on which instances of the base class may be keyed.[]
		=parse=> {'name': 'UniqueKey', 'one_liner': 'a list of attributes on which instances of the base class may be keyed.[]', 'parenthetical': ''} 
		=render=> UniqueKey - a list of attributes on which instances of the base class may be keyed.[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for SUBTYPE_OF: Subtype of: Key
RoundTrip SUBTYPE_OF: input is - ' Key[]'
parse_name_list:  Key[]
RoundTrip SUBTYPE_OF: value is - ['Key[]']
validating name list:  ['Key[]']
OK. ['Key[]'] ok for SUBTYPE_OF
RoundTrip SUBTYPE_OF: renders as - 'Key[]'
parse_name_list: Key[]
RoundTrip SUBTYPE_OF: reparses as - ['Key[]']
RoundTrip SUCCESS:  Key[]
		=parse=> ['Key[]'] 
		=render=> Key[] 
		=parse=> ['Key[]']
adding non raw value. Subtype of -. ['Key[]']
{
  "Subtype of_raw": " Key[]",
  "Subtype of": [
    "Key[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Subtype of_raw': ' Key[]', 'Subtype of': ['Key[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for NOTE: Note: order unimportant for Unique Keys.
RoundTrip NOTE: input is - ' order unimportant for Unique Keys.[]'
RoundTrip NOTE: value is -  order unimportant for Unique Keys.[]
OK.  order unimportant for Unique Keys.[] ok for NOTE
RoundTrip NOTE: renders as - ' order unimportant for Unique Keys.[]'
RoundTrip NOTE: reparses as -  order unimportant for Unique Keys.[]
RoundTrip SUCCESS:  order unimportant for Unique Keys.[]
		=parse=>  order unimportant for Unique Keys.[] 
		=render=>  order unimportant for Unique Keys.[] 
		=parse=>  order unimportant for Unique Keys.[]
adding non raw value. Note -.  order unimportant for Unique Keys.[]
{
  "Note_raw": " order unimportant for Unique Keys.[]",
  "Note": " order unimportant for Unique Keys.[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Note_raw': ' order unimportant for Unique Keys.[]', 'Note': ' order unimportant for Unique Keys.[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **UniqueKey** - a list of attributes on which instances of the base class may be keyed.
_ _ SUBTYPE_OF: Subtype of: Key
_ _ BLANK_LINE: 
. . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ NOTE: Note: order unimportant for Unique Keys.
_ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **UniqueKey** - a list of attributes on which instances of the base class may be keyed.[]",
  "name": "UniqueKey",
  "one_liner": "a list of attributes on which instances of the base class may be keyed.[]",
  "parenthetical": "",
  "Subtype of_raw": [
    " Key[]"
  ],
  "Subtype of": [
    "Key[]"
  ],
  "Annotation": [
    {
      "_type": "Annotation",
      "Note_raw": [
        " order unimportant for Unique Keys.[]"
      ],
      "Note": [
        " order unimportant for Unique Keys.[]"
      ]
    }
  ]
}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Section2
		Full header is: ## Attributes[]
RoundTrip Section2_Head: input is - '## Attributes[]'
RoundTrip Section2_Head: value is - {'name': 'Attributes[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Attributes[]', 'one_liner': '', 'parenthetical': ''} ok for Section2_Head
RoundTrip Section2_Head: renders as - 'Attributes[]'
RoundTrip Section2_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: ## Attributes[]
		=parse=> {'name': 'Attributes[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Attributes[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
DerivingDict for Part:  Class
		Full header is: _ **Attribute Section** - a group of attributes for a class that merit a shared explanation.[]
RoundTrip Class_Head: input is - '_ **Attribute Section** - a group of attributes for a class that merit a shared explanation.[]'
RoundTrip Class_Head: value is - {'name': 'Attribute Section', 'one_liner': 'a group of attributes for a class that merit a shared explanation.[]', 'parenthetical': ''}
OK. {'name': 'Attribute Section', 'one_liner': 'a group of attributes for a class that merit a shared explanation.[]', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Attribute Section - a group of attributes for a class that merit a shared explanation.[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **Attribute Section** - a group of attributes for a class that merit a shared explanation.[]
		=parse=> {'name': 'Attribute Section', 'one_liner': 'a group of attributes for a class that merit a shared explanation.[]', 'parenthetical': ''} 
		=render=> Attribute Section - a group of attributes for a class that merit a shared explanation.[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for SUBTYPE_OF: ***SubtypeOf***: Component.
RoundTrip SUBTYPE_OF: input is - ' Component.[]'
parse_name_list:  Component.[]
RoundTrip SUBTYPE_OF: value is - ['Component.[]']
validating name list:  ['Component.[]']
OK. ['Component.[]'] ok for SUBTYPE_OF
RoundTrip SUBTYPE_OF: renders as - 'Component.[]'
parse_name_list: Component.[]
RoundTrip SUBTYPE_OF: reparses as - ['Component.[]']
RoundTrip SUCCESS:  Component.[]
		=parse=> ['Component.[]'] 
		=render=> Component.[] 
		=parse=> ['Component.[]']
adding non raw value. ***SubtypeOf*** -. ['Component.[]']
{
  "***SubtypeOf***_raw": " Component.[]",
  "***SubtypeOf***": [
    "Component.[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***SubtypeOf***_raw': ' Component.[]', '***SubtypeOf***': ['Component.[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for BASED_ON: ***Based on***: Class
RoundTrip BASED_ON: input is - ' Class[]'
parse_name_list:  Class[]
RoundTrip BASED_ON: value is - ['Class[]']
validating name list:  ['Class[]']
OK. ['Class[]'] ok for BASED_ON
RoundTrip BASED_ON: renders as - 'Class[]'
parse_name_list: Class[]
RoundTrip BASED_ON: reparses as - ['Class[]']
RoundTrip SUCCESS:  Class[]
		=parse=> ['Class[]'] 
		=render=> Class[] 
		=parse=> ['Class[]']
adding non raw value. ***Based on*** -. ['Class[]']
{
  "***Based on***_raw": " Class[]",
  "***Based on***": [
    "Class[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Based on***_raw': ' Class[]', '***Based on***': ['Class[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: -	isOptional - whether the attributes in this section, taken together, are optional. (Boolean)[]
RoundTrip Attribute_Head: input is - '-	isOptional - whether the attributes in this section, taken together, are optional. (Boolean)[]'
RoundTrip Attribute_Head: value is - {'name': 'isOptional', 'one_liner': 'whether the attributes in this section, taken together, are optional.', 'parenthetical': 'Boolean'}
OK. {'name': 'isOptional', 'one_liner': 'whether the attributes in this section, taken together, are optional.', 'parenthetical': 'Boolean'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'isOptional - whether the attributes in this section, taken together, are optional. (Boolean)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: -	isOptional - whether the attributes in this section, taken together, are optional. (Boolean)[]
		=parse=> {'name': 'isOptional', 'one_liner': 'whether the attributes in this section, taken together, are optional.', 'parenthetical': 'Boolean'} 
		=render=> isOptional - whether the attributes in this section, taken together, are optional. (Boolean) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **Attribute Section** - a group of attributes for a class that merit a shared explanation.
_ _ SUBTYPE_OF: ***SubtypeOf***: Component.
_ _ BASED_ON: ***Based on***: Class
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: -	isOptional - whether the attributes in this section, taken together, are optional. (Boolean)
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **Attribute Section** - a group of attributes for a class that merit a shared explanation.[]",
  "name": "Attribute Section",
  "one_liner": "a group of attributes for a class that merit a shared explanation.[]",
  "parenthetical": "",
  "***SubtypeOf***_raw": [
    " Component.[]"
  ],
  "***SubtypeOf***": [
    "Component.[]"
  ],
  "***Based on***_raw": [
    " Class[]"
  ],
  "***Based on***": [
    "Class[]"
  ],
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "-\tisOptional - whether the attributes in this section, taken together, are optional. (Boolean)[]",
      "name": "isOptional",
      "one_liner": "whether the attributes in this section, taken together, are optional.",
      "parenthetical": "Boolean"
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _['If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.', '&nbsp;', 'But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.']
RoundTrip Class_Head: input is - '_['If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.', '&nbsp;', 'But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.']'
RoundTrip Class_Head: value is - {'name': "['If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.', '&nbsp;', 'But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.']", 'one_liner': '', 'parenthetical': ''}
OK. {'name': "['If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.', '&nbsp;', 'But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.']", 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - '['If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.', '&nbsp;', 'But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.']'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _['If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.', '&nbsp;', 'But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.']
		=parse=> {'name': "['If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.', '&nbsp;', 'But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.']", 'one_liner': '', 'parenthetical': ''} 
		=render=> ['If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.', '&nbsp;', 'But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.'] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
DerivingDict for Part:  AttributeSection
		Full header is: __***Markdown Support***[]
RoundTrip AttributeSection_Head: input is - '__***Markdown Support***[]'
RoundTrip AttributeSection_Head: value is - {'name': 'Markdown Support[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Markdown Support[]', 'one_liner': '', 'parenthetical': ''} ok for AttributeSection_Head
RoundTrip AttributeSection_Head: renders as - 'Markdown Support[]'
RoundTrip AttributeSection_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: __***Markdown Support***[]
		=parse=> {'name': 'Markdown Support[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Markdown Support[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Attribute
		Full header is: - **mdPrefix** (*[String](#string)*)[]
RoundTrip Attribute_Head: input is - '- **mdPrefix** (*[String](#string)*)[]'
RoundTrip Attribute_Head: value is - {'name': 'mdPrefix', 'one_liner': '', 'parenthetical': '*[String](#string'}
OK. {'name': 'mdPrefix', 'one_liner': '', 'parenthetical': '*[String](#string'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'mdPrefix (*[String](#string)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **mdPrefix** (*[String](#string)*)[]
		=parse=> {'name': 'mdPrefix', 'one_liner': '', 'parenthetical': '*[String](#string'} 
		=render=> mdPrefix (*[String](#string) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Default
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DEFAULT: ***Default***: "_ "
RoundTrip DEFAULT: input is - ' "_ "[]'
RoundTrip DEFAULT: value is -  "_ "[]
OK.  "_ "[] ok for DEFAULT
RoundTrip DEFAULT: renders as - ' "_ "[]'
RoundTrip DEFAULT: reparses as -  "_ "[]
RoundTrip SUCCESS:  "_ "[]
		=parse=>  "_ "[] 
		=render=>  "_ "[] 
		=parse=>  "_ "[]
adding non raw value. ***Default*** -.  "_ "[]
{
  "***Default***_raw": " \"_ \"[]",
  "***Default***": " \"_ \"[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Default***_raw': ' "_ "[]', '***Default***': ' "_ "[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **mdTopLine** (*[String](#string)*).[]
RoundTrip Attribute_Head: input is - '- **mdTopLine** (*[String](#string)*).[]'
RoundTrip Attribute_Head: value is - {'name': 'mdTopLine', 'one_liner': '', 'parenthetical': '*[String](#string'}
OK. {'name': 'mdTopLine', 'one_liner': '', 'parenthetical': '*[String](#string'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'mdTopLine (*[String](#string)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **mdTopLine** (*[String](#string)*).[]
		=parse=> {'name': 'mdTopLine', 'one_liner': '', 'parenthetical': '*[String](#string'} 
		=render=> mdTopLine (*[String](#string) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked. + &nbsp; + But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.
_ _ BLANK_LINE: 
. . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ AttributeSection_Head: __***Markdown Support***
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **mdPrefix** (*[String](#string)*)
. . . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ DEFAULT: ***Default***: "_ "
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **mdTopLine** (*[String](#string)*).
_ _ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_['If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.', '&nbsp;', 'But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.']",
  "name": "['If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.', '&nbsp;', 'But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.']",
  "one_liner": "",
  "parenthetical": "",
  "AttributeSection": [
    {
      "_type": "AttributeSection",
      "full_header": "__***Markdown Support***[]",
      "name": "Markdown Support[]",
      "one_liner": "",
      "parenthetical": "",
      "Attribute": [
        {
          "_type": "Attribute",
          "full_header": "- **mdPrefix** (*[String](#string)*)[]",
          "name": "mdPrefix",
          "one_liner": "",
          "parenthetical": "*[String](#string",
          "Default": [
            {
              "_type": "Default",
              "***Default***_raw": [
                " \"_ \"[]"
              ],
              "***Default***": " \"_ \"[]"
            }
          ]
        },
        {
          "_type": "Attribute",
          "full_header": "- **mdTopLine** (*[String](#string)*).[]",
          "name": "mdTopLine",
          "one_liner": "",
          "parenthetical": "*[String](#string"
        }
      ]
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ **Attribute**['A property or characteristic of a class']
RoundTrip Class_Head: input is - '_ **Attribute**['A property or characteristic of a class']'
RoundTrip Class_Head: value is - {'name': "Attribute['A property or characteristic of a class']", 'one_liner': '', 'parenthetical': ''}
OK. {'name': "Attribute['A property or characteristic of a class']", 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Attribute['A property or characteristic of a class']'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **Attribute**['A property or characteristic of a class']
		=parse=> {'name': "Attribute['A property or characteristic of a class']", 'one_liner': '', 'parenthetical': ''} 
		=render=> Attribute['A property or characteristic of a class'] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for PLURAL: _Plural:_ Attributes
RoundTrip PLURAL: input is - '_ Attributes[]'
RoundTrip PLURAL: value is - _ Attributes[]
OK. _ Attributes[] ok for PLURAL
RoundTrip PLURAL: renders as - '_ Attributes[]'
RoundTrip PLURAL: reparses as - _ Attributes[]
RoundTrip SUCCESS: _ Attributes[]
		=parse=> _ Attributes[] 
		=render=> _ Attributes[] 
		=parse=> _ Attributes[]
adding non raw value. _Plural -. _ Attributes[]
{
  "_Plural_raw": "_ Attributes[]",
  "_Plural": "_ Attributes[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'_Plural_raw': '_ Attributes[]', '_Plural': '_ Attributes[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **Attribute**A property or characteristic of a class
_ _ PLURAL: _Plural:_ Attributes
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **Attribute**['A property or characteristic of a class']",
  "name": "Attribute['A property or characteristic of a class']",
  "one_liner": "",
  "parenthetical": "",
  "_Plural_raw": [
    "_ Attributes[]"
  ],
  "_Plural": "_ Attributes[]"
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _Subtype of:_ Component[]
RoundTrip Class_Head: input is - '_Subtype of:_ Component[]'
RoundTrip Class_Head: value is - {'name': 'Subtype of: Component[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Subtype of: Component[]', 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Subtype of: Component[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _Subtype of:_ Component[]
		=parse=> {'name': 'Subtype of: Component[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Subtype of: Component[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for BASED_ON: *Based on*: AttributeSection
RoundTrip BASED_ON: input is - ' AttributeSection[]'
parse_name_list:  AttributeSection[]
RoundTrip BASED_ON: value is - ['AttributeSection[]']
validating name list:  ['AttributeSection[]']
OK. ['AttributeSection[]'] ok for BASED_ON
RoundTrip BASED_ON: renders as - 'AttributeSection[]'
parse_name_list: AttributeSection[]
RoundTrip BASED_ON: reparses as - ['AttributeSection[]']
RoundTrip SUCCESS:  AttributeSection[]
		=parse=> ['AttributeSection[]'] 
		=render=> AttributeSection[] 
		=parse=> ['AttributeSection[]']
adding non raw value. *Based on* -. ['AttributeSection[]']
{
  "*Based on*_raw": " AttributeSection[]",
  "*Based on*": [
    "AttributeSection[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'*Based on*_raw': ' AttributeSection[]', '*Based on*': ['AttributeSection[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **name** - (Lower Camel).[]
RoundTrip Attribute_Head: input is - '- **name** - (Lower Camel).[]'
RoundTrip Attribute_Head: value is - {'name': 'name', 'one_liner': '', 'parenthetical': 'Lower Camel'}
OK. {'name': 'name', 'one_liner': '', 'parenthetical': 'Lower Camel'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'name (Lower Camel)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **name** - (Lower Camel).[]
		=parse=> {'name': 'name', 'one_liner': '', 'parenthetical': 'Lower Camel'} 
		=render=> name (Lower Camel) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for OVERRIDES: Overrides: CamelName
RoundTrip OVERRIDES: input is - ' CamelName[]'
RoundTrip OVERRIDES: value is - {'class_name': 'CamelName[]', 'attribute_name': ''}
OK. {'class_name': 'CamelName[]', 'attribute_name': ''} ok for OVERRIDES
RoundTrip OVERRIDES: renders as - 'CamelName[].'
RoundTrip OVERRIDES: reparses as - {'class_name': 'CamelName[]', 'attribute_name': ''}
RoundTrip SUCCESS:  CamelName[]
		=parse=> {'class_name': 'CamelName[]', 'attribute_name': ''} 
		=render=> CamelName[]. 
		=parse=> {'class_name': 'CamelName[]', 'attribute_name': ''}
adding non raw value. Overrides -. {'class_name': 'CamelName[]', 'attribute_name': ''}
{
  "Overrides_raw": " CamelName[]",
  "Overrides": {
    "class_name": "CamelName[]",
    "attribute_name": ""
  }
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Overrides_raw': ' CamelName[]', 'Overrides': {'class_name': 'CamelName[]', 'attribute_name': ''}}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **dataType** - The kind of object to which the attribute refers.  _(DataType)_['H', 'In the simplest cases, the data type will be a class. And the specifier is the just the name of that class.']
RoundTrip Attribute_Head: input is - '- **dataType** - The kind of object to which the attribute refers.  _(DataType)_['H', 'In the simplest cases, the data type will be a class. And the specifier is the just the name of that class.']'
RoundTrip Attribute_Head: value is - {'name': 'dataType', 'one_liner': 'The kind of object to which the attribute refers.  _', 'parenthetical': 'DataType'}
OK. {'name': 'dataType', 'one_liner': 'The kind of object to which the attribute refers.  _', 'parenthetical': 'DataType'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'dataType - The kind of object to which the attribute refers.  _ (DataType)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **dataType** - The kind of object to which the attribute refers.  _(DataType)_['H', 'In the simplest cases, the data type will be a class. And the specifier is the just the name of that class.']
		=parse=> {'name': 'dataType', 'one_liner': 'The kind of object to which the attribute refers.  _', 'parenthetical': 'DataType'} 
		=render=> dataType - The kind of object to which the attribute refers.  _ (DataType) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- adding TEXT para
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - List of Editions[]
RoundTrip Attribute_Head: input is - '- List of Editions[]'
RoundTrip Attribute_Head: value is - {'name': 'List of Editions[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'List of Editions[]', 'one_liner': '', 'parenthetical': ''} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'List of Editions[]'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - List of Editions[]
		=parse=> {'name': 'List of Editions[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> List of Editions[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - Set of Edition[]
RoundTrip Attribute_Head: input is - '- Set of Edition[]'
RoundTrip Attribute_Head: value is - {'name': 'Set of Edition[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Set of Edition[]', 'one_liner': '', 'parenthetical': ''} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'Set of Edition[]'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - Set of Edition[]
		=parse=> {'name': 'Set of Edition[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Set of Edition[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - ... and more complicated cases.[]
RoundTrip Attribute_Head: input is - '- ... and more complicated cases.[]'
RoundTrip Attribute_Head: value is - {'name': '... and more complicated cases.[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': '... and more complicated cases.[]', 'one_liner': '', 'parenthetical': ''} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - '... and more complicated cases.[]'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - ... and more complicated cases.[]
		=parse=> {'name': '... and more complicated cases.[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> ... and more complicated cases.[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for SEE: ***See***: the section below on Data Type Specifiers.
RoundTrip SEE: input is - ' the section below on Data Type Specifiers.[]'
RoundTrip SEE: value is -  the section below on Data Type Specifiers.[]
OK.  the section below on Data Type Specifiers.[] ok for SEE
RoundTrip SEE: renders as - ' the section below on Data Type Specifiers.[]'
RoundTrip SEE: reparses as -  the section below on Data Type Specifiers.[]
RoundTrip SUCCESS:  the section below on Data Type Specifiers.[]
		=parse=>  the section below on Data Type Specifiers.[] 
		=render=>  the section below on Data Type Specifiers.[] 
		=parse=>  the section below on Data Type Specifiers.[]
adding non raw value. ***See*** -.  the section below on Data Type Specifiers.[]
{
  "***See***_raw": " the section below on Data Type Specifiers.[]",
  "***See***": " the section below on Data Type Specifiers.[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***See***_raw': ' the section below on Data Type Specifiers.[]', '***See***': ' the section below on Data Type Specifiers.[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  AttributeSection
		Full header is: __ **Cardinalities**.[]
RoundTrip AttributeSection_Head: input is - '__ **Cardinalities**.[]'
RoundTrip AttributeSection_Head: value is - {'name': 'Cardinalities.[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Cardinalities.[]', 'one_liner': '', 'parenthetical': ''} ok for AttributeSection_Head
RoundTrip AttributeSection_Head: renders as - 'Cardinalities.[]'
RoundTrip AttributeSection_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: __ **Cardinalities**.[]
		=parse=> {'name': 'Cardinalities.[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Cardinalities.[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Attribute
		Full header is: - **isOptional** - Indicates whether the attribute must have a value for every instance of the class _(Boolean)_[]
RoundTrip Attribute_Head: input is - '- **isOptional** - Indicates whether the attribute must have a value for every instance of the class _(Boolean)_[]'
RoundTrip Attribute_Head: value is - {'name': 'isOptional', 'one_liner': 'Indicates whether the attribute must have a value for every instance of the class _', 'parenthetical': 'Boolean'}
OK. {'name': 'isOptional', 'one_liner': 'Indicates whether the attribute must have a value for every instance of the class _', 'parenthetical': 'Boolean'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'isOptional - Indicates whether the attribute must have a value for every instance of the class _ (Boolean)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **isOptional** - Indicates whether the attribute must have a value for every instance of the class _(Boolean)_[]
		=parse=> {'name': 'isOptional', 'one_liner': 'Indicates whether the attribute must have a value for every instance of the class _', 'parenthetical': 'Boolean'} 
		=render=> isOptional - Indicates whether the attribute must have a value for every instance of the class _ (Boolean) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
DerivingDict for Part:  Default
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DEFAULT: ***Default:*** False
RoundTrip DEFAULT: input is - '*** False[]'
RoundTrip DEFAULT: value is - *** False[]
OK. *** False[] ok for DEFAULT
RoundTrip DEFAULT: renders as - '*** False[]'
RoundTrip DEFAULT: reparses as - *** False[]
RoundTrip SUCCESS: *** False[]
		=parse=> *** False[] 
		=render=> *** False[] 
		=parse=> *** False[]
adding non raw value. ***Default -. *** False[]
{
  "***Default_raw": "*** False[]",
  "***Default": "*** False[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Default_raw': '*** False[]', '***Default': '*** False[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **cardinality** - The cardinality of the relationship represented by the attribute _(CardinalityCode)_[]
RoundTrip Attribute_Head: input is - '- **cardinality** - The cardinality of the relationship represented by the attribute _(CardinalityCode)_[]'
RoundTrip Attribute_Head: value is - {'name': 'cardinality', 'one_liner': 'The cardinality of the relationship represented by the attribute _', 'parenthetical': 'CardinalityCode'}
OK. {'name': 'cardinality', 'one_liner': 'The cardinality of the relationship represented by the attribute _', 'parenthetical': 'CardinalityCode'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'cardinality - The cardinality of the relationship represented by the attribute _ (CardinalityCode)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **cardinality** - The cardinality of the relationship represented by the attribute _(CardinalityCode)_[]
		=parse=> {'name': 'cardinality', 'one_liner': 'The cardinality of the relationship represented by the attribute _', 'parenthetical': 'CardinalityCode'} 
		=render=> cardinality - The cardinality of the relationship represented by the attribute _ (CardinalityCode) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
DerivingDict for Part:  Default
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DEFAULT: ***Default:***
RoundTrip DEFAULT: input is - '***[]'
RoundTrip DEFAULT: value is - ***[]
OK. ***[] ok for DEFAULT
RoundTrip DEFAULT: renders as - '***[]'
RoundTrip DEFAULT: reparses as - ***[]
RoundTrip SUCCESS: ***[]
		=parse=> ***[] 
		=render=> ***[] 
		=parse=> ***[]
adding non raw value. ***Default -. ***[]
{
  "***Default_raw": "***[]",
  "***Default": "***[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Default_raw': '***[]', '***Default': '***[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.[]
RoundTrip Attribute_Head: input is - '- For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.[]'
RoundTrip Attribute_Head: value is - {'name': 'For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.[]', 'one_liner': '', 'parenthetical': ''} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.[]'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.[]
		=parse=> {'name': 'For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.[]
RoundTrip Attribute_Head: input is - '- For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.[]'
RoundTrip Attribute_Head: value is - {'name': 'For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.[]', 'one_liner': '', 'parenthetical': ''} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.[]'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.[]
		=parse=> {'name': 'For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- skipping BLANK_LINE
--- skipping BLANK_LINE
--- adding TEXT para
--- adding TEXT para
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - author (1:1 Author)[]
RoundTrip Attribute_Head: input is - '- author (1:1 Author)[]'
RoundTrip Attribute_Head: value is - {'name': 'author', 'one_liner': '', 'parenthetical': '1:1 Author'}
OK. {'name': 'author', 'one_liner': '', 'parenthetical': '1:1 Author'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'author (1:1 Author)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - author (1:1 Author)[]
		=parse=> {'name': 'author', 'one_liner': '', 'parenthetical': '1:1 Author'} 
		=render=> author (1:1 Author) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - books (optional N:M Set of Books)[]
RoundTrip Attribute_Head: input is - '- books (optional N:M Set of Books)[]'
RoundTrip Attribute_Head: value is - {'name': 'books', 'one_liner': '', 'parenthetical': 'optional N:M Set of Books'}
OK. {'name': 'books', 'one_liner': '', 'parenthetical': 'optional N:M Set of Books'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'books (optional N:M Set of Books)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - books (optional N:M Set of Books)[]
		=parse=> {'name': 'books', 'one_liner': '', 'parenthetical': 'optional N:M Set of Books'} 
		=render=> books (optional N:M Set of Books) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for NOTE: ***Note***: how this works with optionality
RoundTrip NOTE: input is - ' how this works with optionality[]'
RoundTrip NOTE: value is -  how this works with optionality[]
OK.  how this works with optionality[] ok for NOTE
RoundTrip NOTE: renders as - ' how this works with optionality[]'
RoundTrip NOTE: reparses as -  how this works with optionality[]
RoundTrip SUCCESS:  how this works with optionality[]
		=parse=>  how this works with optionality[] 
		=render=>  how this works with optionality[] 
		=parse=>  how this works with optionality[]
adding non raw value. ***Note*** -.  how this works with optionality[]
{
  "***Note***_raw": " how this works with optionality[]",
  "***Note***": " how this works with optionality[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Note***_raw': ' how this works with optionality[]', '***Note***': ' how this works with optionality[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  AttributeSection
		Full header is: __ ***Inverse Attributes***[]
RoundTrip AttributeSection_Head: input is - '__ ***Inverse Attributes***[]'
RoundTrip AttributeSection_Head: value is - {'name': 'Inverse Attributes[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Inverse Attributes[]', 'one_liner': '', 'parenthetical': ''} ok for AttributeSection_Head
RoundTrip AttributeSection_Head: renders as - 'Inverse Attributes[]'
RoundTrip AttributeSection_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: __ ***Inverse Attributes***[]
		=parse=> {'name': 'Inverse Attributes[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Inverse Attributes[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Attribute
		Full header is: - **isInvertible** - (Boolean)[]
RoundTrip Attribute_Head: input is - '- **isInvertible** - (Boolean)[]'
RoundTrip Attribute_Head: value is - {'name': 'isInvertible', 'one_liner': '', 'parenthetical': 'Boolean'}
OK. {'name': 'isInvertible', 'one_liner': '', 'parenthetical': 'Boolean'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'isInvertible (Boolean)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **isInvertible** - (Boolean)[]
		=parse=> {'name': 'isInvertible', 'one_liner': '', 'parenthetical': 'Boolean'} 
		=render=> isInvertible (Boolean) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Derivation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DERIVATION: ***Derivation***: true if the data type is a class or a simple collection of members of a class.
RoundTrip DERIVATION: input is - ' true if the data type is a class or a simple collection of members of a class.[]'
RoundTrip DERIVATION: value is -  true if the data type is a class or a simple collection of members of a class.[]
OK.  true if the data type is a class or a simple collection of members of a class.[] ok for DERIVATION
RoundTrip DERIVATION: renders as - ' true if the data type is a class or a simple collection of members of a class.[]'
RoundTrip DERIVATION: reparses as -  true if the data type is a class or a simple collection of members of a class.[]
RoundTrip SUCCESS:  true if the data type is a class or a simple collection of members of a class.[]
		=parse=>  true if the data type is a class or a simple collection of members of a class.[] 
		=render=>  true if the data type is a class or a simple collection of members of a class.[] 
		=parse=>  true if the data type is a class or a simple collection of members of a class.[]
adding non raw value. ***Derivation*** -.  true if the data type is a class or a simple collection of members of a class.[]
{
  "***Derivation***_raw": " true if the data type is a class or a simple collection of members of a class.[]",
  "***Derivation***": " true if the data type is a class or a simple collection of members of a class.[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Derivation***_raw': ' true if the data type is a class or a simple collection of members of a class.[]', '***Derivation***': ' true if the data type is a class or a simple collection of members of a class.[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **inverseClass** - the class which contains, or would contain the inverse attribute (optional Class)[]
RoundTrip Attribute_Head: input is - '- **inverseClass** - the class which contains, or would contain the inverse attribute (optional Class)[]'
RoundTrip Attribute_Head: value is - {'name': 'inverseClass', 'one_liner': 'the class which contains, or would contain the inverse attribute', 'parenthetical': 'optional Class'}
OK. {'name': 'inverseClass', 'one_liner': 'the class which contains, or would contain the inverse attribute', 'parenthetical': 'optional Class'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'inverseClass - the class which contains, or would contain the inverse attribute (optional Class)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **inverseClass** - the class which contains, or would contain the inverse attribute (optional Class)[]
		=parse=> {'name': 'inverseClass', 'one_liner': 'the class which contains, or would contain the inverse attribute', 'parenthetical': 'optional Class'} 
		=render=> inverseClass - the class which contains, or would contain the inverse attribute (optional Class) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Derivation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for DERIVATION: ***Derivation***: from the data type. Null unless arrribute is invertible.
RoundTrip DERIVATION: input is - ' from the data type. Null unless arrribute is invertible.[]'
RoundTrip DERIVATION: value is -  from the data type. Null unless arrribute is invertible.[]
OK.  from the data type. Null unless arrribute is invertible.[] ok for DERIVATION
RoundTrip DERIVATION: renders as - ' from the data type. Null unless arrribute is invertible.[]'
RoundTrip DERIVATION: reparses as -  from the data type. Null unless arrribute is invertible.[]
RoundTrip SUCCESS:  from the data type. Null unless arrribute is invertible.[]
		=parse=>  from the data type. Null unless arrribute is invertible.[] 
		=render=>  from the data type. Null unless arrribute is invertible.[] 
		=parse=>  from the data type. Null unless arrribute is invertible.[]
adding non raw value. ***Derivation*** -.  from the data type. Null unless arrribute is invertible.[]
{
  "***Derivation***_raw": " from the data type. Null unless arrribute is invertible.[]",
  "***Derivation***": " from the data type. Null unless arrribute is invertible.[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Derivation***_raw': ' from the data type. Null unless arrribute is invertible.[]', '***Derivation***': ' from the data type. Null unless arrribute is invertible.[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **inverseAttribute** - (optional Attribute)[]
RoundTrip Attribute_Head: input is - '- **inverseAttribute** - (optional Attribute)[]'
RoundTrip Attribute_Head: value is - {'name': 'inverseAttribute', 'one_liner': '', 'parenthetical': 'optional Attribute'}
OK. {'name': 'inverseAttribute', 'one_liner': '', 'parenthetical': 'optional Attribute'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'inverseAttribute (optional Attribute)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **inverseAttribute** - (optional Attribute)[]
		=parse=> {'name': 'inverseAttribute', 'one_liner': '', 'parenthetical': 'optional Attribute'} 
		=render=> inverseAttribute (optional Attribute) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **inverseIsOptional** - (optional Attribute)[]
RoundTrip Attribute_Head: input is - '- **inverseIsOptional** - (optional Attribute)[]'
RoundTrip Attribute_Head: value is - {'name': 'inverseIsOptional', 'one_liner': '', 'parenthetical': 'optional Attribute'}
OK. {'name': 'inverseIsOptional', 'one_liner': '', 'parenthetical': 'optional Attribute'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'inverseIsOptional (optional Attribute)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **inverseIsOptional** - (optional Attribute)[]
		=parse=> {'name': 'inverseIsOptional', 'one_liner': '', 'parenthetical': 'optional Attribute'} 
		=render=> inverseIsOptional (optional Attribute) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _Subtype of:_ Component
_ _ BASED_ON: *Based on*: AttributeSection
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **name** - (Lower Camel).
_ _ _ OVERRIDES: Overrides: CamelName
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **dataType** - The kind of object to which the attribute refers.  _(DataType)_H + In the simplest cases, the data type will be a class. And the specifier is the just the name of that class.
_ _ _ BLANK_LINE: 
_ _ _ TEXT_LINE: But,
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - List of Editions
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - Set of Edition
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - ... and more complicated cases.
. . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ SEE: ***See***: the section below on Data Type Specifiers.
_ _ _ _ BLANK_LINE: 
. . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ AttributeSection_Head: __ **Cardinalities**.
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **isOptional** - Indicates whether the attribute must have a value for every instance of the class _(Boolean)_
_ _ _ _ BLANK_LINE: 
. . . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ DEFAULT: ***Default:*** False
_ _ _ _ _ BLANK_LINE: 
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **cardinality** - The cardinality of the relationship represented by the attribute _(CardinalityCode)_
_ _ _ _ BLANK_LINE: 
. . . . Default - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ DEFAULT: ***Default:***
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
_ _ _ _ TEXT_LINE: ***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.
_ _ _ _ TEXT_LINE: For example:
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - author (1:1 Author)
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - books (optional N:M Set of Books)
_ _ _ _ BLANK_LINE: 
. . . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ NOTE: ***Note***: how this works with optionality
_ _ _ _ _ BLANK_LINE: 
. . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ AttributeSection_Head: __ ***Inverse Attributes***
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **isInvertible** - (Boolean)
. . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ DERIVATION: ***Derivation***: true if the data type is a class or a simple collection of members of a class.
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **inverseClass** - the class which contains, or would contain the inverse attribute (optional Class)
. . . . Derivation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ _ DERIVATION: ***Derivation***: from the data type. Null unless arrribute is invertible.
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **inverseAttribute** - (optional Attribute)
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - **inverseIsOptional** - (optional Attribute)
_ _ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_Subtype of:_ Component[]",
  "name": "Subtype of: Component[]",
  "one_liner": "",
  "parenthetical": "",
  "*Based on*_raw": [
    " AttributeSection[]"
  ],
  "*Based on*": [
    "AttributeSection[]"
  ],
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "- **name** - (Lower Camel).[]",
      "name": "name",
      "one_liner": "",
      "parenthetical": "Lower Camel",
      "Overrides_raw": [
        " CamelName[]"
      ],
      "Overrides": {
        "class_name": "CamelName[]",
        "attribute_name": ""
      }
    },
    {
      "_type": "Attribute",
      "full_header": "- **dataType** - The kind of object to which the attribute refers.  _(DataType)_['H', 'In the simplest cases, the data type will be a class. And the specifier is the just the name of that class.']",
      "name": "dataType",
      "one_liner": "The kind of object to which the attribute refers.  _",
      "parenthetical": "DataType"
    },
    {
      "_type": "Attribute",
      "full_header": "- List of Editions[]",
      "name": "List of Editions[]",
      "one_liner": "",
      "parenthetical": ""
    },
    {
      "_type": "Attribute",
      "full_header": "- Set of Edition[]",
      "name": "Set of Edition[]",
      "one_liner": "",
      "parenthetical": ""
    },
    {
      "_type": "Attribute",
      "full_header": "- ... and more complicated cases.[]",
      "name": "... and more complicated cases.[]",
      "one_liner": "",
      "parenthetical": "",
      "Annotation": [
        {
          "_type": "Annotation",
          "***See***_raw": [
            " the section below on Data Type Specifiers.[]"
          ],
          "***See***": [
            " the section below on Data Type Specifiers.[]"
          ]
        }
      ]
    }
  ],
  "AttributeSection": [
    {
      "_type": "AttributeSection",
      "full_header": "__ **Cardinalities**.[]",
      "name": "Cardinalities.[]",
      "one_liner": "",
      "parenthetical": "",
      "Attribute": [
        {
          "_type": "Attribute",
          "full_header": "- **isOptional** - Indicates whether the attribute must have a value for every instance of the class _(Boolean)_[]",
          "name": "isOptional",
          "one_liner": "Indicates whether the attribute must have a value for every instance of the class _",
          "parenthetical": "Boolean",
          "Default": [
            {
              "_type": "Default",
              "***Default_raw": [
                "*** False[]"
              ],
              "***Default": "*** False[]"
            }
          ]
        },
        {
          "_type": "Attribute",
          "full_header": "- **cardinality** - The cardinality of the relationship represented by the attribute _(CardinalityCode)_[]",
          "name": "cardinality",
          "one_liner": "The cardinality of the relationship represented by the attribute _",
          "parenthetical": "CardinalityCode",
          "Default": [
            {
              "_type": "Default",
              "***Default_raw": [
                "***[]"
              ],
              "***Default": "***[]"
            }
          ]
        },
        {
          "_type": "Attribute",
          "full_header": "- For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.[]",
          "name": "For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.[]",
          "one_liner": "",
          "parenthetical": ""
        },
        {
          "_type": "Attribute",
          "full_header": "- For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.[]",
          "name": "For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.[]",
          "one_liner": "",
          "parenthetical": ""
        },
        {
          "_type": "Attribute",
          "full_header": "- author (1:1 Author)[]",
          "name": "author",
          "one_liner": "",
          "parenthetical": "1:1 Author"
        },
        {
          "_type": "Attribute",
          "full_header": "- books (optional N:M Set of Books)[]",
          "name": "books",
          "one_liner": "",
          "parenthetical": "optional N:M Set of Books",
          "Annotation": [
            {
              "_type": "Annotation",
              "***Note***_raw": [
                " how this works with optionality[]"
              ],
              "***Note***": [
                " how this works with optionality[]"
              ]
            }
          ]
        }
      ]
    },
    {
      "_type": "AttributeSection",
      "full_header": "__ ***Inverse Attributes***[]",
      "name": "Inverse Attributes[]",
      "one_liner": "",
      "parenthetical": "",
      "Attribute": [
        {
          "_type": "Attribute",
          "full_header": "- **isInvertible** - (Boolean)[]",
          "name": "isInvertible",
          "one_liner": "",
          "parenthetical": "Boolean",
          "Derivation": [
            {
              "_type": "Derivation",
              "***Derivation***_raw": [
                " true if the data type is a class or a simple collection of members of a class.[]"
              ],
              "***Derivation***": " true if the data type is a class or a simple collection of members of a class.[]"
            }
          ]
        },
        {
          "_type": "Attribute",
          "full_header": "- **inverseClass** - the class which contains, or would contain the inverse attribute (optional Class)[]",
          "name": "inverseClass",
          "one_liner": "the class which contains, or would contain the inverse attribute",
          "parenthetical": "optional Class",
          "Derivation": [
            {
              "_type": "Derivation",
              "***Derivation***_raw": [
                " from the data type. Null unless arrribute is invertible.[]"
              ],
              "***Derivation***": " from the data type. Null unless arrribute is invertible.[]"
            }
          ]
        },
        {
          "_type": "Attribute",
          "full_header": "- **inverseAttribute** - (optional Attribute)[]",
          "name": "inverseAttribute",
          "one_liner": "",
          "parenthetical": "optional Attribute"
        },
        {
          "_type": "Attribute",
          "full_header": "- **inverseIsOptional** - (optional Attribute)[]",
          "name": "inverseIsOptional",
          "one_liner": "",
          "parenthetical": "optional Attribute"
        }
      ]
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ ***Formulas***[]
RoundTrip Class_Head: input is - '_ ***Formulas***[]'
RoundTrip Class_Head: value is - {'name': 'Formulas[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Formulas[]', 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Formulas[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ ***Formulas***[]
		=parse=> {'name': 'Formulas[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Formulas[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
DerivingDict for Part:  Attribute
		Full header is: - **default** - The rule or formula for calculating the value, if no value is supplied _(Derivation, optional)_[]
RoundTrip Attribute_Head: input is - '- **default** - The rule or formula for calculating the value, if no value is supplied _(Derivation, optional)_[]'
RoundTrip Attribute_Head: value is - {'name': 'default', 'one_liner': 'The rule or formula for calculating the value, if no value is supplied _', 'parenthetical': 'Derivation, optional'}
OK. {'name': 'default', 'one_liner': 'The rule or formula for calculating the value, if no value is supplied _', 'parenthetical': 'Derivation, optional'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'default - The rule or formula for calculating the value, if no value is supplied _ (Derivation, optional)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **default** - The rule or formula for calculating the value, if no value is supplied _(Derivation, optional)_[]
		=parse=> {'name': 'default', 'one_liner': 'The rule or formula for calculating the value, if no value is supplied _', 'parenthetical': 'Derivation, optional'} 
		=render=> default - The rule or formula for calculating the value, if no value is supplied _ (Derivation, optional) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for NOTE: Note: even when an Attribute has a default derivation, theres no guarantee that every instance will have an assigned value. Example needed.
RoundTrip NOTE: input is - ' even when an Attribute has a default derivation, theres no guarantee that every instance will have an assigned value. Example needed.[]'
RoundTrip NOTE: value is -  even when an Attribute has a default derivation, theres no guarantee that every instance will have an assigned value. Example needed.[]
OK.  even when an Attribute has a default derivation, theres no guarantee that every instance will have an assigned value. Example needed.[] ok for NOTE
RoundTrip NOTE: renders as - ' even when an Attribute has a default derivation, theres no guarantee that every instance will have an assigned value. Example needed.[]'
RoundTrip NOTE: reparses as -  even when an Attribute has a default derivation, theres no guarantee that every instance will have an assigned value. Example needed.[]
RoundTrip SUCCESS:  even when an Attribute has a default derivation, theres no guarantee that every instance will have an assigned value. Example needed.[]
		=parse=>  even when an Attribute has a default derivation, theres no guarantee that every instance will have an assigned value. Example needed.[] 
		=render=>  even when an Attribute has a default derivation, theres no guarantee that every instance will have an assigned value. Example needed.[] 
		=parse=>  even when an Attribute has a default derivation, theres no guarantee that every instance will have an assigned value. Example needed.[]
adding non raw value. Note -.  even when an Attribute has a default derivation, theres no guarantee that every instance will have an assigned value. Example needed.[]
{
  "Note_raw": " even when an Attribute has a default derivation, there\u2019s no guarantee that every instance will have an assigned value. Example needed.[]",
  "Note": " even when an Attribute has a default derivation, there\u2019s no guarantee that every instance will have an assigned value. Example needed.[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Note_raw': ' even when an Attribute has a default derivation, theres no guarantee that every instance will have an assigned value. Example needed.[]', 'Note': ' even when an Attribute has a default derivation, theres no guarantee that every instance will have an assigned value. Example needed.[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **derivation** - For derived attributes, the rule or formula for calculating the value _(Derivation, optional)_[]
RoundTrip Attribute_Head: input is - '- **derivation** - For derived attributes, the rule or formula for calculating the value _(Derivation, optional)_[]'
RoundTrip Attribute_Head: value is - {'name': 'derivation', 'one_liner': 'For derived attributes, the rule or formula for calculating the value _', 'parenthetical': 'Derivation, optional'}
OK. {'name': 'derivation', 'one_liner': 'For derived attributes, the rule or formula for calculating the value _', 'parenthetical': 'Derivation, optional'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'derivation - For derived attributes, the rule or formula for calculating the value _ (Derivation, optional)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **derivation** - For derived attributes, the rule or formula for calculating the value _(Derivation, optional)_[]
		=parse=> {'name': 'derivation', 'one_liner': 'For derived attributes, the rule or formula for calculating the value _', 'parenthetical': 'Derivation, optional'} 
		=render=> derivation - For derived attributes, the rule or formula for calculating the value _ (Derivation, optional) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for ISSUE: ***Issue***: on insert vs on access?
RoundTrip ISSUE: input is - ' on insert vs on access?[]'
RoundTrip ISSUE: value is -  on insert vs on access?[]
OK.  on insert vs on access?[] ok for ISSUE
RoundTrip ISSUE: renders as - ' on insert vs on access?[]'
RoundTrip ISSUE: reparses as -  on insert vs on access?[]
RoundTrip SUCCESS:  on insert vs on access?[]
		=parse=>  on insert vs on access?[] 
		=render=>  on insert vs on access?[] 
		=parse=>  on insert vs on access?[]
adding non raw value. ***Issue*** -.  on insert vs on access?[]
{
  "***Issue***_raw": " on insert vs on access?[]",
  "***Issue***": " on insert vs on access?[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Issue***_raw': ' on insert vs on access?[]', '***Issue***': ' on insert vs on access?[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **constraints** - Any validation rules specific to this attribute _(ListOf Constraints)_[]
RoundTrip Attribute_Head: input is - '- **constraints** - Any validation rules specific to this attribute _(ListOf Constraints)_[]'
RoundTrip Attribute_Head: value is - {'name': 'constraints', 'one_liner': 'Any validation rules specific to this attribute _', 'parenthetical': 'ListOf Constraints'}
OK. {'name': 'constraints', 'one_liner': 'Any validation rules specific to this attribute _', 'parenthetical': 'ListOf Constraints'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'constraints - Any validation rules specific to this attribute _ (ListOf Constraints)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **constraints** - Any validation rules specific to this attribute _(ListOf Constraints)_[]
		=parse=> {'name': 'constraints', 'one_liner': 'Any validation rules specific to this attribute _', 'parenthetical': 'ListOf Constraints'} 
		=render=> constraints - Any validation rules specific to this attribute _ (ListOf Constraints) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for NOTE: Note: from Class.constraints
RoundTrip NOTE: input is - ' from Class.constraints[]'
RoundTrip NOTE: value is -  from Class.constraints[]
OK.  from Class.constraints[] ok for NOTE
RoundTrip NOTE: renders as - ' from Class.constraints[]'
RoundTrip NOTE: reparses as -  from Class.constraints[]
RoundTrip SUCCESS:  from Class.constraints[]
		=parse=>  from Class.constraints[] 
		=render=>  from Class.constraints[] 
		=parse=>  from Class.constraints[]
adding non raw value. Note -.  from Class.constraints[]
{
  "Note_raw": " from Class.constraints[]",
  "Note": " from Class.constraints[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Note_raw': ' from Class.constraints[]', 'Note': ' from Class.constraints[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  AttributeSection
		Full header is: __Override Tracking[]
RoundTrip AttributeSection_Head: input is - '__Override Tracking[]'
RoundTrip AttributeSection_Head: value is - {'name': 'Override Tracking[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Override Tracking[]', 'one_liner': '', 'parenthetical': ''} ok for AttributeSection_Head
RoundTrip AttributeSection_Head: renders as - 'Override Tracking[]'
RoundTrip AttributeSection_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: __Override Tracking[]
		=parse=> {'name': 'Override Tracking[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Override Tracking[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Attribute
		Full header is: - Overrides[]
RoundTrip Attribute_Head: input is - '- Overrides[]'
RoundTrip Attribute_Head: value is - {'name': 'Overrides[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Overrides[]', 'one_liner': '', 'parenthetical': ''} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'Overrides[]'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - Overrides[]
		=parse=> {'name': 'Overrides[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Overrides[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- skipping BLANK_LINE
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ ***Formulas***
_ _ BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **default** - The rule or formula for calculating the value, if no value is supplied _(Derivation, optional)_
. . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ NOTE: Note: even when an Attribute has a default derivation, theres no guarantee that every instance will have an assigned value. Example needed.
_ _ _ _ BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **derivation** - For derived attributes, the rule or formula for calculating the value _(Derivation, optional)_
. . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ ISSUE: ***Issue***: on insert vs on access?
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **constraints** - Any validation rules specific to this attribute _(ListOf Constraints)_
. . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ NOTE: Note: from Class.constraints
_ _ _ _ BLANK_LINE: 
. . AttributeSection - <class 'ldm_parse_core.DocPart'> 
_ _ _ AttributeSection_Head: __Override Tracking
. . . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ Attribute_Head: - Overrides
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ ***Formulas***[]",
  "name": "Formulas[]",
  "one_liner": "",
  "parenthetical": "",
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "- **default** - The rule or formula for calculating the value, if no value is supplied _(Derivation, optional)_[]",
      "name": "default",
      "one_liner": "The rule or formula for calculating the value, if no value is supplied _",
      "parenthetical": "Derivation, optional",
      "Annotation": [
        {
          "_type": "Annotation",
          "Note_raw": [
            " even when an Attribute has a default derivation, there\u2019s no guarantee that every instance will have an assigned value. Example needed.[]"
          ],
          "Note": [
            " even when an Attribute has a default derivation, there\u2019s no guarantee that every instance will have an assigned value. Example needed.[]"
          ]
        }
      ]
    },
    {
      "_type": "Attribute",
      "full_header": "- **derivation** - For derived attributes, the rule or formula for calculating the value _(Derivation, optional)_[]",
      "name": "derivation",
      "one_liner": "For derived attributes, the rule or formula for calculating the value _",
      "parenthetical": "Derivation, optional",
      "Annotation": [
        {
          "_type": "Annotation",
          "***Issue***_raw": [
            " on insert vs on access?[]"
          ],
          "***Issue***": [
            " on insert vs on access?[]"
          ]
        }
      ]
    },
    {
      "_type": "Attribute",
      "full_header": "- **constraints** - Any validation rules specific to this attribute _(ListOf Constraints)_[]",
      "name": "constraints",
      "one_liner": "Any validation rules specific to this attribute _",
      "parenthetical": "ListOf Constraints",
      "Annotation": [
        {
          "_type": "Annotation",
          "Note_raw": [
            " from Class.constraints[]"
          ],
          "Note": [
            " from Class.constraints[]"
          ]
        }
      ]
    }
  ],
  "AttributeSection": [
    {
      "_type": "AttributeSection",
      "full_header": "__Override Tracking[]",
      "name": "Override Tracking[]",
      "one_liner": "",
      "parenthetical": "",
      "Attribute": [
        {
          "_type": "Attribute",
          "full_header": "- Overrides[]",
          "name": "Overrides[]",
          "one_liner": "",
          "parenthetical": ""
        }
      ]
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ ***ValueType:*** **Derivation**['A rule or formula for deriving the value of an attribute']
RoundTrip Class_Head: input is - '_ ***ValueType:*** **Derivation**['A rule or formula for deriving the value of an attribute']'
RoundTrip Class_Head: value is - {'name': "ValueType: Derivation['A rule or formula for deriving the value of an attribute']", 'one_liner': '', 'parenthetical': ''}
OK. {'name': "ValueType: Derivation['A rule or formula for deriving the value of an attribute']", 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'ValueType: Derivation['A rule or formula for deriving the value of an attribute']'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ ***ValueType:*** **Derivation**['A rule or formula for deriving the value of an attribute']
		=parse=> {'name': "ValueType: Derivation['A rule or formula for deriving the value of an attribute']", 'one_liner': '', 'parenthetical': ''} 
		=render=> ValueType: Derivation['A rule or formula for deriving the value of an attribute'] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for PLURAL: _Plural:_ Derivations
RoundTrip PLURAL: input is - '_ Derivations[]'
RoundTrip PLURAL: value is - _ Derivations[]
OK. _ Derivations[] ok for PLURAL
RoundTrip PLURAL: renders as - '_ Derivations[]'
RoundTrip PLURAL: reparses as - _ Derivations[]
RoundTrip SUCCESS: _ Derivations[]
		=parse=> _ Derivations[] 
		=render=> _ Derivations[] 
		=parse=> _ Derivations[]
adding non raw value. _Plural -. _ Derivations[]
{
  "_Plural_raw": "_ Derivations[]",
  "_Plural": "_ Derivations[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'_Plural_raw': '_ Derivations[]', '_Plural': '_ Derivations[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
DerivingDict for Part:  Attribute
		Full header is: - **statement** - An English language statement of the derivation rule _(RichText)_[]
RoundTrip Attribute_Head: input is - '- **statement** - An English language statement of the derivation rule _(RichText)_[]'
RoundTrip Attribute_Head: value is - {'name': 'statement', 'one_liner': 'An English language statement of the derivation rule _', 'parenthetical': 'RichText'}
OK. {'name': 'statement', 'one_liner': 'An English language statement of the derivation rule _', 'parenthetical': 'RichText'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'statement - An English language statement of the derivation rule _ (RichText)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **statement** - An English language statement of the derivation rule _(RichText)_[]
		=parse=> {'name': 'statement', 'one_liner': 'An English language statement of the derivation rule _', 'parenthetical': 'RichText'} 
		=render=> statement - An English language statement of the derivation rule _ (RichText) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **expression** - The formal expression of the derivation in a programming language _(CodeExpression)_[]
RoundTrip Attribute_Head: input is - '- **expression** - The formal expression of the derivation in a programming language _(CodeExpression)_[]'
RoundTrip Attribute_Head: value is - {'name': 'expression', 'one_liner': 'The formal expression of the derivation in a programming language _', 'parenthetical': 'CodeExpression'}
OK. {'name': 'expression', 'one_liner': 'The formal expression of the derivation in a programming language _', 'parenthetical': 'CodeExpression'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'expression - The formal expression of the derivation in a programming language _ (CodeExpression)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **expression** - The formal expression of the derivation in a programming language _(CodeExpression)_[]
		=parse=> {'name': 'expression', 'one_liner': 'The formal expression of the derivation in a programming language _', 'parenthetical': 'CodeExpression'} 
		=render=> expression - The formal expression of the derivation in a programming language _ (CodeExpression) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- skipping BLANK_LINE
--- skipping BLANK_LINE
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ ***ValueType:*** **Derivation**A rule or formula for deriving the value of an attribute
_ _ PLURAL: _Plural:_ Derivations
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **statement** - An English language statement of the derivation rule _(RichText)_
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **expression** - The formal expression of the derivation in a programming language _(CodeExpression)_
_ _ _ BLANK_LINE: 
_ _ _ BLANK_LINE: 
_ _ _ BLANK_LINE: 
_ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ ***ValueType:*** **Derivation**['A rule or formula for deriving the value of an attribute']",
  "name": "ValueType: Derivation['A rule or formula for deriving the value of an attribute']",
  "one_liner": "",
  "parenthetical": "",
  "_Plural_raw": [
    "_ Derivations[]"
  ],
  "_Plural": "_ Derivations[]",
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "- **statement** - An English language statement of the derivation rule _(RichText)_[]",
      "name": "statement",
      "one_liner": "An English language statement of the derivation rule _",
      "parenthetical": "RichText"
    },
    {
      "_type": "Attribute",
      "full_header": "- **expression** - The formal expression of the derivation in a programming language _(CodeExpression)_[]",
      "name": "expression",
      "one_liner": "The formal expression of the derivation in a programming language _",
      "parenthetical": "CodeExpression"
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ ***ValueType:*** **Constraint**['A rule, condition, or validation that must be satisfied by the model']
RoundTrip Class_Head: input is - '_ ***ValueType:*** **Constraint**['A rule, condition, or validation that must be satisfied by the model']'
RoundTrip Class_Head: value is - {'name': "ValueType: Constraint['A rule, condition, or validation that must be satisfied by the model']", 'one_liner': '', 'parenthetical': ''}
OK. {'name': "ValueType: Constraint['A rule, condition, or validation that must be satisfied by the model']", 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'ValueType: Constraint['A rule, condition, or validation that must be satisfied by the model']'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ ***ValueType:*** **Constraint**['A rule, condition, or validation that must be satisfied by the model']
		=parse=> {'name': "ValueType: Constraint['A rule, condition, or validation that must be satisfied by the model']", 'one_liner': '', 'parenthetical': ''} 
		=render=> ValueType: Constraint['A rule, condition, or validation that must be satisfied by the model'] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for PLURAL: _Plural:_ Constraints
RoundTrip PLURAL: input is - '_ Constraints[]'
RoundTrip PLURAL: value is - _ Constraints[]
OK. _ Constraints[] ok for PLURAL
RoundTrip PLURAL: renders as - '_ Constraints[]'
RoundTrip PLURAL: reparses as - _ Constraints[]
RoundTrip SUCCESS: _ Constraints[]
		=parse=> _ Constraints[] 
		=render=> _ Constraints[] 
		=parse=> _ Constraints[]
adding non raw value. _Plural -. _ Constraints[]
{
  "_Plural_raw": "_ Constraints[]",
  "_Plural": "_ Constraints[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'_Plural_raw': '_ Constraints[]', '_Plural': '_ Constraints[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ ***ValueType:*** **Constraint**A rule, condition, or validation that must be satisfied by the model
_ _ PLURAL: _Plural:_ Constraints
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ ***ValueType:*** **Constraint**['A rule, condition, or validation that must be satisfied by the model']",
  "name": "ValueType: Constraint['A rule, condition, or validation that must be satisfied by the model']",
  "one_liner": "",
  "parenthetical": "",
  "_Plural_raw": [
    "_ Constraints[]"
  ],
  "_Plural": "_ Constraints[]"
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _Subtype of:_ Component[]
RoundTrip Class_Head: input is - '_Subtype of:_ Component[]'
RoundTrip Class_Head: value is - {'name': 'Subtype of: Component[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Subtype of: Component[]', 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Subtype of: Component[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _Subtype of:_ Component[]
		=parse=> {'name': 'Subtype of: Component[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Subtype of: Component[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Attribute
		Full header is: - **statement** - An English language statement of the constraint _(RichText)_[]
RoundTrip Attribute_Head: input is - '- **statement** - An English language statement of the constraint _(RichText)_[]'
RoundTrip Attribute_Head: value is - {'name': 'statement', 'one_liner': 'An English language statement of the constraint _', 'parenthetical': 'RichText'}
OK. {'name': 'statement', 'one_liner': 'An English language statement of the constraint _', 'parenthetical': 'RichText'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'statement - An English language statement of the constraint _ (RichText)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **statement** - An English language statement of the constraint _(RichText)_[]
		=parse=> {'name': 'statement', 'one_liner': 'An English language statement of the constraint _', 'parenthetical': 'RichText'} 
		=render=> statement - An English language statement of the constraint _ (RichText) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **expression** - The formal expression of the constraint in a programming language (e.g., OCL _(CodeExpression)_[]
RoundTrip Attribute_Head: input is - '- **expression** - The formal expression of the constraint in a programming language (e.g., OCL _(CodeExpression)_[]'
RoundTrip Attribute_Head: value is - {'name': 'expression', 'one_liner': 'The formal expression of the constraint in a programming language', 'parenthetical': 'e.g., OCL _(CodeExpression'}
OK. {'name': 'expression', 'one_liner': 'The formal expression of the constraint in a programming language', 'parenthetical': 'e.g., OCL _(CodeExpression'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'expression - The formal expression of the constraint in a programming language (e.g., OCL _(CodeExpression)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **expression** - The formal expression of the constraint in a programming language (e.g., OCL _(CodeExpression)_[]
		=parse=> {'name': 'expression', 'one_liner': 'The formal expression of the constraint in a programming language', 'parenthetical': 'e.g., OCL _(CodeExpression'} 
		=render=> expression - The formal expression of the constraint in a programming language (e.g., OCL _(CodeExpression) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **severity** -  (Code)[]
RoundTrip Attribute_Head: input is - '- **severity** -  (Code)[]'
RoundTrip Attribute_Head: value is - {'name': 'severity', 'one_liner': '', 'parenthetical': 'Code'}
OK. {'name': 'severity', 'one_liner': '', 'parenthetical': 'Code'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'severity (Code)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **severity** -  (Code)[]
		=parse=> {'name': 'severity', 'one_liner': '', 'parenthetical': 'Code'} 
		=render=> severity (Code) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: -- **Warning** - nothing fatal; just a caution[]
RoundTrip Attribute_Head: input is - '-- **Warning** - nothing fatal; just a caution[]'
RoundTrip Attribute_Head: value is - {'name': '', 'one_liner': '**Warning** - nothing fatal; just a caution[]', 'parenthetical': ''}
OK. {'name': '', 'one_liner': '**Warning** - nothing fatal; just a caution[]', 'parenthetical': ''} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'NAME? - **Warning** - nothing fatal; just a caution[]'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: -- **Warning** - nothing fatal; just a caution[]
		=parse=> {'name': '', 'one_liner': '**Warning** - nothing fatal; just a caution[]', 'parenthetical': ''} 
		=render=> NAME? - **Warning** - nothing fatal; just a caution[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: -- **Error** - serious. Fix now[]
RoundTrip Attribute_Head: input is - '-- **Error** - serious. Fix now[]'
RoundTrip Attribute_Head: value is - {'name': '', 'one_liner': '**Error** - serious. Fix now[]', 'parenthetical': ''}
OK. {'name': '', 'one_liner': '**Error** - serious. Fix now[]', 'parenthetical': ''} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'NAME? - **Error** - serious. Fix now[]'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: -- **Error** - serious. Fix now[]
		=parse=> {'name': '', 'one_liner': '**Error** - serious. Fix now[]', 'parenthetical': ''} 
		=render=> NAME? - **Error** - serious. Fix now[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **Message** - (Template)[]
RoundTrip Attribute_Head: input is - '- **Message** - (Template)[]'
RoundTrip Attribute_Head: value is - {'name': 'Message', 'one_liner': '', 'parenthetical': 'Template'}
OK. {'name': 'Message', 'one_liner': '', 'parenthetical': 'Template'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'Message (Template)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **Message** - (Template)[]
		=parse=> {'name': 'Message', 'one_liner': '', 'parenthetical': 'Template'} 
		=render=> Message (Template) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _Subtype of:_ Component
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **statement** - An English language statement of the constraint _(RichText)_
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **expression** - The formal expression of the constraint in a programming language (e.g., OCL _(CodeExpression)_
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **severity** -  (Code)
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: -- **Warning** - nothing fatal; just a caution
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: -- **Error** - serious. Fix now
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **Message** - (Template)
_ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_Subtype of:_ Component[]",
  "name": "Subtype of: Component[]",
  "one_liner": "",
  "parenthetical": "",
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "- **statement** - An English language statement of the constraint _(RichText)_[]",
      "name": "statement",
      "one_liner": "An English language statement of the constraint _",
      "parenthetical": "RichText"
    },
    {
      "_type": "Attribute",
      "full_header": "- **expression** - The formal expression of the constraint in a programming language (e.g., OCL _(CodeExpression)_[]",
      "name": "expression",
      "one_liner": "The formal expression of the constraint in a programming language",
      "parenthetical": "e.g., OCL _(CodeExpression"
    },
    {
      "_type": "Attribute",
      "full_header": "- **severity** -  (Code)[]",
      "name": "severity",
      "one_liner": "",
      "parenthetical": "Code"
    },
    {
      "_type": "Attribute",
      "full_header": "-- **Warning** - nothing fatal; just a caution[]",
      "name": "",
      "one_liner": "**Warning** - nothing fatal; just a caution[]",
      "parenthetical": ""
    },
    {
      "_type": "Attribute",
      "full_header": "-- **Error** - serious. Fix now[]",
      "name": "",
      "one_liner": "**Error** - serious. Fix now[]",
      "parenthetical": ""
    },
    {
      "_type": "Attribute",
      "full_header": "- **Message** - (Template)[]",
      "name": "Message",
      "one_liner": "",
      "parenthetical": "Template"
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ **Class Constraint**[]
RoundTrip Class_Head: input is - '_ **Class Constraint**[]'
RoundTrip Class_Head: value is - {'name': 'Class Constraint[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Class Constraint[]', 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Class Constraint[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **Class Constraint**[]
		=parse=> {'name': 'Class Constraint[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Class Constraint[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for SUBTYPE_OF: **Subtype of**: Constraint
RoundTrip SUBTYPE_OF: input is - ' Constraint[]'
parse_name_list:  Constraint[]
RoundTrip SUBTYPE_OF: value is - ['Constraint[]']
validating name list:  ['Constraint[]']
OK. ['Constraint[]'] ok for SUBTYPE_OF
RoundTrip SUBTYPE_OF: renders as - 'Constraint[]'
parse_name_list: Constraint[]
RoundTrip SUBTYPE_OF: reparses as - ['Constraint[]']
RoundTrip SUCCESS:  Constraint[]
		=parse=> ['Constraint[]'] 
		=render=> Constraint[] 
		=parse=> ['Constraint[]']
adding non raw value. **Subtype of** -. ['Constraint[]']
{
  "**Subtype of**_raw": " Constraint[]",
  "**Subtype of**": [
    "Constraint[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'**Subtype of**_raw': ' Constraint[]', '**Subtype of**': ['Constraint[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for BASED_ON: ***Based on***: Class.
RoundTrip BASED_ON: input is - ' Class.[]'
parse_name_list:  Class.[]
RoundTrip BASED_ON: value is - ['Class.[]']
validating name list:  ['Class.[]']
OK. ['Class.[]'] ok for BASED_ON
RoundTrip BASED_ON: renders as - 'Class.[]'
parse_name_list: Class.[]
RoundTrip BASED_ON: reparses as - ['Class.[]']
RoundTrip SUCCESS:  Class.[]
		=parse=> ['Class.[]'] 
		=render=> Class.[] 
		=parse=> ['Class.[]']
adding non raw value. ***Based on*** -. ['Class.[]']
{
  "***Based on***_raw": " Class.[]",
  "***Based on***": [
    "Class.[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Based on***_raw': ' Class.[]', '***Based on***': ['Class.[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **Class Constraint**
_ _ SUBTYPE_OF: **Subtype of**: Constraint
_ _ BASED_ON: ***Based on***: Class.
_ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **Class Constraint**[]",
  "name": "Class Constraint[]",
  "one_liner": "",
  "parenthetical": "",
  "**Subtype of**_raw": [
    " Constraint[]"
  ],
  "**Subtype of**": [
    "Constraint[]"
  ],
  "***Based on***_raw": [
    " Class.[]"
  ],
  "***Based on***": [
    "Class.[]"
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ **Attribute Constraint**[]
RoundTrip Class_Head: input is - '_ **Attribute Constraint**[]'
RoundTrip Class_Head: value is - {'name': 'Attribute Constraint[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Attribute Constraint[]', 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Attribute Constraint[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **Attribute Constraint**[]
		=parse=> {'name': 'Attribute Constraint[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Attribute Constraint[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for SUBTYPE_OF: ***Subtype of***: Constraint
RoundTrip SUBTYPE_OF: input is - ' Constraint[]'
parse_name_list:  Constraint[]
RoundTrip SUBTYPE_OF: value is - ['Constraint[]']
validating name list:  ['Constraint[]']
OK. ['Constraint[]'] ok for SUBTYPE_OF
RoundTrip SUBTYPE_OF: renders as - 'Constraint[]'
parse_name_list: Constraint[]
RoundTrip SUBTYPE_OF: reparses as - ['Constraint[]']
RoundTrip SUCCESS:  Constraint[]
		=parse=> ['Constraint[]'] 
		=render=> Constraint[] 
		=parse=> ['Constraint[]']
adding non raw value. ***Subtype of*** -. ['Constraint[]']
{
  "***Subtype of***_raw": " Constraint[]",
  "***Subtype of***": [
    "Constraint[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Subtype of***_raw': ' Constraint[]', '***Subtype of***': ['Constraint[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for BASED_ON: ***Based on***: Attribute
RoundTrip BASED_ON: input is - ' Attribute[]'
parse_name_list:  Attribute[]
RoundTrip BASED_ON: value is - ['Attribute[]']
validating name list:  ['Attribute[]']
OK. ['Attribute[]'] ok for BASED_ON
RoundTrip BASED_ON: renders as - 'Attribute[]'
parse_name_list: Attribute[]
RoundTrip BASED_ON: reparses as - ['Attribute[]']
RoundTrip SUCCESS:  Attribute[]
		=parse=> ['Attribute[]'] 
		=render=> Attribute[] 
		=parse=> ['Attribute[]']
adding non raw value. ***Based on*** -. ['Attribute[]']
{
  "***Based on***_raw": " Attribute[]",
  "***Based on***": [
    "Attribute[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Based on***_raw': ' Attribute[]', '***Based on***': ['Attribute[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **Attribute Constraint**
_ _ SUBTYPE_OF: ***Subtype of***: Constraint
_ _ BASED_ON: ***Based on***: Attribute
_ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **Attribute Constraint**[]",
  "name": "Attribute Constraint[]",
  "one_liner": "",
  "parenthetical": "",
  "***Subtype of***_raw": [
    " Constraint[]"
  ],
  "***Subtype of***": [
    "Constraint[]"
  ],
  "***Based on***_raw": [
    " Attribute[]"
  ],
  "***Based on***": [
    "Attribute[]"
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ **CodeExpression**[]
RoundTrip Class_Head: input is - '_ **CodeExpression**[]'
RoundTrip Class_Head: value is - {'name': 'CodeExpression[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'CodeExpression[]', 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'CodeExpression[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **CodeExpression**[]
		=parse=> {'name': 'CodeExpression[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> CodeExpression[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Attribute
		Full header is: - **Language** - the programming language (Code)[]
RoundTrip Attribute_Head: input is - '- **Language** - the programming language (Code)[]'
RoundTrip Attribute_Head: value is - {'name': 'Language', 'one_liner': 'the programming language', 'parenthetical': 'Code'}
OK. {'name': 'Language', 'one_liner': 'the programming language', 'parenthetical': 'Code'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'Language - the programming language (Code)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **Language** - the programming language (Code)[]
		=parse=> {'name': 'Language', 'one_liner': 'the programming language', 'parenthetical': 'Code'} 
		=render=> Language - the programming language (Code) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: -- OCL: Object Constraint Language[]
RoundTrip Attribute_Head: input is - '-- OCL: Object Constraint Language[]'
RoundTrip Attribute_Head: value is - {'name': '', 'one_liner': 'OCL: Object Constraint Language[]', 'parenthetical': ''}
OK. {'name': '', 'one_liner': 'OCL: Object Constraint Language[]', 'parenthetical': ''} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'NAME? - OCL: Object Constraint Language[]'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: -- OCL: Object Constraint Language[]
		=parse=> {'name': '', 'one_liner': 'OCL: Object Constraint Language[]', 'parenthetical': ''} 
		=render=> NAME? - OCL: Object Constraint Language[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: -- Java: Java[]
RoundTrip Attribute_Head: input is - '-- Java: Java[]'
RoundTrip Attribute_Head: value is - {'name': '', 'one_liner': 'Java: Java[]', 'parenthetical': ''}
OK. {'name': '', 'one_liner': 'Java: Java[]', 'parenthetical': ''} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'NAME? - Java: Java[]'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: -- Java: Java[]
		=parse=> {'name': '', 'one_liner': 'Java: Java[]', 'parenthetical': ''} 
		=render=> NAME? - Java: Java[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **Expression** (String)[]
RoundTrip Attribute_Head: input is - '- **Expression** (String)[]'
RoundTrip Attribute_Head: value is - {'name': 'Expression', 'one_liner': '', 'parenthetical': 'String'}
OK. {'name': 'Expression', 'one_liner': '', 'parenthetical': 'String'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'Expression (String)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **Expression** (String)[]
		=parse=> {'name': 'Expression', 'one_liner': '', 'parenthetical': 'String'} 
		=render=> Expression (String) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **CodeExpression**
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **Language** - the programming language (Code)
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: -- OCL: Object Constraint Language
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: -- Java: Java
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **Expression** (String)
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **CodeExpression**[]",
  "name": "CodeExpression[]",
  "one_liner": "",
  "parenthetical": "",
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "- **Language** - the programming language (Code)[]",
      "name": "Language",
      "one_liner": "the programming language",
      "parenthetical": "Code"
    },
    {
      "_type": "Attribute",
      "full_header": "-- OCL: Object Constraint Language[]",
      "name": "",
      "one_liner": "OCL: Object Constraint Language[]",
      "parenthetical": ""
    },
    {
      "_type": "Attribute",
      "full_header": "-- Java: Java[]",
      "name": "",
      "one_liner": "Java: Java[]",
      "parenthetical": ""
    },
    {
      "_type": "Attribute",
      "full_header": "- **Expression** (String)[]",
      "name": "Expression",
      "one_liner": "",
      "parenthetical": "String"
    }
  ]
}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Section2
		Full header is: ## Methods[]
RoundTrip Section2_Head: input is - '## Methods[]'
RoundTrip Section2_Head: value is - {'name': 'Methods[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Methods[]', 'one_liner': '', 'parenthetical': ''} ok for Section2_Head
RoundTrip Section2_Head: renders as - 'Methods[]'
RoundTrip Section2_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: ## Methods[]
		=parse=> {'name': 'Methods[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Methods[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Class
		Full header is: _ **Method**['A behavior or operation associated with a class']
RoundTrip Class_Head: input is - '_ **Method**['A behavior or operation associated with a class']'
RoundTrip Class_Head: value is - {'name': "Method['A behavior or operation associated with a class']", 'one_liner': '', 'parenthetical': ''}
OK. {'name': "Method['A behavior or operation associated with a class']", 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Method['A behavior or operation associated with a class']'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **Method**['A behavior or operation associated with a class']
		=parse=> {'name': "Method['A behavior or operation associated with a class']", 'one_liner': '', 'parenthetical': ''} 
		=render=> Method['A behavior or operation associated with a class'] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for PLURAL: _Plural:_ Methods
RoundTrip PLURAL: input is - '_ Methods[]'
RoundTrip PLURAL: value is - _ Methods[]
OK. _ Methods[] ok for PLURAL
RoundTrip PLURAL: renders as - '_ Methods[]'
RoundTrip PLURAL: reparses as - _ Methods[]
RoundTrip SUCCESS: _ Methods[]
		=parse=> _ Methods[] 
		=render=> _ Methods[] 
		=parse=> _ Methods[]
adding non raw value. _Plural -. _ Methods[]
{
  "_Plural_raw": "_ Methods[]",
  "_Plural": "_ Methods[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'_Plural_raw': '_ Methods[]', '_Plural': '_ Methods[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **Method**A behavior or operation associated with a class
_ _ PLURAL: _Plural:_ Methods
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **Method**['A behavior or operation associated with a class']",
  "name": "Method['A behavior or operation associated with a class']",
  "one_liner": "",
  "parenthetical": "",
  "_Plural_raw": [
    "_ Methods[]"
  ],
  "_Plural": "_ Methods[]"
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _Subtype of:_ Component[]
RoundTrip Class_Head: input is - '_Subtype of:_ Component[]'
RoundTrip Class_Head: value is - {'name': 'Subtype of: Component[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Subtype of: Component[]', 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Subtype of: Component[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _Subtype of:_ Component[]
		=parse=> {'name': 'Subtype of: Component[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Subtype of: Component[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Attribute
		Full header is: - **parameters** - The input parameters of the method _(ListOf Parameters)_[]
RoundTrip Attribute_Head: input is - '- **parameters** - The input parameters of the method _(ListOf Parameters)_[]'
RoundTrip Attribute_Head: value is - {'name': 'parameters', 'one_liner': 'The input parameters of the method _', 'parenthetical': 'ListOf Parameters'}
OK. {'name': 'parameters', 'one_liner': 'The input parameters of the method _', 'parenthetical': 'ListOf Parameters'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'parameters - The input parameters of the method _ (ListOf Parameters)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **parameters** - The input parameters of the method _(ListOf Parameters)_[]
		=parse=> {'name': 'parameters', 'one_liner': 'The input parameters of the method _', 'parenthetical': 'ListOf Parameters'} 
		=render=> parameters - The input parameters of the method _ (ListOf Parameters) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **returnType** - The data type of the value returned by the method _(DataType )_[]
RoundTrip Attribute_Head: input is - '- **returnType** - The data type of the value returned by the method _(DataType )_[]'
RoundTrip Attribute_Head: value is - {'name': 'returnType', 'one_liner': 'The data type of the value returned by the method _', 'parenthetical': 'DataType'}
OK. {'name': 'returnType', 'one_liner': 'The data type of the value returned by the method _', 'parenthetical': 'DataType'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'returnType - The data type of the value returned by the method _ (DataType)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **returnType** - The data type of the value returned by the method _(DataType )_[]
		=parse=> {'name': 'returnType', 'one_liner': 'The data type of the value returned by the method _', 'parenthetical': 'DataType'} 
		=render=> returnType - The data type of the value returned by the method _ (DataType) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _Subtype of:_ Component
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **parameters** - The input parameters of the method _(ListOf Parameters)_
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **returnType** - The data type of the value returned by the method _(DataType )_
_ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_Subtype of:_ Component[]",
  "name": "Subtype of: Component[]",
  "one_liner": "",
  "parenthetical": "",
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "- **parameters** - The input parameters of the method _(ListOf Parameters)_[]",
      "name": "parameters",
      "one_liner": "The input parameters of the method _",
      "parenthetical": "ListOf Parameters"
    },
    {
      "_type": "Attribute",
      "full_header": "- **returnType** - The data type of the value returned by the method _(DataType )_[]",
      "name": "returnType",
      "one_liner": "The data type of the value returned by the method _",
      "parenthetical": "DataType"
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ **Parameter**['An input to a method']
RoundTrip Class_Head: input is - '_ **Parameter**['An input to a method']'
RoundTrip Class_Head: value is - {'name': "Parameter['An input to a method']", 'one_liner': '', 'parenthetical': ''}
OK. {'name': "Parameter['An input to a method']", 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Parameter['An input to a method']'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **Parameter**['An input to a method']
		=parse=> {'name': "Parameter['An input to a method']", 'one_liner': '', 'parenthetical': ''} 
		=render=> Parameter['An input to a method'] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for PLURAL: _Plural:_ Parameters
RoundTrip PLURAL: input is - '_ Parameters[]'
RoundTrip PLURAL: value is - _ Parameters[]
OK. _ Parameters[] ok for PLURAL
RoundTrip PLURAL: renders as - '_ Parameters[]'
RoundTrip PLURAL: reparses as - _ Parameters[]
RoundTrip SUCCESS: _ Parameters[]
		=parse=> _ Parameters[] 
		=render=> _ Parameters[] 
		=parse=> _ Parameters[]
adding non raw value. _Plural -. _ Parameters[]
{
  "_Plural_raw": "_ Parameters[]",
  "_Plural": "_ Parameters[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'_Plural_raw': '_ Parameters[]', '_Plural': '_ Parameters[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **Parameter**An input to a method
_ _ PLURAL: _Plural:_ Parameters
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **Parameter**['An input to a method']",
  "name": "Parameter['An input to a method']",
  "one_liner": "",
  "parenthetical": "",
  "_Plural_raw": [
    "_ Parameters[]"
  ],
  "_Plural": "_ Parameters[]"
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _Subtype of:_ Component[]
RoundTrip Class_Head: input is - '_Subtype of:_ Component[]'
RoundTrip Class_Head: value is - {'name': 'Subtype of: Component[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Subtype of: Component[]', 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Subtype of: Component[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _Subtype of:_ Component[]
		=parse=> {'name': 'Subtype of: Component[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Subtype of: Component[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Attribute
		Full header is: - **type** - The data type of the parameter _(DataType )_[]
RoundTrip Attribute_Head: input is - '- **type** - The data type of the parameter _(DataType )_[]'
RoundTrip Attribute_Head: value is - {'name': 'type', 'one_liner': 'The data type of the parameter _', 'parenthetical': 'DataType'}
OK. {'name': 'type', 'one_liner': 'The data type of the parameter _', 'parenthetical': 'DataType'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'type - The data type of the parameter _ (DataType)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **type** - The data type of the parameter _(DataType )_[]
		=parse=> {'name': 'type', 'one_liner': 'The data type of the parameter _', 'parenthetical': 'DataType'} 
		=render=> type - The data type of the parameter _ (DataType) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **cardinality** - The cardinality of the parameter (e.g., optional, required) _(AttributeCardinality)_[]
RoundTrip Attribute_Head: input is - '- **cardinality** - The cardinality of the parameter (e.g., optional, required) _(AttributeCardinality)_[]'
RoundTrip Attribute_Head: value is - {'name': 'cardinality', 'one_liner': 'The cardinality of the parameter', 'parenthetical': 'e.g., optional, required'}
OK. {'name': 'cardinality', 'one_liner': 'The cardinality of the parameter', 'parenthetical': 'e.g., optional, required'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'cardinality - The cardinality of the parameter (e.g., optional, required)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **cardinality** - The cardinality of the parameter (e.g., optional, required) _(AttributeCardinality)_[]
		=parse=> {'name': 'cardinality', 'one_liner': 'The cardinality of the parameter', 'parenthetical': 'e.g., optional, required'} 
		=render=> cardinality - The cardinality of the parameter (e.g., optional, required) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _Subtype of:_ Component
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **type** - The data type of the parameter _(DataType )_
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **cardinality** - The cardinality of the parameter (e.g., optional, required) _(AttributeCardinality)_
_ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_Subtype of:_ Component[]",
  "name": "Subtype of: Component[]",
  "one_liner": "",
  "parenthetical": "",
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "- **type** - The data type of the parameter _(DataType )_[]",
      "name": "type",
      "one_liner": "The data type of the parameter _",
      "parenthetical": "DataType"
    },
    {
      "_type": "Attribute",
      "full_header": "- **cardinality** - The cardinality of the parameter (e.g., optional, required) _(AttributeCardinality)_[]",
      "name": "cardinality",
      "one_liner": "The cardinality of the parameter",
      "parenthetical": "e.g., optional, required"
    }
  ]
}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Section2
		Full header is: ## Data Types[]
RoundTrip Section2_Head: input is - '## Data Types[]'
RoundTrip Section2_Head: value is - {'name': 'Data Types[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Data Types[]', 'one_liner': '', 'parenthetical': ''} ok for Section2_Head
RoundTrip Section2_Head: renders as - 'Data Types[]'
RoundTrip Section2_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: ## Data Types[]
		=parse=> {'name': 'Data Types[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Data Types[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- adding TEXT para
--- skipping BLANK_LINE
DerivingDict for Part:  Class
		Full header is: _ **Simple Data Type**['***SubtpeOf***: DataType']
RoundTrip Class_Head: input is - '_ **Simple Data Type**['***SubtpeOf***: DataType']'
RoundTrip Class_Head: value is - {'name': "Simple Data Type['SubtpeOf: DataType']", 'one_liner': '', 'parenthetical': ''}
OK. {'name': "Simple Data Type['SubtpeOf: DataType']", 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Simple Data Type['SubtpeOf: DataType']'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **Simple Data Type**['***SubtpeOf***: DataType']
		=parse=> {'name': "Simple Data Type['SubtpeOf: DataType']", 'one_liner': '', 'parenthetical': ''} 
		=render=> Simple Data Type['SubtpeOf: DataType'] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Attribute
		Full header is: - **coreClass** - (Class)[]
RoundTrip Attribute_Head: input is - '- **coreClass** - (Class)[]'
RoundTrip Attribute_Head: value is - {'name': 'coreClass', 'one_liner': '', 'parenthetical': 'Class'}
OK. {'name': 'coreClass', 'one_liner': '', 'parenthetical': 'Class'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'coreClass (Class)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **coreClass** - (Class)[]
		=parse=> {'name': 'coreClass', 'one_liner': '', 'parenthetical': 'Class'} 
		=render=> coreClass (Class) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **Simple Data Type*****SubtpeOf***: DataType
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **coreClass** - (Class)
_ _ _ BLANK_LINE: 
_ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **Simple Data Type**['***SubtpeOf***: DataType']",
  "name": "Simple Data Type['SubtpeOf: DataType']",
  "one_liner": "",
  "parenthetical": "",
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "- **coreClass** - (Class)[]",
      "name": "coreClass",
      "one_liner": "",
      "parenthetical": "Class"
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ **Complex Data Type**[]
RoundTrip Class_Head: input is - '_ **Complex Data Type**[]'
RoundTrip Class_Head: value is - {'name': 'Complex Data Type[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Complex Data Type[]', 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Complex Data Type[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **Complex Data Type**[]
		=parse=> {'name': 'Complex Data Type[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Complex Data Type[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Attribute
		Full header is: - **aggregation** (Aggregating Operator)[]
RoundTrip Attribute_Head: input is - '- **aggregation** (Aggregating Operator)[]'
RoundTrip Attribute_Head: value is - {'name': 'aggregation', 'one_liner': '', 'parenthetical': 'Aggregating Operator'}
OK. {'name': 'aggregation', 'one_liner': '', 'parenthetical': 'Aggregating Operator'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'aggregation (Aggregating Operator)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **aggregation** (Aggregating Operator)[]
		=parse=> {'name': 'aggregation', 'one_liner': '', 'parenthetical': 'Aggregating Operator'} 
		=render=> aggregation (Aggregating Operator) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **aggregatedTypes** (List of DataTypes)[]
RoundTrip Attribute_Head: input is - '- **aggregatedTypes** (List of DataTypes)[]'
RoundTrip Attribute_Head: value is - {'name': 'aggregatedTypes', 'one_liner': '', 'parenthetical': 'List of DataTypes'}
OK. {'name': 'aggregatedTypes', 'one_liner': '', 'parenthetical': 'List of DataTypes'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'aggregatedTypes (List of DataTypes)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **aggregatedTypes** (List of DataTypes)[]
		=parse=> {'name': 'aggregatedTypes', 'one_liner': '', 'parenthetical': 'List of DataTypes'} 
		=render=> aggregatedTypes (List of DataTypes) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **Complex Data Type**
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **aggregation** (Aggregating Operator)
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **aggregatedTypes** (List of DataTypes)
_ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **Complex Data Type**[]",
  "name": "Complex Data Type[]",
  "one_liner": "",
  "parenthetical": "",
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "- **aggregation** (Aggregating Operator)[]",
      "name": "aggregation",
      "one_liner": "",
      "parenthetical": "Aggregating Operator"
    },
    {
      "_type": "Attribute",
      "full_header": "- **aggregatedTypes** (List of DataTypes)[]",
      "name": "aggregatedTypes",
      "one_liner": "",
      "parenthetical": "List of DataTypes"
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ **Aggregating Operator**[]
RoundTrip Class_Head: input is - '_ **Aggregating Operator**[]'
RoundTrip Class_Head: value is - {'name': 'Aggregating Operator[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Aggregating Operator[]', 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Aggregating Operator[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **Aggregating Operator**[]
		=parse=> {'name': 'Aggregating Operator[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Aggregating Operator[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
DerivingDict for Part:  Attribute
		Full header is: - **Name**- (Code)[]
RoundTrip Attribute_Head: input is - '- **Name**- (Code)[]'
RoundTrip Attribute_Head: value is - {'name': 'Name', 'one_liner': '', 'parenthetical': 'Code'}
OK. {'name': 'Name', 'one_liner': '', 'parenthetical': 'Code'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'Name (Code)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **Name**- (Code)[]
		=parse=> {'name': 'Name', 'one_liner': '', 'parenthetical': 'Code'} 
		=render=> Name (Code) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: -- **SetOf**[]
RoundTrip Attribute_Head: input is - '-- **SetOf**[]'
RoundTrip Attribute_Head: value is - {'name': '', 'one_liner': '**SetOf**[]', 'parenthetical': ''}
OK. {'name': '', 'one_liner': '**SetOf**[]', 'parenthetical': ''} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'NAME? - **SetOf**[]'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: -- **SetOf**[]
		=parse=> {'name': '', 'one_liner': '**SetOf**[]', 'parenthetical': ''} 
		=render=> NAME? - **SetOf**[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: -- **ListOf**[]
RoundTrip Attribute_Head: input is - '-- **ListOf**[]'
RoundTrip Attribute_Head: value is - {'name': '', 'one_liner': '**ListOf**[]', 'parenthetical': ''}
OK. {'name': '', 'one_liner': '**ListOf**[]', 'parenthetical': ''} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'NAME? - **ListOf**[]'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: -- **ListOf**[]
		=parse=> {'name': '', 'one_liner': '**ListOf**[]', 'parenthetical': ''} 
		=render=> NAME? - **ListOf**[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: -- **Mapping**[]
RoundTrip Attribute_Head: input is - '-- **Mapping**[]'
RoundTrip Attribute_Head: value is - {'name': '', 'one_liner': '**Mapping**[]', 'parenthetical': ''}
OK. {'name': '', 'one_liner': '**Mapping**[]', 'parenthetical': ''} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'NAME? - **Mapping**[]'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: -- **Mapping**[]
		=parse=> {'name': '', 'one_liner': '**Mapping**[]', 'parenthetical': ''} 
		=render=> NAME? - **Mapping**[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **arity** - (Integer)[]
RoundTrip Attribute_Head: input is - '- **arity** - (Integer)[]'
RoundTrip Attribute_Head: value is - {'name': 'arity', 'one_liner': '', 'parenthetical': 'Integer'}
OK. {'name': 'arity', 'one_liner': '', 'parenthetical': 'Integer'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'arity (Integer)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **arity** - (Integer)[]
		=parse=> {'name': 'arity', 'one_liner': '', 'parenthetical': 'Integer'} 
		=render=> arity (Integer) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **spelling** - (Template)[]
RoundTrip Attribute_Head: input is - '- **spelling** - (Template)[]'
RoundTrip Attribute_Head: value is - {'name': 'spelling', 'one_liner': '', 'parenthetical': 'Template'}
OK. {'name': 'spelling', 'one_liner': '', 'parenthetical': 'Template'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'spelling (Template)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **spelling** - (Template)[]
		=parse=> {'name': 'spelling', 'one_liner': '', 'parenthetical': 'Template'} 
		=render=> spelling (Template) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **Aggregating Operator**
_ _ BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **Name**- (Code)
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: -- **SetOf**
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: -- **ListOf**
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: -- **Mapping**
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **arity** - (Integer)
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **spelling** - (Template)
_ _ _ BLANK_LINE: 
_ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **Aggregating Operator**[]",
  "name": "Aggregating Operator[]",
  "one_liner": "",
  "parenthetical": "",
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "- **Name**- (Code)[]",
      "name": "Name",
      "one_liner": "",
      "parenthetical": "Code"
    },
    {
      "_type": "Attribute",
      "full_header": "-- **SetOf**[]",
      "name": "",
      "one_liner": "**SetOf**[]",
      "parenthetical": ""
    },
    {
      "_type": "Attribute",
      "full_header": "-- **ListOf**[]",
      "name": "",
      "one_liner": "**ListOf**[]",
      "parenthetical": ""
    },
    {
      "_type": "Attribute",
      "full_header": "-- **Mapping**[]",
      "name": "",
      "one_liner": "**Mapping**[]",
      "parenthetical": ""
    },
    {
      "_type": "Attribute",
      "full_header": "- **arity** - (Integer)[]",
      "name": "arity",
      "one_liner": "",
      "parenthetical": "Integer"
    },
    {
      "_type": "Attribute",
      "full_header": "- **spelling** - (Template)[]",
      "name": "spelling",
      "one_liner": "",
      "parenthetical": "Template"
    }
  ]
}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Section2
		Full header is: ## Low level Data Types[]
RoundTrip Section2_Head: input is - '## Low level Data Types[]'
RoundTrip Section2_Head: value is - {'name': 'Low level Data Types[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'Low level Data Types[]', 'one_liner': '', 'parenthetical': ''} ok for Section2_Head
RoundTrip Section2_Head: renders as - 'Low level Data Types[]'
RoundTrip Section2_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: ## Low level Data Types[]
		=parse=> {'name': 'Low level Data Types[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> Low level Data Types[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- adding TEXT para
--- skipping BLANK_LINE
DerivingDict for Part:  Class
		Full header is: _ ***ValueType***: **CamelName**[]
RoundTrip Class_Head: input is - '_ ***ValueType***: **CamelName**[]'
RoundTrip Class_Head: value is - {'name': 'ValueType: CamelName[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'ValueType: CamelName[]', 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'ValueType: CamelName[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ ***ValueType***: **CamelName**[]
		=parse=> {'name': 'ValueType: CamelName[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> ValueType: CamelName[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- adding TEXT para
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for SUBTYPE_OF: ***Subtype of***: String
RoundTrip SUBTYPE_OF: input is - ' String[]'
parse_name_list:  String[]
RoundTrip SUBTYPE_OF: value is - ['String[]']
validating name list:  ['String[]']
OK. ['String[]'] ok for SUBTYPE_OF
RoundTrip SUBTYPE_OF: renders as - 'String[]'
parse_name_list: String[]
RoundTrip SUBTYPE_OF: reparses as - ['String[]']
RoundTrip SUCCESS:  String[]
		=parse=> ['String[]'] 
		=render=> String[] 
		=parse=> ['String[]']
adding non raw value. ***Subtype of*** -. ['String[]']
{
  "***Subtype of***_raw": " String[]",
  "***Subtype of***": [
    "String[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Subtype of***_raw': ' String[]', '***Subtype of***': ['String[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - value: the string (String)[]
RoundTrip Attribute_Head: input is - '- value: the string (String)[]'
RoundTrip Attribute_Head: value is - {'name': 'value: the string', 'one_liner': '', 'parenthetical': 'String'}
OK. {'name': 'value: the string', 'one_liner': '', 'parenthetical': 'String'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'value: the string (String)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - value: the string (String)[]
		=parse=> {'name': 'value: the string', 'one_liner': '', 'parenthetical': 'String'} 
		=render=> value: the string (String) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Constraint
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for CONSTRAINT: ***Constraint***: Must follow the camel case naming convention and not be empty.
RoundTrip CONSTRAINT: input is - ' Must follow the camel case naming convention and not be empty.[]'
RoundTrip CONSTRAINT: value is -  Must follow the camel case naming convention and not be empty.[]
OK.  Must follow the camel case naming convention and not be empty.[] ok for CONSTRAINT
RoundTrip CONSTRAINT: renders as - ' Must follow the camel case naming convention and not be empty.[]'
RoundTrip CONSTRAINT: reparses as -  Must follow the camel case naming convention and not be empty.[]
RoundTrip SUCCESS:  Must follow the camel case naming convention and not be empty.[]
		=parse=>  Must follow the camel case naming convention and not be empty.[] 
		=render=>  Must follow the camel case naming convention and not be empty.[] 
		=parse=>  Must follow the camel case naming convention and not be empty.[]
adding non raw value. ***Constraint*** -.  Must follow the camel case naming convention and not be empty.[]
{
  "***Constraint***_raw": " Must follow the camel case naming convention and not be empty.[]",
  "***Constraint***": " Must follow the camel case naming convention and not be empty.[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Constraint***_raw': ' Must follow the camel case naming convention and not be empty.[]', '***Constraint***': ' Must follow the camel case naming convention and not be empty.[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for EXAMPLE: _Example:_ "firstName", "orderDate", "customerID"
RoundTrip EXAMPLE: input is - '_ "firstName", "orderDate", "customerID"[]'
RoundTrip EXAMPLE: value is - _ "firstName", "orderDate", "customerID"[]
OK. _ "firstName", "orderDate", "customerID"[] ok for EXAMPLE
RoundTrip EXAMPLE: renders as - '_ "firstName", "orderDate", "customerID"[]'
RoundTrip EXAMPLE: reparses as - _ "firstName", "orderDate", "customerID"[]
RoundTrip SUCCESS: _ "firstName", "orderDate", "customerID"[]
		=parse=> _ "firstName", "orderDate", "customerID"[] 
		=render=> _ "firstName", "orderDate", "customerID"[] 
		=parse=> _ "firstName", "orderDate", "customerID"[]
adding non raw value. _Example -. _ "firstName", "orderDate", "customerID"[]
{
  "_Example_raw": "_ \"firstName\", \"orderDate\", \"customerID\"[]",
  "_Example": "_ \"firstName\", \"orderDate\", \"customerID\"[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'_Example_raw': '_ "firstName", "orderDate", "customerID"[]', '_Example': '_ "firstName", "orderDate", "customerID"[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
--- adding TEXT para
--- skipping BLANK_LINE
--- skipping BLANK_LINE
--- adding TEXT para
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ ***ValueType***: **CamelName**
_ _ BLANK_LINE: 
_ _ TEXT_LINE: A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.
_ _ SUBTYPE_OF: ***Subtype of***: String
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - value: the string (String)
. . . Constraint - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ CONSTRAINT: ***Constraint***: Must follow the camel case naming convention and not be empty.
. . . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ EXAMPLE: _Example:_ "firstName", "orderDate", "customerID"
_ _ _ _ BLANK_LINE: 
_ _ _ _ TEXT_LINE: >  ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.
_ _ _ _ BLANK_LINE: 
_ _ _ _ BLANK_LINE: 
_ _ _ _ TEXT_LINE: *ModelingNote:* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.
_ _ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ ***ValueType***: **CamelName**[]",
  "name": "ValueType: CamelName[]",
  "one_liner": "",
  "parenthetical": "",
  "elaboration": [
    {
      "type_label": "TEXT_LINE",
      "content": "A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case."
    }
  ],
  "***Subtype of***_raw": [
    " String[]"
  ],
  "***Subtype of***": [
    "String[]"
  ],
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "- value: the string (String)[]",
      "name": "value: the string",
      "one_liner": "",
      "parenthetical": "String",
      "Constraint": [
        {
          "_type": "Constraint",
          "***Constraint***_raw": [
            " Must follow the camel case naming convention and not be empty.[]"
          ],
          "***Constraint***": [
            " ",
            "M",
            "u",
            "s",
            "t",
            " ",
            "f",
            "o",
            "l",
            "l",
            "o",
            "w",
            " ",
            "t",
            "h",
            "e",
            " ",
            "c",
            "a",
            "m",
            "e",
            "l",
            " ",
            "c",
            "a",
            "s",
            "e",
            " ",
            "n",
            "a",
            "m",
            "i",
            "n",
            "g",
            " ",
            "c",
            "o",
            "n",
            "v",
            "e",
            "n",
            "t",
            "i",
            "o",
            "n",
            " ",
            "a",
            "n",
            "d",
            " ",
            "n",
            "o",
            "t",
            " ",
            "b",
            "e",
            " ",
            "e",
            "m",
            "p",
            "t",
            "y",
            ".",
            "[",
            "]"
          ]
        }
      ],
      "Annotation": [
        {
          "_type": "Annotation",
          "_Example_raw": [
            "_ \"firstName\", \"orderDate\", \"customerID\"[]"
          ],
          "_Example": [
            "_ \"firstName\", \"orderDate\", \"customerID\"[]"
          ]
        }
      ]
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ **UpperCamel**- a CamelName that begins with a capital letter[]
RoundTrip Class_Head: input is - '_ **UpperCamel**- a CamelName that begins with a capital letter[]'
RoundTrip Class_Head: value is - {'name': 'UpperCamel', 'one_liner': 'a CamelName that begins with a capital letter[]', 'parenthetical': ''}
OK. {'name': 'UpperCamel', 'one_liner': 'a CamelName that begins with a capital letter[]', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'UpperCamel - a CamelName that begins with a capital letter[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **UpperCamel**- a CamelName that begins with a capital letter[]
		=parse=> {'name': 'UpperCamel', 'one_liner': 'a CamelName that begins with a capital letter[]', 'parenthetical': ''} 
		=render=> UpperCamel - a CamelName that begins with a capital letter[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for SUBTYPE_OF: **Subtype of**: CamelName
RoundTrip SUBTYPE_OF: input is - ' CamelName[]'
parse_name_list:  CamelName[]
RoundTrip SUBTYPE_OF: value is - ['CamelName[]']
validating name list:  ['CamelName[]']
OK. ['CamelName[]'] ok for SUBTYPE_OF
RoundTrip SUBTYPE_OF: renders as - 'CamelName[]'
parse_name_list: CamelName[]
RoundTrip SUBTYPE_OF: reparses as - ['CamelName[]']
RoundTrip SUCCESS:  CamelName[]
		=parse=> ['CamelName[]'] 
		=render=> CamelName[] 
		=parse=> ['CamelName[]']
adding non raw value. **Subtype of** -. ['CamelName[]']
{
  "**Subtype of**_raw": " CamelName[]",
  "**Subtype of**": [
    "CamelName[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'**Subtype of**_raw': ' CamelName[]', '**Subtype of**': ['CamelName[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for WHERE: **Where**: content begins with an upper case letter.
RoundTrip WHERE: input is - ' content begins with an upper case letter.[]'
RoundTrip WHERE: value is -  content begins with an upper case letter.[]
OK.  content begins with an upper case letter.[] ok for WHERE
RoundTrip WHERE: renders as - ' content begins with an upper case letter.[]'
RoundTrip WHERE: reparses as -  content begins with an upper case letter.[]
RoundTrip SUCCESS:  content begins with an upper case letter.[]
		=parse=>  content begins with an upper case letter.[] 
		=render=>  content begins with an upper case letter.[] 
		=parse=>  content begins with an upper case letter.[]
adding non raw value. **Where** -.  content begins with an upper case letter.[]
{
  "**Where**_raw": " content begins with an upper case letter.[]",
  "**Where**": " content begins with an upper case letter.[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'**Where**_raw': ' content begins with an upper case letter.[]', '**Where**': ' content begins with an upper case letter.[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for EXAMPLE: _Example:_ "Customer", "ProductCategory", "PaymentMethod"
RoundTrip EXAMPLE: input is - '_ "Customer", "ProductCategory", "PaymentMethod"[]'
RoundTrip EXAMPLE: value is - _ "Customer", "ProductCategory", "PaymentMethod"[]
OK. _ "Customer", "ProductCategory", "PaymentMethod"[] ok for EXAMPLE
RoundTrip EXAMPLE: renders as - '_ "Customer", "ProductCategory", "PaymentMethod"[]'
RoundTrip EXAMPLE: reparses as - _ "Customer", "ProductCategory", "PaymentMethod"[]
RoundTrip SUCCESS: _ "Customer", "ProductCategory", "PaymentMethod"[]
		=parse=> _ "Customer", "ProductCategory", "PaymentMethod"[] 
		=render=> _ "Customer", "ProductCategory", "PaymentMethod"[] 
		=parse=> _ "Customer", "ProductCategory", "PaymentMethod"[]
adding non raw value. _Example -. _ "Customer", "ProductCategory", "PaymentMethod"[]
{
  "_Example_raw": "_ \"Customer\", \"ProductCategory\", \"PaymentMethod\"[]",
  "_Example": "_ \"Customer\", \"ProductCategory\", \"PaymentMethod\"[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'_Example_raw': '_ "Customer", "ProductCategory", "PaymentMethod"[]', '_Example': '_ "Customer", "ProductCategory", "PaymentMethod"[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **UpperCamel**- a CamelName that begins with a capital letter
_ _ SUBTYPE_OF: **Subtype of**: CamelName
_ _ WHERE: **Where**: content begins with an upper case letter.
. . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ EXAMPLE: _Example:_ "Customer", "ProductCategory", "PaymentMethod"
_ _ _ BLANK_LINE: 
_ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **UpperCamel**- a CamelName that begins with a capital letter[]",
  "name": "UpperCamel",
  "one_liner": "a CamelName that begins with a capital letter[]",
  "parenthetical": "",
  "**Subtype of**_raw": [
    " CamelName[]"
  ],
  "**Subtype of**": [
    "CamelName[]"
  ],
  "**Where**_raw": [
    " content begins with an upper case letter.[]"
  ],
  "**Where**": " content begins with an upper case letter.[]",
  "Annotation": [
    {
      "_type": "Annotation",
      "_Example_raw": [
        "_ \"Customer\", \"ProductCategory\", \"PaymentMethod\"[]"
      ],
      "_Example": [
        "_ \"Customer\", \"ProductCategory\", \"PaymentMethod\"[]"
      ]
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ **LowerCamel** - a CamelName that begins with a lower case letter[]
RoundTrip Class_Head: input is - '_ **LowerCamel** - a CamelName that begins with a lower case letter[]'
RoundTrip Class_Head: value is - {'name': 'LowerCamel', 'one_liner': 'a CamelName that begins with a lower case letter[]', 'parenthetical': ''}
OK. {'name': 'LowerCamel', 'one_liner': 'a CamelName that begins with a lower case letter[]', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'LowerCamel - a CamelName that begins with a lower case letter[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **LowerCamel** - a CamelName that begins with a lower case letter[]
		=parse=> {'name': 'LowerCamel', 'one_liner': 'a CamelName that begins with a lower case letter[]', 'parenthetical': ''} 
		=render=> LowerCamel - a CamelName that begins with a lower case letter[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for SUBTYPE_OF: **Subtype of**: CamelName
RoundTrip SUBTYPE_OF: input is - ' CamelName[]'
parse_name_list:  CamelName[]
RoundTrip SUBTYPE_OF: value is - ['CamelName[]']
validating name list:  ['CamelName[]']
OK. ['CamelName[]'] ok for SUBTYPE_OF
RoundTrip SUBTYPE_OF: renders as - 'CamelName[]'
parse_name_list: CamelName[]
RoundTrip SUBTYPE_OF: reparses as - ['CamelName[]']
RoundTrip SUCCESS:  CamelName[]
		=parse=> ['CamelName[]'] 
		=render=> CamelName[] 
		=parse=> ['CamelName[]']
adding non raw value. **Subtype of** -. ['CamelName[]']
{
  "**Subtype of**_raw": " CamelName[]",
  "**Subtype of**": [
    "CamelName[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'**Subtype of**_raw': ' CamelName[]', '**Subtype of**': ['CamelName[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for WHERE: **Where**: content begins with a lower case letter.
RoundTrip WHERE: input is - ' content begins with a lower case letter.[]'
RoundTrip WHERE: value is -  content begins with a lower case letter.[]
OK.  content begins with a lower case letter.[] ok for WHERE
RoundTrip WHERE: renders as - ' content begins with a lower case letter.[]'
RoundTrip WHERE: reparses as -  content begins with a lower case letter.[]
RoundTrip SUCCESS:  content begins with a lower case letter.[]
		=parse=>  content begins with a lower case letter.[] 
		=render=>  content begins with a lower case letter.[] 
		=parse=>  content begins with a lower case letter.[]
adding non raw value. **Where** -.  content begins with a lower case letter.[]
{
  "**Where**_raw": " content begins with a lower case letter.[]",
  "**Where**": " content begins with a lower case letter.[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'**Where**_raw': ' content begins with a lower case letter.[]', '**Where**': ' content begins with a lower case letter.[]'}
	Either is_list or is_cum; create list value
	Neither is_list nor is_cum; create scalar value
--- skipping BLANK_LINE
DerivingDict for Part:  Annotation
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for EXAMPLE: _Example:_ "firstName", "orderTotal", "shippingAddress"
RoundTrip EXAMPLE: input is - '_ "firstName", "orderTotal", "shippingAddress"[]'
RoundTrip EXAMPLE: value is - _ "firstName", "orderTotal", "shippingAddress"[]
OK. _ "firstName", "orderTotal", "shippingAddress"[] ok for EXAMPLE
RoundTrip EXAMPLE: renders as - '_ "firstName", "orderTotal", "shippingAddress"[]'
RoundTrip EXAMPLE: reparses as - _ "firstName", "orderTotal", "shippingAddress"[]
RoundTrip SUCCESS: _ "firstName", "orderTotal", "shippingAddress"[]
		=parse=> _ "firstName", "orderTotal", "shippingAddress"[] 
		=render=> _ "firstName", "orderTotal", "shippingAddress"[] 
		=parse=> _ "firstName", "orderTotal", "shippingAddress"[]
adding non raw value. _Example -. _ "firstName", "orderTotal", "shippingAddress"[]
{
  "_Example_raw": "_ \"firstName\", \"orderTotal\", \"shippingAddress\"[]",
  "_Example": "_ \"firstName\", \"orderTotal\", \"shippingAddress\"[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'_Example_raw': '_ "firstName", "orderTotal", "shippingAddress"[]', '_Example': '_ "firstName", "orderTotal", "shippingAddress"[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **LowerCamel** - a CamelName that begins with a lower case letter
_ _ SUBTYPE_OF: **Subtype of**: CamelName
_ _ WHERE: **Where**: content begins with a lower case letter.
_ _ BLANK_LINE: 
. . Annotation - <class 'ldm_parse_core.DocPart'> 
_ _ _ EXAMPLE: _Example:_ "firstName", "orderTotal", "shippingAddress"
_ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **LowerCamel** - a CamelName that begins with a lower case letter[]",
  "name": "LowerCamel",
  "one_liner": "a CamelName that begins with a lower case letter[]",
  "parenthetical": "",
  "**Subtype of**_raw": [
    " CamelName[]"
  ],
  "**Subtype of**": [
    "CamelName[]"
  ],
  "**Where**_raw": [
    " content begins with a lower case letter.[]"
  ],
  "**Where**": " content begins with a lower case letter.[]",
  "Annotation": [
    {
      "_type": "Annotation",
      "_Example_raw": [
        "_ \"firstName\", \"orderTotal\", \"shippingAddress\"[]"
      ],
      "_Example": [
        "_ \"firstName\", \"orderTotal\", \"shippingAddress\"[]"
      ]
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ **Qualified Camel** - an expression consisting of Camel Names separated by periods[]
RoundTrip Class_Head: input is - '_ **Qualified Camel** - an expression consisting of Camel Names separated by periods[]'
RoundTrip Class_Head: value is - {'name': 'Qualified Camel', 'one_liner': 'an expression consisting of Camel Names separated by periods[]', 'parenthetical': ''}
OK. {'name': 'Qualified Camel', 'one_liner': 'an expression consisting of Camel Names separated by periods[]', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Qualified Camel - an expression consisting of Camel Names separated by periods[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **Qualified Camel** - an expression consisting of Camel Names separated by periods[]
		=parse=> {'name': 'Qualified Camel', 'one_liner': 'an expression consisting of Camel Names separated by periods[]', 'parenthetical': ''} 
		=render=> Qualified Camel - an expression consisting of Camel Names separated by periods[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for SUBTYPE_OF: ***Subtype of***: String
RoundTrip SUBTYPE_OF: input is - ' String[]'
parse_name_list:  String[]
RoundTrip SUBTYPE_OF: value is - ['String[]']
validating name list:  ['String[]']
OK. ['String[]'] ok for SUBTYPE_OF
RoundTrip SUBTYPE_OF: renders as - 'String[]'
parse_name_list: String[]
RoundTrip SUBTYPE_OF: reparses as - ['String[]']
RoundTrip SUCCESS:  String[]
		=parse=> ['String[]'] 
		=render=> String[] 
		=parse=> ['String[]']
adding non raw value. ***Subtype of*** -. ['String[]']
{
  "***Subtype of***_raw": " String[]",
  "***Subtype of***": [
    "String[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Subtype of***_raw': ' String[]', '***Subtype of***': ['String[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Constraint
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for CONSTRAINT: ***Constraint***: content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.
RoundTrip CONSTRAINT: input is - ' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.[]'
RoundTrip CONSTRAINT: value is -  content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.[]
OK.  content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.[] ok for CONSTRAINT
RoundTrip CONSTRAINT: renders as - ' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.[]'
RoundTrip CONSTRAINT: reparses as -  content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.[]
RoundTrip SUCCESS:  content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.[]
		=parse=>  content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.[] 
		=render=>  content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.[] 
		=parse=>  content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.[]
adding non raw value. ***Constraint*** -.  content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.[]
{
  "***Constraint***_raw": " content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.[]",
  "***Constraint***": " content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Constraint***_raw': ' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.[]', '***Constraint***': ' content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **Qualified Camel** - an expression consisting of Camel Names separated by periods
_ _ SUBTYPE_OF: ***Subtype of***: String
. . Constraint - <class 'ldm_parse_core.DocPart'> 
_ _ _ CONSTRAINT: ***Constraint***: content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.
_ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **Qualified Camel** - an expression consisting of Camel Names separated by periods[]",
  "name": "Qualified Camel",
  "one_liner": "an expression consisting of Camel Names separated by periods[]",
  "parenthetical": "",
  "***Subtype of***_raw": [
    " String[]"
  ],
  "***Subtype of***": [
    "String[]"
  ],
  "Constraint": [
    {
      "_type": "Constraint",
      "***Constraint***_raw": [
        " content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.[]"
      ],
      "***Constraint***": [
        " ",
        "c",
        "o",
        "n",
        "t",
        "e",
        "n",
        "t",
        " ",
        "c",
        "o",
        "n",
        "s",
        "i",
        "s",
        "t",
        "s",
        " ",
        "o",
        "f",
        " ",
        "C",
        "a",
        "m",
        "e",
        "l",
        "N",
        "a",
        "m",
        "e",
        "s",
        ",",
        " ",
        "s",
        "e",
        "p",
        "a",
        "r",
        "a",
        "t",
        "e",
        "d",
        " ",
        "b",
        "y",
        " ",
        "p",
        "e",
        "r",
        "i",
        "o",
        "d",
        "s",
        ".",
        " ",
        " ",
        "E",
        "a",
        "c",
        "h",
        " ",
        "o",
        "f",
        " ",
        "t",
        "h",
        "e",
        " ",
        "c",
        "a",
        "m",
        "e",
        "l",
        " ",
        "n",
        "a",
        "m",
        "e",
        "s",
        " ",
        "m",
        "u",
        "s",
        "t",
        " ",
        "b",
        "e",
        " ",
        "U",
        "p",
        "p",
        "e",
        "r",
        " ",
        "C",
        "a",
        "m",
        "e",
        "l",
        " ",
        "e",
        "x",
        "c",
        "e",
        "p",
        "t",
        ",",
        " ",
        "p",
        "o",
        "s",
        "s",
        "i",
        "b",
        "l",
        "y",
        ",",
        " ",
        "t",
        "h",
        "e",
        " ",
        "f",
        "i",
        "r",
        "s",
        "t",
        ".",
        "[",
        "]"
      ]
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ **RichText**.  A string with markup for block level formatting.[]
RoundTrip Class_Head: input is - '_ **RichText**.  A string with markup for block level formatting.[]'
RoundTrip Class_Head: value is - {'name': 'RichText.  A string with markup for block level formatting.[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'RichText.  A string with markup for block level formatting.[]', 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'RichText.  A string with markup for block level formatting.[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **RichText**.  A string with markup for block level formatting.[]
		=parse=> {'name': 'RichText.  A string with markup for block level formatting.[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> RichText.  A string with markup for block level formatting.[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for SUBTYPE_OF: ***SubtypeOf***: String
RoundTrip SUBTYPE_OF: input is - ' String[]'
parse_name_list:  String[]
RoundTrip SUBTYPE_OF: value is - ['String[]']
validating name list:  ['String[]']
OK. ['String[]'] ok for SUBTYPE_OF
RoundTrip SUBTYPE_OF: renders as - 'String[]'
parse_name_list: String[]
RoundTrip SUBTYPE_OF: reparses as - ['String[]']
RoundTrip SUCCESS:  String[]
		=parse=> ['String[]'] 
		=render=> String[] 
		=parse=> ['String[]']
adding non raw value. ***SubtypeOf*** -. ['String[]']
{
  "***SubtypeOf***_raw": " String[]",
  "***SubtypeOf***": [
    "String[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***SubtypeOf***_raw': ' String[]', '***SubtypeOf***': ['String[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
DerivingDict for Part:  Attribute
		Full header is: - **value** - the string content (string)[]
RoundTrip Attribute_Head: input is - '- **value** - the string content (string)[]'
RoundTrip Attribute_Head: value is - {'name': 'value', 'one_liner': 'the string content', 'parenthetical': 'string'}
OK. {'name': 'value', 'one_liner': 'the string content', 'parenthetical': 'string'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'value - the string content (string)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **value** - the string content (string)[]
		=parse=> {'name': 'value', 'one_liner': 'the string content', 'parenthetical': 'string'} 
		=render=> value - the string content (string) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **format** - the rich text coding language used (Code)[]
RoundTrip Attribute_Head: input is - '- **format** - the rich text coding language used (Code)[]'
RoundTrip Attribute_Head: value is - {'name': 'format', 'one_liner': 'the rich text coding language used', 'parenthetical': 'Code'}
OK. {'name': 'format', 'one_liner': 'the rich text coding language used', 'parenthetical': 'Code'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'format - the rich text coding language used (Code)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **format** - the rich text coding language used (Code)[]
		=parse=> {'name': 'format', 'one_liner': 'the rich text coding language used', 'parenthetical': 'Code'} 
		=render=> format - the rich text coding language used (Code) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **HTML**[]
RoundTrip Attribute_Head: input is - '- **HTML**[]'
RoundTrip Attribute_Head: value is - {'name': 'HTML[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'HTML[]', 'one_liner': '', 'parenthetical': ''} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'HTML[]'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **HTML**[]
		=parse=> {'name': 'HTML[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> HTML[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Attribute
		Full header is: - **MarkDown**[]
RoundTrip Attribute_Head: input is - '- **MarkDown**[]'
RoundTrip Attribute_Head: value is - {'name': 'MarkDown[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'MarkDown[]', 'one_liner': '', 'parenthetical': ''} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'MarkDown[]'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **MarkDown**[]
		=parse=> {'name': 'MarkDown[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> MarkDown[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **RichText**.  A string with markup for block level formatting.
_ _ SUBTYPE_OF: ***SubtypeOf***: String
_ _ BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **value** - the string content (string)
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **format** - the rich text coding language used (Code)
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **HTML**
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **MarkDown**
_ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **RichText**.  A string with markup for block level formatting.[]",
  "name": "RichText.  A string with markup for block level formatting.[]",
  "one_liner": "",
  "parenthetical": "",
  "***SubtypeOf***_raw": [
    " String[]"
  ],
  "***SubtypeOf***": [
    "String[]"
  ],
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "- **value** - the string content (string)[]",
      "name": "value",
      "one_liner": "the string content",
      "parenthetical": "string"
    },
    {
      "_type": "Attribute",
      "full_header": "- **format** - the rich text coding language used (Code)[]",
      "name": "format",
      "one_liner": "the rich text coding language used",
      "parenthetical": "Code"
    },
    {
      "_type": "Attribute",
      "full_header": "- **HTML**[]",
      "name": "HTML[]",
      "one_liner": "",
      "parenthetical": ""
    },
    {
      "_type": "Attribute",
      "full_header": "- **MarkDown**[]",
      "name": "MarkDown[]",
      "one_liner": "",
      "parenthetical": ""
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _  **RichLine**   - String with markup for line level formatting.[]
RoundTrip Class_Head: input is - '_  **RichLine**   - String with markup for line level formatting.[]'
RoundTrip Class_Head: value is - {'name': 'RichLine', 'one_liner': 'String with markup for line level formatting.[]', 'parenthetical': ''}
OK. {'name': 'RichLine', 'one_liner': 'String with markup for line level formatting.[]', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'RichLine - String with markup for line level formatting.[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _  **RichLine**   - String with markup for line level formatting.[]
		=parse=> {'name': 'RichLine', 'one_liner': 'String with markup for line level formatting.[]', 'parenthetical': ''} 
		=render=> RichLine - String with markup for line level formatting.[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for SUBTYPE_OF: ***SubtypeOf***: RichText
RoundTrip SUBTYPE_OF: input is - ' RichText[]'
parse_name_list:  RichText[]
RoundTrip SUBTYPE_OF: value is - ['RichText[]']
validating name list:  ['RichText[]']
OK. ['RichText[]'] ok for SUBTYPE_OF
RoundTrip SUBTYPE_OF: renders as - 'RichText[]'
parse_name_list: RichText[]
RoundTrip SUBTYPE_OF: reparses as - ['RichText[]']
RoundTrip SUCCESS:  RichText[]
		=parse=> ['RichText[]'] 
		=render=> RichText[] 
		=parse=> ['RichText[]']
adding non raw value. ***SubtypeOf*** -. ['RichText[]']
{
  "***SubtypeOf***_raw": " RichText[]",
  "***SubtypeOf***": [
    "RichText[]"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***SubtypeOf***_raw': ' RichText[]', '***SubtypeOf***': ['RichText[]']}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
DerivingDict for Part:  Attribute
		Full header is: - **value** - the string content (string)[]
RoundTrip Attribute_Head: input is - '- **value** - the string content (string)[]'
RoundTrip Attribute_Head: value is - {'name': 'value', 'one_liner': 'the string content', 'parenthetical': 'string'}
OK. {'name': 'value', 'one_liner': 'the string content', 'parenthetical': 'string'} ok for Attribute_Head
RoundTrip Attribute_Head: renders as - 'value - the string content (string)'
RoundTrip Attribute_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: - **value** - the string content (string)[]
		=parse=> {'name': 'value', 'one_liner': 'the string content', 'parenthetical': 'string'} 
		=render=> value - the string content (string) 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
DerivingDict for Part:  Constraint
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for CONSTRAINT: ***Constraint***: must not containa line break or new line character
RoundTrip CONSTRAINT: input is - ' must not containa line break or new line character[]'
RoundTrip CONSTRAINT: value is -  must not containa line break or new line character[]
OK.  must not containa line break or new line character[] ok for CONSTRAINT
RoundTrip CONSTRAINT: renders as - ' must not containa line break or new line character[]'
RoundTrip CONSTRAINT: reparses as -  must not containa line break or new line character[]
RoundTrip SUCCESS:  must not containa line break or new line character[]
		=parse=>  must not containa line break or new line character[] 
		=render=>  must not containa line break or new line character[] 
		=parse=>  must not containa line break or new line character[]
adding non raw value. ***Constraint*** -.  must not containa line break or new line character[]
{
  "***Constraint***_raw": " must not containa line break or new line character[]",
  "***Constraint***": " must not containa line break or new line character[]"
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'***Constraint***_raw': ' must not containa line break or new line character[]', '***Constraint***': ' must not containa line break or new line character[]'}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _  **RichLine**   - String with markup for line level formatting.
_ _ SUBTYPE_OF: ***SubtypeOf***: RichText
_ _ BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.DocPart'> 
_ _ _ Attribute_Head: - **value** - the string content (string)
. . . Constraint - <class 'ldm_parse_core.DocPart'> 
_ _ _ _ CONSTRAINT: ***Constraint***: must not containa line break or new line character
_ _ _ _ BLANK_LINE: 
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_  **RichLine**   - String with markup for line level formatting.[]",
  "name": "RichLine",
  "one_liner": "String with markup for line level formatting.[]",
  "parenthetical": "",
  "***SubtypeOf***_raw": [
    " RichText[]"
  ],
  "***SubtypeOf***": [
    "RichText[]"
  ],
  "Attribute": [
    {
      "_type": "Attribute",
      "full_header": "- **value** - the string content (string)[]",
      "name": "value",
      "one_liner": "the string content",
      "parenthetical": "string",
      "Constraint": [
        {
          "_type": "Constraint",
          "***Constraint***_raw": [
            " must not containa line break or new line character[]"
          ],
          "***Constraint***": [
            " ",
            "m",
            "u",
            "s",
            "t",
            " ",
            "n",
            "o",
            "t",
            " ",
            "c",
            "o",
            "n",
            "t",
            "a",
            "i",
            "n",
            "a",
            " ",
            "l",
            "i",
            "n",
            "e",
            " ",
            "b",
            "r",
            "e",
            "a",
            "k",
            " ",
            "o",
            "r",
            " ",
            "n",
            "e",
            "w",
            " ",
            "l",
            "i",
            "n",
            "e",
            " ",
            "c",
            "h",
            "a",
            "r",
            "a",
            "c",
            "t",
            "e",
            "r",
            "[",
            "]"
          ]
        }
      ]
    }
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _ **PrimitiveType**[]
RoundTrip Class_Head: input is - '_ **PrimitiveType**[]'
RoundTrip Class_Head: value is - {'name': 'PrimitiveType[]', 'one_liner': '', 'parenthetical': ''}
OK. {'name': 'PrimitiveType[]', 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'PrimitiveType[]'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _ **PrimitiveType**[]
		=parse=> {'name': 'PrimitiveType[]', 'one_liner': '', 'parenthetical': ''} 
		=render=> PrimitiveType[] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
[ldm_parse_core.py:314 -                         derive_dict()] <  Called by derive_dict with args (0,) {}
Derive dict for SUBTYPE_OF: Subtype of: ValueTypeA basic, built-in data type
RoundTrip SUBTYPE_OF: input is - ' ValueType['A basic, built-in data type']'
parse_name_list:  ValueType['A basic, built-in data type']
RoundTrip SUBTYPE_OF: value is - ["ValueType['A basic", "built-in data type']"]
validating name list:  ["ValueType['A basic", "built-in data type']"]
OK. ["ValueType['A basic", "built-in data type']"] ok for SUBTYPE_OF
RoundTrip SUBTYPE_OF: renders as - 'ValueType['A basic, built-in data type']'
parse_name_list: ValueType['A basic, built-in data type']
RoundTrip SUBTYPE_OF: reparses as - ["ValueType['A basic", "built-in data type']"]
RoundTrip SUCCESS:  ValueType['A basic, built-in data type']
		=parse=> ["ValueType['A basic", "built-in data type']"] 
		=render=> ValueType['A basic, built-in data type'] 
		=parse=> ["ValueType['A basic", "built-in data type']"]
adding non raw value. Subtype of -. ["ValueType['A basic", "built-in data type']"]
{
  "Subtype of_raw": " ValueType['A basic, built-in data type']",
  "Subtype of": [
    "ValueType['A basic",
    "built-in data type']"
  ]
}
[ldm_parse_core.py:314 -                         derive_dict()] >  Returned {'Subtype of_raw': " ValueType['A basic, built-in data type']", 'Subtype of': ["ValueType['A basic", "built-in data type']"]}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _ **PrimitiveType**
_ _ SUBTYPE_OF: Subtype of: ValueTypeA basic, built-in data type
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_ **PrimitiveType**[]",
  "name": "PrimitiveType[]",
  "one_liner": "",
  "parenthetical": "",
  "Subtype of_raw": [
    " ValueType['A basic, built-in data type']"
  ],
  "Subtype of": [
    "ValueType['A basic",
    "built-in data type']"
  ]
}
	Either is_list or is_cum; create list value
DerivingDict for Part:  Class
		Full header is: _Values:_['**String**', '**Integer**', '**Decimal**', '**Boolean**', '**Date**', '**Time**', '**DateTime**']
RoundTrip Class_Head: input is - '_Values:_['**String**', '**Integer**', '**Decimal**', '**Boolean**', '**Date**', '**Time**', '**DateTime**']'
RoundTrip Class_Head: value is - {'name': "Values:['String', 'Integer', 'Decimal', 'Boolean', 'Date', 'Time', 'DateTime']", 'one_liner': '', 'parenthetical': ''}
OK. {'name': "Values:['String', 'Integer', 'Decimal', 'Boolean', 'Date', 'Time', 'DateTime']", 'one_liner': '', 'parenthetical': ''} ok for Class_Head
RoundTrip Class_Head: renders as - 'Values:['String', 'Integer', 'Decimal', 'Boolean', 'Date', 'Time', 'DateTime']'
RoundTrip Class_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: _Values:_['**String**', '**Integer**', '**Decimal**', '**Boolean**', '**Date**', '**Time**', '**DateTime**']
		=parse=> {'name': "Values:['String', 'Integer', 'Decimal', 'Boolean', 'Date', 'Time', 'DateTime']", 'one_liner': '', 'parenthetical': ''} 
		=render=> Values:['String', 'Integer', 'Decimal', 'Boolean', 'Date', 'Time', 'DateTime'] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- adding TEXT para
Re-display for Part:  Class
. Class - <class 'ldm_parse_core.DocPart'> 
_ _ Class_Head: _Values:_**String** + **Integer** + **Decimal** + **Boolean** + **Date** + **Time** + **DateTime**
_ _ BLANK_LINE: 
_ _ TEXT_LINE: ===
DerivedDict for Part:  Class
{
  "_type": "Class",
  "full_header": "_Values:_['**String**', '**Integer**', '**Decimal**', '**Boolean**', '**Date**', '**Time**', '**DateTime**']",
  "name": "Values:['String', 'Integer', 'Decimal', 'Boolean', 'Date', 'Time', 'DateTime']",
  "one_liner": "",
  "parenthetical": ""
}
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
DerivingDict for Part:  Section2
		Full header is: ## Appendices['Insert More Sidebars.md', 'Insert Overrides.md', 'insert LDM Intro.md', 'Insert OCL.md', 'Insert Camel Case.md']
RoundTrip Section2_Head: input is - '## Appendices['Insert More Sidebars.md', 'Insert Overrides.md', 'insert LDM Intro.md', 'Insert OCL.md', 'Insert Camel Case.md']'
RoundTrip Section2_Head: value is - {'name': "Appendices['Insert More Sidebars.md', 'Insert Overrides.md', 'insert LDM Intro.md', 'Insert OCL.md', 'Insert Camel Case.md']", 'one_liner': '', 'parenthetical': ''}
OK. {'name': "Appendices['Insert More Sidebars.md', 'Insert Overrides.md', 'insert LDM Intro.md', 'Insert OCL.md', 'Insert Camel Case.md']", 'one_liner': '', 'parenthetical': ''} ok for Section2_Head
RoundTrip Section2_Head: renders as - 'Appendices['Insert More Sidebars.md', 'Insert Overrides.md', 'insert LDM Intro.md', 'Insert OCL.md', 'Insert Camel Case.md']'
RoundTrip Section2_Head: reparses as - {'name': '', 'one_liner': '', 'parenthetical': ''}
RoundTrip FAILURE: ## Appendices['Insert More Sidebars.md', 'Insert Overrides.md', 'insert LDM Intro.md', 'Insert OCL.md', 'Insert Camel Case.md']
		=parse=> {'name': "Appendices['Insert More Sidebars.md', 'Insert Overrides.md', 'insert LDM Intro.md', 'Insert OCL.md', 'Insert Camel Case.md']", 'one_liner': '', 'parenthetical': ''} 
		=render=> Appendices['Insert More Sidebars.md', 'Insert Overrides.md', 'insert LDM Intro.md', 'Insert OCL.md', 'Insert Camel Case.md'] 
		=parse=> {'name': '', 'one_liner': '', 'parenthetical': ''}
--- skipping BLANK_LINE
--- skipping BLANK_LINE
--- skipping BLANK_LINE
--- skipping BLANK_LINE
	Either is_list or is_cum; create list value
	Either is_list or is_cum; create list value
