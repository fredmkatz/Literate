[do_pom_test.py:6 -             test_pom()] Starting to test POM
[pom_grammar.py:39 -             __init__()] Initializing PresentableGrammar with model_name=Lit_01, format_name=dull
[pom_grammar.py:50 -             __init__()] Found model directory: C:\Users\fmkat\OneDrive\AllFMKFIles\AllVSCode\FMKProjects\Presentable\models\Lit_01
[pom_grammar.py:53 -             __init__()] Loaded model module: Lit_01.Lit_01
[do_pom_test.py:12 -             test_pom()] < __init__ of () {'model_name': 'Lit_01', 'format_name': 'dull', 'config_dict': {'case_sensitive': True, 'ambiguity': 'resolve', 'debug': False}}
[pom_grammar.py:56 -             __init__()] . Initializing PomConfig with model_name=Lit_01, format_name=dull
[util_flogging.py:203 -              wrapper()] . . Loading format files from paths: ['settings/dull_format.yaml', 'models/Lit_01/Lit_01_dull_format.yaml']
[util_flogging.py:203 -              wrapper()] . . Found format file: settings/dull_format.yaml
[util_flogging.py:203 -              wrapper()] . . Updated metadata: {'_defaults': {'is_abstract': False, 'field_value': '{field_name}: {field_value}', 'str': 'dull_str', 'int': 'dull_int', 'float': 'dull_float', 'bool': {'true': 'true', 'false': 'false', 'is_explicit': True}, 'list': '{element} (, {element})+', 'dict': 'dull dict', 'set': '{{element} (, {element})+}', 'tuple': '[{element} (, {element})+]', 'field_clause': '{field_name}: {field_value}'}}
[util_flogging.py:203 -              wrapper()] . . Found format file: models/Lit_01/Lit_01_dull_format.yaml
[util_flogging.py:203 -              wrapper()] . . Updated metadata: {'_defaults': {'is_abstract': False, 'field_value': '{field_name}: {field_value}', 'str': 'dull_str', 'int': 'dull_int', 'float': 'dull_float', 'bool': {'true': 'true', 'false': 'false', 'is_explicit': True}, 'list': '{element} (, {element})+', 'dict': 'dull dict', 'set': '{{element} (, {element})+}', 'tuple': '[{element} (, {element})+]', 'field_clause': '{field_name} ":"  {field_value}'}, 'Component': {'header': '_ {_type}: {name}{? - {one_liner}} NEWLINE'}, 'Class': {'header': '_ Class: {name}{? - {one_liner}} NEWLINE'}, 'Attribute': {'header': '-  {name}{? - {one_liner}}{? ({data_type_clause})} NEWLINE'}, 'BaseDataType': {'template': '{class_name} {? - {is_value}}'}, 'ListDataType': {'template': 'list of {element_type}'}, 'SetDataType': {'template': 'Set of {element_type}'}, 'MappingDataType': {'template': 'Mapping from {domain_type} to {range_type}'}, 'DataTypeClause': {'template': '{is_optional} {data_type}{? {cardinality}}'}}
Saved metadata to models/Lit_01/Lit_01_dull_y_external.yaml
## PomDict - External: 
# From YAML files:
##	Using built-in format: dull
## 	Using: settings/dull_format.yaml
## 	Using: models/Lit_01/Lit_01_dull_format.yaml
_defaults:
  is_abstract: false
  field_value: '{field_name}: {field_value}'
  str: dull_str
  int: dull_int
  float: dull_float
  bool:
    'true': 'true'
    'false': 'false'
    is_explicit: true
  list: '{element} (, {element})+'
  dict: dull dict
  set: '{{element} (, {element})+}'
  tuple: '[{element} (, {element})+]'
  field_clause: '{field_name} ":"  {field_value}'
Component:
  header: '_ {_type}: {name}{? - {one_liner}} NEWLINE'
Class:
  header: '_ Class: {name}{? - {one_liner}} NEWLINE'
Attribute:
  header: '-  {name}{? - {one_liner}}{? ({data_type_clause})} NEWLINE'
BaseDataType:
  template: '{class_name} {? - {is_value}}'
ListDataType:
  template: list of {element_type}
SetDataType:
  template: Set of {element_type}
MappingDataType:
  template: Mapping from {domain_type} to {range_type}
DataTypeClause:
  template: '{is_optional} {data_type}{? {cardinality}}'

[util_flogging.py:203 -              wrapper()] . Loading default configuration
[util_flogging.py:203 -              wrapper()] . . Looking for default config in settings/config.yaml
[util_flogging.py:203 -              wrapper()] . . . Updating config from file: settings/config.yaml
[do_pom_test.py:12 -             test_pom()] > None - from __init__
Config is  {
  "lark": {
    "case_sensitive": false,
    "ambiguity": "resolve",
    "debug": false
  },
  "case_sensitive": true,
  "ambiguity": "resolve",
  "debug": false
}
[pom_grammar_generator.py:101 -     generate_grammar()] Generating grammar for model module Lit_01.Lit_01
[pom_grammar.py:170 -  _initialize_grammar()] . . < _find_model_classes of (<module 'Lit_01.Lit_01' from 'C:\\Users\\fmkat\\OneDrive\\AllFMKFIles\\AllVSCode\\FMKProjects\\Presentable\\models\\Lit_01\\Lit_01.py'>,) {}
[pom_grammar_generator.py:110 -     generate_grammar()] . . . Found model_imports = [<class 'class_casing.UpperCamel'>, <class 'class_casing.LowerCamel'>, <class 'class_casing.CamelCase'>, <class 'class_pom_token.IsOptional'>, <class 'class_pom_token.IsRequired'>, <class 'class_pom_token.ReferenceOrValue'>]
[pom_grammar_generator.py:110 -     generate_grammar()] . . . Import class names: ['UpperCamel', 'LowerCamel', 'CamelCase', 'IsOptional', 'IsRequired', 'ReferenceOrValue']
[pom_grammar.py:170 -  _initialize_grammar()] . . > {'UpperCamel': <class 'class_casing.UpperCamel'>, 'LowerCamel': <class 'class_casing.LowerCamel'>, 'CamelCase': <class 'class_casing.CamelCase'>, 'IsOptional': <class 'class_pom_token.IsOptional'>, 'ReferenceOrValue': <class 'class_pom_token.ReferenceOrValue'>, 'IsRequired': <class 'class_pom_token.IsRequired'>, 'Paragraph': <class 'Lit_01.Lit_01.Paragraph'>, 'OneLiner': <class 'Lit_01.Lit_01.OneLiner'>, 'Label': <class 'Lit_01.Lit_01.Label'>, 'Annotation': <class 'Lit_01.Lit_01.Annotation'>, 'Component': <class 'Lit_01.Lit_01.Component'>, 'SubjectE': <class 'Lit_01.Lit_01.SubjectE'>, 'SubjectD': <class 'Lit_01.Lit_01.SubjectD'>, 'SubjectC': <class 'Lit_01.Lit_01.SubjectC'>, 'SubjectB': <class 'Lit_01.Lit_01.SubjectB'>, 'LDM': <class 'Lit_01.Lit_01.LDM'>, 'DataType': <class 'Lit_01.Lit_01.DataType'>, 'BaseDataType': <class 'Lit_01.Lit_01.BaseDataType'>, 'ListDataType': <class 'Lit_01.Lit_01.ListDataType'>, 'SetDataType': <class 'Lit_01.Lit_01.SetDataType'>, 'MappingDataType': <class 'Lit_01.Lit_01.MappingDataType'>, 'DataTypeClause': <class 'Lit_01.Lit_01.DataTypeClause'>, 'FormulaClause': <class 'Lit_01.Lit_01.FormulaClause'>, 'Formula': <class 'Lit_01.Lit_01.Formula'>, 'Constraint': <class 'Lit_01.Lit_01.Constraint'>, 'Derivation': <class 'Lit_01.Lit_01.Derivation'>, 'Default': <class 'Lit_01.Lit_01.Default'>, 'Class': <class 'Lit_01.Lit_01.Class'>, 'ValueType': <class 'Lit_01.Lit_01.ValueType'>, 'ReferenceType': <class 'Lit_01.Lit_01.ReferenceType'>, 'AttributeSection': <class 'Lit_01.Lit_01.AttributeSection'>, 'Attribute': <class 'Lit_01.Lit_01.Attribute'>} - from _find_model_classes
Saved metadata to models/Lit_01/Lit_01_dull_y_live.yaml
Saved metadata to models/Lit_01/Lit_01_dull_y_resolved.yaml
## PomDict - Resolved: 
## Resolved metadata from Live and External
# extracted from the Lit_01 model
# From YAML files:
##	Using built-in format: dull
## 	Using: settings/dull_format.yaml
## 	Using: models/Lit_01/Lit_01_dull_format.yaml
_defaults:
  field_value: '{field_name}: {field_value}'
  is_abstract: false
  str: dull_str
  int: dull_int
  float: dull_float
  bool:
    'true': 'true'
    'false': 'false'
    is_explicit: true
  list: '{element} (, {element})+'
  dict: dull dict
  set: '{{element} (, {element})+}'
  tuple: '[{element} (, {element})+]'
  field_clause: '{field_name} ":"  {field_value}'
Annotation:
  template: '{?{emoji}}  {label}: {content} NEWLINE'
Component:
  is_abstract: true
  header: '_ {_type}: {name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
SubjectE:
  header: '#####  {{name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
SubjectD:
  header: '####  {{name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
SubjectC:
  header: '###  {{name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
SubjectB:
  header: '##  {{name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
LDM:
  header: '#  {{name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
DataType:
  is_abstract: true
BaseDataType:
  template: '{class_name} {? - {is_value}}'
ListDataType:
  template: list of {element_type}
SetDataType:
  template: Set of {element_type}
MappingDataType:
  template: Mapping from {domain_type} to {range_type}
DataTypeClause:
  template: '{is_optional} {data_type}{? {cardinality}}'
  _fields:
    is_optional:
      bool:
        'true': optional
        'false': required
        is_explicit: false
Class:
  header: '_ Class: {name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
    attribute_sections:
      list: '{element}+'
      field_value: '{field_value}'
ValueType:
  header: _ {name}{? - {one_liner}} NEWLINE
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
    attribute_sections:
      list: '{element}+'
      field_value: '{field_value}'
ReferenceType:
  header: _ {name}{? - {one_liner}} NEWLINE
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
    attribute_sections:
      list: '{element}+'
      field_value: '{field_value}'
AttributeSection:
  header: '-  {name}{? - {one_liner}}{? ({is_required})} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
Attribute:
  header: '-  {name}{? - {one_liner}}{? ({data_type_clause})} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    constraints:
      list: '{element}+'
      field_value: '{field_value}'

[pom_grammar.py:170 -  _initialize_grammar()] . . < _derive_class_hierarchy of ({'UpperCamel': <class 'class_casing.UpperCamel'>, 'LowerCamel': <class 'class_casing.LowerCamel'>, 'CamelCase': <class 'class_casing.CamelCase'>, 'IsOptional': <class 'class_pom_token.IsOptional'>, 'ReferenceOrValue': <class 'class_pom_token.ReferenceOrValue'>, 'IsRequired': <class 'class_pom_token.IsRequired'>, 'Paragraph': <class 'Lit_01.Lit_01.Paragraph'>, 'OneLiner': <class 'Lit_01.Lit_01.OneLiner'>, 'Label': <class 'Lit_01.Lit_01.Label'>, 'Annotation': <class 'Lit_01.Lit_01.Annotation'>, 'Component': <class 'Lit_01.Lit_01.Component'>, 'SubjectE': <class 'Lit_01.Lit_01.SubjectE'>, 'SubjectD': <class 'Lit_01.Lit_01.SubjectD'>, 'SubjectC': <class 'Lit_01.Lit_01.SubjectC'>, 'SubjectB': <class 'Lit_01.Lit_01.SubjectB'>, 'LDM': <class 'Lit_01.Lit_01.LDM'>, 'DataType': <class 'Lit_01.Lit_01.DataType'>, 'BaseDataType': <class 'Lit_01.Lit_01.BaseDataType'>, 'ListDataType': <class 'Lit_01.Lit_01.ListDataType'>, 'SetDataType': <class 'Lit_01.Lit_01.SetDataType'>, 'MappingDataType': <class 'Lit_01.Lit_01.MappingDataType'>, 'DataTypeClause': <class 'Lit_01.Lit_01.DataTypeClause'>, 'FormulaClause': <class 'Lit_01.Lit_01.FormulaClause'>, 'Formula': <class 'Lit_01.Lit_01.Formula'>, 'Constraint': <class 'Lit_01.Lit_01.Constraint'>, 'Derivation': <class 'Lit_01.Lit_01.Derivation'>, 'Default': <class 'Lit_01.Lit_01.Default'>, 'Class': <class 'Lit_01.Lit_01.Class'>, 'ValueType': <class 'Lit_01.Lit_01.ValueType'>, 'ReferenceType': <class 'Lit_01.Lit_01.ReferenceType'>, 'AttributeSection': <class 'Lit_01.Lit_01.AttributeSection'>, 'Attribute': <class 'Lit_01.Lit_01.Attribute'>},) {}
[pom_grammar.py:170 -  _initialize_grammar()] . . > {'UpperCamel': {'class': <class 'class_casing.UpperCamel'>, 'bases': ['CamelCase'], 'subtypes': [], 'attributes': {}}, 'LowerCamel': {'class': <class 'class_casing.LowerCamel'>, 'bases': ['CamelCase'], 'subtypes': [], 'attributes': {}}, 'CamelCase': {'class': <class 'class_casing.CamelCase'>, 'bases': [], 'subtypes': ['UpperCamel', 'LowerCamel', 'Label'], 'attributes': {}}, 'IsOptional': {'class': <class 'class_pom_token.IsOptional'>, 'bases': [], 'subtypes': [], 'attributes': {}}, 'ReferenceOrValue': {'class': <class 'class_pom_token.ReferenceOrValue'>, 'bases': [], 'subtypes': [], 'attributes': {}}, 'IsRequired': {'class': <class 'class_pom_token.IsRequired'>, 'bases': [], 'subtypes': [], 'attributes': {}}, 'Paragraph': {'class': <class 'Lit_01.Lit_01.Paragraph'>, 'bases': [], 'subtypes': ['OneLiner'], 'attributes': {}}, 'OneLiner': {'class': <class 'Lit_01.Lit_01.OneLiner'>, 'bases': ['Paragraph'], 'subtypes': [], 'attributes': {}}, 'Label': {'class': <class 'Lit_01.Lit_01.Label'>, 'bases': ['CamelCase'], 'subtypes': [], 'attributes': {}}, 'Annotation': {'class': <class 'Lit_01.Lit_01.Annotation'>, 'bases': [], 'subtypes': [], 'attributes': {}}, 'Component': {'class': <class 'Lit_01.Lit_01.Component'>, 'bases': [], 'subtypes': ['SubjectE', 'Class', 'AttributeSection', 'Attribute'], 'attributes': {}}, 'SubjectE': {'class': <class 'Lit_01.Lit_01.SubjectE'>, 'bases': ['Component'], 'subtypes': ['SubjectD'], 'attributes': {}}, 'SubjectD': {'class': <class 'Lit_01.Lit_01.SubjectD'>, 'bases': ['SubjectE'], 'subtypes': ['SubjectC'], 'attributes': {}}, 'SubjectC': {'class': <class 'Lit_01.Lit_01.SubjectC'>, 'bases': ['SubjectD'], 'subtypes': ['SubjectB'], 'attributes': {}}, 'SubjectB': {'class': <class 'Lit_01.Lit_01.SubjectB'>, 'bases': ['SubjectC'], 'subtypes': ['LDM'], 'attributes': {}}, 'LDM': {'class': <class 'Lit_01.Lit_01.LDM'>, 'bases': ['SubjectB'], 'subtypes': [], 'attributes': {}}, 'DataType': {'class': <class 'Lit_01.Lit_01.DataType'>, 'bases': [], 'subtypes': ['BaseDataType', 'ListDataType', 'SetDataType', 'MappingDataType'], 'attributes': {}}, 'BaseDataType': {'class': <class 'Lit_01.Lit_01.BaseDataType'>, 'bases': ['DataType'], 'subtypes': [], 'attributes': {}}, 'ListDataType': {'class': <class 'Lit_01.Lit_01.ListDataType'>, 'bases': ['DataType'], 'subtypes': [], 'attributes': {}}, 'SetDataType': {'class': <class 'Lit_01.Lit_01.SetDataType'>, 'bases': ['DataType'], 'subtypes': [], 'attributes': {}}, 'MappingDataType': {'class': <class 'Lit_01.Lit_01.MappingDataType'>, 'bases': ['DataType'], 'subtypes': [], 'attributes': {}}, 'DataTypeClause': {'class': <class 'Lit_01.Lit_01.DataTypeClause'>, 'bases': [], 'subtypes': [], 'attributes': {}}, 'FormulaClause': {'class': <class 'Lit_01.Lit_01.FormulaClause'>, 'bases': [], 'subtypes': [], 'attributes': {}}, 'Formula': {'class': <class 'Lit_01.Lit_01.Formula'>, 'bases': [], 'subtypes': ['Constraint', 'Derivation', 'Default'], 'attributes': {}}, 'Constraint': {'class': <class 'Lit_01.Lit_01.Constraint'>, 'bases': ['Formula'], 'subtypes': [], 'attributes': {}}, 'Derivation': {'class': <class 'Lit_01.Lit_01.Derivation'>, 'bases': ['Formula'], 'subtypes': [], 'attributes': {}}, 'Default': {'class': <class 'Lit_01.Lit_01.Default'>, 'bases': ['Formula'], 'subtypes': [], 'attributes': {}}, 'Class': {'class': <class 'Lit_01.Lit_01.Class'>, 'bases': ['Component'], 'subtypes': ['ValueType', 'ReferenceType'], 'attributes': {}}, 'ValueType': {'class': <class 'Lit_01.Lit_01.ValueType'>, 'bases': ['Class'], 'subtypes': [], 'attributes': {}}, 'ReferenceType': {'class': <class 'Lit_01.Lit_01.ReferenceType'>, 'bases': ['Class'], 'subtypes': [], 'attributes': {}}, 'AttributeSection': {'class': <class 'Lit_01.Lit_01.AttributeSection'>, 'bases': ['Component'], 'subtypes': [], 'attributes': {}}, 'Attribute': {'class': <class 'Lit_01.Lit_01.Attribute'>, 'bases': ['Component'], 'subtypes': [], 'attributes': {}}} - from _derive_class_hierarchy
Starting class rules
## PomDict - Resolved: 
## Resolved metadata from Live and External
# extracted from the Lit_01 model
# From YAML files:
##	Using built-in format: dull
## 	Using: settings/dull_format.yaml
## 	Using: models/Lit_01/Lit_01_dull_format.yaml
_defaults:
  field_value: '{field_name}: {field_value}'
  is_abstract: false
  str: dull_str
  int: dull_int
  float: dull_float
  bool:
    'true': 'true'
    'false': 'false'
    is_explicit: true
  list: '{element} (, {element})+'
  dict: dull dict
  set: '{{element} (, {element})+}'
  tuple: '[{element} (, {element})+]'
  field_clause: '{field_name} ":"  {field_value}'
Annotation:
  template: '{?{emoji}}  {label}: {content} NEWLINE'
Component:
  is_abstract: true
  header: '_ {_type}: {name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
SubjectE:
  header: '#####  {{name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
SubjectD:
  header: '####  {{name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
SubjectC:
  header: '###  {{name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
SubjectB:
  header: '##  {{name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
LDM:
  header: '#  {{name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
DataType:
  is_abstract: true
BaseDataType:
  template: '{class_name} {? - {is_value}}'
ListDataType:
  template: list of {element_type}
SetDataType:
  template: Set of {element_type}
MappingDataType:
  template: Mapping from {domain_type} to {range_type}
DataTypeClause:
  template: '{is_optional} {data_type}{? {cardinality}}'
  _fields:
    is_optional:
      bool:
        'true': optional
        'false': required
        is_explicit: false
Class:
  header: '_ Class: {name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
    attribute_sections:
      list: '{element}+'
      field_value: '{field_value}'
ValueType:
  header: _ {name}{? - {one_liner}} NEWLINE
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
    attribute_sections:
      list: '{element}+'
      field_value: '{field_value}'
ReferenceType:
  header: _ {name}{? - {one_liner}} NEWLINE
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
    attribute_sections:
      list: '{element}+'
      field_value: '{field_value}'
AttributeSection:
  header: '-  {name}{? - {one_liner}}{? ({is_required})} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
Attribute:
  header: '-  {name}{? - {one_liner}}{? ({data_type_clause})} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    constraints:
      list: '{element}+'
      field_value: '{field_value}'

[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('UpperCamel', <class 'class_casing.UpperCamel'>) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Token pattern: (?:[A-Za-z][A-Za-z0-9]*(?:[-_.][A-Za-z][A-Za-z0-9]*)*)(?:\s+(?:[A-Za-z][A-Za-z0-9]*(?:[-_.][A-Za-z][A-Za-z0-9]*)*))*
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('LowerCamel', <class 'class_casing.LowerCamel'>) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Token pattern: (?:[A-Za-z][A-Za-z0-9]*(?:[-_.][A-Za-z][A-Za-z0-9]*)*)(?:\s+(?:[A-Za-z][A-Za-z0-9]*(?:[-_.][A-Za-z][A-Za-z0-9]*)*))*
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('CamelCase', <class 'class_casing.CamelCase'>) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Token pattern: (?:[A-Za-z][A-Za-z0-9]*(?:[-_.][A-Za-z][A-Za-z0-9]*)*)(?:\s+(?:[A-Za-z][A-Za-z0-9]*(?:[-_.][A-Za-z][A-Za-z0-9]*)*))*
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('IsOptional', <class 'class_pom_token.IsOptional'>) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Token pattern: "optional"i | "true"i | "sure"i | "yes"i | "required"i | "false"i | "no way"i
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('ReferenceOrValue', <class 'class_pom_token.ReferenceOrValue'>) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Token pattern: "reference"i | "value"i
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('IsRequired', <class 'class_pom_token.IsRequired'>) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Token pattern: "required"i | "true"i | "sure"i | "yes"i | "optional"i | "false"i | "no way"i
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('Paragraph', <class 'Lit_01.Lit_01.Paragraph'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('Paragraph',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of Paragraph are ['OneLiner']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class Paragraph is not abstract, generating own rule with clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('Paragraph', <class 'Lit_01.Lit_01.Paragraph'>, set()) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['CONTENT: STRING\t-> Paragraph_content_str'], []) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('OneLiner', <class 'Lit_01.Lit_01.OneLiner'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('OneLiner',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of OneLiner are []
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class OneLiner is not abstract, generating own rule with clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('OneLiner', <class 'Lit_01.Lit_01.OneLiner'>, set()) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['CONTENT: STRING\t-> OneLiner_content_str'], []) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('Label', <class 'Lit_01.Lit_01.Label'>) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Token pattern: (?:[A-Za-z][A-Za-z0-9]*(?:[-_.][A-Za-z][A-Za-z0-9]*)*)(?:\s+(?:[A-Za-z][A-Za-z0-9]*(?:[-_.][A-Za-z][A-Za-z0-9]*)*))*
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('Annotation', <class 'Lit_01.Lit_01.Annotation'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('Annotation',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of Annotation are []
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class Annotation is not abstract, generating own rule with clauses
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Full template is {?{emoji}}  {label}: {content} NEWLINE
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_full_class_by_template of ('Annotation', PomTemplate({?{emoji}}  {label}: {content} NEWLINE)) {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Preprocessed template: [{emoji}]  {label}: {content} NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . Preprocessed template: {emoji}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . Final grammar parts: ['Annotation_emoji_value']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Final grammar parts: ['[', 'Annotation_emoji_value', ']', 'Annotation_label_value', 'COLON', 'Annotation_content_value', 'NEWLINE']
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . rule parts are: ['[', 'Annotation_emoji_value', ']', 'Annotation_label_value', 'COLON', 'Annotation_content_value', 'NEWLINE']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > Annotation:	[ Annotation_emoji_value ] Annotation_label_value COLON Annotation_content_value NEWLINE - from _gen_full_class_by_template
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(2, 9, 'emoji')]
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(2, 9, 'emoji'), (12, 19, 'label')]
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(2, 9, 'emoji'), (12, 19, 'label'), (21, 30, 'content')]
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > {'label', 'emoji', 'content'} - from find_fields
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('Annotation', <class 'Lit_01.Lit_01.Annotation'>, {'label', 'emoji', 'content'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['LABEL: Label\t-> Annotation_label_simple', 'CONTENT: OneLiner\t-> Annotation_content_simple', 'EMOJI: STRING\t-> Annotation_emoji_str'], [Rule(name='Annotation_label_value', text='Label'), Rule(name='Annotation_content_value', text='OneLiner'), Rule(name='Annotation_emoji_value', text='STRING')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('Component', <class 'Lit_01.Lit_01.Component'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('Component',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of Component are ['SubjectE', 'Class', 'AttributeSection', 'Attribute']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class Component is abstract, skipping rule generation
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('SubjectE', <class 'Lit_01.Lit_01.SubjectE'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('SubjectE',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of SubjectE are ['SubjectD']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class SubjectE is not abstract, generating own rule with clauses
[util_flogging.py:203 -              wrapper()] . . . . . . Preprocessed template: #####  {{name}[- {one_liner}] NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . Preprocessed template: - {one_liner}
[util_flogging.py:239 -              wrapper()] . . . . . . . Final grammar parts: ['DASH', 'SubjectE_oneLiner_value']
[util_flogging.py:203 -              wrapper()] . . . . . . Final grammar parts: ['HASH', 'HASH', 'HASH', 'HASH', 'HASH', 'LBRACE', 'SubjectE_name_value', '[', 'DASH', 'SubjectE_oneLiner_value', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . rule parts are: ['HASH', 'HASH', 'HASH', 'HASH', 'HASH', 'LBRACE', 'SubjectE_name_value', '[', 'DASH', 'SubjectE_oneLiner_value', ']', 'NEWLINE']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(8, 14, 'name')]
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(8, 14, 'name'), (19, 30, 'one_liner')]
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > {'one_liner', 'name'} - from find_fields
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('SubjectE', <class 'Lit_01.Lit_01.SubjectE'>, {'one_liner', 'name'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['NAME: CamelCase\t-> SubjectE_name_simple', 'ONE_LINER: OneLiner\t-> SubjectE_oneLiner_simple', 'ABBREVIATION: UpperCamel\t-> SubjectE_abbreviation_simple', 'Paragraph+\t-> SubjectE_elaboration_list', 'Annotation+\t-> SubjectE_annotations_list', 'Class+\t-> SubjectE_classes_list'], [Rule(name='SubjectE_name_value', text='CamelCase'), Rule(name='SubjectE_oneLiner_value', text='OneLiner')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('SubjectE', <class 'Lit_01.Lit_01.SubjectE'>, {'one_liner', 'name'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['NAME: CamelCase\t-> SubjectE_name_simple', 'ONE_LINER: OneLiner\t-> SubjectE_oneLiner_simple', 'ABBREVIATION: UpperCamel\t-> SubjectE_abbreviation_simple', 'Paragraph+\t-> SubjectE_elaboration_list', 'Annotation+\t-> SubjectE_annotations_list', 'Class+\t-> SubjectE_classes_list'], [Rule(name='SubjectE_name_value', text='CamelCase'), Rule(name='SubjectE_oneLiner_value', text='OneLiner')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('SubjectD', <class 'Lit_01.Lit_01.SubjectD'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('SubjectD',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of SubjectD are ['SubjectC']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class SubjectD is not abstract, generating own rule with clauses
[util_flogging.py:203 -              wrapper()] . . . . . . Preprocessed template: ####  {{name}[- {one_liner}] NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . Preprocessed template: - {one_liner}
[util_flogging.py:239 -              wrapper()] . . . . . . . Final grammar parts: ['DASH', 'SubjectD_oneLiner_value']
[util_flogging.py:203 -              wrapper()] . . . . . . Final grammar parts: ['HASH', 'HASH', 'HASH', 'HASH', 'LBRACE', 'SubjectD_name_value', '[', 'DASH', 'SubjectD_oneLiner_value', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . rule parts are: ['HASH', 'HASH', 'HASH', 'HASH', 'LBRACE', 'SubjectD_name_value', '[', 'DASH', 'SubjectD_oneLiner_value', ']', 'NEWLINE']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(7, 13, 'name')]
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(7, 13, 'name'), (18, 29, 'one_liner')]
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > {'one_liner', 'name'} - from find_fields
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('SubjectD', <class 'Lit_01.Lit_01.SubjectD'>, {'one_liner', 'name'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['NAME: CamelCase\t-> SubjectD_name_simple', 'ONE_LINER: OneLiner\t-> SubjectD_oneLiner_simple', 'ABBREVIATION: UpperCamel\t-> SubjectD_abbreviation_simple', 'Paragraph+\t-> SubjectD_elaboration_list', 'Annotation+\t-> SubjectD_annotations_list', 'Class+\t-> SubjectD_classes_list', 'SubjectE+\t-> SubjectD_subjects_list'], [Rule(name='SubjectD_name_value', text='CamelCase'), Rule(name='SubjectD_oneLiner_value', text='OneLiner')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('SubjectD', <class 'Lit_01.Lit_01.SubjectD'>, {'one_liner', 'name'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['NAME: CamelCase\t-> SubjectD_name_simple', 'ONE_LINER: OneLiner\t-> SubjectD_oneLiner_simple', 'ABBREVIATION: UpperCamel\t-> SubjectD_abbreviation_simple', 'Paragraph+\t-> SubjectD_elaboration_list', 'Annotation+\t-> SubjectD_annotations_list', 'Class+\t-> SubjectD_classes_list', 'SubjectE+\t-> SubjectD_subjects_list'], [Rule(name='SubjectD_name_value', text='CamelCase'), Rule(name='SubjectD_oneLiner_value', text='OneLiner')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('SubjectC', <class 'Lit_01.Lit_01.SubjectC'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('SubjectC',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of SubjectC are ['SubjectB']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class SubjectC is not abstract, generating own rule with clauses
[util_flogging.py:203 -              wrapper()] . . . . . . Preprocessed template: ###  {{name}[- {one_liner}] NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . Preprocessed template: - {one_liner}
[util_flogging.py:239 -              wrapper()] . . . . . . . Final grammar parts: ['DASH', 'SubjectC_oneLiner_value']
[util_flogging.py:203 -              wrapper()] . . . . . . Final grammar parts: ['HASH', 'HASH', 'HASH', 'LBRACE', 'SubjectC_name_value', '[', 'DASH', 'SubjectC_oneLiner_value', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . rule parts are: ['HASH', 'HASH', 'HASH', 'LBRACE', 'SubjectC_name_value', '[', 'DASH', 'SubjectC_oneLiner_value', ']', 'NEWLINE']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(6, 12, 'name')]
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(6, 12, 'name'), (17, 28, 'one_liner')]
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > {'one_liner', 'name'} - from find_fields
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('SubjectC', <class 'Lit_01.Lit_01.SubjectC'>, {'one_liner', 'name'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['NAME: CamelCase\t-> SubjectC_name_simple', 'ONE_LINER: OneLiner\t-> SubjectC_oneLiner_simple', 'ABBREVIATION: UpperCamel\t-> SubjectC_abbreviation_simple', 'Paragraph+\t-> SubjectC_elaboration_list', 'Annotation+\t-> SubjectC_annotations_list', 'Class+\t-> SubjectC_classes_list', 'SubjectD+\t-> SubjectC_subjects_list'], [Rule(name='SubjectC_name_value', text='CamelCase'), Rule(name='SubjectC_oneLiner_value', text='OneLiner')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('SubjectC', <class 'Lit_01.Lit_01.SubjectC'>, {'one_liner', 'name'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['NAME: CamelCase\t-> SubjectC_name_simple', 'ONE_LINER: OneLiner\t-> SubjectC_oneLiner_simple', 'ABBREVIATION: UpperCamel\t-> SubjectC_abbreviation_simple', 'Paragraph+\t-> SubjectC_elaboration_list', 'Annotation+\t-> SubjectC_annotations_list', 'Class+\t-> SubjectC_classes_list', 'SubjectD+\t-> SubjectC_subjects_list'], [Rule(name='SubjectC_name_value', text='CamelCase'), Rule(name='SubjectC_oneLiner_value', text='OneLiner')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('SubjectB', <class 'Lit_01.Lit_01.SubjectB'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('SubjectB',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of SubjectB are ['LDM']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class SubjectB is not abstract, generating own rule with clauses
[util_flogging.py:203 -              wrapper()] . . . . . . Preprocessed template: ##  {{name}[- {one_liner}] NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . Preprocessed template: - {one_liner}
[util_flogging.py:239 -              wrapper()] . . . . . . . Final grammar parts: ['DASH', 'SubjectB_oneLiner_value']
[util_flogging.py:203 -              wrapper()] . . . . . . Final grammar parts: ['HASH', 'HASH', 'LBRACE', 'SubjectB_name_value', '[', 'DASH', 'SubjectB_oneLiner_value', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . rule parts are: ['HASH', 'HASH', 'LBRACE', 'SubjectB_name_value', '[', 'DASH', 'SubjectB_oneLiner_value', ']', 'NEWLINE']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(5, 11, 'name')]
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(5, 11, 'name'), (16, 27, 'one_liner')]
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > {'one_liner', 'name'} - from find_fields
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('SubjectB', <class 'Lit_01.Lit_01.SubjectB'>, {'one_liner', 'name'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['NAME: CamelCase\t-> SubjectB_name_simple', 'ONE_LINER: OneLiner\t-> SubjectB_oneLiner_simple', 'ABBREVIATION: UpperCamel\t-> SubjectB_abbreviation_simple', 'Paragraph+\t-> SubjectB_elaboration_list', 'Annotation+\t-> SubjectB_annotations_list', 'Class+\t-> SubjectB_classes_list', 'SubjectC+\t-> SubjectB_subjects_list'], [Rule(name='SubjectB_name_value', text='CamelCase'), Rule(name='SubjectB_oneLiner_value', text='OneLiner')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('SubjectB', <class 'Lit_01.Lit_01.SubjectB'>, {'one_liner', 'name'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['NAME: CamelCase\t-> SubjectB_name_simple', 'ONE_LINER: OneLiner\t-> SubjectB_oneLiner_simple', 'ABBREVIATION: UpperCamel\t-> SubjectB_abbreviation_simple', 'Paragraph+\t-> SubjectB_elaboration_list', 'Annotation+\t-> SubjectB_annotations_list', 'Class+\t-> SubjectB_classes_list', 'SubjectC+\t-> SubjectB_subjects_list'], [Rule(name='SubjectB_name_value', text='CamelCase'), Rule(name='SubjectB_oneLiner_value', text='OneLiner')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('LDM', <class 'Lit_01.Lit_01.LDM'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('LDM',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of LDM are []
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class LDM is not abstract, generating own rule with clauses
[util_flogging.py:203 -              wrapper()] . . . . . . Preprocessed template: #  {{name}[- {one_liner}] NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . Preprocessed template: - {one_liner}
[util_flogging.py:239 -              wrapper()] . . . . . . . Final grammar parts: ['DASH', 'LDM_oneLiner_value']
[util_flogging.py:203 -              wrapper()] . . . . . . Final grammar parts: ['HASH', 'LBRACE', 'LDM_name_value', '[', 'DASH', 'LDM_oneLiner_value', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . rule parts are: ['HASH', 'LBRACE', 'LDM_name_value', '[', 'DASH', 'LDM_oneLiner_value', ']', 'NEWLINE']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(4, 10, 'name')]
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(4, 10, 'name'), (15, 26, 'one_liner')]
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > {'one_liner', 'name'} - from find_fields
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('LDM', <class 'Lit_01.Lit_01.LDM'>, {'one_liner', 'name'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['NAME: CamelCase\t-> LDM_name_simple', 'ONE_LINER: OneLiner\t-> LDM_oneLiner_simple', 'ABBREVIATION: UpperCamel\t-> LDM_abbreviation_simple', 'Paragraph+\t-> LDM_elaboration_list', 'Annotation+\t-> LDM_annotations_list', 'Class+\t-> LDM_classes_list', 'SubjectB+\t-> LDM_subjects_list'], [Rule(name='LDM_name_value', text='CamelCase'), Rule(name='LDM_oneLiner_value', text='OneLiner')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('LDM', <class 'Lit_01.Lit_01.LDM'>, {'one_liner', 'name'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['NAME: CamelCase\t-> LDM_name_simple', 'ONE_LINER: OneLiner\t-> LDM_oneLiner_simple', 'ABBREVIATION: UpperCamel\t-> LDM_abbreviation_simple', 'Paragraph+\t-> LDM_elaboration_list', 'Annotation+\t-> LDM_annotations_list', 'Class+\t-> LDM_classes_list', 'SubjectB+\t-> LDM_subjects_list'], [Rule(name='LDM_name_value', text='CamelCase'), Rule(name='LDM_oneLiner_value', text='OneLiner')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('DataType', <class 'Lit_01.Lit_01.DataType'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('DataType',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of DataType are ['BaseDataType', 'ListDataType', 'SetDataType', 'MappingDataType']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class DataType is abstract, skipping rule generation
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('BaseDataType', <class 'Lit_01.Lit_01.BaseDataType'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('BaseDataType',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of BaseDataType are []
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class BaseDataType is not abstract, generating own rule with clauses
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Full template is {class_name} {? - {is_value}}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_full_class_by_template of ('BaseDataType', PomTemplate({class_name} {? - {is_value}})) {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Preprocessed template: {class_name} [- {is_value}]
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . Preprocessed template: - {is_value}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . Final grammar parts: ['DASH', 'BaseDataType_isValue_value']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Final grammar parts: ['BaseDataType_className_value', '[', 'DASH', 'BaseDataType_isValue_value', ']']
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . rule parts are: ['BaseDataType_className_value', '[', 'DASH', 'BaseDataType_isValue_value', ']']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > BaseDataType:	BaseDataType_className_value [ DASH BaseDataType_isValue_value ] - from _gen_full_class_by_template
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(0, 12, 'class_name')]
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(0, 12, 'class_name'), (18, 28, 'is_value')]
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > {'is_value', 'class_name'} - from find_fields
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('BaseDataType', <class 'Lit_01.Lit_01.BaseDataType'>, {'is_value', 'class_name'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['CLASS_NAME: STRING\t-> BaseDataType_className_str', 'IS_VALUE: ReferenceOrValue\t-> BaseDataType_isValue_simple'], [Rule(name='BaseDataType_className_value', text='STRING'), Rule(name='BaseDataType_isValue_value', text='ReferenceOrValue')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('ListDataType', <class 'Lit_01.Lit_01.ListDataType'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('ListDataType',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of ListDataType are []
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class ListDataType is not abstract, generating own rule with clauses
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Full template is list of {element_type}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_full_class_by_template of ('ListDataType', PomTemplate(list of {element_type})) {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Preprocessed template: list of {element_type}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Final grammar parts: ['LIST', 'OF', 'ListDataType_elementType_value']
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . rule parts are: ['LIST', 'OF', 'ListDataType_elementType_value']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > ListDataType:	LIST OF ListDataType_elementType_value - from _gen_full_class_by_template
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(8, 22, 'element_type')]
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > {'element_type'} - from find_fields
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('ListDataType', <class 'Lit_01.Lit_01.ListDataType'>, {'element_type'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['ELEMENT_TYPE: DataType\t-> ListDataType_elementType_simple'], [Rule(name='ListDataType_elementType_value', text='DataType')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('SetDataType', <class 'Lit_01.Lit_01.SetDataType'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('SetDataType',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of SetDataType are []
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class SetDataType is not abstract, generating own rule with clauses
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Full template is Set of {element_type}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_full_class_by_template of ('SetDataType', PomTemplate(Set of {element_type})) {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Preprocessed template: Set of {element_type}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Final grammar parts: ['SET', 'OF', 'SetDataType_elementType_value']
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . rule parts are: ['SET', 'OF', 'SetDataType_elementType_value']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > SetDataType:	SET OF SetDataType_elementType_value - from _gen_full_class_by_template
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(7, 21, 'element_type')]
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > {'element_type'} - from find_fields
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('SetDataType', <class 'Lit_01.Lit_01.SetDataType'>, {'element_type'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['ELEMENT_TYPE: DataType\t-> SetDataType_elementType_simple'], [Rule(name='SetDataType_elementType_value', text='DataType')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('MappingDataType', <class 'Lit_01.Lit_01.MappingDataType'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('MappingDataType',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of MappingDataType are []
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class MappingDataType is not abstract, generating own rule with clauses
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Full template is Mapping from {domain_type} to {range_type}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_full_class_by_template of ('MappingDataType', PomTemplate(Mapping from {domain_type} to {range_type})) {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Preprocessed template: Mapping from {domain_type} to {range_type}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Final grammar parts: ['MAPPING', 'FROM', 'MappingDataType_domainType_value', 'TO', 'MappingDataType_rangeType_value']
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . rule parts are: ['MAPPING', 'FROM', 'MappingDataType_domainType_value', 'TO', 'MappingDataType_rangeType_value']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > MappingDataType:	MAPPING FROM MappingDataType_domainType_value TO MappingDataType_rangeType_value - from _gen_full_class_by_template
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(13, 26, 'domain_type')]
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(13, 26, 'domain_type'), (30, 42, 'range_type')]
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > {'domain_type', 'range_type'} - from find_fields
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('MappingDataType', <class 'Lit_01.Lit_01.MappingDataType'>, {'domain_type', 'range_type'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['DOMAIN_TYPE: DataType\t-> MappingDataType_domainType_simple', 'RANGE_TYPE: DataType\t-> MappingDataType_rangeType_simple'], [Rule(name='MappingDataType_domainType_value', text='DataType'), Rule(name='MappingDataType_rangeType_value', text='DataType')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('DataTypeClause', <class 'Lit_01.Lit_01.DataTypeClause'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('DataTypeClause',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of DataTypeClause are []
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class DataTypeClause is not abstract, generating own rule with clauses
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Full template is {is_optional} {data_type}{? {cardinality}}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_full_class_by_template of ('DataTypeClause', PomTemplate({is_optional} {data_type}{? {cardinality}})) {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Preprocessed template: {is_optional} {data_type}[{cardinality}]
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . Preprocessed template: {cardinality}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . Final grammar parts: ['DataTypeClause_cardinality_value']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Final grammar parts: ['DataTypeClause_isOptional_value', 'DataTypeClause_dataType_value', '[', 'DataTypeClause_cardinality_value', ']']
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . rule parts are: ['DataTypeClause_isOptional_value', 'DataTypeClause_dataType_value', '[', 'DataTypeClause_cardinality_value', ']']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > DataTypeClause:	DataTypeClause_isOptional_value DataTypeClause_dataType_value [ DataTypeClause_cardinality_value ] - from _gen_full_class_by_template
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(0, 13, 'is_optional')]
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(0, 13, 'is_optional'), (14, 25, 'data_type')]
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(0, 13, 'is_optional'), (14, 25, 'data_type'), (28, 41, 'cardinality')]
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > {'cardinality', 'data_type', 'is_optional'} - from find_fields
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('DataTypeClause', <class 'Lit_01.Lit_01.DataTypeClause'>, {'cardinality', 'data_type', 'is_optional'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['DATA_TYPE: DataType\t-> DataTypeClause_dataType_simple', 'IS_REQUIRED: IsRequired\t-> DataTypeClause_isRequired_simple', 'IS_ALSO_OPTIONAL: IsOptional\t-> DataTypeClause_isAlsoOptional_simple', 'IS_OPTIONAL: BOOLEAN\t-> DataTypeClause_isOptional_bool', 'CARDINALITY: STRING\t-> DataTypeClause_cardinality_str'], [Rule(name='DataTypeClause_dataType_value', text='DataType'), Rule(name='DataTypeClause_isOptional_value', text='BOOLEAN'), Rule(name='DataTypeClause_cardinality_value', text='STRING')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('FormulaClause', <class 'Lit_01.Lit_01.FormulaClause'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('FormulaClause',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of FormulaClause are []
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class FormulaClause is not abstract, generating own rule with clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('FormulaClause', <class 'Lit_01.Lit_01.FormulaClause'>, set()) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['CONTENT: STRING\t-> FormulaClause_content_str'], []) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('Formula', <class 'Lit_01.Lit_01.Formula'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('Formula',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of Formula are ['Constraint', 'Derivation', 'Default']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class Formula is not abstract, generating own rule with clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('Formula', <class 'Lit_01.Lit_01.Formula'>, set()) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['ENGLISH: STRING\t-> Formula_english_str', 'CODE: FormulaClause\t-> Formula_code_simple'], []) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('Constraint', <class 'Lit_01.Lit_01.Constraint'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('Constraint',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of Constraint are []
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class Constraint is not abstract, generating own rule with clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('Constraint', <class 'Lit_01.Lit_01.Constraint'>, set()) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['ENGLISH: STRING\t-> Constraint_english_str', 'CODE: FormulaClause\t-> Constraint_code_simple', 'MESSAGE: STRING\t-> Constraint_message_str', 'SEVERITY: STRING\t-> Constraint_severity_str'], []) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('Derivation', <class 'Lit_01.Lit_01.Derivation'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('Derivation',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of Derivation are []
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class Derivation is not abstract, generating own rule with clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('Derivation', <class 'Lit_01.Lit_01.Derivation'>, set()) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['ENGLISH: STRING\t-> Derivation_english_str', 'CODE: FormulaClause\t-> Derivation_code_simple'], []) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('Default', <class 'Lit_01.Lit_01.Default'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('Default',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of Default are []
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class Default is not abstract, generating own rule with clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('Default', <class 'Lit_01.Lit_01.Default'>, set()) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['ENGLISH: STRING\t-> Default_english_str', 'CODE: FormulaClause\t-> Default_code_simple'], []) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('Class', <class 'Lit_01.Lit_01.Class'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('Class',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of Class are ['ValueType', 'ReferenceType']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class Class is not abstract, generating own rule with clauses
[util_flogging.py:203 -              wrapper()] . . . . . . Preprocessed template: _ Class: {name}[- {one_liner}] NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . Preprocessed template: - {one_liner}
[util_flogging.py:239 -              wrapper()] . . . . . . . Final grammar parts: ['DASH', 'Class_oneLiner_value']
[util_flogging.py:203 -              wrapper()] . . . . . . Final grammar parts: ['UNDERSCORE', 'CLASS', 'COLON', 'Class_name_value', '[', 'DASH', 'Class_oneLiner_value', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . rule parts are: ['UNDERSCORE', 'CLASS', 'COLON', 'Class_name_value', '[', 'DASH', 'Class_oneLiner_value', ']', 'NEWLINE']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(9, 15, 'name')]
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(9, 15, 'name'), (20, 31, 'one_liner')]
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > {'one_liner', 'name'} - from find_fields
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('Class', <class 'Lit_01.Lit_01.Class'>, {'one_liner', 'name'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['NAME: UpperCamel\t-> Class_name_simple', 'ONE_LINER: OneLiner\t-> Class_oneLiner_simple', 'ABBREVIATION: UpperCamel\t-> Class_abbreviation_simple', 'Paragraph+\t-> Class_elaboration_list', 'Annotation+\t-> Class_annotations_list', 'PLURAL: UpperCamel\t-> Class_plural_simple', 'SUBTYPE_OF: ClassName (, ClassName)+\t-> Class_subtypeOf_list', 'SUBTYPES: ClassName (, ClassName)+\t-> Class_subtypes_list', 'BASED_ON: ClassName (, ClassName)+\t-> Class_basedOn_list', 'DEPENDENTS: ClassName (, ClassName)+\t-> Class_dependents_list', "SAMPLERA: '(' NUMBER, STRING, DataType ')'\t-> Class_samplerA_tuple", 'IS_VALUE_TYPE: BOOLEAN\t-> Class_isValueType_bool', 'WHERE: STRING\t-> Class_where_str', 'Attribute+\t-> Class_attributes_list', 'AttributeSection+\t-> Class_attributeSections_list'], [Rule(name='Class_name_value', text='UpperCamel'), Rule(name='Class_oneLiner_value', text='OneLiner')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('Class', <class 'Lit_01.Lit_01.Class'>, {'one_liner', 'name'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['NAME: UpperCamel\t-> Class_name_simple', 'ONE_LINER: OneLiner\t-> Class_oneLiner_simple', 'ABBREVIATION: UpperCamel\t-> Class_abbreviation_simple', 'Paragraph+\t-> Class_elaboration_list', 'Annotation+\t-> Class_annotations_list', 'PLURAL: UpperCamel\t-> Class_plural_simple', 'SUBTYPE_OF: ClassName (, ClassName)+\t-> Class_subtypeOf_list', 'SUBTYPES: ClassName (, ClassName)+\t-> Class_subtypes_list', 'BASED_ON: ClassName (, ClassName)+\t-> Class_basedOn_list', 'DEPENDENTS: ClassName (, ClassName)+\t-> Class_dependents_list', "SAMPLERA: '(' NUMBER, STRING, DataType ')'\t-> Class_samplerA_tuple", 'IS_VALUE_TYPE: BOOLEAN\t-> Class_isValueType_bool', 'WHERE: STRING\t-> Class_where_str', 'Attribute+\t-> Class_attributes_list', 'AttributeSection+\t-> Class_attributeSections_list'], [Rule(name='Class_name_value', text='UpperCamel'), Rule(name='Class_oneLiner_value', text='OneLiner')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('ValueType', <class 'Lit_01.Lit_01.ValueType'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('ValueType',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of ValueType are []
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class ValueType is not abstract, generating own rule with clauses
[util_flogging.py:203 -              wrapper()] . . . . . . Preprocessed template: _ {name}[- {one_liner}] NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . Preprocessed template: - {one_liner}
[util_flogging.py:239 -              wrapper()] . . . . . . . Final grammar parts: ['DASH', 'ValueType_oneLiner_value']
[util_flogging.py:203 -              wrapper()] . . . . . . Final grammar parts: ['UNDERSCORE', 'ValueType_name_value', '[', 'DASH', 'ValueType_oneLiner_value', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . rule parts are: ['UNDERSCORE', 'ValueType_name_value', '[', 'DASH', 'ValueType_oneLiner_value', ']', 'NEWLINE']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(2, 8, 'name')]
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(2, 8, 'name'), (13, 24, 'one_liner')]
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > {'one_liner', 'name'} - from find_fields
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('ValueType', <class 'Lit_01.Lit_01.ValueType'>, {'one_liner', 'name'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['NAME: UpperCamel\t-> ValueType_name_simple', 'ONE_LINER: OneLiner\t-> ValueType_oneLiner_simple', 'ABBREVIATION: UpperCamel\t-> ValueType_abbreviation_simple', 'Paragraph+\t-> ValueType_elaboration_list', 'Annotation+\t-> ValueType_annotations_list', 'PLURAL: UpperCamel\t-> ValueType_plural_simple', 'SUBTYPE_OF: ClassName (, ClassName)+\t-> ValueType_subtypeOf_list', 'SUBTYPES: ClassName (, ClassName)+\t-> ValueType_subtypes_list', 'BASED_ON: ClassName (, ClassName)+\t-> ValueType_basedOn_list', 'DEPENDENTS: ClassName (, ClassName)+\t-> ValueType_dependents_list', "SAMPLERA: '(' NUMBER, STRING, DataType ')'\t-> ValueType_samplerA_tuple", 'IS_VALUE_TYPE: BOOLEAN\t-> ValueType_isValueType_bool', 'WHERE: STRING\t-> ValueType_where_str', 'Attribute+\t-> ValueType_attributes_list', 'AttributeSection+\t-> ValueType_attributeSections_list'], [Rule(name='ValueType_name_value', text='UpperCamel'), Rule(name='ValueType_oneLiner_value', text='OneLiner')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('ValueType', <class 'Lit_01.Lit_01.ValueType'>, {'one_liner', 'name'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['NAME: UpperCamel\t-> ValueType_name_simple', 'ONE_LINER: OneLiner\t-> ValueType_oneLiner_simple', 'ABBREVIATION: UpperCamel\t-> ValueType_abbreviation_simple', 'Paragraph+\t-> ValueType_elaboration_list', 'Annotation+\t-> ValueType_annotations_list', 'PLURAL: UpperCamel\t-> ValueType_plural_simple', 'SUBTYPE_OF: ClassName (, ClassName)+\t-> ValueType_subtypeOf_list', 'SUBTYPES: ClassName (, ClassName)+\t-> ValueType_subtypes_list', 'BASED_ON: ClassName (, ClassName)+\t-> ValueType_basedOn_list', 'DEPENDENTS: ClassName (, ClassName)+\t-> ValueType_dependents_list', "SAMPLERA: '(' NUMBER, STRING, DataType ')'\t-> ValueType_samplerA_tuple", 'IS_VALUE_TYPE: BOOLEAN\t-> ValueType_isValueType_bool', 'WHERE: STRING\t-> ValueType_where_str', 'Attribute+\t-> ValueType_attributes_list', 'AttributeSection+\t-> ValueType_attributeSections_list'], [Rule(name='ValueType_name_value', text='UpperCamel'), Rule(name='ValueType_oneLiner_value', text='OneLiner')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('ReferenceType', <class 'Lit_01.Lit_01.ReferenceType'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('ReferenceType',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of ReferenceType are []
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class ReferenceType is not abstract, generating own rule with clauses
[util_flogging.py:203 -              wrapper()] . . . . . . Preprocessed template: _ {name}[- {one_liner}] NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . Preprocessed template: - {one_liner}
[util_flogging.py:239 -              wrapper()] . . . . . . . Final grammar parts: ['DASH', 'ReferenceType_oneLiner_value']
[util_flogging.py:203 -              wrapper()] . . . . . . Final grammar parts: ['UNDERSCORE', 'ReferenceType_name_value', '[', 'DASH', 'ReferenceType_oneLiner_value', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . rule parts are: ['UNDERSCORE', 'ReferenceType_name_value', '[', 'DASH', 'ReferenceType_oneLiner_value', ']', 'NEWLINE']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(2, 8, 'name')]
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(2, 8, 'name'), (13, 24, 'one_liner')]
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > {'one_liner', 'name'} - from find_fields
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('ReferenceType', <class 'Lit_01.Lit_01.ReferenceType'>, {'one_liner', 'name'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['NAME: UpperCamel\t-> ReferenceType_name_simple', 'ONE_LINER: OneLiner\t-> ReferenceType_oneLiner_simple', 'ABBREVIATION: UpperCamel\t-> ReferenceType_abbreviation_simple', 'Paragraph+\t-> ReferenceType_elaboration_list', 'Annotation+\t-> ReferenceType_annotations_list', 'PLURAL: UpperCamel\t-> ReferenceType_plural_simple', 'SUBTYPE_OF: ClassName (, ClassName)+\t-> ReferenceType_subtypeOf_list', 'SUBTYPES: ClassName (, ClassName)+\t-> ReferenceType_subtypes_list', 'BASED_ON: ClassName (, ClassName)+\t-> ReferenceType_basedOn_list', 'DEPENDENTS: ClassName (, ClassName)+\t-> ReferenceType_dependents_list', "SAMPLERA: '(' NUMBER, STRING, DataType ')'\t-> ReferenceType_samplerA_tuple", 'IS_VALUE_TYPE: BOOLEAN\t-> ReferenceType_isValueType_bool', 'WHERE: STRING\t-> ReferenceType_where_str', 'Attribute+\t-> ReferenceType_attributes_list', 'AttributeSection+\t-> ReferenceType_attributeSections_list'], [Rule(name='ReferenceType_name_value', text='UpperCamel'), Rule(name='ReferenceType_oneLiner_value', text='OneLiner')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('ReferenceType', <class 'Lit_01.Lit_01.ReferenceType'>, {'one_liner', 'name'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['NAME: UpperCamel\t-> ReferenceType_name_simple', 'ONE_LINER: OneLiner\t-> ReferenceType_oneLiner_simple', 'ABBREVIATION: UpperCamel\t-> ReferenceType_abbreviation_simple', 'Paragraph+\t-> ReferenceType_elaboration_list', 'Annotation+\t-> ReferenceType_annotations_list', 'PLURAL: UpperCamel\t-> ReferenceType_plural_simple', 'SUBTYPE_OF: ClassName (, ClassName)+\t-> ReferenceType_subtypeOf_list', 'SUBTYPES: ClassName (, ClassName)+\t-> ReferenceType_subtypes_list', 'BASED_ON: ClassName (, ClassName)+\t-> ReferenceType_basedOn_list', 'DEPENDENTS: ClassName (, ClassName)+\t-> ReferenceType_dependents_list', "SAMPLERA: '(' NUMBER, STRING, DataType ')'\t-> ReferenceType_samplerA_tuple", 'IS_VALUE_TYPE: BOOLEAN\t-> ReferenceType_isValueType_bool', 'WHERE: STRING\t-> ReferenceType_where_str', 'Attribute+\t-> ReferenceType_attributes_list', 'AttributeSection+\t-> ReferenceType_attributeSections_list'], [Rule(name='ReferenceType_name_value', text='UpperCamel'), Rule(name='ReferenceType_oneLiner_value', text='OneLiner')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('AttributeSection', <class 'Lit_01.Lit_01.AttributeSection'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('AttributeSection',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of AttributeSection are []
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class AttributeSection is not abstract, generating own rule with clauses
[util_flogging.py:203 -              wrapper()] . . . . . . Preprocessed template: -  {name}[- {one_liner}][({is_required})] NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . Preprocessed template: - {one_liner}
[util_flogging.py:239 -              wrapper()] . . . . . . . Final grammar parts: ['DASH', 'AttributeSection_oneLiner_value']
[util_flogging.py:239 -              wrapper()] . . . . . . . Preprocessed template: ({is_required})
[util_flogging.py:239 -              wrapper()] . . . . . . . Final grammar parts: ['LPAREN', 'AttributeSection_isRequired_value', 'RPAREN']
[util_flogging.py:203 -              wrapper()] . . . . . . Final grammar parts: ['DASH', 'AttributeSection_name_value', '[', 'DASH', 'AttributeSection_oneLiner_value', ']', '[', 'LPAREN', 'AttributeSection_isRequired_value', 'RPAREN', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . rule parts are: ['DASH', 'AttributeSection_name_value', '[', 'DASH', 'AttributeSection_oneLiner_value', ']', '[', 'LPAREN', 'AttributeSection_isRequired_value', 'RPAREN', ']', 'NEWLINE']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(3, 9, 'name')]
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(3, 9, 'name'), (14, 25, 'one_liner')]
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(3, 9, 'name'), (14, 25, 'one_liner'), (30, 43, 'is_required')]
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > {'one_liner', 'is_required', 'name'} - from find_fields
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('AttributeSection', <class 'Lit_01.Lit_01.AttributeSection'>, {'one_liner', 'is_required', 'name'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['NAME: CamelCase\t-> AttributeSection_name_simple', 'ONE_LINER: OneLiner\t-> AttributeSection_oneLiner_simple', 'ABBREVIATION: UpperCamel\t-> AttributeSection_abbreviation_simple', 'Paragraph+\t-> AttributeSection_elaboration_list', 'Annotation+\t-> AttributeSection_annotations_list', 'IS_REQUIRED: IsRequired\t-> AttributeSection_isRequired_simple', 'Attribute+\t-> AttributeSection_attributes_list'], [Rule(name='AttributeSection_name_value', text='CamelCase'), Rule(name='AttributeSection_oneLiner_value', text='OneLiner'), Rule(name='AttributeSection_isRequired_value', text='IsRequired')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('AttributeSection', <class 'Lit_01.Lit_01.AttributeSection'>, {'one_liner', 'is_required', 'name'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['NAME: CamelCase\t-> AttributeSection_name_simple', 'ONE_LINER: OneLiner\t-> AttributeSection_oneLiner_simple', 'ABBREVIATION: UpperCamel\t-> AttributeSection_abbreviation_simple', 'Paragraph+\t-> AttributeSection_elaboration_list', 'Annotation+\t-> AttributeSection_annotations_list', 'IS_REQUIRED: IsRequired\t-> AttributeSection_isRequired_simple', 'Attribute+\t-> AttributeSection_attributes_list'], [Rule(name='AttributeSection_name_value', text='CamelCase'), Rule(name='AttributeSection_oneLiner_value', text='OneLiner'), Rule(name='AttributeSection_isRequired_value', text='IsRequired')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:115 -     generate_grammar()] . . . < _gen_rules_for_class of ('Attribute', <class 'Lit_01.Lit_01.Attribute'>) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_rule of ('Attribute',) {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . . subtypes of Attribute are []
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_rule
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . Class Attribute is not abstract, generating own rule with clauses
[util_flogging.py:203 -              wrapper()] . . . . . . Preprocessed template: -  {name}[- {one_liner}][({data_type_clause})] NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . Preprocessed template: - {one_liner}
[util_flogging.py:239 -              wrapper()] . . . . . . . Final grammar parts: ['DASH', 'Attribute_oneLiner_value']
[util_flogging.py:239 -              wrapper()] . . . . . . . Preprocessed template: ({data_type_clause})
[util_flogging.py:239 -              wrapper()] . . . . . . . Final grammar parts: ['LPAREN', 'Attribute_dataTypeClause_value', 'RPAREN']
[util_flogging.py:203 -              wrapper()] . . . . . . Final grammar parts: ['DASH', 'Attribute_name_value', '[', 'DASH', 'Attribute_oneLiner_value', ']', '[', 'LPAREN', 'Attribute_dataTypeClause_value', 'RPAREN', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . rule parts are: ['DASH', 'Attribute_name_value', '[', 'DASH', 'Attribute_oneLiner_value', ']', '[', 'LPAREN', 'Attribute_dataTypeClause_value', 'RPAREN', ']', 'NEWLINE']
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(3, 9, 'name')]
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(3, 9, 'name'), (14, 25, 'one_liner')]
[pom_grammar_generator.py:214 - _gen_all_class_rules()] . . . . . . . Field posiitons: [(3, 9, 'name'), (14, 25, 'one_liner'), (30, 48, 'data_type_clause')]
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > {'data_type_clause', 'one_liner', 'name'} - from find_fields
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('Attribute', <class 'Lit_01.Lit_01.Attribute'>, {'data_type_clause', 'one_liner', 'name'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['NAME: LowerCamel\t-> Attribute_name_simple', 'ONE_LINER: OneLiner\t-> Attribute_oneLiner_simple', 'ABBREVIATION: UpperCamel\t-> Attribute_abbreviation_simple', 'Paragraph+\t-> Attribute_elaboration_list', 'Annotation+\t-> Attribute_annotations_list', 'DATA_TYPE_CLAUSE: DataTypeClause\t-> Attribute_dataTypeClause_simple', 'DERIVATION: Derivation\t-> Attribute_derivation_simple', 'DEFAULT: Default\t-> Attribute_default_simple', 'Constraint+\t-> Attribute_constraints_list'], [Rule(name='Attribute_name_value', text='LowerCamel'), Rule(name='Attribute_oneLiner_value', text='OneLiner'), Rule(name='Attribute_dataTypeClause_value', text='DataTypeClause')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('Attribute', <class 'Lit_01.Lit_01.Attribute'>, {'data_type_clause', 'one_liner', 'name'}) {}
[pom_grammar_generator.py:115 -     generate_grammar()] . . . . . . . > (['NAME: LowerCamel\t-> Attribute_name_simple', 'ONE_LINER: OneLiner\t-> Attribute_oneLiner_simple', 'ABBREVIATION: UpperCamel\t-> Attribute_abbreviation_simple', 'Paragraph+\t-> Attribute_elaboration_list', 'Annotation+\t-> Attribute_annotations_list', 'DATA_TYPE_CLAUSE: DataTypeClause\t-> Attribute_dataTypeClause_simple', 'DERIVATION: Derivation\t-> Attribute_derivation_simple', 'DEFAULT: Default\t-> Attribute_default_simple', 'Constraint+\t-> Attribute_constraints_list'], [Rule(name='Attribute_name_value', text='LowerCamel'), Rule(name='Attribute_oneLiner_value', text='OneLiner'), Rule(name='Attribute_dataTypeClause_value', text='DataTypeClause')]) - from _gen_field_clauses
[pom_grammar_generator.py:115 -     generate_grammar()] . . . > None - from _gen_rules_for_class
Field terminals:  {'RPAREN', 'OF', 'LBRACE', 'MAPPING', 'CLASS', 'LPAREN', 'NEWLINE', 'LIST', 'FROM', 'DASH', 'TO', 'UNDERSCORE', 'COLON', 'HASH', 'SET'}
Self terminals:  {'CODE', 'ATTRIBUTE_SECTIONS', 'LABEL', 'IS_OPTIONAL', 'PLURAL', 'IS_VALUE_TYPE', 'IS_REQUIRED', 'DATA_TYPE', 'ELABORATION', 'RANGE_TYPE', 'ABBREVIATION', 'MESSAGE', 'SUBTYPES', 'CONSTRAINTS', 'WHERE', 'DATA_TYPE_CLAUSE', 'NAME', 'BASED_ON', 'SEVERITY', 'DOMAIN_TYPE', 'DERIVATION', 'ANNOTATIONS', 'CLASSES', 'ONE_LINER', 'DEPENDENTS', 'ATTRIBUTES', 'CARDINALITY', 'EMOJI', 'DEFAULT', 'IS_VALUE', 'SUBTYPE_OF', 'CONTENT', 'IS_ALSO_OPTIONAL', 'ELEMENT_TYPE', 'SAMPLERA', 'ENGLISH', 'CLASS_NAME', 'SUBJECTS'}
[pom_grammar.py:189 -           save_rules()] Saved grammar rules to C:\Users\fmkat\OneDrive\AllFMKFIles\AllVSCode\FMKProjects\Presentable\models\Lit_01\Lit_01_dull_grammar.lark
[pom_grammar.py:210 -       save_templates()] Saved templates to C:\Users\fmkat\OneDrive\AllFMKFIles\AllVSCode\FMKProjects\Presentable\models\Lit_01\Lit_01_dull_templates.hbs
[pom_grammar.py:70 -             __init__()] PresentableGrammar initialization complete
[do_pom_test.py:13 -             test_pom()] Grammar created
<pom_grammar.PresentableGrammar object at 0x0000024F187AD550>
[do_pom_test.py:17 -             test_pom()] Trying file models/Lit_01/SamplerClass.md
Text is:  _ Class: SampleClassB - something to test Class clauses
abbreviation: CSample
where: A = B
dependents: Abc, Def

[pom_parser.py:84 -             __init__()] PomParser initialized
[pom_grammar.py:249 -                parse()] Parsing input text (length: 112)
[pom_parser.py:113 -          _get_parser()] Creating new Lark parser with settings: {'start': 'start', 'parser': 'earley', 'debug': False, 'ambiguity': 'resolve'}
[pom_parser.py:118 -          _get_parser()] Error creating parser: Unexpected token Token('RULE', 'pper') at line 21, column 2.
Expected one of: 
	* _COLON
	* _DOT

[pom_parser.py:164 -                parse()] Unexpected token during parsing: Unexpected token Token('RULE', 'pper') at line 21, column 2.
Expected one of: 
	* _COLON
	* _DOT

parse tree =  None
Text is:  _ Class: SampleClassB - something to test Class clauses
abbreviation: CSample
where: A = B
dependents: Abc, Def

[do_pom_test.py:19 -             test_pom()] Done testing POM
