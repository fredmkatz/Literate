[do_pom_test.py:8 -             test_pom()] Starting to test POM
[pom_grammar.py:39 -             __init__()] Initializing PresentableGrammar with model_name=Lit_01, format_name=dull
[pom_grammar.py:50 -             __init__()] Found model directory: C:\Users\fmkat\OneDrive\AllFMKFIles\AllVSCode\FMKProjects\Presentable\models\Lit_01
[pom_grammar.py:53 -             __init__()] Loaded model module: Lit_01.Lit_01
[do_pom_test.py:14 -             test_pom()] < __init__ of () {'model_name': 'Lit_01', 'format_name': 'dull', 'config_dict': {'case_sensitive': True, 'ambiguity': 'resolve', 'debug': False}}
[pom_grammar.py:56 -             __init__()] . Initializing PomConfig with model_name=Lit_01, format_name=dull
[util_flogging.py:203 -              wrapper()] . . Loading format files from paths: ['settings/dull_format.yaml', 'models/Lit_01/Lit_01_dull_format.yaml']
[util_flogging.py:203 -              wrapper()] . . Found format file: settings/dull_format.yaml
[util_flogging.py:203 -              wrapper()] . . Updated metadata: {'_defaults': {'is_abstract': False, 'field_value': '{field_name} COLON {field_value} NEWLINE', 'str': 'dull_str', 'int': 'dull_int', 'float': 'dull_float', 'bool': {'true': 'true', 'false': 'false', 'is_explicit': True}, 'list': '{element} (COMMA {element})+', 'dict': 'dull dict', 'set': "'{'{element} (','' {element})+'}'", 'tuple': " '[' {element} (','' {element})+ ']'", 'field_clause': '{field_name}: {field_value}'}}
[util_flogging.py:203 -              wrapper()] . . Found format file: models/Lit_01/Lit_01_dull_format.yaml
[util_flogging.py:203 -              wrapper()] . . Updated metadata: {'_defaults': {'is_abstract': False, 'field_value': '{field_name} COLON {field_value} NEWLINE', 'str': 'dull_str', 'int': 'dull_int', 'float': 'dull_float', 'bool': {'true': 'true', 'false': 'false', 'is_explicit': True}, 'list': '{element} (COMMA {element})+', 'dict': 'dull dict', 'set': "'{'{element} (','' {element})+'}'", 'tuple': " '[' {element} (','' {element})+ ']'", 'field_clause': '{field_name} ":"  {field_value}'}, 'Component': {'header': '_ {_type}: {name}{? - {one_liner}} "\\n"'}, 'Class': {'header': '_ Class: {name}{? - {one_liner}} "\\n"'}, 'Attribute': {'header': '-  {name}{? - {one_liner}}{? ({data_type_clause})} "\\n"'}, 'BaseDataType': {'template': '{class_name} {? - {is_value}}'}, 'ListDataType': {'template': 'list of {element_type}'}, 'SetDataType': {'template': 'Set of {element_type}'}, 'MappingDataType': {'template': 'Mapping from {domain_type} to {range_type}'}, 'DataTypeClause': {'template': '{is_optional} {data_type}{? {cardinality}}'}}
Saved metadata to models/Lit_01/Lit_01_dull_y_external.yaml
## PomDict - External: 
# From YAML files:
##	Using built-in format: dull
## 	Using: settings/dull_format.yaml
## 	Using: models/Lit_01/Lit_01_dull_format.yaml
_defaults:
  is_abstract: false
  field_value: '{field_name} COLON {field_value} NEWLINE'
  str: dull_str
  int: dull_int
  float: dull_float
  bool:
    'true': 'true'
    'false': 'false'
    is_explicit: true
  list: '{element} (COMMA {element})+'
  dict: dull dict
  set: '''{''{element} ('','''' {element})+''}'''
  tuple: ' ''['' {element} ('','''' {element})+ '']'''
  field_clause: '{field_name} ":"  {field_value}'
Component:
  header: '_ {_type}: {name}{? - {one_liner}} "\n"'
Class:
  header: '_ Class: {name}{? - {one_liner}} "\n"'
Attribute:
  header: '-  {name}{? - {one_liner}}{? ({data_type_clause})} "\n"'
BaseDataType:
  template: '{class_name} {? - {is_value}}'
ListDataType:
  template: list of {element_type}
SetDataType:
  template: Set of {element_type}
MappingDataType:
  template: Mapping from {domain_type} to {range_type}
DataTypeClause:
  template: '{is_optional} {data_type}{? {cardinality}}'

[util_flogging.py:203 -              wrapper()] . Loading default configuration
[util_flogging.py:203 -              wrapper()] . . Looking for default config in settings/config.yaml
[util_flogging.py:203 -              wrapper()] . . . Updating config from file: settings/config.yaml
[do_pom_test.py:14 -             test_pom()] > None - from __init__
Config is  {
  "lark": {
    "case_sensitive": false,
    "ambiguity": "resolve",
    "debug": false
  },
  "case_sensitive": true,
  "ambiguity": "resolve",
  "debug": false
}
[pom_grammar_generator.py:110 -     generate_grammar()] Generating grammar for model module Lit_01.Lit_01
[pom_grammar.py:170 -  _initialize_grammar()] . . < _find_model_classes of (<module 'Lit_01.Lit_01' from 'C:\\Users\\fmkat\\OneDrive\\AllFMKFIles\\AllVSCode\\FMKProjects\\Presentable\\models\\Lit_01\\Lit_01.py'>,) {}
[pom_grammar_generator.py:118 -     generate_grammar()] . . . Found model_imports = [<class 'class_casing.UpperCamel'>, <class 'class_casing.LowerCamel'>, <class 'class_casing.CamelCase'>, <class 'class_pom_token.IsOptional'>, <class 'class_pom_token.IsReallyRequired'>, <class 'class_pom_token.ReferenceOrValue'>]
[pom_grammar_generator.py:118 -     generate_grammar()] . . . Import class names: ['UpperCamel', 'LowerCamel', 'CamelCase', 'IsOptional', 'IsReallyRequired', 'ReferenceOrValue']
[pom_grammar.py:170 -  _initialize_grammar()] . . > {'UpperCamel': <class 'class_casing.UpperCamel'>, 'LowerCamel': <class 'class_casing.LowerCamel'>, 'CamelCase': <class 'class_casing.CamelCase'>, 'IsOptional': <class 'class_pom_token.IsOptional'>, 'ReferenceOrValue': <class 'class_pom_token.ReferenceOrValue'>, 'IsReallyRequired': <class 'class_pom_token.IsReallyRequired'>, 'Paragraph': <class 'Lit_01.Lit_01.Paragraph'>, 'OneLiner': <class 'Lit_01.Lit_01.OneLiner'>, 'ClassName': <class 'Lit_01.Lit_01.ClassName'>, 'Label': <class 'Lit_01.Lit_01.Label'>, 'Annotation': <class 'Lit_01.Lit_01.Annotation'>, 'Component': <class 'Lit_01.Lit_01.Component'>, 'SubjectE': <class 'Lit_01.Lit_01.SubjectE'>, 'SubjectD': <class 'Lit_01.Lit_01.SubjectD'>, 'SubjectC': <class 'Lit_01.Lit_01.SubjectC'>, 'SubjectB': <class 'Lit_01.Lit_01.SubjectB'>, 'LDM': <class 'Lit_01.Lit_01.LDM'>, 'DataType': <class 'Lit_01.Lit_01.DataType'>, 'BaseDataType': <class 'Lit_01.Lit_01.BaseDataType'>, 'ListDataType': <class 'Lit_01.Lit_01.ListDataType'>, 'SetDataType': <class 'Lit_01.Lit_01.SetDataType'>, 'MappingDataType': <class 'Lit_01.Lit_01.MappingDataType'>, 'DataTypeClause': <class 'Lit_01.Lit_01.DataTypeClause'>, 'FormulaCoding': <class 'Lit_01.Lit_01.FormulaCoding'>, 'Formula': <class 'Lit_01.Lit_01.Formula'>, 'Constraint': <class 'Lit_01.Lit_01.Constraint'>, 'Derivation': <class 'Lit_01.Lit_01.Derivation'>, 'Default': <class 'Lit_01.Lit_01.Default'>, 'Class': <class 'Lit_01.Lit_01.Class'>, 'ValueType': <class 'Lit_01.Lit_01.ValueType'>, 'ReferenceType': <class 'Lit_01.Lit_01.ReferenceType'>, 'AttributeSection': <class 'Lit_01.Lit_01.AttributeSection'>, 'Attribute': <class 'Lit_01.Lit_01.Attribute'>} - from _find_model_classes
Saved metadata to models/Lit_01/Lit_01_dull_y_live.yaml
Saved metadata to models/Lit_01/Lit_01_dull_y_resolved.yaml
## PomDict - Resolved: 
## Resolved metadata from Live and External
# extracted from the Lit_01 model
# From YAML files:
##	Using built-in format: dull
## 	Using: settings/dull_format.yaml
## 	Using: models/Lit_01/Lit_01_dull_format.yaml
_defaults:
  field_value: '{field_name} COLON {field_value} NEWLINE'
  is_abstract: false
  str: dull_str
  int: dull_int
  float: dull_float
  bool:
    'true': 'true'
    'false': 'false'
    is_explicit: true
  list: '{element} (COMMA {element})+'
  dict: dull dict
  set: '''{''{element} ('','''' {element})+''}'''
  tuple: ' ''['' {element} ('','''' {element})+ '']'''
  field_clause: '{field_name} ":"  {field_value}'
Paragraph:
  template: '{content}'
OneLiner:
  template: '{content}'
Annotation:
  template: '{?{emoji}}  {label}: {content} ''

    '''
Component:
  is_abstract: true
  header: '_ {_type}: {name}{? - {one_liner}} "\n"'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
SubjectE:
  header: '#####  {{name}{? - {one_liner}} ''

    '''
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
SubjectD:
  header: '####  {{name}{? - {one_liner}} ''

    '''
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
SubjectC:
  header: '###  {{name}{? - {one_liner}} ''

    '''
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
SubjectB:
  header: '##  {{name}{? - {one_liner}} ''

    '''
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
LDM:
  header: '#  {{name}{? - {one_liner}} ''

    '''
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
DataType:
  is_abstract: true
BaseDataType:
  template: '{class_name} {? - {is_value}}'
ListDataType:
  template: list of {element_type}
SetDataType:
  template: Set of {element_type}
MappingDataType:
  template: Mapping from {domain_type} to {range_type}
DataTypeClause:
  template: '{is_optional} {data_type}{? {cardinality}}'
  _fields:
    is_optional:
      bool:
        'true': optional
        'false': required
        is_explicit: false
Class:
  header: '_ Class: {name}{? - {one_liner}} "\n"'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
    attribute_sections:
      list: '{element}+'
      field_value: '{field_value}'
ValueType:
  header: '_ {name}{? - {one_liner}} ''

    '''
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
    attribute_sections:
      list: '{element}+'
      field_value: '{field_value}'
ReferenceType:
  header: '_ {name}{? - {one_liner}} ''

    '''
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
    attribute_sections:
      list: '{element}+'
      field_value: '{field_value}'
AttributeSection:
  header: '-  {name}{? - {one_liner}}{? ({is_required})} ''

    '''
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
Attribute:
  header: '-  {name}{? - {one_liner}}{? ({data_type_clause})} "\n"'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    constraints:
      list: '{element}+'
      field_value: '{field_value}'

[pom_grammar.py:170 -  _initialize_grammar()] . . < _derive_class_hierarchy of ({'UpperCamel': <class 'class_casing.UpperCamel'>, 'LowerCamel': <class 'class_casing.LowerCamel'>, 'CamelCase': <class 'class_casing.CamelCase'>, 'IsOptional': <class 'class_pom_token.IsOptional'>, 'ReferenceOrValue': <class 'class_pom_token.ReferenceOrValue'>, 'IsReallyRequired': <class 'class_pom_token.IsReallyRequired'>, 'Paragraph': <class 'Lit_01.Lit_01.Paragraph'>, 'OneLiner': <class 'Lit_01.Lit_01.OneLiner'>, 'ClassName': <class 'Lit_01.Lit_01.ClassName'>, 'Label': <class 'Lit_01.Lit_01.Label'>, 'Annotation': <class 'Lit_01.Lit_01.Annotation'>, 'Component': <class 'Lit_01.Lit_01.Component'>, 'SubjectE': <class 'Lit_01.Lit_01.SubjectE'>, 'SubjectD': <class 'Lit_01.Lit_01.SubjectD'>, 'SubjectC': <class 'Lit_01.Lit_01.SubjectC'>, 'SubjectB': <class 'Lit_01.Lit_01.SubjectB'>, 'LDM': <class 'Lit_01.Lit_01.LDM'>, 'DataType': <class 'Lit_01.Lit_01.DataType'>, 'BaseDataType': <class 'Lit_01.Lit_01.BaseDataType'>, 'ListDataType': <class 'Lit_01.Lit_01.ListDataType'>, 'SetDataType': <class 'Lit_01.Lit_01.SetDataType'>, 'MappingDataType': <class 'Lit_01.Lit_01.MappingDataType'>, 'DataTypeClause': <class 'Lit_01.Lit_01.DataTypeClause'>, 'FormulaCoding': <class 'Lit_01.Lit_01.FormulaCoding'>, 'Formula': <class 'Lit_01.Lit_01.Formula'>, 'Constraint': <class 'Lit_01.Lit_01.Constraint'>, 'Derivation': <class 'Lit_01.Lit_01.Derivation'>, 'Default': <class 'Lit_01.Lit_01.Default'>, 'Class': <class 'Lit_01.Lit_01.Class'>, 'ValueType': <class 'Lit_01.Lit_01.ValueType'>, 'ReferenceType': <class 'Lit_01.Lit_01.ReferenceType'>, 'AttributeSection': <class 'Lit_01.Lit_01.AttributeSection'>, 'Attribute': <class 'Lit_01.Lit_01.Attribute'>},) {}
[pom_grammar.py:170 -  _initialize_grammar()] . . > {'UpperCamel': {'class': <class 'class_casing.UpperCamel'>, 'bases': ['CamelCase'], 'subtypes': [], 'attributes': {}}, 'LowerCamel': {'class': <class 'class_casing.LowerCamel'>, 'bases': ['CamelCase'], 'subtypes': [], 'attributes': {}}, 'CamelCase': {'class': <class 'class_casing.CamelCase'>, 'bases': [], 'subtypes': ['UpperCamel', 'LowerCamel', 'ClassName', 'Label'], 'attributes': {}}, 'IsOptional': {'class': <class 'class_pom_token.IsOptional'>, 'bases': [], 'subtypes': [], 'attributes': {}}, 'ReferenceOrValue': {'class': <class 'class_pom_token.ReferenceOrValue'>, 'bases': [], 'subtypes': [], 'attributes': {}}, 'IsReallyRequired': {'class': <class 'class_pom_token.IsReallyRequired'>, 'bases': [], 'subtypes': [], 'attributes': {}}, 'Paragraph': {'class': <class 'Lit_01.Lit_01.Paragraph'>, 'bases': [], 'subtypes': ['OneLiner'], 'attributes': {}}, 'OneLiner': {'class': <class 'Lit_01.Lit_01.OneLiner'>, 'bases': ['Paragraph'], 'subtypes': [], 'attributes': {}}, 'ClassName': {'class': <class 'Lit_01.Lit_01.ClassName'>, 'bases': ['CamelCase'], 'subtypes': [], 'attributes': {}}, 'Label': {'class': <class 'Lit_01.Lit_01.Label'>, 'bases': ['CamelCase'], 'subtypes': [], 'attributes': {}}, 'Annotation': {'class': <class 'Lit_01.Lit_01.Annotation'>, 'bases': [], 'subtypes': [], 'attributes': {}}, 'Component': {'class': <class 'Lit_01.Lit_01.Component'>, 'bases': [], 'subtypes': ['SubjectE', 'Class', 'AttributeSection', 'Attribute'], 'attributes': {}}, 'SubjectE': {'class': <class 'Lit_01.Lit_01.SubjectE'>, 'bases': ['Component'], 'subtypes': ['SubjectD'], 'attributes': {}}, 'SubjectD': {'class': <class 'Lit_01.Lit_01.SubjectD'>, 'bases': ['SubjectE'], 'subtypes': ['SubjectC'], 'attributes': {}}, 'SubjectC': {'class': <class 'Lit_01.Lit_01.SubjectC'>, 'bases': ['SubjectD'], 'subtypes': ['SubjectB'], 'attributes': {}}, 'SubjectB': {'class': <class 'Lit_01.Lit_01.SubjectB'>, 'bases': ['SubjectC'], 'subtypes': ['LDM'], 'attributes': {}}, 'LDM': {'class': <class 'Lit_01.Lit_01.LDM'>, 'bases': ['SubjectB'], 'subtypes': [], 'attributes': {}}, 'DataType': {'class': <class 'Lit_01.Lit_01.DataType'>, 'bases': [], 'subtypes': ['BaseDataType', 'ListDataType', 'SetDataType', 'MappingDataType'], 'attributes': {}}, 'BaseDataType': {'class': <class 'Lit_01.Lit_01.BaseDataType'>, 'bases': ['DataType'], 'subtypes': [], 'attributes': {}}, 'ListDataType': {'class': <class 'Lit_01.Lit_01.ListDataType'>, 'bases': ['DataType'], 'subtypes': [], 'attributes': {}}, 'SetDataType': {'class': <class 'Lit_01.Lit_01.SetDataType'>, 'bases': ['DataType'], 'subtypes': [], 'attributes': {}}, 'MappingDataType': {'class': <class 'Lit_01.Lit_01.MappingDataType'>, 'bases': ['DataType'], 'subtypes': [], 'attributes': {}}, 'DataTypeClause': {'class': <class 'Lit_01.Lit_01.DataTypeClause'>, 'bases': [], 'subtypes': [], 'attributes': {}}, 'FormulaCoding': {'class': <class 'Lit_01.Lit_01.FormulaCoding'>, 'bases': [], 'subtypes': [], 'attributes': {}}, 'Formula': {'class': <class 'Lit_01.Lit_01.Formula'>, 'bases': [], 'subtypes': ['Constraint', 'Derivation', 'Default'], 'attributes': {}}, 'Constraint': {'class': <class 'Lit_01.Lit_01.Constraint'>, 'bases': ['Formula'], 'subtypes': [], 'attributes': {}}, 'Derivation': {'class': <class 'Lit_01.Lit_01.Derivation'>, 'bases': ['Formula'], 'subtypes': [], 'attributes': {}}, 'Default': {'class': <class 'Lit_01.Lit_01.Default'>, 'bases': ['Formula'], 'subtypes': [], 'attributes': {}}, 'Class': {'class': <class 'Lit_01.Lit_01.Class'>, 'bases': ['Component'], 'subtypes': ['ValueType', 'ReferenceType'], 'attributes': {}}, 'ValueType': {'class': <class 'Lit_01.Lit_01.ValueType'>, 'bases': ['Class'], 'subtypes': [], 'attributes': {}}, 'ReferenceType': {'class': <class 'Lit_01.Lit_01.ReferenceType'>, 'bases': ['Class'], 'subtypes': [], 'attributes': {}}, 'AttributeSection': {'class': <class 'Lit_01.Lit_01.AttributeSection'>, 'bases': ['Component'], 'subtypes': [], 'attributes': {}}, 'Attribute': {'class': <class 'Lit_01.Lit_01.Attribute'>, 'bases': ['Component'], 'subtypes': [], 'attributes': {}}} - from _derive_class_hierarchy
Starting class rules
## PomDict - Resolved: 
## Resolved metadata from Live and External
# extracted from the Lit_01 model
# From YAML files:
##	Using built-in format: dull
## 	Using: settings/dull_format.yaml
## 	Using: models/Lit_01/Lit_01_dull_format.yaml
_defaults:
  field_value: '{field_name} COLON {field_value} NEWLINE'
  is_abstract: false
  str: dull_str
  int: dull_int
  float: dull_float
  bool:
    'true': 'true'
    'false': 'false'
    is_explicit: true
  list: '{element} (COMMA {element})+'
  dict: dull dict
  set: '''{''{element} ('','''' {element})+''}'''
  tuple: ' ''['' {element} ('','''' {element})+ '']'''
  field_clause: '{field_name} ":"  {field_value}'
Paragraph:
  template: '{content}'
OneLiner:
  template: '{content}'
Annotation:
  template: '{?{emoji}}  {label}: {content} ''

    '''
Component:
  is_abstract: true
  header: '_ {_type}: {name}{? - {one_liner}} "\n"'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
SubjectE:
  header: '#####  {{name}{? - {one_liner}} ''

    '''
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
SubjectD:
  header: '####  {{name}{? - {one_liner}} ''

    '''
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
SubjectC:
  header: '###  {{name}{? - {one_liner}} ''

    '''
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
SubjectB:
  header: '##  {{name}{? - {one_liner}} ''

    '''
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
LDM:
  header: '#  {{name}{? - {one_liner}} ''

    '''
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
DataType:
  is_abstract: true
BaseDataType:
  template: '{class_name} {? - {is_value}}'
ListDataType:
  template: list of {element_type}
SetDataType:
  template: Set of {element_type}
MappingDataType:
  template: Mapping from {domain_type} to {range_type}
DataTypeClause:
  template: '{is_optional} {data_type}{? {cardinality}}'
  _fields:
    is_optional:
      bool:
        'true': optional
        'false': required
        is_explicit: false
Class:
  header: '_ Class: {name}{? - {one_liner}} "\n"'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
    attribute_sections:
      list: '{element}+'
      field_value: '{field_value}'
ValueType:
  header: '_ {name}{? - {one_liner}} ''

    '''
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
    attribute_sections:
      list: '{element}+'
      field_value: '{field_value}'
ReferenceType:
  header: '_ {name}{? - {one_liner}} ''

    '''
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
    attribute_sections:
      list: '{element}+'
      field_value: '{field_value}'
AttributeSection:
  header: '-  {name}{? - {one_liner}}{? ({is_required})} ''

    '''
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
Attribute:
  header: '-  {name}{? - {one_liner}}{? ({data_type_clause})} "\n"'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    constraints:
      list: '{element}+'
      field_value: '{field_value}'

[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('UpperCamel', <class 'class_casing.UpperCamel'>) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Token pattern: /[A-Za-z][A-Za-z0-9]*/
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('LowerCamel', <class 'class_casing.LowerCamel'>) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Token pattern: /[A-Za-z][A-Za-z0-9]*/
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('CamelCase', <class 'class_casing.CamelCase'>) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Token pattern: /[A-Za-z][A-Za-z0-9]*/
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('IsOptional', <class 'class_pom_token.IsOptional'>) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Token pattern: "optional"i | "true"i | "sure"i | "yes"i | "required"i | "false"i | "no way"i
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('ReferenceOrValue', <class 'class_pom_token.ReferenceOrValue'>) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Token pattern: "reference"i | "value"i
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('IsReallyRequired', <class 'class_pom_token.IsReallyRequired'>) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Token pattern: "required"i | "true"i | "sure"i | "yes"i | "optional"i | "false"i | "no way"i
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('Paragraph', <class 'Lit_01.Lit_01.Paragraph'>) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Token pattern: AAA+?ZZZ
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('OneLiner', <class 'Lit_01.Lit_01.OneLiner'>) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Token pattern: AAA+?ZZZ
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('ClassName', <class 'Lit_01.Lit_01.ClassName'>) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Token pattern: /[A-Za-z][A-Za-z0-9]*/
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('Label', <class 'Lit_01.Lit_01.Label'>) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Token pattern: /[A-Za-z][A-Za-z0-9]*/
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('Annotation', <class 'Lit_01.Lit_01.Annotation'>) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_clause of ('Annotation',) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . subtypes of Annotation are []
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_clause
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Class Annotation is not abstract, generating own rule with clauses
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Full template is {?{emoji}}  {label}: {content} '
'
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_full_class_by_template of ('Annotation', PomTemplate({?{emoji}}  {label}: {content} '
')) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . . . < to_fragment of (PomTemplate({?{emoji}}  {label}: {content} '
'), 'Annotation') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate({?{emoji}}  {label}: {content} '
'), 'Annotation') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . Preprocessed template: [{emoji}]  {label}: {content} '
'
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate({emoji}), 'Annotation') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . . . Preprocessed template: {emoji}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . . . Final grammar parts: ['annotation__emoji__value']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . . . > to_grammar_parts returned ['annotation__emoji__value']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . Adding NEWLINE to punctuation_terminals
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . NEWLINE found in template: [{emoji}]  {label}: {content} '
'
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . Final grammar parts: ['[', 'annotation__emoji__value', ']', 'annotation__label__value', 'COLON', 'annotation__content__value', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . > to_grammar_parts returned ['[', 'annotation__emoji__value', ']', 'annotation__label__value', 'COLON', 'annotation__content__value', 'NEWLINE']
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . . . > to_fragment returned [ annotation__emoji__value ] annotation__label__value COLON annotation__content__value NEWLINE
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > [ annotation__emoji__value ] annotation__label__value COLON annotation__content__value NEWLINE - from _gen_full_class_by_template
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(2, 9, 'emoji')]
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(2, 9, 'emoji'), (12, 19, 'label')]
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(2, 9, 'emoji'), (12, 19, 'label'), (21, 30, 'content')]
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > {'content', 'label', 'emoji'} - from find_fields
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_value_rules of ('Annotation', <class 'Lit_01.Lit_01.Annotation'>, {'content', 'label', 'emoji'}) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > [Rule(name='annotation__label__value', text='label'), Rule(name='annotation__content__value', text='one_liner'), Rule(name='annotation__emoji__value', text='STRING')] - from _gen_field_value_rules
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('Component', <class 'Lit_01.Lit_01.Component'>) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_clause of ('Component',) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . subtypes of Component are ['SubjectE', 'Class', 'AttributeSection', 'Attribute']
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > subject_e | class | attribute_section | attribute - from _generate_type_hierarchy_clause
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Class Component is abstract, skipping rule generation
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('SubjectE', <class 'Lit_01.Lit_01.SubjectE'>) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_clause of ('SubjectE',) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . subtypes of SubjectE are ['SubjectD']
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > subject_d - from _generate_type_hierarchy_clause
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Class SubjectE is not abstract, generating own rule with clauses
[util_flogging.py:203 -              wrapper()] . . . . . . . < to_fragment of (PomTemplate(#####  {{name}{? - {one_liner}} '
'), 'SubjectE') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . < to_grammar_parts of (PomTemplate(#####  {{name}{? - {one_liner}} '
'), 'SubjectE') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Preprocessed template: #####  {{name}[- {one_liner}] '
'
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(- {one_liner}), 'SubjectE') {}
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Preprocessed template: - {one_liner}
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Final grammar parts: ['DASH', 'subject_e__one_liner__value']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . > to_grammar_parts returned ['DASH', 'subject_e__one_liner__value']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Adding NEWLINE to punctuation_terminals
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . NEWLINE found in template: #####  {{name}[- {one_liner}] '
'
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Final grammar parts: ['HASH', 'HASH', 'HASH', 'HASH', 'HASH', 'LBRACE', 'subject_e__name__value', '[', 'DASH', 'subject_e__one_liner__value', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . > to_grammar_parts returned ['HASH', 'HASH', 'HASH', 'HASH', 'HASH', 'LBRACE', 'subject_e__name__value', '[', 'DASH', 'subject_e__one_liner__value', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . > to_fragment returned HASH HASH HASH HASH HASH LBRACE subject_e__name__value [ DASH subject_e__one_liner__value ] NEWLINE
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(8, 14, 'name')]
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(8, 14, 'name'), (19, 30, 'one_liner')]
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > {'name', 'one_liner'} - from find_fields
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('SubjectE', <class 'Lit_01.Lit_01.SubjectE'>) {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectE.name is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(NAME_QF COLON FIELDVALUE NEWLINE), 'SubjectE') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(NAME_QF COLON FIELDVALUE NEWLINE), 'SubjectE') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: NAME_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NAME_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['NAME_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['NAME_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned NAME_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = NAME_QF COLON camel_case NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectE.one_liner is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ONE_LINER_QF COLON FIELDVALUE NEWLINE), 'SubjectE') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ONE_LINER_QF COLON FIELDVALUE NEWLINE), 'SubjectE') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ONE_LINER_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ONE_LINER_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ONE_LINER_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ONE_LINER_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ONE_LINER_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ONE_LINER_QF COLON one_liner NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectE.abbreviation is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ABBREVIATION_QF COLON FIELDVALUE NEWLINE), 'SubjectE') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ABBREVIATION_QF COLON FIELDVALUE NEWLINE), 'SubjectE') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ABBREVIATION_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ABBREVIATION_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ABBREVIATION_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ABBREVIATION_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ABBREVIATION_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ABBREVIATION_QF COLON upper_camel NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectE.elaboration is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'SubjectE') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'SubjectE') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = paragraph+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectE.annotations is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'SubjectE') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'SubjectE') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = annotation+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectE.classes is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'SubjectE') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'SubjectE') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = class+
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > ['NAME_QF COLON camel_case NEWLINE\t-> subject_e__name__simple', 'ONE_LINER_QF COLON one_liner NEWLINE\t-> subject_e__one_liner__simple', 'ABBREVIATION_QF COLON upper_camel NEWLINE\t-> subject_e__abbreviation__simple', 'paragraph+\t-> subject_e__elaboration__list', 'annotation+\t-> subject_e__annotations__list', 'class+\t-> subject_e__classes__list'] - from _gen_field_clauses
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_value_rules of ('SubjectE', <class 'Lit_01.Lit_01.SubjectE'>, {'name', 'one_liner'}) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > [Rule(name='subject_e__name__value', text='camel_case'), Rule(name='subject_e__one_liner__value', text='one_liner')] - from _gen_field_value_rules
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('SubjectD', <class 'Lit_01.Lit_01.SubjectD'>) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_clause of ('SubjectD',) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . subtypes of SubjectD are ['SubjectC']
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > subject_c - from _generate_type_hierarchy_clause
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Class SubjectD is not abstract, generating own rule with clauses
[util_flogging.py:203 -              wrapper()] . . . . . . . < to_fragment of (PomTemplate(####  {{name}{? - {one_liner}} '
'), 'SubjectD') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . < to_grammar_parts of (PomTemplate(####  {{name}{? - {one_liner}} '
'), 'SubjectD') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Preprocessed template: ####  {{name}[- {one_liner}] '
'
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(- {one_liner}), 'SubjectD') {}
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Preprocessed template: - {one_liner}
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Final grammar parts: ['DASH', 'subject_d__one_liner__value']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . > to_grammar_parts returned ['DASH', 'subject_d__one_liner__value']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Adding NEWLINE to punctuation_terminals
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . NEWLINE found in template: ####  {{name}[- {one_liner}] '
'
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Final grammar parts: ['HASH', 'HASH', 'HASH', 'HASH', 'LBRACE', 'subject_d__name__value', '[', 'DASH', 'subject_d__one_liner__value', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . > to_grammar_parts returned ['HASH', 'HASH', 'HASH', 'HASH', 'LBRACE', 'subject_d__name__value', '[', 'DASH', 'subject_d__one_liner__value', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . > to_fragment returned HASH HASH HASH HASH LBRACE subject_d__name__value [ DASH subject_d__one_liner__value ] NEWLINE
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(7, 13, 'name')]
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(7, 13, 'name'), (18, 29, 'one_liner')]
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > {'name', 'one_liner'} - from find_fields
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('SubjectD', <class 'Lit_01.Lit_01.SubjectD'>) {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectD.name is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(NAME_QF COLON FIELDVALUE NEWLINE), 'SubjectD') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(NAME_QF COLON FIELDVALUE NEWLINE), 'SubjectD') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: NAME_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NAME_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['NAME_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['NAME_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned NAME_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = NAME_QF COLON camel_case NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectD.one_liner is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ONE_LINER_QF COLON FIELDVALUE NEWLINE), 'SubjectD') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ONE_LINER_QF COLON FIELDVALUE NEWLINE), 'SubjectD') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ONE_LINER_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ONE_LINER_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ONE_LINER_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ONE_LINER_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ONE_LINER_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ONE_LINER_QF COLON one_liner NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectD.abbreviation is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ABBREVIATION_QF COLON FIELDVALUE NEWLINE), 'SubjectD') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ABBREVIATION_QF COLON FIELDVALUE NEWLINE), 'SubjectD') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ABBREVIATION_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ABBREVIATION_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ABBREVIATION_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ABBREVIATION_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ABBREVIATION_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ABBREVIATION_QF COLON upper_camel NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectD.elaboration is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'SubjectD') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'SubjectD') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = paragraph+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectD.annotations is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'SubjectD') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'SubjectD') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = annotation+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectD.classes is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'SubjectD') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'SubjectD') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = class+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectD.subjects is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'SubjectD') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'SubjectD') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = subject_e+
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > ['NAME_QF COLON camel_case NEWLINE\t-> subject_d__name__simple', 'ONE_LINER_QF COLON one_liner NEWLINE\t-> subject_d__one_liner__simple', 'ABBREVIATION_QF COLON upper_camel NEWLINE\t-> subject_d__abbreviation__simple', 'paragraph+\t-> subject_d__elaboration__list', 'annotation+\t-> subject_d__annotations__list', 'class+\t-> subject_d__classes__list', 'subject_e+\t-> subject_d__subjects__list'] - from _gen_field_clauses
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_value_rules of ('SubjectD', <class 'Lit_01.Lit_01.SubjectD'>, {'name', 'one_liner'}) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > [Rule(name='subject_d__name__value', text='camel_case'), Rule(name='subject_d__one_liner__value', text='one_liner')] - from _gen_field_value_rules
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('SubjectC', <class 'Lit_01.Lit_01.SubjectC'>) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_clause of ('SubjectC',) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . subtypes of SubjectC are ['SubjectB']
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > subject_b - from _generate_type_hierarchy_clause
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Class SubjectC is not abstract, generating own rule with clauses
[util_flogging.py:203 -              wrapper()] . . . . . . . < to_fragment of (PomTemplate(###  {{name}{? - {one_liner}} '
'), 'SubjectC') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . < to_grammar_parts of (PomTemplate(###  {{name}{? - {one_liner}} '
'), 'SubjectC') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Preprocessed template: ###  {{name}[- {one_liner}] '
'
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(- {one_liner}), 'SubjectC') {}
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Preprocessed template: - {one_liner}
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Final grammar parts: ['DASH', 'subject_c__one_liner__value']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . > to_grammar_parts returned ['DASH', 'subject_c__one_liner__value']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Adding NEWLINE to punctuation_terminals
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . NEWLINE found in template: ###  {{name}[- {one_liner}] '
'
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Final grammar parts: ['HASH', 'HASH', 'HASH', 'LBRACE', 'subject_c__name__value', '[', 'DASH', 'subject_c__one_liner__value', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . > to_grammar_parts returned ['HASH', 'HASH', 'HASH', 'LBRACE', 'subject_c__name__value', '[', 'DASH', 'subject_c__one_liner__value', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . > to_fragment returned HASH HASH HASH LBRACE subject_c__name__value [ DASH subject_c__one_liner__value ] NEWLINE
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(6, 12, 'name')]
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(6, 12, 'name'), (17, 28, 'one_liner')]
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > {'name', 'one_liner'} - from find_fields
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('SubjectC', <class 'Lit_01.Lit_01.SubjectC'>) {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectC.name is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(NAME_QF COLON FIELDVALUE NEWLINE), 'SubjectC') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(NAME_QF COLON FIELDVALUE NEWLINE), 'SubjectC') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: NAME_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NAME_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['NAME_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['NAME_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned NAME_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = NAME_QF COLON camel_case NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectC.one_liner is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ONE_LINER_QF COLON FIELDVALUE NEWLINE), 'SubjectC') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ONE_LINER_QF COLON FIELDVALUE NEWLINE), 'SubjectC') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ONE_LINER_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ONE_LINER_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ONE_LINER_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ONE_LINER_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ONE_LINER_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ONE_LINER_QF COLON one_liner NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectC.abbreviation is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ABBREVIATION_QF COLON FIELDVALUE NEWLINE), 'SubjectC') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ABBREVIATION_QF COLON FIELDVALUE NEWLINE), 'SubjectC') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ABBREVIATION_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ABBREVIATION_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ABBREVIATION_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ABBREVIATION_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ABBREVIATION_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ABBREVIATION_QF COLON upper_camel NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectC.elaboration is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'SubjectC') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'SubjectC') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = paragraph+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectC.annotations is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'SubjectC') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'SubjectC') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = annotation+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectC.classes is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'SubjectC') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'SubjectC') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = class+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectC.subjects is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'SubjectC') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'SubjectC') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = subject_d+
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > ['NAME_QF COLON camel_case NEWLINE\t-> subject_c__name__simple', 'ONE_LINER_QF COLON one_liner NEWLINE\t-> subject_c__one_liner__simple', 'ABBREVIATION_QF COLON upper_camel NEWLINE\t-> subject_c__abbreviation__simple', 'paragraph+\t-> subject_c__elaboration__list', 'annotation+\t-> subject_c__annotations__list', 'class+\t-> subject_c__classes__list', 'subject_d+\t-> subject_c__subjects__list'] - from _gen_field_clauses
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_value_rules of ('SubjectC', <class 'Lit_01.Lit_01.SubjectC'>, {'name', 'one_liner'}) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > [Rule(name='subject_c__name__value', text='camel_case'), Rule(name='subject_c__one_liner__value', text='one_liner')] - from _gen_field_value_rules
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('SubjectB', <class 'Lit_01.Lit_01.SubjectB'>) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_clause of ('SubjectB',) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . subtypes of SubjectB are ['LDM']
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > ldm - from _generate_type_hierarchy_clause
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Class SubjectB is not abstract, generating own rule with clauses
[util_flogging.py:203 -              wrapper()] . . . . . . . < to_fragment of (PomTemplate(##  {{name}{? - {one_liner}} '
'), 'SubjectB') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . < to_grammar_parts of (PomTemplate(##  {{name}{? - {one_liner}} '
'), 'SubjectB') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Preprocessed template: ##  {{name}[- {one_liner}] '
'
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(- {one_liner}), 'SubjectB') {}
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Preprocessed template: - {one_liner}
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Final grammar parts: ['DASH', 'subject_b__one_liner__value']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . > to_grammar_parts returned ['DASH', 'subject_b__one_liner__value']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Adding NEWLINE to punctuation_terminals
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . NEWLINE found in template: ##  {{name}[- {one_liner}] '
'
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Final grammar parts: ['HASH', 'HASH', 'LBRACE', 'subject_b__name__value', '[', 'DASH', 'subject_b__one_liner__value', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . > to_grammar_parts returned ['HASH', 'HASH', 'LBRACE', 'subject_b__name__value', '[', 'DASH', 'subject_b__one_liner__value', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . > to_fragment returned HASH HASH LBRACE subject_b__name__value [ DASH subject_b__one_liner__value ] NEWLINE
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(5, 11, 'name')]
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(5, 11, 'name'), (16, 27, 'one_liner')]
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > {'name', 'one_liner'} - from find_fields
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('SubjectB', <class 'Lit_01.Lit_01.SubjectB'>) {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectB.name is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(NAME_QF COLON FIELDVALUE NEWLINE), 'SubjectB') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(NAME_QF COLON FIELDVALUE NEWLINE), 'SubjectB') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: NAME_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NAME_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['NAME_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['NAME_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned NAME_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = NAME_QF COLON camel_case NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectB.one_liner is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ONE_LINER_QF COLON FIELDVALUE NEWLINE), 'SubjectB') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ONE_LINER_QF COLON FIELDVALUE NEWLINE), 'SubjectB') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ONE_LINER_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ONE_LINER_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ONE_LINER_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ONE_LINER_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ONE_LINER_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ONE_LINER_QF COLON one_liner NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectB.abbreviation is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ABBREVIATION_QF COLON FIELDVALUE NEWLINE), 'SubjectB') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ABBREVIATION_QF COLON FIELDVALUE NEWLINE), 'SubjectB') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ABBREVIATION_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ABBREVIATION_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ABBREVIATION_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ABBREVIATION_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ABBREVIATION_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ABBREVIATION_QF COLON upper_camel NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectB.elaboration is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'SubjectB') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'SubjectB') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = paragraph+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectB.annotations is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'SubjectB') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'SubjectB') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = annotation+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectB.classes is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'SubjectB') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'SubjectB') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = class+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for SubjectB.subjects is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'SubjectB') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'SubjectB') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = subject_c+
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > ['NAME_QF COLON camel_case NEWLINE\t-> subject_b__name__simple', 'ONE_LINER_QF COLON one_liner NEWLINE\t-> subject_b__one_liner__simple', 'ABBREVIATION_QF COLON upper_camel NEWLINE\t-> subject_b__abbreviation__simple', 'paragraph+\t-> subject_b__elaboration__list', 'annotation+\t-> subject_b__annotations__list', 'class+\t-> subject_b__classes__list', 'subject_c+\t-> subject_b__subjects__list'] - from _gen_field_clauses
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_value_rules of ('SubjectB', <class 'Lit_01.Lit_01.SubjectB'>, {'name', 'one_liner'}) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > [Rule(name='subject_b__name__value', text='camel_case'), Rule(name='subject_b__one_liner__value', text='one_liner')] - from _gen_field_value_rules
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('LDM', <class 'Lit_01.Lit_01.LDM'>) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_clause of ('LDM',) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . subtypes of LDM are []
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_clause
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Class LDM is not abstract, generating own rule with clauses
[util_flogging.py:203 -              wrapper()] . . . . . . . < to_fragment of (PomTemplate(#  {{name}{? - {one_liner}} '
'), 'LDM') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . < to_grammar_parts of (PomTemplate(#  {{name}{? - {one_liner}} '
'), 'LDM') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Preprocessed template: #  {{name}[- {one_liner}] '
'
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(- {one_liner}), 'LDM') {}
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Preprocessed template: - {one_liner}
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Final grammar parts: ['DASH', 'ldm__one_liner__value']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . > to_grammar_parts returned ['DASH', 'ldm__one_liner__value']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Adding NEWLINE to punctuation_terminals
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . NEWLINE found in template: #  {{name}[- {one_liner}] '
'
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Final grammar parts: ['HASH', 'LBRACE', 'ldm__name__value', '[', 'DASH', 'ldm__one_liner__value', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . > to_grammar_parts returned ['HASH', 'LBRACE', 'ldm__name__value', '[', 'DASH', 'ldm__one_liner__value', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . > to_fragment returned HASH LBRACE ldm__name__value [ DASH ldm__one_liner__value ] NEWLINE
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(4, 10, 'name')]
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(4, 10, 'name'), (15, 26, 'one_liner')]
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > {'name', 'one_liner'} - from find_fields
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('LDM', <class 'Lit_01.Lit_01.LDM'>) {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for LDM.name is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(NAME_QF COLON FIELDVALUE NEWLINE), 'LDM') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(NAME_QF COLON FIELDVALUE NEWLINE), 'LDM') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: NAME_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NAME_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['NAME_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['NAME_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned NAME_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = NAME_QF COLON camel_case NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for LDM.one_liner is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ONE_LINER_QF COLON FIELDVALUE NEWLINE), 'LDM') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ONE_LINER_QF COLON FIELDVALUE NEWLINE), 'LDM') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ONE_LINER_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ONE_LINER_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ONE_LINER_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ONE_LINER_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ONE_LINER_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ONE_LINER_QF COLON one_liner NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for LDM.abbreviation is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ABBREVIATION_QF COLON FIELDVALUE NEWLINE), 'LDM') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ABBREVIATION_QF COLON FIELDVALUE NEWLINE), 'LDM') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ABBREVIATION_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ABBREVIATION_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ABBREVIATION_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ABBREVIATION_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ABBREVIATION_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ABBREVIATION_QF COLON upper_camel NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for LDM.elaboration is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'LDM') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'LDM') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = paragraph+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for LDM.annotations is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'LDM') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'LDM') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = annotation+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for LDM.classes is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'LDM') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'LDM') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = class+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for LDM.subjects is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'LDM') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'LDM') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = subject_b+
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > ['NAME_QF COLON camel_case NEWLINE\t-> ldm__name__simple', 'ONE_LINER_QF COLON one_liner NEWLINE\t-> ldm__one_liner__simple', 'ABBREVIATION_QF COLON upper_camel NEWLINE\t-> ldm__abbreviation__simple', 'paragraph+\t-> ldm__elaboration__list', 'annotation+\t-> ldm__annotations__list', 'class+\t-> ldm__classes__list', 'subject_b+\t-> ldm__subjects__list'] - from _gen_field_clauses
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_value_rules of ('LDM', <class 'Lit_01.Lit_01.LDM'>, {'name', 'one_liner'}) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > [Rule(name='ldm__name__value', text='camel_case'), Rule(name='ldm__one_liner__value', text='one_liner')] - from _gen_field_value_rules
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('DataType', <class 'Lit_01.Lit_01.DataType'>) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_clause of ('DataType',) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . subtypes of DataType are ['BaseDataType', 'ListDataType', 'SetDataType', 'MappingDataType']
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > base_data_type | list_data_type | set_data_type | mapping_data_type - from _generate_type_hierarchy_clause
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Class DataType is abstract, skipping rule generation
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('BaseDataType', <class 'Lit_01.Lit_01.BaseDataType'>) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_clause of ('BaseDataType',) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . subtypes of BaseDataType are []
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_clause
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Class BaseDataType is not abstract, generating own rule with clauses
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Full template is {class_name} {? - {is_value}}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_full_class_by_template of ('BaseDataType', PomTemplate({class_name} {? - {is_value}})) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . . . < to_fragment of (PomTemplate({class_name} {? - {is_value}}), 'BaseDataType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate({class_name} {? - {is_value}}), 'BaseDataType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . Preprocessed template: {class_name} [- {is_value}]
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(- {is_value}), 'BaseDataType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . . . Preprocessed template: - {is_value}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . . . Final grammar parts: ['DASH', 'base_data_type__is_value__value']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . . . > to_grammar_parts returned ['DASH', 'base_data_type__is_value__value']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . Final grammar parts: ['base_data_type__class_name__value', '[', 'DASH', 'base_data_type__is_value__value', ']']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . > to_grammar_parts returned ['base_data_type__class_name__value', '[', 'DASH', 'base_data_type__is_value__value', ']']
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . . . > to_fragment returned base_data_type__class_name__value [ DASH base_data_type__is_value__value ]
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > base_data_type__class_name__value [ DASH base_data_type__is_value__value ] - from _gen_full_class_by_template
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(0, 12, 'class_name')]
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(0, 12, 'class_name'), (18, 28, 'is_value')]
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > {'class_name', 'is_value'} - from find_fields
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_value_rules of ('BaseDataType', <class 'Lit_01.Lit_01.BaseDataType'>, {'class_name', 'is_value'}) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > [Rule(name='base_data_type__class_name__value', text='STRING'), Rule(name='base_data_type__is_value__value', text='reference_or_value')] - from _gen_field_value_rules
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('ListDataType', <class 'Lit_01.Lit_01.ListDataType'>) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_clause of ('ListDataType',) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . subtypes of ListDataType are []
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_clause
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Class ListDataType is not abstract, generating own rule with clauses
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Full template is list of {element_type}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_full_class_by_template of ('ListDataType', PomTemplate(list of {element_type})) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . . . < to_fragment of (PomTemplate(list of {element_type}), 'ListDataType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(list of {element_type}), 'ListDataType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . Preprocessed template: list of {element_type}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . Found a WORD list 
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . Found a WORD of 
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . Final grammar parts: ['LIST_Q', 'OF_Q', 'list_data_type__element_type__value']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . > to_grammar_parts returned ['LIST_Q', 'OF_Q', 'list_data_type__element_type__value']
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . . . > to_fragment returned LIST_Q OF_Q list_data_type__element_type__value
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > LIST_Q OF_Q list_data_type__element_type__value - from _gen_full_class_by_template
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(8, 22, 'element_type')]
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > {'element_type'} - from find_fields
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_value_rules of ('ListDataType', <class 'Lit_01.Lit_01.ListDataType'>, {'element_type'}) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > [Rule(name='list_data_type__element_type__value', text='data_type')] - from _gen_field_value_rules
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('SetDataType', <class 'Lit_01.Lit_01.SetDataType'>) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_clause of ('SetDataType',) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . subtypes of SetDataType are []
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_clause
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Class SetDataType is not abstract, generating own rule with clauses
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Full template is Set of {element_type}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_full_class_by_template of ('SetDataType', PomTemplate(Set of {element_type})) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . . . < to_fragment of (PomTemplate(Set of {element_type}), 'SetDataType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(Set of {element_type}), 'SetDataType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . Preprocessed template: Set of {element_type}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . Found a WORD Set 
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . Found a WORD of 
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . Final grammar parts: ['SET_Q', 'OF_Q', 'set_data_type__element_type__value']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . > to_grammar_parts returned ['SET_Q', 'OF_Q', 'set_data_type__element_type__value']
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . . . > to_fragment returned SET_Q OF_Q set_data_type__element_type__value
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > SET_Q OF_Q set_data_type__element_type__value - from _gen_full_class_by_template
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(7, 21, 'element_type')]
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > {'element_type'} - from find_fields
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_value_rules of ('SetDataType', <class 'Lit_01.Lit_01.SetDataType'>, {'element_type'}) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > [Rule(name='set_data_type__element_type__value', text='data_type')] - from _gen_field_value_rules
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('MappingDataType', <class 'Lit_01.Lit_01.MappingDataType'>) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_clause of ('MappingDataType',) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . subtypes of MappingDataType are []
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_clause
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Class MappingDataType is not abstract, generating own rule with clauses
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Full template is Mapping from {domain_type} to {range_type}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_full_class_by_template of ('MappingDataType', PomTemplate(Mapping from {domain_type} to {range_type})) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . . . < to_fragment of (PomTemplate(Mapping from {domain_type} to {range_type}), 'MappingDataType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(Mapping from {domain_type} to {range_type}), 'MappingDataType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . Preprocessed template: Mapping from {domain_type} to {range_type}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . Found a WORD Mapping 
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . Found a WORD from 
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . Found a WORD to 
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . Final grammar parts: ['MAPPING_Q', 'FROM_Q', 'mapping_data_type__domain_type__value', 'TO_Q', 'mapping_data_type__range_type__value']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . > to_grammar_parts returned ['MAPPING_Q', 'FROM_Q', 'mapping_data_type__domain_type__value', 'TO_Q', 'mapping_data_type__range_type__value']
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . . . > to_fragment returned MAPPING_Q FROM_Q mapping_data_type__domain_type__value TO_Q mapping_data_type__range_type__value
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > MAPPING_Q FROM_Q mapping_data_type__domain_type__value TO_Q mapping_data_type__range_type__value - from _gen_full_class_by_template
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(13, 26, 'domain_type')]
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(13, 26, 'domain_type'), (30, 42, 'range_type')]
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > {'range_type', 'domain_type'} - from find_fields
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_value_rules of ('MappingDataType', <class 'Lit_01.Lit_01.MappingDataType'>, {'range_type', 'domain_type'}) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > [Rule(name='mapping_data_type__domain_type__value', text='data_type'), Rule(name='mapping_data_type__range_type__value', text='data_type')] - from _gen_field_value_rules
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('DataTypeClause', <class 'Lit_01.Lit_01.DataTypeClause'>) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_clause of ('DataTypeClause',) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . subtypes of DataTypeClause are []
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_clause
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Class DataTypeClause is not abstract, generating own rule with clauses
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Full template is {is_optional} {data_type}{? {cardinality}}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_full_class_by_template of ('DataTypeClause', PomTemplate({is_optional} {data_type}{? {cardinality}})) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . . . < to_fragment of (PomTemplate({is_optional} {data_type}{? {cardinality}}), 'DataTypeClause') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate({is_optional} {data_type}{? {cardinality}}), 'DataTypeClause') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . Preprocessed template: {is_optional} {data_type}[{cardinality}]
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate({cardinality}), 'DataTypeClause') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . . . Preprocessed template: {cardinality}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . . . Final grammar parts: ['data_type_clause__cardinality__value']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . . . > to_grammar_parts returned ['data_type_clause__cardinality__value']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . Final grammar parts: ['data_type_clause__is_optional__value', 'data_type_clause__data_type__value', '[', 'data_type_clause__cardinality__value', ']']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . > to_grammar_parts returned ['data_type_clause__is_optional__value', 'data_type_clause__data_type__value', '[', 'data_type_clause__cardinality__value', ']']
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . . . > to_fragment returned data_type_clause__is_optional__value data_type_clause__data_type__value [ data_type_clause__cardinality__value ]
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > data_type_clause__is_optional__value data_type_clause__data_type__value [ data_type_clause__cardinality__value ] - from _gen_full_class_by_template
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(0, 13, 'is_optional')]
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(0, 13, 'is_optional'), (14, 25, 'data_type')]
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(0, 13, 'is_optional'), (14, 25, 'data_type'), (28, 41, 'cardinality')]
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > {'cardinality', 'is_optional', 'data_type'} - from find_fields
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_value_rules of ('DataTypeClause', <class 'Lit_01.Lit_01.DataTypeClause'>, {'cardinality', 'is_optional', 'data_type'}) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > [Rule(name='data_type_clause__data_type__value', text='data_type'), Rule(name='data_type_clause__is_optional__value', text='BOOLEAN'), Rule(name='data_type_clause__cardinality__value', text='STRING')] - from _gen_field_value_rules
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('FormulaCoding', <class 'Lit_01.Lit_01.FormulaCoding'>) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_clause of ('FormulaCoding',) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . subtypes of FormulaCoding are []
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_clause
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Class FormulaCoding is not abstract, generating own rule with clauses
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('FormulaCoding', <class 'Lit_01.Lit_01.FormulaCoding'>) {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for FormulaCoding.content is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'str': 'dull_str'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(CONTENT_QF COLON FIELDVALUE NEWLINE), 'FormulaCoding') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(CONTENT_QF COLON FIELDVALUE NEWLINE), 'FormulaCoding') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: CONTENT_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD CONTENT_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['CONTENT_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['CONTENT_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned CONTENT_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = CONTENT_QF COLON STRING NEWLINE
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > ['CONTENT_QF COLON STRING NEWLINE\t-> formula_coding__content__str'] - from _gen_field_clauses
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('Formula', <class 'Lit_01.Lit_01.Formula'>) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_clause of ('Formula',) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . subtypes of Formula are ['Constraint', 'Derivation', 'Default']
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > constraint | derivation | default - from _generate_type_hierarchy_clause
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Class Formula is not abstract, generating own rule with clauses
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('Formula', <class 'Lit_01.Lit_01.Formula'>) {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Formula.english is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'str': 'dull_str'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ENGLISH_QF COLON FIELDVALUE NEWLINE), 'Formula') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ENGLISH_QF COLON FIELDVALUE NEWLINE), 'Formula') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ENGLISH_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ENGLISH_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ENGLISH_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ENGLISH_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ENGLISH_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ENGLISH_QF COLON STRING NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Formula.code is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(CODE_QF COLON FIELDVALUE NEWLINE), 'Formula') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(CODE_QF COLON FIELDVALUE NEWLINE), 'Formula') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: CODE_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD CODE_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['CODE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['CODE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned CODE_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = CODE_QF COLON formula_coding NEWLINE
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > ['ENGLISH_QF COLON STRING NEWLINE\t-> formula__english__str', 'CODE_QF COLON formula_coding NEWLINE\t-> formula__code__simple'] - from _gen_field_clauses
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('Constraint', <class 'Lit_01.Lit_01.Constraint'>) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_clause of ('Constraint',) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . subtypes of Constraint are []
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_clause
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Class Constraint is not abstract, generating own rule with clauses
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('Constraint', <class 'Lit_01.Lit_01.Constraint'>) {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Constraint.english is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'str': 'dull_str'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ENGLISH_QF COLON FIELDVALUE NEWLINE), 'Constraint') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ENGLISH_QF COLON FIELDVALUE NEWLINE), 'Constraint') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ENGLISH_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ENGLISH_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ENGLISH_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ENGLISH_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ENGLISH_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ENGLISH_QF COLON STRING NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Constraint.code is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(CODE_QF COLON FIELDVALUE NEWLINE), 'Constraint') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(CODE_QF COLON FIELDVALUE NEWLINE), 'Constraint') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: CODE_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD CODE_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['CODE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['CODE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned CODE_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = CODE_QF COLON formula_coding NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Constraint.message is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'str': 'dull_str'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(MESSAGE_QF COLON FIELDVALUE NEWLINE), 'Constraint') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(MESSAGE_QF COLON FIELDVALUE NEWLINE), 'Constraint') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: MESSAGE_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD MESSAGE_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['MESSAGE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['MESSAGE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned MESSAGE_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = MESSAGE_QF COLON STRING NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Constraint.severity is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'str': 'dull_str'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(SEVERITY_QF COLON FIELDVALUE NEWLINE), 'Constraint') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(SEVERITY_QF COLON FIELDVALUE NEWLINE), 'Constraint') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: SEVERITY_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD SEVERITY_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['SEVERITY_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['SEVERITY_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned SEVERITY_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = SEVERITY_QF COLON STRING NEWLINE
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > ['ENGLISH_QF COLON STRING NEWLINE\t-> constraint__english__str', 'CODE_QF COLON formula_coding NEWLINE\t-> constraint__code__simple', 'MESSAGE_QF COLON STRING NEWLINE\t-> constraint__message__str', 'SEVERITY_QF COLON STRING NEWLINE\t-> constraint__severity__str'] - from _gen_field_clauses
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('Derivation', <class 'Lit_01.Lit_01.Derivation'>) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_clause of ('Derivation',) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . subtypes of Derivation are []
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_clause
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Class Derivation is not abstract, generating own rule with clauses
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('Derivation', <class 'Lit_01.Lit_01.Derivation'>) {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Derivation.english is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'str': 'dull_str'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ENGLISH_QF COLON FIELDVALUE NEWLINE), 'Derivation') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ENGLISH_QF COLON FIELDVALUE NEWLINE), 'Derivation') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ENGLISH_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ENGLISH_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ENGLISH_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ENGLISH_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ENGLISH_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ENGLISH_QF COLON STRING NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Derivation.code is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(CODE_QF COLON FIELDVALUE NEWLINE), 'Derivation') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(CODE_QF COLON FIELDVALUE NEWLINE), 'Derivation') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: CODE_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD CODE_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['CODE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['CODE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned CODE_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = CODE_QF COLON formula_coding NEWLINE
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > ['ENGLISH_QF COLON STRING NEWLINE\t-> derivation__english__str', 'CODE_QF COLON formula_coding NEWLINE\t-> derivation__code__simple'] - from _gen_field_clauses
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('Default', <class 'Lit_01.Lit_01.Default'>) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_clause of ('Default',) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . subtypes of Default are []
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_clause
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Class Default is not abstract, generating own rule with clauses
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('Default', <class 'Lit_01.Lit_01.Default'>) {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Default.english is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'str': 'dull_str'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ENGLISH_QF COLON FIELDVALUE NEWLINE), 'Default') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ENGLISH_QF COLON FIELDVALUE NEWLINE), 'Default') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ENGLISH_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ENGLISH_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ENGLISH_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ENGLISH_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ENGLISH_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ENGLISH_QF COLON STRING NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Default.code is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(CODE_QF COLON FIELDVALUE NEWLINE), 'Default') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(CODE_QF COLON FIELDVALUE NEWLINE), 'Default') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: CODE_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD CODE_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['CODE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['CODE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned CODE_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = CODE_QF COLON formula_coding NEWLINE
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > ['ENGLISH_QF COLON STRING NEWLINE\t-> default__english__str', 'CODE_QF COLON formula_coding NEWLINE\t-> default__code__simple'] - from _gen_field_clauses
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('Class', <class 'Lit_01.Lit_01.Class'>) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_clause of ('Class',) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . subtypes of Class are ['ValueType', 'ReferenceType']
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > value_type | reference_type - from _generate_type_hierarchy_clause
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Class Class is not abstract, generating own rule with clauses
[util_flogging.py:203 -              wrapper()] . . . . . . . < to_fragment of (PomTemplate(_ Class: {name}{? - {one_liner}} "\n"), 'Class') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . < to_grammar_parts of (PomTemplate(_ Class: {name}{? - {one_liner}} "\n"), 'Class') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Preprocessed template: _ Class: {name}[- {one_liner}] "\n"
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Found a WORD Class 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(- {one_liner}), 'Class') {}
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Preprocessed template: - {one_liner}
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Final grammar parts: ['DASH', 'class__one_liner__value']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . > to_grammar_parts returned ['DASH', 'class__one_liner__value']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Final grammar parts: ['UNDERSCORE', 'CLASS_Q', 'COLON', 'class__name__value', '[', 'DASH', 'class__one_liner__value', ']', 'N']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . > to_grammar_parts returned ['UNDERSCORE', 'CLASS_Q', 'COLON', 'class__name__value', '[', 'DASH', 'class__one_liner__value', ']', 'N']
[util_flogging.py:203 -              wrapper()] . . . . . . . > to_fragment returned UNDERSCORE CLASS_Q COLON class__name__value [ DASH class__one_liner__value ] N
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(9, 15, 'name')]
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(9, 15, 'name'), (20, 31, 'one_liner')]
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > {'name', 'one_liner'} - from find_fields
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('Class', <class 'Lit_01.Lit_01.Class'>) {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Class.name is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(NAME_QF COLON FIELDVALUE NEWLINE), 'Class') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(NAME_QF COLON FIELDVALUE NEWLINE), 'Class') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: NAME_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NAME_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['NAME_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['NAME_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned NAME_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = NAME_QF COLON upper_camel NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Class.one_liner is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ONE_LINER_QF COLON FIELDVALUE NEWLINE), 'Class') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ONE_LINER_QF COLON FIELDVALUE NEWLINE), 'Class') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ONE_LINER_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ONE_LINER_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ONE_LINER_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ONE_LINER_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ONE_LINER_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ONE_LINER_QF COLON one_liner NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Class.abbreviation is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ABBREVIATION_QF COLON FIELDVALUE NEWLINE), 'Class') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ABBREVIATION_QF COLON FIELDVALUE NEWLINE), 'Class') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ABBREVIATION_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ABBREVIATION_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ABBREVIATION_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ABBREVIATION_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ABBREVIATION_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ABBREVIATION_QF COLON upper_camel NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Class.elaboration is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'Class') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'Class') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = paragraph+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Class.annotations is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'Class') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'Class') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = annotation+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Class.plural is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(PLURAL_QF COLON FIELDVALUE NEWLINE), 'Class') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(PLURAL_QF COLON FIELDVALUE NEWLINE), 'Class') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: PLURAL_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD PLURAL_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['PLURAL_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['PLURAL_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned PLURAL_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = PLURAL_QF COLON upper_camel NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Class.subtype_of is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'list': '{element} (COMMA {element})+'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(SUBTYPE_OF_QF COLON FIELDVALUE NEWLINE), 'Class') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(SUBTYPE_OF_QF COLON FIELDVALUE NEWLINE), 'Class') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: SUBTYPE_OF_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD SUBTYPE_OF_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['SUBTYPE_OF_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['SUBTYPE_OF_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned SUBTYPE_OF_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = SUBTYPE_OF_QF COLON class_name (COMMA class_name)+ NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Class.subtypes is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'list': '{element} (COMMA {element})+'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(SUBTYPES_QF COLON FIELDVALUE NEWLINE), 'Class') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(SUBTYPES_QF COLON FIELDVALUE NEWLINE), 'Class') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: SUBTYPES_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD SUBTYPES_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['SUBTYPES_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['SUBTYPES_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned SUBTYPES_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = SUBTYPES_QF COLON class_name (COMMA class_name)+ NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Class.based_on is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'list': '{element} (COMMA {element})+'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(BASED_ON_QF COLON FIELDVALUE NEWLINE), 'Class') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(BASED_ON_QF COLON FIELDVALUE NEWLINE), 'Class') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: BASED_ON_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD BASED_ON_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['BASED_ON_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['BASED_ON_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned BASED_ON_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = BASED_ON_QF COLON class_name (COMMA class_name)+ NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Class.dependents is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'list': '{element} (COMMA {element})+'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(DEPENDENTS_QF COLON FIELDVALUE NEWLINE), 'Class') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(DEPENDENTS_QF COLON FIELDVALUE NEWLINE), 'Class') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: DEPENDENTS_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD DEPENDENTS_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['DEPENDENTS_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['DEPENDENTS_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned DEPENDENTS_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = DEPENDENTS_QF COLON class_name (COMMA class_name)+ NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Class.is_value_type is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'bool': {'true': 'true', 'false': 'false', 'is_explicit': True}}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(IS_VALUE_TYPE_QF COLON FIELDVALUE NEWLINE), 'Class') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(IS_VALUE_TYPE_QF COLON FIELDVALUE NEWLINE), 'Class') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: IS_VALUE_TYPE_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD IS_VALUE_TYPE_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['IS_VALUE_TYPE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['IS_VALUE_TYPE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned IS_VALUE_TYPE_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = IS_VALUE_TYPE_QF COLON BOOLEAN NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Class.where is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'str': 'dull_str'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(WHERE_QF COLON FIELDVALUE NEWLINE), 'Class') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(WHERE_QF COLON FIELDVALUE NEWLINE), 'Class') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: WHERE_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD WHERE_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['WHERE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['WHERE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned WHERE_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = WHERE_QF COLON STRING NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Class.attributes is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'Class') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'Class') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = attribute+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Class.attribute_sections is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'Class') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'Class') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = attribute_section+
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > ['NAME_QF COLON upper_camel NEWLINE\t-> class__name__simple', 'ONE_LINER_QF COLON one_liner NEWLINE\t-> class__one_liner__simple', 'ABBREVIATION_QF COLON upper_camel NEWLINE\t-> class__abbreviation__simple', 'paragraph+\t-> class__elaboration__list', 'annotation+\t-> class__annotations__list', 'PLURAL_QF COLON upper_camel NEWLINE\t-> class__plural__simple', 'SUBTYPE_OF_QF COLON class_name (COMMA class_name)+ NEWLINE\t-> class__subtype_of__list', 'SUBTYPES_QF COLON class_name (COMMA class_name)+ NEWLINE\t-> class__subtypes__list', 'BASED_ON_QF COLON class_name (COMMA class_name)+ NEWLINE\t-> class__based_on__list', 'DEPENDENTS_QF COLON class_name (COMMA class_name)+ NEWLINE\t-> class__dependents__list', 'IS_VALUE_TYPE_QF COLON BOOLEAN NEWLINE\t-> class__is_value_type__bool', 'WHERE_QF COLON STRING NEWLINE\t-> class__where__str', 'attribute+\t-> class__attributes__list', 'attribute_section+\t-> class__attribute_sections__list'] - from _gen_field_clauses
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_value_rules of ('Class', <class 'Lit_01.Lit_01.Class'>, {'name', 'one_liner'}) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > [Rule(name='class__name__value', text='upper_camel'), Rule(name='class__one_liner__value', text='one_liner')] - from _gen_field_value_rules
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('ValueType', <class 'Lit_01.Lit_01.ValueType'>) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_clause of ('ValueType',) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . subtypes of ValueType are []
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_clause
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Class ValueType is not abstract, generating own rule with clauses
[util_flogging.py:203 -              wrapper()] . . . . . . . < to_fragment of (PomTemplate(_ {name}{? - {one_liner}} '
'), 'ValueType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . < to_grammar_parts of (PomTemplate(_ {name}{? - {one_liner}} '
'), 'ValueType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Preprocessed template: _ {name}[- {one_liner}] '
'
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(- {one_liner}), 'ValueType') {}
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Preprocessed template: - {one_liner}
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Final grammar parts: ['DASH', 'value_type__one_liner__value']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . > to_grammar_parts returned ['DASH', 'value_type__one_liner__value']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Adding NEWLINE to punctuation_terminals
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . NEWLINE found in template: _ {name}[- {one_liner}] '
'
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Final grammar parts: ['UNDERSCORE', 'value_type__name__value', '[', 'DASH', 'value_type__one_liner__value', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . > to_grammar_parts returned ['UNDERSCORE', 'value_type__name__value', '[', 'DASH', 'value_type__one_liner__value', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . > to_fragment returned UNDERSCORE value_type__name__value [ DASH value_type__one_liner__value ] NEWLINE
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(2, 8, 'name')]
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(2, 8, 'name'), (13, 24, 'one_liner')]
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > {'name', 'one_liner'} - from find_fields
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('ValueType', <class 'Lit_01.Lit_01.ValueType'>) {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ValueType.name is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(NAME_QF COLON FIELDVALUE NEWLINE), 'ValueType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(NAME_QF COLON FIELDVALUE NEWLINE), 'ValueType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: NAME_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NAME_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['NAME_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['NAME_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned NAME_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = NAME_QF COLON upper_camel NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ValueType.one_liner is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ONE_LINER_QF COLON FIELDVALUE NEWLINE), 'ValueType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ONE_LINER_QF COLON FIELDVALUE NEWLINE), 'ValueType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ONE_LINER_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ONE_LINER_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ONE_LINER_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ONE_LINER_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ONE_LINER_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ONE_LINER_QF COLON one_liner NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ValueType.abbreviation is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ABBREVIATION_QF COLON FIELDVALUE NEWLINE), 'ValueType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ABBREVIATION_QF COLON FIELDVALUE NEWLINE), 'ValueType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ABBREVIATION_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ABBREVIATION_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ABBREVIATION_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ABBREVIATION_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ABBREVIATION_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ABBREVIATION_QF COLON upper_camel NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ValueType.elaboration is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'ValueType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'ValueType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = paragraph+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ValueType.annotations is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'ValueType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'ValueType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = annotation+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ValueType.plural is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(PLURAL_QF COLON FIELDVALUE NEWLINE), 'ValueType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(PLURAL_QF COLON FIELDVALUE NEWLINE), 'ValueType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: PLURAL_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD PLURAL_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['PLURAL_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['PLURAL_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned PLURAL_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = PLURAL_QF COLON upper_camel NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ValueType.subtype_of is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'list': '{element} (COMMA {element})+'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(SUBTYPE_OF_QF COLON FIELDVALUE NEWLINE), 'ValueType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(SUBTYPE_OF_QF COLON FIELDVALUE NEWLINE), 'ValueType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: SUBTYPE_OF_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD SUBTYPE_OF_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['SUBTYPE_OF_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['SUBTYPE_OF_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned SUBTYPE_OF_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = SUBTYPE_OF_QF COLON class_name (COMMA class_name)+ NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ValueType.subtypes is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'list': '{element} (COMMA {element})+'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(SUBTYPES_QF COLON FIELDVALUE NEWLINE), 'ValueType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(SUBTYPES_QF COLON FIELDVALUE NEWLINE), 'ValueType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: SUBTYPES_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD SUBTYPES_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['SUBTYPES_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['SUBTYPES_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned SUBTYPES_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = SUBTYPES_QF COLON class_name (COMMA class_name)+ NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ValueType.based_on is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'list': '{element} (COMMA {element})+'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(BASED_ON_QF COLON FIELDVALUE NEWLINE), 'ValueType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(BASED_ON_QF COLON FIELDVALUE NEWLINE), 'ValueType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: BASED_ON_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD BASED_ON_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['BASED_ON_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['BASED_ON_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned BASED_ON_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = BASED_ON_QF COLON class_name (COMMA class_name)+ NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ValueType.dependents is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'list': '{element} (COMMA {element})+'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(DEPENDENTS_QF COLON FIELDVALUE NEWLINE), 'ValueType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(DEPENDENTS_QF COLON FIELDVALUE NEWLINE), 'ValueType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: DEPENDENTS_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD DEPENDENTS_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['DEPENDENTS_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['DEPENDENTS_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned DEPENDENTS_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = DEPENDENTS_QF COLON class_name (COMMA class_name)+ NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ValueType.is_value_type is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'bool': {'true': 'true', 'false': 'false', 'is_explicit': True}}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(IS_VALUE_TYPE_QF COLON FIELDVALUE NEWLINE), 'ValueType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(IS_VALUE_TYPE_QF COLON FIELDVALUE NEWLINE), 'ValueType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: IS_VALUE_TYPE_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD IS_VALUE_TYPE_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['IS_VALUE_TYPE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['IS_VALUE_TYPE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned IS_VALUE_TYPE_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = IS_VALUE_TYPE_QF COLON BOOLEAN NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ValueType.where is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'str': 'dull_str'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(WHERE_QF COLON FIELDVALUE NEWLINE), 'ValueType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(WHERE_QF COLON FIELDVALUE NEWLINE), 'ValueType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: WHERE_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD WHERE_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['WHERE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['WHERE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned WHERE_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = WHERE_QF COLON STRING NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ValueType.attributes is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'ValueType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'ValueType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = attribute+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ValueType.attribute_sections is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'ValueType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'ValueType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = attribute_section+
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > ['NAME_QF COLON upper_camel NEWLINE\t-> value_type__name__simple', 'ONE_LINER_QF COLON one_liner NEWLINE\t-> value_type__one_liner__simple', 'ABBREVIATION_QF COLON upper_camel NEWLINE\t-> value_type__abbreviation__simple', 'paragraph+\t-> value_type__elaboration__list', 'annotation+\t-> value_type__annotations__list', 'PLURAL_QF COLON upper_camel NEWLINE\t-> value_type__plural__simple', 'SUBTYPE_OF_QF COLON class_name (COMMA class_name)+ NEWLINE\t-> value_type__subtype_of__list', 'SUBTYPES_QF COLON class_name (COMMA class_name)+ NEWLINE\t-> value_type__subtypes__list', 'BASED_ON_QF COLON class_name (COMMA class_name)+ NEWLINE\t-> value_type__based_on__list', 'DEPENDENTS_QF COLON class_name (COMMA class_name)+ NEWLINE\t-> value_type__dependents__list', 'IS_VALUE_TYPE_QF COLON BOOLEAN NEWLINE\t-> value_type__is_value_type__bool', 'WHERE_QF COLON STRING NEWLINE\t-> value_type__where__str', 'attribute+\t-> value_type__attributes__list', 'attribute_section+\t-> value_type__attribute_sections__list'] - from _gen_field_clauses
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_value_rules of ('ValueType', <class 'Lit_01.Lit_01.ValueType'>, {'name', 'one_liner'}) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > [Rule(name='value_type__name__value', text='upper_camel'), Rule(name='value_type__one_liner__value', text='one_liner')] - from _gen_field_value_rules
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('ReferenceType', <class 'Lit_01.Lit_01.ReferenceType'>) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_clause of ('ReferenceType',) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . subtypes of ReferenceType are []
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_clause
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Class ReferenceType is not abstract, generating own rule with clauses
[util_flogging.py:203 -              wrapper()] . . . . . . . < to_fragment of (PomTemplate(_ {name}{? - {one_liner}} '
'), 'ReferenceType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . < to_grammar_parts of (PomTemplate(_ {name}{? - {one_liner}} '
'), 'ReferenceType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Preprocessed template: _ {name}[- {one_liner}] '
'
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(- {one_liner}), 'ReferenceType') {}
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Preprocessed template: - {one_liner}
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Final grammar parts: ['DASH', 'reference_type__one_liner__value']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . > to_grammar_parts returned ['DASH', 'reference_type__one_liner__value']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Adding NEWLINE to punctuation_terminals
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . NEWLINE found in template: _ {name}[- {one_liner}] '
'
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Final grammar parts: ['UNDERSCORE', 'reference_type__name__value', '[', 'DASH', 'reference_type__one_liner__value', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . > to_grammar_parts returned ['UNDERSCORE', 'reference_type__name__value', '[', 'DASH', 'reference_type__one_liner__value', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . > to_fragment returned UNDERSCORE reference_type__name__value [ DASH reference_type__one_liner__value ] NEWLINE
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(2, 8, 'name')]
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(2, 8, 'name'), (13, 24, 'one_liner')]
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > {'name', 'one_liner'} - from find_fields
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('ReferenceType', <class 'Lit_01.Lit_01.ReferenceType'>) {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ReferenceType.name is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(NAME_QF COLON FIELDVALUE NEWLINE), 'ReferenceType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(NAME_QF COLON FIELDVALUE NEWLINE), 'ReferenceType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: NAME_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NAME_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['NAME_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['NAME_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned NAME_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = NAME_QF COLON upper_camel NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ReferenceType.one_liner is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ONE_LINER_QF COLON FIELDVALUE NEWLINE), 'ReferenceType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ONE_LINER_QF COLON FIELDVALUE NEWLINE), 'ReferenceType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ONE_LINER_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ONE_LINER_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ONE_LINER_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ONE_LINER_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ONE_LINER_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ONE_LINER_QF COLON one_liner NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ReferenceType.abbreviation is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ABBREVIATION_QF COLON FIELDVALUE NEWLINE), 'ReferenceType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ABBREVIATION_QF COLON FIELDVALUE NEWLINE), 'ReferenceType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ABBREVIATION_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ABBREVIATION_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ABBREVIATION_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ABBREVIATION_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ABBREVIATION_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ABBREVIATION_QF COLON upper_camel NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ReferenceType.elaboration is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'ReferenceType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'ReferenceType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = paragraph+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ReferenceType.annotations is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'ReferenceType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'ReferenceType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = annotation+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ReferenceType.plural is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(PLURAL_QF COLON FIELDVALUE NEWLINE), 'ReferenceType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(PLURAL_QF COLON FIELDVALUE NEWLINE), 'ReferenceType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: PLURAL_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD PLURAL_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['PLURAL_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['PLURAL_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned PLURAL_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = PLURAL_QF COLON upper_camel NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ReferenceType.subtype_of is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'list': '{element} (COMMA {element})+'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(SUBTYPE_OF_QF COLON FIELDVALUE NEWLINE), 'ReferenceType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(SUBTYPE_OF_QF COLON FIELDVALUE NEWLINE), 'ReferenceType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: SUBTYPE_OF_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD SUBTYPE_OF_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['SUBTYPE_OF_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['SUBTYPE_OF_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned SUBTYPE_OF_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = SUBTYPE_OF_QF COLON class_name (COMMA class_name)+ NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ReferenceType.subtypes is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'list': '{element} (COMMA {element})+'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(SUBTYPES_QF COLON FIELDVALUE NEWLINE), 'ReferenceType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(SUBTYPES_QF COLON FIELDVALUE NEWLINE), 'ReferenceType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: SUBTYPES_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD SUBTYPES_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['SUBTYPES_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['SUBTYPES_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned SUBTYPES_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = SUBTYPES_QF COLON class_name (COMMA class_name)+ NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ReferenceType.based_on is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'list': '{element} (COMMA {element})+'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(BASED_ON_QF COLON FIELDVALUE NEWLINE), 'ReferenceType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(BASED_ON_QF COLON FIELDVALUE NEWLINE), 'ReferenceType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: BASED_ON_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD BASED_ON_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['BASED_ON_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['BASED_ON_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned BASED_ON_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = BASED_ON_QF COLON class_name (COMMA class_name)+ NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ReferenceType.dependents is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'list': '{element} (COMMA {element})+'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(DEPENDENTS_QF COLON FIELDVALUE NEWLINE), 'ReferenceType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(DEPENDENTS_QF COLON FIELDVALUE NEWLINE), 'ReferenceType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: DEPENDENTS_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD DEPENDENTS_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['DEPENDENTS_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['DEPENDENTS_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned DEPENDENTS_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = DEPENDENTS_QF COLON class_name (COMMA class_name)+ NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ReferenceType.is_value_type is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'bool': {'true': 'true', 'false': 'false', 'is_explicit': True}}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(IS_VALUE_TYPE_QF COLON FIELDVALUE NEWLINE), 'ReferenceType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(IS_VALUE_TYPE_QF COLON FIELDVALUE NEWLINE), 'ReferenceType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: IS_VALUE_TYPE_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD IS_VALUE_TYPE_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['IS_VALUE_TYPE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['IS_VALUE_TYPE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned IS_VALUE_TYPE_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = IS_VALUE_TYPE_QF COLON BOOLEAN NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ReferenceType.where is: {'field_value': '{field_name} COLON {field_value} NEWLINE', 'str': 'dull_str'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(WHERE_QF COLON FIELDVALUE NEWLINE), 'ReferenceType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(WHERE_QF COLON FIELDVALUE NEWLINE), 'ReferenceType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: WHERE_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD WHERE_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['WHERE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['WHERE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned WHERE_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = WHERE_QF COLON STRING NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ReferenceType.attributes is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'ReferenceType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'ReferenceType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = attribute+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for ReferenceType.attribute_sections is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'ReferenceType') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'ReferenceType') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = attribute_section+
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > ['NAME_QF COLON upper_camel NEWLINE\t-> reference_type__name__simple', 'ONE_LINER_QF COLON one_liner NEWLINE\t-> reference_type__one_liner__simple', 'ABBREVIATION_QF COLON upper_camel NEWLINE\t-> reference_type__abbreviation__simple', 'paragraph+\t-> reference_type__elaboration__list', 'annotation+\t-> reference_type__annotations__list', 'PLURAL_QF COLON upper_camel NEWLINE\t-> reference_type__plural__simple', 'SUBTYPE_OF_QF COLON class_name (COMMA class_name)+ NEWLINE\t-> reference_type__subtype_of__list', 'SUBTYPES_QF COLON class_name (COMMA class_name)+ NEWLINE\t-> reference_type__subtypes__list', 'BASED_ON_QF COLON class_name (COMMA class_name)+ NEWLINE\t-> reference_type__based_on__list', 'DEPENDENTS_QF COLON class_name (COMMA class_name)+ NEWLINE\t-> reference_type__dependents__list', 'IS_VALUE_TYPE_QF COLON BOOLEAN NEWLINE\t-> reference_type__is_value_type__bool', 'WHERE_QF COLON STRING NEWLINE\t-> reference_type__where__str', 'attribute+\t-> reference_type__attributes__list', 'attribute_section+\t-> reference_type__attribute_sections__list'] - from _gen_field_clauses
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_value_rules of ('ReferenceType', <class 'Lit_01.Lit_01.ReferenceType'>, {'name', 'one_liner'}) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > [Rule(name='reference_type__name__value', text='upper_camel'), Rule(name='reference_type__one_liner__value', text='one_liner')] - from _gen_field_value_rules
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('AttributeSection', <class 'Lit_01.Lit_01.AttributeSection'>) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_clause of ('AttributeSection',) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . subtypes of AttributeSection are []
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_clause
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Class AttributeSection is not abstract, generating own rule with clauses
[util_flogging.py:203 -              wrapper()] . . . . . . . < to_fragment of (PomTemplate(-  {name}{? - {one_liner}}{? ({is_required})} '
'), 'AttributeSection') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . < to_grammar_parts of (PomTemplate(-  {name}{? - {one_liner}}{? ({is_required})} '
'), 'AttributeSection') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Preprocessed template: -  {name}[- {one_liner}][({is_required})] '
'
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(- {one_liner}), 'AttributeSection') {}
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Preprocessed template: - {one_liner}
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Final grammar parts: ['DASH', 'attribute_section__one_liner__value']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . > to_grammar_parts returned ['DASH', 'attribute_section__one_liner__value']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(({is_required})), 'AttributeSection') {}
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Preprocessed template: ({is_required})
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Final grammar parts: ['LPAREN', 'attribute_section__is_required__value', 'RPAREN']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . > to_grammar_parts returned ['LPAREN', 'attribute_section__is_required__value', 'RPAREN']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Adding NEWLINE to punctuation_terminals
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . NEWLINE found in template: -  {name}[- {one_liner}][({is_required})] '
'
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Final grammar parts: ['DASH', 'attribute_section__name__value', '[', 'DASH', 'attribute_section__one_liner__value', ']', '[', 'LPAREN', 'attribute_section__is_required__value', 'RPAREN', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . > to_grammar_parts returned ['DASH', 'attribute_section__name__value', '[', 'DASH', 'attribute_section__one_liner__value', ']', '[', 'LPAREN', 'attribute_section__is_required__value', 'RPAREN', ']', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . > to_fragment returned DASH attribute_section__name__value [ DASH attribute_section__one_liner__value ] [ LPAREN attribute_section__is_required__value RPAREN ] NEWLINE
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(3, 9, 'name')]
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(3, 9, 'name'), (14, 25, 'one_liner')]
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(3, 9, 'name'), (14, 25, 'one_liner'), (30, 43, 'is_required')]
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > {'name', 'is_required', 'one_liner'} - from find_fields
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('AttributeSection', <class 'Lit_01.Lit_01.AttributeSection'>) {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for AttributeSection.name is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(NAME_QF COLON FIELDVALUE NEWLINE), 'AttributeSection') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(NAME_QF COLON FIELDVALUE NEWLINE), 'AttributeSection') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: NAME_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NAME_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['NAME_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['NAME_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned NAME_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = NAME_QF COLON camel_case NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for AttributeSection.one_liner is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ONE_LINER_QF COLON FIELDVALUE NEWLINE), 'AttributeSection') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ONE_LINER_QF COLON FIELDVALUE NEWLINE), 'AttributeSection') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ONE_LINER_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ONE_LINER_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ONE_LINER_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ONE_LINER_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ONE_LINER_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ONE_LINER_QF COLON one_liner NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for AttributeSection.abbreviation is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ABBREVIATION_QF COLON FIELDVALUE NEWLINE), 'AttributeSection') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ABBREVIATION_QF COLON FIELDVALUE NEWLINE), 'AttributeSection') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ABBREVIATION_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ABBREVIATION_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ABBREVIATION_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ABBREVIATION_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ABBREVIATION_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ABBREVIATION_QF COLON upper_camel NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for AttributeSection.elaboration is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'AttributeSection') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'AttributeSection') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = paragraph+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for AttributeSection.annotations is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'AttributeSection') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'AttributeSection') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = annotation+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for AttributeSection.is_required is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(IS_REQUIRED_QF COLON FIELDVALUE NEWLINE), 'AttributeSection') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(IS_REQUIRED_QF COLON FIELDVALUE NEWLINE), 'AttributeSection') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: IS_REQUIRED_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD IS_REQUIRED_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['IS_REQUIRED_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['IS_REQUIRED_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned IS_REQUIRED_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = IS_REQUIRED_QF COLON is_really_required NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for AttributeSection.attributes is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'AttributeSection') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'AttributeSection') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = attribute+
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > ['NAME_QF COLON camel_case NEWLINE\t-> attribute_section__name__simple', 'ONE_LINER_QF COLON one_liner NEWLINE\t-> attribute_section__one_liner__simple', 'ABBREVIATION_QF COLON upper_camel NEWLINE\t-> attribute_section__abbreviation__simple', 'paragraph+\t-> attribute_section__elaboration__list', 'annotation+\t-> attribute_section__annotations__list', 'IS_REQUIRED_QF COLON is_really_required NEWLINE\t-> attribute_section__is_required__simple', 'attribute+\t-> attribute_section__attributes__list'] - from _gen_field_clauses
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_value_rules of ('AttributeSection', <class 'Lit_01.Lit_01.AttributeSection'>, {'name', 'is_required', 'one_liner'}) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > [Rule(name='attribute_section__name__value', text='camel_case'), Rule(name='attribute_section__one_liner__value', text='one_liner'), Rule(name='attribute_section__is_required__value', text='is_really_required')] - from _gen_field_value_rules
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
[pom_grammar_generator.py:123 -     generate_grammar()] . . . < _gen_rules_for_class of ('Attribute', <class 'Lit_01.Lit_01.Attribute'>) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _generate_type_hierarchy_clause of ('Attribute',) {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . subtypes of Attribute are []
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > None - from _generate_type_hierarchy_clause
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . Class Attribute is not abstract, generating own rule with clauses
[util_flogging.py:203 -              wrapper()] . . . . . . . < to_fragment of (PomTemplate(-  {name}{? - {one_liner}}{? ({data_type_clause})} "\n"), 'Attribute') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . < to_grammar_parts of (PomTemplate(-  {name}{? - {one_liner}}{? ({data_type_clause})} "\n"), 'Attribute') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Preprocessed template: -  {name}[- {one_liner}][({data_type_clause})] "\n"
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(- {one_liner}), 'Attribute') {}
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Preprocessed template: - {one_liner}
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Final grammar parts: ['DASH', 'attribute__one_liner__value']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . > to_grammar_parts returned ['DASH', 'attribute__one_liner__value']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(({data_type_clause})), 'Attribute') {}
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Preprocessed template: ({data_type_clause})
[pom_grammar_generator.py:392 - _gen_rules_for_class()] . . . . . . . . . . . . . . Final grammar parts: ['LPAREN', 'attribute__data_type_clause__value', 'RPAREN']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . > to_grammar_parts returned ['LPAREN', 'attribute__data_type_clause__value', 'RPAREN']
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . Final grammar parts: ['DASH', 'attribute__name__value', '[', 'DASH', 'attribute__one_liner__value', ']', '[', 'LPAREN', 'attribute__data_type_clause__value', 'RPAREN', ']', 'N']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . > to_grammar_parts returned ['DASH', 'attribute__name__value', '[', 'DASH', 'attribute__one_liner__value', ']', '[', 'LPAREN', 'attribute__data_type_clause__value', 'RPAREN', ']', 'N']
[util_flogging.py:203 -              wrapper()] . . . . . . . > to_fragment returned DASH attribute__name__value [ DASH attribute__one_liner__value ] [ LPAREN attribute__data_type_clause__value RPAREN ] N
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < find_fields of () {}
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(3, 9, 'name')]
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(3, 9, 'name'), (14, 25, 'one_liner')]
[pom_grammar_generator.py:222 - _gen_all_class_rules()] . . . . . . . . Field posiitons: [(3, 9, 'name'), (14, 25, 'one_liner'), (30, 48, 'data_type_clause')]
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > {'name', 'data_type_clause', 'one_liner'} - from find_fields
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_clauses of ('Attribute', <class 'Lit_01.Lit_01.Attribute'>) {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Attribute.name is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(NAME_QF COLON FIELDVALUE NEWLINE), 'Attribute') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(NAME_QF COLON FIELDVALUE NEWLINE), 'Attribute') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: NAME_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NAME_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['NAME_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['NAME_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned NAME_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = NAME_QF COLON lower_camel NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Attribute.one_liner is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ONE_LINER_QF COLON FIELDVALUE NEWLINE), 'Attribute') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ONE_LINER_QF COLON FIELDVALUE NEWLINE), 'Attribute') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ONE_LINER_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ONE_LINER_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ONE_LINER_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ONE_LINER_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ONE_LINER_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ONE_LINER_QF COLON one_liner NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Attribute.abbreviation is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(ABBREVIATION_QF COLON FIELDVALUE NEWLINE), 'Attribute') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(ABBREVIATION_QF COLON FIELDVALUE NEWLINE), 'Attribute') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: ABBREVIATION_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD ABBREVIATION_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['ABBREVIATION_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['ABBREVIATION_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned ABBREVIATION_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = ABBREVIATION_QF COLON upper_camel NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Attribute.elaboration is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'Attribute') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'Attribute') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = paragraph+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Attribute.annotations is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'Attribute') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'Attribute') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = annotation+
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Attribute.data_type_clause is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(DATA_TYPE_CLAUSE_QF COLON FIELDVALUE NEWLINE), 'Attribute') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(DATA_TYPE_CLAUSE_QF COLON FIELDVALUE NEWLINE), 'Attribute') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: DATA_TYPE_CLAUSE_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD DATA_TYPE_CLAUSE_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['DATA_TYPE_CLAUSE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['DATA_TYPE_CLAUSE_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned DATA_TYPE_CLAUSE_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = DATA_TYPE_CLAUSE_QF COLON data_type_clause NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Attribute.derivation is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(DERIVATION_QF COLON FIELDVALUE NEWLINE), 'Attribute') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(DERIVATION_QF COLON FIELDVALUE NEWLINE), 'Attribute') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: DERIVATION_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD DERIVATION_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['DERIVATION_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['DERIVATION_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned DERIVATION_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = DERIVATION_QF COLON derivation NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Attribute.default is: {'field_value': '{field_name} COLON {field_value} NEWLINE'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(DEFAULT_QF COLON FIELDVALUE NEWLINE), 'Attribute') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(DEFAULT_QF COLON FIELDVALUE NEWLINE), 'Attribute') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: DEFAULT_QF COLON FIELDVALUE NEWLINE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD DEFAULT_QF 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD COLON 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name COLON added for :
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD NEWLINE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Punctuation name NEWLINE added for \n
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['DEFAULT_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['DEFAULT_QF', 'COLON', 'FIELDVALUE_Q', 'NEWLINE']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned DEFAULT_QF COLON FIELDVALUE_Q NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = DEFAULT_QF COLON default NEWLINE
[util_flogging.py:203 -              wrapper()] . . . . . . . . . Field meta  for Attribute.constraints is: {'list': '{element}+', 'field_value': '{field_value}'}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . < to_fragment of (PomTemplate(FIELDVALUE), 'Attribute') {}
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . < to_grammar_parts of (PomTemplate(FIELDVALUE), 'Attribute') {}
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Preprocessed template: FIELDVALUE
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Found a WORD FIELDVALUE 
[util_flogging.py:239 -              wrapper()] . . . . . . . . . . . . . . . Final grammar parts: ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . . . . > to_grammar_parts returned ['FIELDVALUE_Q']
[util_flogging.py:203 -              wrapper()] . . . . . . . . . . . > to_fragment returned FIELDVALUE_Q
[util_flogging.py:203 -              wrapper()] . . . . . . . . . repaired fragment = constraint+
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > ['NAME_QF COLON lower_camel NEWLINE\t-> attribute__name__simple', 'ONE_LINER_QF COLON one_liner NEWLINE\t-> attribute__one_liner__simple', 'ABBREVIATION_QF COLON upper_camel NEWLINE\t-> attribute__abbreviation__simple', 'paragraph+\t-> attribute__elaboration__list', 'annotation+\t-> attribute__annotations__list', 'DATA_TYPE_CLAUSE_QF COLON data_type_clause NEWLINE\t-> attribute__data_type_clause__simple', 'DERIVATION_QF COLON derivation NEWLINE\t-> attribute__derivation__simple', 'DEFAULT_QF COLON default NEWLINE\t-> attribute__default__simple', 'constraint+\t-> attribute__constraints__list'] - from _gen_field_clauses
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . < _gen_field_value_rules of ('Attribute', <class 'Lit_01.Lit_01.Attribute'>, {'name', 'data_type_clause', 'one_liner'}) {}
[pom_grammar_generator.py:123 -     generate_grammar()] . . . . . . . > [Rule(name='attribute__name__value', text='lower_camel'), Rule(name='attribute__one_liner__value', text='one_liner'), Rule(name='attribute__data_type_clause__value', text='data_type_clause')] - from _gen_field_value_rules
[pom_grammar_generator.py:123 -     generate_grammar()] . . . > None - from _gen_rules_for_class
Field terminals:  {'TO_Q', 'LIST_Q', 'CLASS_Q', 'FROM_Q', 'N', 'SET_Q', 'FIELDVALUE_Q', 'OF_Q', 'MAPPING_Q'}
Punctiuation used:  {'DASH', 'HASH', 'COLON', 'LPAREN', 'UNDERSCORE', 'RPAREN', 'LBRACE', 'NEWLINE'}
[pom_grammar.py:189 -           save_rules()] Saved grammar rules to C:\Users\fmkat\OneDrive\AllFMKFIles\AllVSCode\FMKProjects\Presentable\models\Lit_01\Lit_01_dull_grammar.lark
[pom_grammar.py:210 -       save_templates()] Saved templates to C:\Users\fmkat\OneDrive\AllFMKFIles\AllVSCode\FMKProjects\Presentable\models\Lit_01\Lit_01_dull_templates.hbs
[pom_grammar.py:70 -             __init__()] PresentableGrammar initialization complete
[do_pom_test.py:15 -             test_pom()] Grammar created
<pom_grammar.PresentableGrammar object at 0x0000016F4A6D17F0>
[do_pom_test.py:19 -             test_pom()] Trying file models/Lit_01/SamplerClass.md
Text is:  _ SampleClassB - something to test Class clauses
abbreviation: CSample
where: A = B
subtype of: B byPrice
subtypes: X, Y, Z 
dependents: Aa
dependents: Abc, Def


Lines are: (8)

 _ SampleClassB - something to test Class clauses

 abbreviation: CSample

 where: A = B

 subtype of: B byPrice

 subtypes: X, Y, Z 

 dependents: Aa

 dependents: Abc, Def

 
DEBUG: All line types seen: {'blank', 'header', 'annotation'}
blank
header
annotation

MarkedLines are: (8)
	 _ SampleClassB - <<<something to test Class clauses>>> ; 

	 abbreviation: CSample
	 where: <<<A = B>>> ; 

	 subtype of: B byPrice
	 subtypes: X, Y, Z 
	 dependents: Aa
	 dependents: Abc, Def
	 <<<

Trimmed lines are: (8)
	 _ SampleClassB - <<<something to test Class clauses>>>
	 abbreviation: CSample
	 where: <<<A = B>>>
	 subtype of: B byPrice
	 subtypes: X, Y, Z 
	 dependents: Aa
	 dependents: Abc, Def
	 <<<

Marked text is: 
 _ SampleClassB - <<<something to test Class clauses>>>
abbreviation: CSample
where: <<<A = B>>>
subtype of: B byPrice
subtypes: X, Y, Z 
dependents: Aa
dependents: Abc, Def

[pom_parser.py:84 -             __init__()] PomParser initialized
[pom_grammar.py:249 -                parse()] Parsing input text (length: 161)
[pom_parser.py:113 -          _get_parser()] Creating new Lark parser with settings: {'start': 'start', 'parser': 'earley', 'debug': False, 'ambiguity': 'resolve'}
[pom_parser.py:118 -          _get_parser()] Error creating parser: Expecting a value, at line 39 column 16

paragraph:	AAA+?ZZZ
                    ^

[pom_parser.py:176 -                parse()] Error during parsing: Expecting a value, at line 39 column 16

paragraph:	AAA+?ZZZ
                    ^

parse tree =  None
