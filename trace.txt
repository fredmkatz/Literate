[do_pom_test.py:9 -                            test_pom()] Starting to test POM
[pom_grammar.py:51 -                            __init__()] Initializing PresentableGrammar with model_name=Lit_01, format_name=dull
[pom_grammar.py:62 -                            __init__()] Found model directory: C:\Users\fmkat\OneDrive\AllFMKFIles\AllVSCode\FMKProjects\Presentable\models\Lit_01
[pom_grammar.py:65 -                            __init__()] Loaded model module: Lit_01.Lit_01
[pom_grammar.py:70 -                            __init__()] <  Called by __init__ with args () {'model_name': 'Lit_01', 'format_name': 'dull', 'config_dict': {'case_sensitive': False, 'ambiguity': 'resolve', 'debug': True}}
[pom_config.py:74 -                            __init__()] . Initializing PomConfig with model_name=Lit_01, format_name=dull
[class_pom_meta.py:317 -                  load_model_formats()] . Loading format files from paths: ['settings/dull_format.yaml', 'models/Lit_01/Lit_01_dull_format.yaml']
[class_pom_meta.py:330 -                  load_model_formats()] . Found format file: settings/dull_format.yaml
[class_pom_meta.py:332 -                  load_model_formats()] . Updated metadata: {'_defaults': {'is_abstract': False, 'field_value': '{field_name} COLON {field_value} NEWLINE', 'str': 'dull_str', 'int': 'dull_int', 'float': 'dull_float', 'bool': {'true': 'true', 'false': 'false', 'is_explicit': True}, 'list': '{element} (COMMA {element})*', 'dict': 'dull dict', 'set': "'{'{element} (','' {element})*'}'", 'tuple': " '[' {element} (','' {element})* ']'", 'field_clause': '{field_name}: {field_value}'}}
[class_pom_meta.py:330 -                  load_model_formats()] . Found format file: models/Lit_01/Lit_01_dull_format.yaml
[class_pom_meta.py:332 -                  load_model_formats()] . Updated metadata: {'_defaults': {'is_abstract': False, 'field_value': '{field_name} COLON {field_value} NEWLINE', 'str': 'dull_str', 'int': 'dull_int', 'float': 'dull_float', 'bool': {'true': 'true', 'false': 'false', 'is_explicit': True}, 'list': '{element} (COMMA {element})*', 'dict': 'dull dict', 'set': "'{'{element} (','' {element})*'}'", 'tuple': " '[' {element} (','' {element})* ']'", 'field_clause': '{field_name} ":"  {field_value}'}, 'Component': {'header': 'COMPONENT: {name}{? - {one_liner}} NEWLINE'}, 'Class': {'header': '_ {name}{? - {one_liner}} NEWLINE'}, 'Attribute': {'header': '-  {name}{? - {one_liner}}{? ({data_type_clause})} NEWLINE'}, 'BaseDataType': {'template': '{class_name} {? - {is_value}}'}, 'ListDataType': {'template': 'list of {element_type}'}, 'SetDataType': {'template': 'Set of {element_type}'}, 'MappingDataType': {'template': 'Mapping from {domain_type} to {range_type}'}, 'DataTypeClause': {'template': '{is_optional} {data_type}{? {cardinality}}'}}
Saved metadata to models/Lit_01/Lit_01_dull_y_external.yaml
## PomDict - External: 
# From YAML files:
##	Using built-in format: dull
## 	Using: settings/dull_format.yaml
## 	Using: models/Lit_01/Lit_01_dull_format.yaml
_defaults:
  is_abstract: false
  field_value: '{field_name} COLON {field_value} NEWLINE'
  str: dull_str
  int: dull_int
  float: dull_float
  bool:
    'true': 'true'
    'false': 'false'
    is_explicit: true
  list: '{element} (COMMA {element})*'
  dict: dull dict
  set: '''{''{element} ('','''' {element})*''}'''
  tuple: ' ''['' {element} ('','''' {element})* '']'''
  field_clause: '{field_name} ":"  {field_value}'
Component:
  header: 'COMPONENT: {name}{? - {one_liner}} NEWLINE'
Class:
  header: _ {name}{? - {one_liner}} NEWLINE
Attribute:
  header: '-  {name}{? - {one_liner}}{? ({data_type_clause})} NEWLINE'
BaseDataType:
  template: '{class_name} {? - {is_value}}'
ListDataType:
  template: list of {element_type}
SetDataType:
  template: Set of {element_type}
MappingDataType:
  template: Mapping from {domain_type} to {range_type}
DataTypeClause:
  template: '{is_optional} {data_type}{? {cardinality}}'

[pom_config.py:106 -                _load_default_config()] . Loading default configuration
[pom_config.py:110 -                _load_default_config()] . Looking for default config in settings/config.yaml
[pom_config.py:128 -             update_config_from_file()] . Updating config from file: settings/config.yaml
[pom_grammar.py:70 -                            __init__()] >  Returned None
Config is  {
  "lark": {
    "case_sensitive": false,
    "ambiguity": "resolve",
    "debug": false
  },
  "case_sensitive": false,
  "ambiguity": "resolve",
  "debug": true
}
[pom_grammar_generator.py:121 -                    generate_grammar()] Generating grammar for model module Lit_01.Lit_01
[pom_grammar_generator.py:126 -                 _find_model_classes()] <  Called by generate_grammar with args (<module 'Lit_01.Lit_01' from 'C:\\Users\\fmkat\\OneDrive\\AllFMKFIles\\AllVSCode\\FMKProjects\\Presentable\\models\\Lit_01\\Lit_01.py'>,) {}
[pom_grammar_generator.py:163 -                 _find_model_classes()] . Found model_imports = [<class 'class_casing.UpperCamel'>, <class 'class_casing.LowerCamel'>, <class 'class_casing.CamelCase'>, <class 'class_pom_token.IsOptional'>, <class 'class_pom_token.IsReallyRequired'>, <class 'class_pom_token.ReferenceOrValue'>, <class 'class_pom_token.MarkedText'>, <class 'class_pom_token.Emoji'>]
[pom_grammar_generator.py:166 -                 _find_model_classes()] . Import class names: ['UpperCamel', 'LowerCamel', 'CamelCase', 'IsOptional', 'IsReallyRequired', 'ReferenceOrValue', 'MarkedText', 'Emoji']
[pom_grammar_generator.py:126 -                 _find_model_classes()] >  Returned {'UpperCamel': <class 'class_casing.UpperCamel'>, 'LowerCamel': <class 'class_casing.LowerCamel'>, 'CamelCase': <class 'class_casing.CamelCase'>, 'IsOptional': <class 'class_pom_token.IsOptional'>, 'ReferenceOrValue': <class 'class_pom_token.ReferenceOrValue'>, 'IsReallyRequired': <class 'class_pom_token.IsReallyRequired'>, 'Emoji': <class 'class_pom_token.Emoji'>, 'Paragraph': <class 'Lit_01.Lit_01.Paragraph'>, 'OneLiner': <class 'Lit_01.Lit_01.OneLiner'>, 'ClassName': <class 'Lit_01.Lit_01.ClassName'>, 'Label': <class 'Lit_01.Lit_01.Label'>, 'Annotation': <class 'Lit_01.Lit_01.Annotation'>, 'Component': <class 'Lit_01.Lit_01.Component'>, 'SubjectE': <class 'Lit_01.Lit_01.SubjectE'>, 'SubjectD': <class 'Lit_01.Lit_01.SubjectD'>, 'SubjectC': <class 'Lit_01.Lit_01.SubjectC'>, 'SubjectB': <class 'Lit_01.Lit_01.SubjectB'>, 'LDM': <class 'Lit_01.Lit_01.LDM'>, 'DataType': <class 'Lit_01.Lit_01.DataType'>, 'BaseDataType': <class 'Lit_01.Lit_01.BaseDataType'>, 'ListDataType': <class 'Lit_01.Lit_01.ListDataType'>, 'SetDataType': <class 'Lit_01.Lit_01.SetDataType'>, 'MappingDataType': <class 'Lit_01.Lit_01.MappingDataType'>, 'DataTypeClause': <class 'Lit_01.Lit_01.DataTypeClause'>, 'FormulaCoding': <class 'Lit_01.Lit_01.FormulaCoding'>, 'Formula': <class 'Lit_01.Lit_01.Formula'>, 'Constraint': <class 'Lit_01.Lit_01.Constraint'>, 'Derivation': <class 'Lit_01.Lit_01.Derivation'>, 'Default': <class 'Lit_01.Lit_01.Default'>, 'Class': <class 'Lit_01.Lit_01.Class'>, 'ValueType': <class 'Lit_01.Lit_01.ValueType'>, 'ReferenceType': <class 'Lit_01.Lit_01.ReferenceType'>, 'AttributeSection': <class 'Lit_01.Lit_01.AttributeSection'>, 'Attribute': <class 'Lit_01.Lit_01.Attribute'>}
Saved metadata to models/Lit_01/Lit_01_dull_y_live.yaml
Saved metadata to models/Lit_01/Lit_01_dull_y_resolved.yaml
## PomDict - Resolved: 
## Resolved metadata from Live and External
# extracted from the Lit_01 model
# From YAML files:
##	Using built-in format: dull
## 	Using: settings/dull_format.yaml
## 	Using: models/Lit_01/Lit_01_dull_format.yaml
_defaults:
  field_value: '{field_name} COLON {field_value} NEWLINE'
  is_abstract: false
  str: dull_str
  int: dull_int
  float: dull_float
  bool:
    'true': 'true'
    'false': 'false'
    is_explicit: true
  list: '{element} (COMMA {element})*'
  dict: dull dict
  set: '''{''{element} ('','''' {element})*''}'''
  tuple: ' ''['' {element} ('','''' {element})* '']'''
  field_clause: '{field_name} ":"  {field_value}'
Paragraph:
  template: '{output}'
Annotation:
  template: '{?{emoji}}  {label}: {content} NEWLINE'
Component:
  is_abstract: true
  header: 'COMPONENT: {name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
SubjectE:
  header: '#####  {{name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
SubjectD:
  header: '####  {{name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
SubjectC:
  header: '###  {{name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
SubjectB:
  header: '##  {{name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
LDM:
  header: '#  {{name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
DataType:
  is_abstract: true
BaseDataType:
  template: '{class_name} {? - {is_value}}'
ListDataType:
  template: list of {element_type}
SetDataType:
  template: Set of {element_type}
MappingDataType:
  template: Mapping from {domain_type} to {range_type}
DataTypeClause:
  template: '{is_optional} {data_type}{? {cardinality}}'
  _fields:
    is_optional:
      bool:
        'true': optional
        'false': required
        is_explicit: false
Class:
  header: _ {name}{? - {one_liner}} NEWLINE
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
    attribute_sections:
      list: '{element}+'
      field_value: '{field_value}'
ValueType:
  header: '_  ValueType : {name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
    attribute_sections:
      list: '{element}+'
      field_value: '{field_value}'
ReferenceType:
  header: _ {name}{? - {one_liner}} NEWLINE
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
    attribute_sections:
      list: '{element}+'
      field_value: '{field_value}'
AttributeSection:
  header: '-  {name}{? - {one_liner}}{? ({is_required})} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
Attribute:
  header: '-  {name}{? - {one_liner}}{? ({data_type_clause})} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    constraints:
      list: '{element}+'
      field_value: '{field_value}'

[pom_grammar_generator.py:129 -             _derive_class_hierarchy()] <  Called by generate_grammar with args ({'UpperCamel': <class 'class_casing.UpperCamel'>, 'LowerCamel': <class 'class_casing.LowerCamel'>, 'CamelCase': <class 'class_casing.CamelCase'>, 'IsOptional': <class 'class_pom_token.IsOptional'>, 'ReferenceOrValue': <class 'class_pom_token.ReferenceOrValue'>, 'IsReallyRequired': <class 'class_pom_token.IsReallyRequired'>, 'Emoji': <class 'class_pom_token.Emoji'>, 'Paragraph': <class 'Lit_01.Lit_01.Paragraph'>, 'OneLiner': <class 'Lit_01.Lit_01.OneLiner'>, 'ClassName': <class 'Lit_01.Lit_01.ClassName'>, 'Label': <class 'Lit_01.Lit_01.Label'>, 'Annotation': <class 'Lit_01.Lit_01.Annotation'>, 'Component': <class 'Lit_01.Lit_01.Component'>, 'SubjectE': <class 'Lit_01.Lit_01.SubjectE'>, 'SubjectD': <class 'Lit_01.Lit_01.SubjectD'>, 'SubjectC': <class 'Lit_01.Lit_01.SubjectC'>, 'SubjectB': <class 'Lit_01.Lit_01.SubjectB'>, 'LDM': <class 'Lit_01.Lit_01.LDM'>, 'DataType': <class 'Lit_01.Lit_01.DataType'>, 'BaseDataType': <class 'Lit_01.Lit_01.BaseDataType'>, 'ListDataType': <class 'Lit_01.Lit_01.ListDataType'>, 'SetDataType': <class 'Lit_01.Lit_01.SetDataType'>, 'MappingDataType': <class 'Lit_01.Lit_01.MappingDataType'>, 'DataTypeClause': <class 'Lit_01.Lit_01.DataTypeClause'>, 'FormulaCoding': <class 'Lit_01.Lit_01.FormulaCoding'>, 'Formula': <class 'Lit_01.Lit_01.Formula'>, 'Constraint': <class 'Lit_01.Lit_01.Constraint'>, 'Derivation': <class 'Lit_01.Lit_01.Derivation'>, 'Default': <class 'Lit_01.Lit_01.Default'>, 'Class': <class 'Lit_01.Lit_01.Class'>, 'ValueType': <class 'Lit_01.Lit_01.ValueType'>, 'ReferenceType': <class 'Lit_01.Lit_01.ReferenceType'>, 'AttributeSection': <class 'Lit_01.Lit_01.AttributeSection'>, 'Attribute': <class 'Lit_01.Lit_01.Attribute'>},) {}
Class hierarchy is: {
  "UpperCamel": {
    "bases": [
      "CamelCase"
    ],
    "subtypes": [
      "ClassName",
      "Label"
    ],
    "depth": 2,
    "path": "CamelCase / UpperCamel"
  },
  "LowerCamel": {
    "bases": [
      "CamelCase"
    ],
    "depth": 2,
    "path": "CamelCase / LowerCamel"
  },
  "CamelCase": {
    "subtypes": [
      "UpperCamel",
      "LowerCamel"
    ],
    "depth": 1,
    "path": "CamelCase"
  },
  "IsOptional": {
    "depth": 1,
    "path": "IsOptional"
  },
  "ReferenceOrValue": {
    "depth": 1,
    "path": "ReferenceOrValue"
  },
  "IsReallyRequired": {
    "depth": 1,
    "path": "IsReallyRequired"
  },
  "Emoji": {
    "depth": 1,
    "path": "Emoji"
  },
  "Paragraph": {
    "depth": 1,
    "path": "Paragraph"
  },
  "OneLiner": {
    "depth": 1,
    "path": "OneLiner"
  },
  "ClassName": {
    "bases": [
      "UpperCamel"
    ],
    "depth": 3,
    "path": "CamelCase / UpperCamel / ClassName"
  },
  "Label": {
    "bases": [
      "UpperCamel"
    ],
    "depth": 3,
    "path": "CamelCase / UpperCamel / Label"
  },
  "Annotation": {
    "depth": 1,
    "path": "Annotation"
  },
  "Component": {
    "subtypes": [
      "SubjectE",
      "Class",
      "AttributeSection",
      "Attribute"
    ],
    "depth": 1,
    "path": "Component"
  },
  "SubjectE": {
    "bases": [
      "Component"
    ],
    "subtypes": [
      "SubjectD"
    ],
    "depth": 2,
    "path": "Component / SubjectE"
  },
  "SubjectD": {
    "bases": [
      "SubjectE"
    ],
    "subtypes": [
      "SubjectC"
    ],
    "depth": 3,
    "path": "Component / SubjectE / SubjectD"
  },
  "SubjectC": {
    "bases": [
      "SubjectD"
    ],
    "subtypes": [
      "SubjectB"
    ],
    "depth": 4,
    "path": "Component / SubjectE / SubjectD / SubjectC"
  },
  "SubjectB": {
    "bases": [
      "SubjectC"
    ],
    "subtypes": [
      "LDM"
    ],
    "depth": 5,
    "path": "Component / SubjectE / SubjectD / SubjectC / SubjectB"
  },
  "LDM": {
    "bases": [
      "SubjectB"
    ],
    "depth": 6,
    "path": "Component / SubjectE / SubjectD / SubjectC / SubjectB / LDM"
  },
  "DataType": {
    "subtypes": [
      "BaseDataType",
      "ListDataType",
      "SetDataType",
      "MappingDataType"
    ],
    "depth": 1,
    "path": "DataType"
  },
  "BaseDataType": {
    "bases": [
      "DataType"
    ],
    "depth": 2,
    "path": "DataType / BaseDataType"
  },
  "ListDataType": {
    "bases": [
      "DataType"
    ],
    "depth": 2,
    "path": "DataType / ListDataType"
  },
  "SetDataType": {
    "bases": [
      "DataType"
    ],
    "depth": 2,
    "path": "DataType / SetDataType"
  },
  "MappingDataType": {
    "bases": [
      "DataType"
    ],
    "depth": 2,
    "path": "DataType / MappingDataType"
  },
  "DataTypeClause": {
    "depth": 1,
    "path": "DataTypeClause"
  },
  "FormulaCoding": {
    "depth": 1,
    "path": "FormulaCoding"
  },
  "Formula": {
    "subtypes": [
      "Constraint",
      "Derivation",
      "Default"
    ],
    "depth": 1,
    "path": "Formula"
  },
  "Constraint": {
    "bases": [
      "Formula"
    ],
    "depth": 2,
    "path": "Formula / Constraint"
  },
  "Derivation": {
    "bases": [
      "Formula"
    ],
    "depth": 2,
    "path": "Formula / Derivation"
  },
  "Default": {
    "bases": [
      "Formula"
    ],
    "depth": 2,
    "path": "Formula / Default"
  },
  "Class": {
    "bases": [
      "Component"
    ],
    "subtypes": [
      "ValueType",
      "ReferenceType"
    ],
    "depth": 2,
    "path": "Component / Class"
  },
  "ValueType": {
    "bases": [
      "Class"
    ],
    "depth": 3,
    "path": "Component / Class / ValueType"
  },
  "ReferenceType": {
    "bases": [
      "Class"
    ],
    "depth": 3,
    "path": "Component / Class / ReferenceType"
  },
  "AttributeSection": {
    "bases": [
      "Component"
    ],
    "depth": 2,
    "path": "Component / AttributeSection"
  },
  "Attribute": {
    "bases": [
      "Component"
    ],
    "depth": 2,
    "path": "Component / Attribute"
  }
}
{'UpperCamel': 'CamelCase / UpperCamel', 'LowerCamel': 'CamelCase / LowerCamel', 'CamelCase': 'CamelCase', 'IsOptional': 'IsOptional', 'ReferenceOrValue': 'ReferenceOrValue', 'IsReallyRequired': 'IsReallyRequired', 'Emoji': 'Emoji', 'Paragraph': 'Paragraph', 'OneLiner': 'OneLiner', 'ClassName': 'CamelCase / UpperCamel / ClassName', 'Label': 'CamelCase / UpperCamel / Label', 'Annotation': 'Annotation', 'Component': 'Component', 'SubjectE': 'Component / SubjectE', 'SubjectD': 'Component / SubjectE / SubjectD', 'SubjectC': 'Component / SubjectE / SubjectD / SubjectC', 'SubjectB': 'Component / SubjectE / SubjectD / SubjectC / SubjectB', 'LDM': 'Component / SubjectE / SubjectD / SubjectC / SubjectB / LDM', 'DataType': 'DataType', 'BaseDataType': 'DataType / BaseDataType', 'ListDataType': 'DataType / ListDataType', 'SetDataType': 'DataType / SetDataType', 'MappingDataType': 'DataType / MappingDataType', 'DataTypeClause': 'DataTypeClause', 'FormulaCoding': 'FormulaCoding', 'Formula': 'Formula', 'Constraint': 'Formula / Constraint', 'Derivation': 'Formula / Derivation', 'Default': 'Formula / Default', 'Class': 'Component / Class', 'ValueType': 'Component / Class / ValueType', 'ReferenceType': 'Component / Class / ReferenceType', 'AttributeSection': 'Component / AttributeSection', 'Attribute': 'Component / Attribute'}
['Annotation', 'CamelCase', 'LowerCamel', 'UpperCamel', 'ClassName', 'Label', 'Component', 'Attribute', 'AttributeSection', 'Class', 'ReferenceType', 'ValueType', 'SubjectE', 'SubjectD', 'SubjectC', 'SubjectB', 'LDM', 'DataType', 'BaseDataType', 'ListDataType', 'MappingDataType', 'SetDataType', 'DataTypeClause', 'Emoji', 'Formula', 'Constraint', 'Default', 'Derivation', 'FormulaCoding', 'IsOptional', 'IsReallyRequired', 'OneLiner', 'Paragraph', 'ReferenceOrValue']
[pom_grammar_generator.py:129 -             _derive_class_hierarchy()] >  Returned {'UpperCamel': {'class': <class 'class_casing.UpperCamel'>, 'bases': ['CamelCase'], 'subtypes': ['ClassName', 'Label'], 'attributes': {}, 'depth': 2, 'path': 'CamelCase / UpperCamel'}, 'LowerCamel': {'class': <class 'class_casing.LowerCamel'>, 'bases': ['CamelCase'], 'subtypes': [], 'attributes': {}, 'depth': 2, 'path': 'CamelCase / LowerCamel'}, 'CamelCase': {'class': <class 'class_casing.CamelCase'>, 'bases': [], 'subtypes': ['UpperCamel', 'LowerCamel'], 'attributes': {}, 'depth': 1, 'path': 'CamelCase'}, 'IsOptional': {'class': <class 'class_pom_token.IsOptional'>, 'bases': [], 'subtypes': [], 'attributes': {}, 'depth': 1, 'path': 'IsOptional'}, 'ReferenceOrValue': {'class': <class 'class_pom_token.ReferenceOrValue'>, 'bases': [], 'subtypes': [], 'attributes': {}, 'depth': 1, 'path': 'ReferenceOrValue'}, 'IsReallyRequired': {'class': <class 'class_pom_token.IsReallyRequired'>, 'bases': [], 'subtypes': [], 'attributes': {}, 'depth': 1, 'path': 'IsReallyRequired'}, 'Emoji': {'class': <class 'class_pom_token.Emoji'>, 'bases': [], 'subtypes': [], 'attributes': {}, 'depth': 1, 'path': 'Emoji'}, 'Paragraph': {'class': <class 'Lit_01.Lit_01.Paragraph'>, 'bases': [], 'subtypes': [], 'attributes': {}, 'depth': 1, 'path': 'Paragraph'}, 'OneLiner': {'class': <class 'Lit_01.Lit_01.OneLiner'>, 'bases': [], 'subtypes': [], 'attributes': {}, 'depth': 1, 'path': 'OneLiner'}, 'ClassName': {'class': <class 'Lit_01.Lit_01.ClassName'>, 'bases': ['UpperCamel'], 'subtypes': [], 'attributes': {}, 'depth': 3, 'path': 'CamelCase / UpperCamel / ClassName'}, 'Label': {'class': <class 'Lit_01.Lit_01.Label'>, 'bases': ['UpperCamel'], 'subtypes': [], 'attributes': {}, 'depth': 3, 'path': 'CamelCase / UpperCamel / Label'}, 'Annotation': {'class': <class 'Lit_01.Lit_01.Annotation'>, 'bases': [], 'subtypes': [], 'attributes': {}, 'depth': 1, 'path': 'Annotation'}, 'Component': {'class': <class 'Lit_01.Lit_01.Component'>, 'bases': [], 'subtypes': ['SubjectE', 'Class', 'AttributeSection', 'Attribute'], 'attributes': {}, 'depth': 1, 'path': 'Component'}, 'SubjectE': {'class': <class 'Lit_01.Lit_01.SubjectE'>, 'bases': ['Component'], 'subtypes': ['SubjectD'], 'attributes': {}, 'depth': 2, 'path': 'Component / SubjectE'}, 'SubjectD': {'class': <class 'Lit_01.Lit_01.SubjectD'>, 'bases': ['SubjectE'], 'subtypes': ['SubjectC'], 'attributes': {}, 'depth': 3, 'path': 'Component / SubjectE / SubjectD'}, 'SubjectC': {'class': <class 'Lit_01.Lit_01.SubjectC'>, 'bases': ['SubjectD'], 'subtypes': ['SubjectB'], 'attributes': {}, 'depth': 4, 'path': 'Component / SubjectE / SubjectD / SubjectC'}, 'SubjectB': {'class': <class 'Lit_01.Lit_01.SubjectB'>, 'bases': ['SubjectC'], 'subtypes': ['LDM'], 'attributes': {}, 'depth': 5, 'path': 'Component / SubjectE / SubjectD / SubjectC / SubjectB'}, 'LDM': {'class': <class 'Lit_01.Lit_01.LDM'>, 'bases': ['SubjectB'], 'subtypes': [], 'attributes': {}, 'depth': 6, 'path': 'Component / SubjectE / SubjectD / SubjectC / SubjectB / LDM'}, 'DataType': {'class': <class 'Lit_01.Lit_01.DataType'>, 'bases': [], 'subtypes': ['BaseDataType', 'ListDataType', 'SetDataType', 'MappingDataType'], 'attributes': {}, 'depth': 1, 'path': 'DataType'}, 'BaseDataType': {'class': <class 'Lit_01.Lit_01.BaseDataType'>, 'bases': ['DataType'], 'subtypes': [], 'attributes': {}, 'depth': 2, 'path': 'DataType / BaseDataType'}, 'ListDataType': {'class': <class 'Lit_01.Lit_01.ListDataType'>, 'bases': ['DataType'], 'subtypes': [], 'attributes': {}, 'depth': 2, 'path': 'DataType / ListDataType'}, 'SetDataType': {'class': <class 'Lit_01.Lit_01.SetDataType'>, 'bases': ['DataType'], 'subtypes': [], 'attributes': {}, 'depth': 2, 'path': 'DataType / SetDataType'}, 'MappingDataType': {'class': <class 'Lit_01.Lit_01.MappingDataType'>, 'bases': ['DataType'], 'subtypes': [], 'attributes': {}, 'depth': 2, 'path': 'DataType / MappingDataType'}, 'DataTypeClause': {'class': <class 'Lit_01.Lit_01.DataTypeClause'>, 'bases': [], 'subtypes': [], 'attributes': {}, 'depth': 1, 'path': 'DataTypeClause'}, 'FormulaCoding': {'class': <class 'Lit_01.Lit_01.FormulaCoding'>, 'bases': [], 'subtypes': [], 'attributes': {}, 'depth': 1, 'path': 'FormulaCoding'}, 'Formula': {'class': <class 'Lit_01.Lit_01.Formula'>, 'bases': [], 'subtypes': ['Constraint', 'Derivation', 'Default'], 'attributes': {}, 'depth': 1, 'path': 'Formula'}, 'Constraint': {'class': <class 'Lit_01.Lit_01.Constraint'>, 'bases': ['Formula'], 'subtypes': [], 'attributes': {}, 'depth': 2, 'path': 'Formula / Constraint'}, 'Derivation': {'class': <class 'Lit_01.Lit_01.Derivation'>, 'bases': ['Formula'], 'subtypes': [], 'attributes': {}, 'depth': 2, 'path': 'Formula / Derivation'}, 'Default': {'class': <class 'Lit_01.Lit_01.Default'>, 'bases': ['Formula'], 'subtypes': [], 'attributes': {}, 'depth': 2, 'path': 'Formula / Default'}, 'Class': {'class': <class 'Lit_01.Lit_01.Class'>, 'bases': ['Component'], 'subtypes': ['ValueType', 'ReferenceType'], 'attributes': {}, 'depth': 2, 'path': 'Component / Class'}, 'ValueType': {'class': <class 'Lit_01.Lit_01.ValueType'>, 'bases': ['Class'], 'subtypes': [], 'attributes': {}, 'depth': 3, 'path': 'Component / Class / ValueType'}, 'ReferenceType': {'class': <class 'Lit_01.Lit_01.ReferenceType'>, 'bases': ['Class'], 'subtypes': [], 'attributes': {}, 'depth': 3, 'path': 'Component / Class / ReferenceType'}, 'AttributeSection': {'class': <class 'Lit_01.Lit_01.AttributeSection'>, 'bases': ['Component'], 'subtypes': [], 'attributes': {}, 'depth': 2, 'path': 'Component / AttributeSection'}, 'Attribute': {'class': <class 'Lit_01.Lit_01.Attribute'>, 'bases': ['Component'], 'subtypes': [], 'attributes': {}, 'depth': 2, 'path': 'Component / Attribute'}}
Starting class rules
## PomDict - Resolved: 
## Resolved metadata from Live and External
# extracted from the Lit_01 model
# From YAML files:
##	Using built-in format: dull
## 	Using: settings/dull_format.yaml
## 	Using: models/Lit_01/Lit_01_dull_format.yaml
_defaults:
  field_value: '{field_name} COLON {field_value} NEWLINE'
  is_abstract: false
  str: dull_str
  int: dull_int
  float: dull_float
  bool:
    'true': 'true'
    'false': 'false'
    is_explicit: true
  list: '{element} (COMMA {element})*'
  dict: dull dict
  set: '''{''{element} ('','''' {element})*''}'''
  tuple: ' ''['' {element} ('','''' {element})* '']'''
  field_clause: '{field_name} ":"  {field_value}'
Paragraph:
  template: '{output}'
Annotation:
  template: '{?{emoji}}  {label}: {content} NEWLINE'
Component:
  is_abstract: true
  header: 'COMPONENT: {name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
SubjectE:
  header: '#####  {{name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
SubjectD:
  header: '####  {{name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
SubjectC:
  header: '###  {{name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
SubjectB:
  header: '##  {{name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
LDM:
  header: '#  {{name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    classes:
      list: '{element}+'
      field_value: '{field_value}'
    subjects:
      list: '{element}+'
      field_value: '{field_value}'
DataType:
  is_abstract: true
BaseDataType:
  template: '{class_name} {? - {is_value}}'
ListDataType:
  template: list of {element_type}
SetDataType:
  template: Set of {element_type}
MappingDataType:
  template: Mapping from {domain_type} to {range_type}
DataTypeClause:
  template: '{is_optional} {data_type}{? {cardinality}}'
  _fields:
    is_optional:
      bool:
        'true': optional
        'false': required
        is_explicit: false
Class:
  header: _ {name}{? - {one_liner}} NEWLINE
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
    attribute_sections:
      list: '{element}+'
      field_value: '{field_value}'
ValueType:
  header: '_  ValueType : {name}{? - {one_liner}} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
    attribute_sections:
      list: '{element}+'
      field_value: '{field_value}'
ReferenceType:
  header: _ {name}{? - {one_liner}} NEWLINE
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
    attribute_sections:
      list: '{element}+'
      field_value: '{field_value}'
AttributeSection:
  header: '-  {name}{? - {one_liner}}{? ({is_required})} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    attributes:
      list: '{element}+'
      field_value: '{field_value}'
Attribute:
  header: '-  {name}{? - {one_liner}}{? ({data_type_clause})} NEWLINE'
  _fields:
    elaboration:
      list: '{element}+'
      field_value: '{field_value}'
    annotations:
      list: '{element}+'
      field_value: '{field_value}'
    constraints:
      list: '{element}+'
      field_value: '{field_value}'

[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'Annotation', <class 'Lit_01.Lit_01.Annotation'>) {}
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . <  Called by _gen_rules_for_class with args ('Annotation',) {}
[pom_grammar_generator.py:844 -     _generate_type_hierarchy_clause()] . . subtypes of Annotation are []
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . >  Returned None
[pom_grammar_generator.py:469 -                _gen_rules_for_class()] . Class Annotation is not abstract, generating own rule with clauses
[pom_grammar_generator.py:478 -                      _assess_fields()] . <  Called by _gen_rules_for_class with args (<class 'Lit_01.Lit_01.Annotation'>,) {}
[pom_grammar_generator.py:734 -                      _assess_fields()] . . Assessed: <class 'Lit_01.Lit_01.Annotation'>...
[pom_grammar_generator.py:735 -                      _assess_fields()] . . ... New fields for <class 'Lit_01.Lit_01.Annotation'> are {'emoji', 'content', 'label', '_type'}
[pom_grammar_generator.py:736 -                      _assess_fields()] . . ... Redefined fields for <class 'Lit_01.Lit_01.Annotation'> are set()
[pom_grammar_generator.py:737 -                      _assess_fields()] . . ... Inherited fields for <class 'Lit_01.Lit_01.Annotation'> are set()
[pom_grammar_generator.py:738 -                      _assess_fields()] . . ... Inherits from for <class 'Lit_01.Lit_01.Annotation'> are set()
[pom_grammar_generator.py:478 -                      _assess_fields()] . >  Returned ({'emoji', 'content', 'label', '_type'}, set(), set(), set())
[pom_grammar_generator.py:485 -                _gen_rules_for_class()] . Full template is {?{emoji}}  {label}: {content} NEWLINE
[pom_grammar_generator.py:486 -         _gen_full_class_by_template()] . <  Called by _gen_rules_for_class with args ('Annotation', PomTemplate({?{emoji}}  {label}: {content} NEWLINE)) {}
[pom_grammar_generator.py:486 -         _gen_full_class_by_template()] . >  Returned [ annotation__emoji__value ] annotation__label__value COLON annotation__content__value NEWLINE
[pom_grammar_generator.py:487 -                         find_fields()] . <  Called by _gen_rules_for_class with args () {}
[pom_grammar_generator.py:487 -                         find_fields()] . >  Returned {'emoji', 'label', 'content'}
Adding rule2:  AbstractNTRule()
for Annotation to [ annotation__emoji__value ] annotation__label__value COLON annotation__content__value NEWLINE
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . <  Called by _gen_rules_for_class with args ('Annotation', <class 'Lit_01.Lit_01.Annotation'>, {'emoji', 'label', 'content'}) {}
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is Label
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.Label'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned LABEL
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is OneLiner
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.OneLiner'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned ONE_LINER
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is Emoji
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'class_pom_token.Emoji'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned EMOJI
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . >  Returned [AbstractRule(), AbstractRule(), AbstractRule()]
Value rule is: annotation__label__value: LABEL
... added as annotation__label__value: LABEL
Value rule is: annotation__content__value: ONE_LINER
... added as annotation__content__value: ONE_LINER
Value rule is: annotation__emoji__value: EMOJI
... added as annotation__emoji__value: EMOJI
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'CamelCase', <class 'class_casing.CamelCase'>) {}
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'LowerCamel', <class 'class_casing.LowerCamel'>) {}
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'UpperCamel', <class 'class_casing.UpperCamel'>) {}
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'ClassName', <class 'Lit_01.Lit_01.ClassName'>) {}
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'Label', <class 'Lit_01.Lit_01.Label'>) {}
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'Component', <class 'Lit_01.Lit_01.Component'>) {}
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . <  Called by _gen_rules_for_class with args ('Component',) {}
[pom_grammar_generator.py:844 -     _generate_type_hierarchy_clause()] . . subtypes of Component are ['SubjectE', 'Class', 'AttributeSection', 'Attribute']
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . >  Returned subject_e | class | attribute_section | attribute
[pom_grammar_generator.py:469 -                _gen_rules_for_class()] . Class Component is not abstract, generating own rule with clauses
[pom_grammar_generator.py:478 -                      _assess_fields()] . <  Called by _gen_rules_for_class with args (<class 'Lit_01.Lit_01.Component'>,) {}
[pom_grammar_generator.py:734 -                      _assess_fields()] . . Assessed: <class 'Lit_01.Lit_01.Component'>...
[pom_grammar_generator.py:735 -                      _assess_fields()] . . ... New fields for <class 'Lit_01.Lit_01.Component'> are {'one_liner', 'elaboration', 'name', '_type', 'annotations', 'abbreviation'}
[pom_grammar_generator.py:736 -                      _assess_fields()] . . ... Redefined fields for <class 'Lit_01.Lit_01.Component'> are set()
[pom_grammar_generator.py:737 -                      _assess_fields()] . . ... Inherited fields for <class 'Lit_01.Lit_01.Component'> are set()
[pom_grammar_generator.py:738 -                      _assess_fields()] . . ... Inherits from for <class 'Lit_01.Lit_01.Component'> are set()
[pom_grammar_generator.py:478 -                      _assess_fields()] . >  Returned ({'one_liner', 'elaboration', 'name', '_type', 'annotations', 'abbreviation'}, set(), set(), set())
[pom_grammar_generator.py:496 -                _gen_rules_for_class()] . Header template is COMPONENT: {name}{? - {one_liner}} NEWLINE
[pom_grammar_generator.py:500 -                _gen_rules_for_class()] . Header clause is COMPONENT_Q COLON component__name__value [ DASH component__one_liner__value ] NEWLINE
[pom_grammar_generator.py:505 -                         find_fields()] . <  Called by _gen_rules_for_class with args () {}
[pom_grammar_generator.py:505 -                         find_fields()] . >  Returned {'name', 'one_liner'}
Adding rule2:  AbstractNTRule()
for component_header to COMPONENT_Q COLON component__name__value [ DASH component__one_liner__value ] NEWLINE
[pom_grammar_generator.py:509 -                _gen_rules_for_class()] . Header clause is: COMPONENT_Q COLON component__name__value [ DASH component__one_liner__value ] NEWLINE
RHS is  'COMPONENT_Q COLON component__name__value [ DASH component__one_liner__value ] NEWLINE'
[pom_grammar_generator.py:510 -                _gen_rules_for_class()] . Header rule is: component_header: COMPONENT_Q COLON component__name__value [ DASH component__one_liner__value ] NEWLINE
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . <  Called by _gen_rules_for_class with args ('Component', <class 'Lit_01.Lit_01.Component'>, set()) {}
[pom_grammar_generator.py:780 -                        value_phrase()] . . <  Called by _generate_field_clause with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is CamelCase
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'class_casing.CamelCase'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:780 -                        value_phrase()] . . >  Returned CAMEL_CASE
[pom_grammar_generator.py:780 -                        value_phrase()] . . <  Called by _generate_field_clause with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is OneLiner
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.OneLiner'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:780 -                        value_phrase()] . . >  Returned ONE_LINER
[pom_grammar_generator.py:780 -                        value_phrase()] . . <  Called by _generate_field_clause with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is UpperCamel
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'class_casing.UpperCamel'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:780 -                        value_phrase()] . . >  Returned UPPER_CAMEL
[class_field_type.py:328 -                        value_phrase()] . . <  Called by value_phrase with args ({'list': '{element}+', 'field_value': '{field_value}'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is Paragraph
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.Paragraph'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[class_field_type.py:328 -                        value_phrase()] . . >  Returned PARAGRAPH
[class_field_type.py:328 -                        value_phrase()] . . <  Called by value_phrase with args ({'list': '{element}+', 'field_value': '{field_value}'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is Annotation
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.Annotation'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned False
[class_field_type.py:328 -                        value_phrase()] . . >  Returned annotation
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . >  Returned [AbstractClause(clause_text='NAME_QF COLON CAMEL_CASE NEWLINE', node_name='component__name__simple', full_text='NAME_QF COLON CAMEL_CASE NEWLINE -> component__name__simple'), AbstractClause(clause_text='ONE_LINER_QF COLON ONE_LINER NEWLINE', node_name='component__one_liner__simple', full_text='ONE_LINER_QF COLON ONE_LINER NEWLINE -> component__one_liner__simple'), AbstractClause(clause_text='ABBREVIATION_QF COLON UPPER_CAMEL NEWLINE', node_name='component__abbreviation__simple', full_text='ABBREVIATION_QF COLON UPPER_CAMEL NEWLINE -> component__abbreviation__simple'), AbstractClause(clause_text='PARAGRAPH+', node_name='component__elaboration__list', full_text='PARAGRAPH+ -> component__elaboration__list'), AbstractClause(clause_text='annotation+', node_name='component__annotations__list', full_text='annotation+ -> component__annotations__list')]
[pom_grammar_generator.py:521 -                _gen_rules_for_class()] . Field clauses for Component are [AbstractClause(clause_text='NAME_QF COLON CAMEL_CASE NEWLINE', node_name='component__name__simple', full_text='NAME_QF COLON CAMEL_CASE NEWLINE -> component__name__simple'), AbstractClause(clause_text='ONE_LINER_QF COLON ONE_LINER NEWLINE', node_name='component__one_liner__simple', full_text='ONE_LINER_QF COLON ONE_LINER NEWLINE -> component__one_liner__simple'), AbstractClause(clause_text='ABBREVIATION_QF COLON UPPER_CAMEL NEWLINE', node_name='component__abbreviation__simple', full_text='ABBREVIATION_QF COLON UPPER_CAMEL NEWLINE -> component__abbreviation__simple'), AbstractClause(clause_text='PARAGRAPH+', node_name='component__elaboration__list', full_text='PARAGRAPH+ -> component__elaboration__list'), AbstractClause(clause_text='annotation+', node_name='component__annotations__list', full_text='annotation+ -> component__annotations__list')]
body_clause is  AbstractDisjunction(clause_text='', node_name='', full_text='NAME_QF COLON CAMEL_CASE NEWLINE -> component__name__simple\n\t\t|\tONE_LINER_QF COLON ONE_LINER NEWLINE -> component__one_liner__simple\n\t\t|\tABBREVIATION_QF COLON UPPER_CAMEL NEWLINE -> component__abbreviation__simple\n\t\t|\tPARAGRAPH+ -> component__elaboration__list\n\t\t|\tannotation+ -> component__annotations__list', disjuncts=[AbstractClause(clause_text='NAME_QF COLON CAMEL_CASE NEWLINE', node_name='component__name__simple', full_text='NAME_QF COLON CAMEL_CASE NEWLINE -> component__name__simple'), AbstractClause(clause_text='ONE_LINER_QF COLON ONE_LINER NEWLINE', node_name='component__one_liner__simple', full_text='ONE_LINER_QF COLON ONE_LINER NEWLINE -> component__one_liner__simple'), AbstractClause(clause_text='ABBREVIATION_QF COLON UPPER_CAMEL NEWLINE', node_name='component__abbreviation__simple', full_text='ABBREVIATION_QF COLON UPPER_CAMEL NEWLINE -> component__abbreviation__simple'), AbstractClause(clause_text='PARAGRAPH+', node_name='component__elaboration__list', full_text='PARAGRAPH+ -> component__elaboration__list'), AbstractClause(clause_text='annotation+', node_name='component__annotations__list', full_text='annotation+ -> component__annotations__list')])
Adding rule2:  AbstractNTRule()
for component_clause to NAME_QF COLON CAMEL_CASE NEWLINE -> component__name__simple
		|	ONE_LINER_QF COLON ONE_LINER NEWLINE -> component__one_liner__simple
		|	ABBREVIATION_QF COLON UPPER_CAMEL NEWLINE -> component__abbreviation__simple
		|	PARAGRAPH+ -> component__elaboration__list
		|	annotation+ -> component__annotations__list
Adding rule2:  AbstractNTRule()
for Component to subject_e | class | attribute_section | attribute
		|	component_header  (component_clause)*
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . <  Called by _gen_rules_for_class with args ('Component', <class 'Lit_01.Lit_01.Component'>, {'name', 'one_liner'}) {}
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is CamelCase
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'class_casing.CamelCase'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned CAMEL_CASE
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is OneLiner
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.OneLiner'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned ONE_LINER
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . >  Returned [AbstractRule(), AbstractRule()]
Value rule is: component__name__value: CAMEL_CASE
... added as component__name__value: CAMEL_CASE
Value rule is: component__one_liner__value: ONE_LINER
... added as component__one_liner__value: ONE_LINER
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'Attribute', <class 'Lit_01.Lit_01.Attribute'>) {}
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . <  Called by _gen_rules_for_class with args ('Attribute',) {}
[pom_grammar_generator.py:844 -     _generate_type_hierarchy_clause()] . . subtypes of Attribute are []
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . >  Returned None
[pom_grammar_generator.py:469 -                _gen_rules_for_class()] . Class Attribute is not abstract, generating own rule with clauses
[pom_grammar_generator.py:478 -                      _assess_fields()] . <  Called by _gen_rules_for_class with args (<class 'Lit_01.Lit_01.Attribute'>,) {}
[pom_grammar_generator.py:734 -                      _assess_fields()] . . Assessed: <class 'Lit_01.Lit_01.Attribute'>...
[pom_grammar_generator.py:735 -                      _assess_fields()] . . ... New fields for <class 'Lit_01.Lit_01.Attribute'> are {'constraints', 'data_type_clause', 'default', 'derivation'}
[pom_grammar_generator.py:736 -                      _assess_fields()] . . ... Redefined fields for <class 'Lit_01.Lit_01.Attribute'> are {'name'}
[pom_grammar_generator.py:737 -                      _assess_fields()] . . ... Inherited fields for <class 'Lit_01.Lit_01.Attribute'> are {'one_liner', 'elaboration', '_type', 'annotations', 'abbreviation'}
[pom_grammar_generator.py:738 -                      _assess_fields()] . . ... Inherits from for <class 'Lit_01.Lit_01.Attribute'> are {'Component'}
[pom_grammar_generator.py:478 -                      _assess_fields()] . >  Returned ({'constraints', 'data_type_clause', 'default', 'derivation'}, {'name'}, {'one_liner', 'elaboration', '_type', 'annotations', 'abbreviation'}, {'Component'})
[pom_grammar_generator.py:496 -                _gen_rules_for_class()] . Header template is -  {name}{? - {one_liner}}{? ({data_type_clause})} NEWLINE
[pom_grammar_generator.py:500 -                _gen_rules_for_class()] . Header clause is DASH attribute__name__value [ DASH attribute__one_liner__value ] [ LPAREN attribute__data_type_clause__value RPAREN ] NEWLINE
[pom_grammar_generator.py:505 -                         find_fields()] . <  Called by _gen_rules_for_class with args () {}
[pom_grammar_generator.py:505 -                         find_fields()] . >  Returned {'data_type_clause', 'name', 'one_liner'}
Adding rule2:  AbstractNTRule()
for attribute_header to DASH attribute__name__value [ DASH attribute__one_liner__value ] [ LPAREN attribute__data_type_clause__value RPAREN ] NEWLINE
[pom_grammar_generator.py:509 -                _gen_rules_for_class()] . Header clause is: DASH attribute__name__value [ DASH attribute__one_liner__value ] [ LPAREN attribute__data_type_clause__value RPAREN ] NEWLINE
RHS is  'DASH attribute__name__value [ DASH attribute__one_liner__value ] [ LPAREN attribute__data_type_clause__value RPAREN ] NEWLINE'
[pom_grammar_generator.py:510 -                _gen_rules_for_class()] . Header rule is: attribute_header: DASH attribute__name__value [ DASH attribute__one_liner__value ] [ LPAREN attribute__data_type_clause__value RPAREN ] NEWLINE
[pom_grammar_generator.py:517 -                _gen_rules_for_class()] . Ancestor clauses for Attribute are [AbstractClause(clause_text='component_clause', node_name='', full_text='component_clause')]
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . <  Called by _gen_rules_for_class with args ('Attribute', <class 'Lit_01.Lit_01.Attribute'>, {'one_liner', 'elaboration', '_type', 'annotations', 'abbreviation'}) {}
[pom_grammar_generator.py:780 -                        value_phrase()] . . <  Called by _generate_field_clause with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is LowerCamel
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'class_casing.LowerCamel'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:780 -                        value_phrase()] . . >  Returned LOWER_CAMEL
[pom_grammar_generator.py:780 -                        value_phrase()] . . <  Called by _generate_field_clause with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is DataTypeClause
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.DataTypeClause'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned False
[pom_grammar_generator.py:780 -                        value_phrase()] . . >  Returned data_type_clause
[pom_grammar_generator.py:780 -                        value_phrase()] . . <  Called by _generate_field_clause with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is Derivation
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.Derivation'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned False
[pom_grammar_generator.py:780 -                        value_phrase()] . . >  Returned derivation
[pom_grammar_generator.py:780 -                        value_phrase()] . . <  Called by _generate_field_clause with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is Default
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.Default'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned False
[pom_grammar_generator.py:780 -                        value_phrase()] . . >  Returned default
[class_field_type.py:328 -                        value_phrase()] . . <  Called by value_phrase with args ({'list': '{element}+', 'field_value': '{field_value}'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is Constraint
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.Constraint'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned False
[class_field_type.py:328 -                        value_phrase()] . . >  Returned constraint
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . >  Returned [AbstractClause(clause_text='NAME_QF COLON LOWER_CAMEL NEWLINE', node_name='attribute__name__simple', full_text='NAME_QF COLON LOWER_CAMEL NEWLINE -> attribute__name__simple'), AbstractClause(clause_text='DATA_TYPE_CLAUSE_QF COLON data_type_clause NEWLINE', node_name='attribute__data_type_clause__simple', full_text='DATA_TYPE_CLAUSE_QF COLON data_type_clause NEWLINE -> attribute__data_type_clause__simple'), AbstractClause(clause_text='DERIVATION_QF COLON derivation NEWLINE', node_name='attribute__derivation__simple', full_text='DERIVATION_QF COLON derivation NEWLINE -> attribute__derivation__simple'), AbstractClause(clause_text='DEFAULT_QF COLON default NEWLINE', node_name='attribute__default__simple', full_text='DEFAULT_QF COLON default NEWLINE -> attribute__default__simple'), AbstractClause(clause_text='constraint+', node_name='attribute__constraints__list', full_text='constraint+ -> attribute__constraints__list')]
[pom_grammar_generator.py:521 -                _gen_rules_for_class()] . Field clauses for Attribute are [AbstractClause(clause_text='NAME_QF COLON LOWER_CAMEL NEWLINE', node_name='attribute__name__simple', full_text='NAME_QF COLON LOWER_CAMEL NEWLINE -> attribute__name__simple'), AbstractClause(clause_text='DATA_TYPE_CLAUSE_QF COLON data_type_clause NEWLINE', node_name='attribute__data_type_clause__simple', full_text='DATA_TYPE_CLAUSE_QF COLON data_type_clause NEWLINE -> attribute__data_type_clause__simple'), AbstractClause(clause_text='DERIVATION_QF COLON derivation NEWLINE', node_name='attribute__derivation__simple', full_text='DERIVATION_QF COLON derivation NEWLINE -> attribute__derivation__simple'), AbstractClause(clause_text='DEFAULT_QF COLON default NEWLINE', node_name='attribute__default__simple', full_text='DEFAULT_QF COLON default NEWLINE -> attribute__default__simple'), AbstractClause(clause_text='constraint+', node_name='attribute__constraints__list', full_text='constraint+ -> attribute__constraints__list')]
body_clause is  AbstractDisjunction(clause_text='', node_name='', full_text='component_clause\n\t\t|\tNAME_QF COLON LOWER_CAMEL NEWLINE -> attribute__name__simple\n\t\t|\tDATA_TYPE_CLAUSE_QF COLON data_type_clause NEWLINE -> attribute__data_type_clause__simple\n\t\t|\tDERIVATION_QF COLON derivation NEWLINE -> attribute__derivation__simple\n\t\t|\tDEFAULT_QF COLON default NEWLINE -> attribute__default__simple\n\t\t|\tconstraint+ -> attribute__constraints__list', disjuncts=[AbstractClause(clause_text='component_clause', node_name='', full_text='component_clause'), AbstractClause(clause_text='NAME_QF COLON LOWER_CAMEL NEWLINE', node_name='attribute__name__simple', full_text='NAME_QF COLON LOWER_CAMEL NEWLINE -> attribute__name__simple'), AbstractClause(clause_text='DATA_TYPE_CLAUSE_QF COLON data_type_clause NEWLINE', node_name='attribute__data_type_clause__simple', full_text='DATA_TYPE_CLAUSE_QF COLON data_type_clause NEWLINE -> attribute__data_type_clause__simple'), AbstractClause(clause_text='DERIVATION_QF COLON derivation NEWLINE', node_name='attribute__derivation__simple', full_text='DERIVATION_QF COLON derivation NEWLINE -> attribute__derivation__simple'), AbstractClause(clause_text='DEFAULT_QF COLON default NEWLINE', node_name='attribute__default__simple', full_text='DEFAULT_QF COLON default NEWLINE -> attribute__default__simple'), AbstractClause(clause_text='constraint+', node_name='attribute__constraints__list', full_text='constraint+ -> attribute__constraints__list')])
Adding rule2:  AbstractNTRule()
for attribute_clause to component_clause
		|	NAME_QF COLON LOWER_CAMEL NEWLINE -> attribute__name__simple
		|	DATA_TYPE_CLAUSE_QF COLON data_type_clause NEWLINE -> attribute__data_type_clause__simple
		|	DERIVATION_QF COLON derivation NEWLINE -> attribute__derivation__simple
		|	DEFAULT_QF COLON default NEWLINE -> attribute__default__simple
		|	constraint+ -> attribute__constraints__list
Adding rule2:  AbstractNTRule()
for Attribute to attribute_header  (attribute_clause)*
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . <  Called by _gen_rules_for_class with args ('Attribute', <class 'Lit_01.Lit_01.Attribute'>, {'data_type_clause', 'name', 'one_liner'}) {}
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is LowerCamel
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'class_casing.LowerCamel'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned LOWER_CAMEL
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is OneLiner
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.OneLiner'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned ONE_LINER
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is DataTypeClause
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.DataTypeClause'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned False
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned data_type_clause
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . >  Returned [AbstractRule(), AbstractRule(), AbstractRule()]
Value rule is: attribute__name__value: LOWER_CAMEL
... added as attribute__name__value: LOWER_CAMEL
Value rule is: attribute__one_liner__value: ONE_LINER
... added as attribute__one_liner__value: ONE_LINER
Value rule is: attribute__data_type_clause__value: data_type_clause
... added as attribute__data_type_clause__value: data_type_clause
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'AttributeSection', <class 'Lit_01.Lit_01.AttributeSection'>) {}
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . <  Called by _gen_rules_for_class with args ('AttributeSection',) {}
[pom_grammar_generator.py:844 -     _generate_type_hierarchy_clause()] . . subtypes of AttributeSection are []
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . >  Returned None
[pom_grammar_generator.py:469 -                _gen_rules_for_class()] . Class AttributeSection is not abstract, generating own rule with clauses
[pom_grammar_generator.py:478 -                      _assess_fields()] . <  Called by _gen_rules_for_class with args (<class 'Lit_01.Lit_01.AttributeSection'>,) {}
[pom_grammar_generator.py:734 -                      _assess_fields()] . . Assessed: <class 'Lit_01.Lit_01.AttributeSection'>...
[pom_grammar_generator.py:735 -                      _assess_fields()] . . ... New fields for <class 'Lit_01.Lit_01.AttributeSection'> are {'is_required', 'attributes'}
[pom_grammar_generator.py:736 -                      _assess_fields()] . . ... Redefined fields for <class 'Lit_01.Lit_01.AttributeSection'> are set()
[pom_grammar_generator.py:737 -                      _assess_fields()] . . ... Inherited fields for <class 'Lit_01.Lit_01.AttributeSection'> are {'one_liner', 'elaboration', 'name', '_type', 'annotations', 'abbreviation'}
[pom_grammar_generator.py:738 -                      _assess_fields()] . . ... Inherits from for <class 'Lit_01.Lit_01.AttributeSection'> are {'Component'}
[pom_grammar_generator.py:478 -                      _assess_fields()] . >  Returned ({'is_required', 'attributes'}, set(), {'one_liner', 'elaboration', 'name', '_type', 'annotations', 'abbreviation'}, {'Component'})
[pom_grammar_generator.py:496 -                _gen_rules_for_class()] . Header template is -  {name}{? - {one_liner}}{? ({is_required})} NEWLINE
[pom_grammar_generator.py:500 -                _gen_rules_for_class()] . Header clause is DASH attribute_section__name__value [ DASH attribute_section__one_liner__value ] [ LPAREN attribute_section__is_required__value RPAREN ] NEWLINE
[pom_grammar_generator.py:505 -                         find_fields()] . <  Called by _gen_rules_for_class with args () {}
[pom_grammar_generator.py:505 -                         find_fields()] . >  Returned {'is_required', 'name', 'one_liner'}
Adding rule2:  AbstractNTRule()
for attribute_section_header to DASH attribute_section__name__value [ DASH attribute_section__one_liner__value ] [ LPAREN attribute_section__is_required__value RPAREN ] NEWLINE
[pom_grammar_generator.py:509 -                _gen_rules_for_class()] . Header clause is: DASH attribute_section__name__value [ DASH attribute_section__one_liner__value ] [ LPAREN attribute_section__is_required__value RPAREN ] NEWLINE
RHS is  'DASH attribute_section__name__value [ DASH attribute_section__one_liner__value ] [ LPAREN attribute_section__is_required__value RPAREN ] NEWLINE'
[pom_grammar_generator.py:510 -                _gen_rules_for_class()] . Header rule is: attribute_section_header: DASH attribute_section__name__value [ DASH attribute_section__one_liner__value ] [ LPAREN attribute_section__is_required__value RPAREN ] NEWLINE
[pom_grammar_generator.py:517 -                _gen_rules_for_class()] . Ancestor clauses for AttributeSection are [AbstractClause(clause_text='component_clause', node_name='', full_text='component_clause')]
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . <  Called by _gen_rules_for_class with args ('AttributeSection', <class 'Lit_01.Lit_01.AttributeSection'>, {'one_liner', 'elaboration', 'name', '_type', 'annotations', 'abbreviation'}) {}
[pom_grammar_generator.py:780 -                        value_phrase()] . . <  Called by _generate_field_clause with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is IsReallyRequired
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'class_pom_token.IsReallyRequired'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:780 -                        value_phrase()] . . >  Returned IS_REALLY_REQUIRED
[class_field_type.py:328 -                        value_phrase()] . . <  Called by value_phrase with args ({'list': '{element}+', 'field_value': '{field_value}'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is Attribute
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.Attribute'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned False
[class_field_type.py:328 -                        value_phrase()] . . >  Returned attribute
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . >  Returned [AbstractClause(clause_text='IS_REQUIRED_QF COLON IS_REALLY_REQUIRED NEWLINE', node_name='attribute_section__is_required__simple', full_text='IS_REQUIRED_QF COLON IS_REALLY_REQUIRED NEWLINE -> attribute_section__is_required__simple'), AbstractClause(clause_text='attribute+', node_name='attribute_section__attributes__list', full_text='attribute+ -> attribute_section__attributes__list')]
[pom_grammar_generator.py:521 -                _gen_rules_for_class()] . Field clauses for AttributeSection are [AbstractClause(clause_text='IS_REQUIRED_QF COLON IS_REALLY_REQUIRED NEWLINE', node_name='attribute_section__is_required__simple', full_text='IS_REQUIRED_QF COLON IS_REALLY_REQUIRED NEWLINE -> attribute_section__is_required__simple'), AbstractClause(clause_text='attribute+', node_name='attribute_section__attributes__list', full_text='attribute+ -> attribute_section__attributes__list')]
body_clause is  AbstractDisjunction(clause_text='', node_name='', full_text='component_clause\n\t\t|\tIS_REQUIRED_QF COLON IS_REALLY_REQUIRED NEWLINE -> attribute_section__is_required__simple\n\t\t|\tattribute+ -> attribute_section__attributes__list', disjuncts=[AbstractClause(clause_text='component_clause', node_name='', full_text='component_clause'), AbstractClause(clause_text='IS_REQUIRED_QF COLON IS_REALLY_REQUIRED NEWLINE', node_name='attribute_section__is_required__simple', full_text='IS_REQUIRED_QF COLON IS_REALLY_REQUIRED NEWLINE -> attribute_section__is_required__simple'), AbstractClause(clause_text='attribute+', node_name='attribute_section__attributes__list', full_text='attribute+ -> attribute_section__attributes__list')])
Adding rule2:  AbstractNTRule()
for attribute_section_clause to component_clause
		|	IS_REQUIRED_QF COLON IS_REALLY_REQUIRED NEWLINE -> attribute_section__is_required__simple
		|	attribute+ -> attribute_section__attributes__list
Adding rule2:  AbstractNTRule()
for AttributeSection to attribute_section_header  (attribute_section_clause)*
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . <  Called by _gen_rules_for_class with args ('AttributeSection', <class 'Lit_01.Lit_01.AttributeSection'>, {'is_required', 'name', 'one_liner'}) {}
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is CamelCase
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'class_casing.CamelCase'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned CAMEL_CASE
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is OneLiner
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.OneLiner'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned ONE_LINER
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is IsReallyRequired
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'class_pom_token.IsReallyRequired'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned IS_REALLY_REQUIRED
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . >  Returned [AbstractRule(), AbstractRule(), AbstractRule()]
Value rule is: attribute_section__name__value: CAMEL_CASE
... added as attribute_section__name__value: CAMEL_CASE
Value rule is: attribute_section__one_liner__value: ONE_LINER
... added as attribute_section__one_liner__value: ONE_LINER
Value rule is: attribute_section__is_required__value: IS_REALLY_REQUIRED
... added as attribute_section__is_required__value: IS_REALLY_REQUIRED
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'Class', <class 'Lit_01.Lit_01.Class'>) {}
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . <  Called by _gen_rules_for_class with args ('Class',) {}
[pom_grammar_generator.py:844 -     _generate_type_hierarchy_clause()] . . subtypes of Class are ['ValueType', 'ReferenceType']
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . >  Returned value_type | reference_type
[pom_grammar_generator.py:469 -                _gen_rules_for_class()] . Class Class is not abstract, generating own rule with clauses
[pom_grammar_generator.py:478 -                      _assess_fields()] . <  Called by _gen_rules_for_class with args (<class 'Lit_01.Lit_01.Class'>,) {}
[pom_grammar_generator.py:734 -                      _assess_fields()] . . Assessed: <class 'Lit_01.Lit_01.Class'>...
[pom_grammar_generator.py:735 -                      _assess_fields()] . . ... New fields for <class 'Lit_01.Lit_01.Class'> are {'attributes', 'plural', 'is_value_type', 'based_on', 'where', 'subtypes', 'attribute_sections', 'subtype_of', 'dependents'}
[pom_grammar_generator.py:736 -                      _assess_fields()] . . ... Redefined fields for <class 'Lit_01.Lit_01.Class'> are {'name'}
[pom_grammar_generator.py:737 -                      _assess_fields()] . . ... Inherited fields for <class 'Lit_01.Lit_01.Class'> are {'one_liner', 'elaboration', '_type', 'annotations', 'abbreviation'}
[pom_grammar_generator.py:738 -                      _assess_fields()] . . ... Inherits from for <class 'Lit_01.Lit_01.Class'> are {'Component'}
[pom_grammar_generator.py:478 -                      _assess_fields()] . >  Returned ({'attributes', 'plural', 'is_value_type', 'based_on', 'where', 'subtypes', 'attribute_sections', 'subtype_of', 'dependents'}, {'name'}, {'one_liner', 'elaboration', '_type', 'annotations', 'abbreviation'}, {'Component'})
[pom_grammar_generator.py:496 -                _gen_rules_for_class()] . Header template is _ {name}{? - {one_liner}} NEWLINE
[pom_grammar_generator.py:500 -                _gen_rules_for_class()] . Header clause is UNDERSCORE class__name__value [ DASH class__one_liner__value ] NEWLINE
[pom_grammar_generator.py:505 -                         find_fields()] . <  Called by _gen_rules_for_class with args () {}
[pom_grammar_generator.py:505 -                         find_fields()] . >  Returned {'name', 'one_liner'}
Adding rule2:  AbstractNTRule()
for class_header to UNDERSCORE class__name__value [ DASH class__one_liner__value ] NEWLINE
[pom_grammar_generator.py:509 -                _gen_rules_for_class()] . Header clause is: UNDERSCORE class__name__value [ DASH class__one_liner__value ] NEWLINE
RHS is  'UNDERSCORE class__name__value [ DASH class__one_liner__value ] NEWLINE'
[pom_grammar_generator.py:510 -                _gen_rules_for_class()] . Header rule is: class_header: UNDERSCORE class__name__value [ DASH class__one_liner__value ] NEWLINE
[pom_grammar_generator.py:517 -                _gen_rules_for_class()] . Ancestor clauses for Class are [AbstractClause(clause_text='component_clause', node_name='', full_text='component_clause')]
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . <  Called by _gen_rules_for_class with args ('Class', <class 'Lit_01.Lit_01.Class'>, {'one_liner', 'elaboration', '_type', 'annotations', 'abbreviation'}) {}
[pom_grammar_generator.py:780 -                        value_phrase()] . . <  Called by _generate_field_clause with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is UpperCamel
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'class_casing.UpperCamel'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:780 -                        value_phrase()] . . >  Returned UPPER_CAMEL
[pom_grammar_generator.py:780 -                        value_phrase()] . . <  Called by _generate_field_clause with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is UpperCamel
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'class_casing.UpperCamel'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:780 -                        value_phrase()] . . >  Returned UPPER_CAMEL
[class_field_type.py:328 -                        value_phrase()] . . <  Called by value_phrase with args ({'field_value': '{field_name} COLON {field_value} NEWLINE', 'list': '{element} (COMMA {element})*'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is ClassName
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.ClassName'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[class_field_type.py:328 -                        value_phrase()] . . >  Returned CLASS_NAME
[class_field_type.py:328 -                        value_phrase()] . . <  Called by value_phrase with args ({'field_value': '{field_name} COLON {field_value} NEWLINE', 'list': '{element} (COMMA {element})*'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is ClassName
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.ClassName'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[class_field_type.py:328 -                        value_phrase()] . . >  Returned CLASS_NAME
[class_field_type.py:328 -                        value_phrase()] . . <  Called by value_phrase with args ({'field_value': '{field_name} COLON {field_value} NEWLINE', 'list': '{element} (COMMA {element})*'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is ClassName
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.ClassName'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[class_field_type.py:328 -                        value_phrase()] . . >  Returned CLASS_NAME
[class_field_type.py:328 -                        value_phrase()] . . <  Called by value_phrase with args ({'field_value': '{field_name} COLON {field_value} NEWLINE', 'list': '{element} (COMMA {element})*'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is ClassName
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.ClassName'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[class_field_type.py:328 -                        value_phrase()] . . >  Returned CLASS_NAME
[pom_grammar_generator.py:780 -                        value_phrase()] . . <  Called by _generate_field_clause with args ({'field_value': '{field_name} COLON {field_value} NEWLINE', 'bool': {'true': 'true', 'false': 'false', 'is_explicit': True}},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[pom_grammar_generator.py:780 -                        value_phrase()] . . >  Returned BOOLEAN
[pom_grammar_generator.py:780 -                        value_phrase()] . . <  Called by _generate_field_clause with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is OneLiner
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.OneLiner'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:780 -                        value_phrase()] . . >  Returned ONE_LINER
[class_field_type.py:328 -                        value_phrase()] . . <  Called by value_phrase with args ({'list': '{element}+', 'field_value': '{field_value}'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is Attribute
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.Attribute'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned False
[class_field_type.py:328 -                        value_phrase()] . . >  Returned attribute
[class_field_type.py:328 -                        value_phrase()] . . <  Called by value_phrase with args ({'list': '{element}+', 'field_value': '{field_value}'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is AttributeSection
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.AttributeSection'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned False
[class_field_type.py:328 -                        value_phrase()] . . >  Returned attribute_section
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . >  Returned [AbstractClause(clause_text='NAME_QF COLON UPPER_CAMEL NEWLINE', node_name='class__name__simple', full_text='NAME_QF COLON UPPER_CAMEL NEWLINE -> class__name__simple'), AbstractClause(clause_text='PLURAL_QF COLON UPPER_CAMEL NEWLINE', node_name='class__plural__simple', full_text='PLURAL_QF COLON UPPER_CAMEL NEWLINE -> class__plural__simple'), AbstractClause(clause_text='SUBTYPE_OF_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE', node_name='class__subtype_of__list', full_text='SUBTYPE_OF_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__subtype_of__list'), AbstractClause(clause_text='SUBTYPES_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE', node_name='class__subtypes__list', full_text='SUBTYPES_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__subtypes__list'), AbstractClause(clause_text='BASED_ON_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE', node_name='class__based_on__list', full_text='BASED_ON_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__based_on__list'), AbstractClause(clause_text='DEPENDENTS_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE', node_name='class__dependents__list', full_text='DEPENDENTS_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__dependents__list'), AbstractClause(clause_text='IS_VALUE_TYPE_QF COLON BOOLEAN NEWLINE', node_name='class__is_value_type__bool', full_text='IS_VALUE_TYPE_QF COLON BOOLEAN NEWLINE -> class__is_value_type__bool'), AbstractClause(clause_text='WHERE_QF COLON ONE_LINER NEWLINE', node_name='class__where__simple', full_text='WHERE_QF COLON ONE_LINER NEWLINE -> class__where__simple'), AbstractClause(clause_text='attribute+', node_name='class__attributes__list', full_text='attribute+ -> class__attributes__list'), AbstractClause(clause_text='attribute_section+', node_name='class__attribute_sections__list', full_text='attribute_section+ -> class__attribute_sections__list')]
[pom_grammar_generator.py:521 -                _gen_rules_for_class()] . Field clauses for Class are [AbstractClause(clause_text='NAME_QF COLON UPPER_CAMEL NEWLINE', node_name='class__name__simple', full_text='NAME_QF COLON UPPER_CAMEL NEWLINE -> class__name__simple'), AbstractClause(clause_text='PLURAL_QF COLON UPPER_CAMEL NEWLINE', node_name='class__plural__simple', full_text='PLURAL_QF COLON UPPER_CAMEL NEWLINE -> class__plural__simple'), AbstractClause(clause_text='SUBTYPE_OF_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE', node_name='class__subtype_of__list', full_text='SUBTYPE_OF_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__subtype_of__list'), AbstractClause(clause_text='SUBTYPES_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE', node_name='class__subtypes__list', full_text='SUBTYPES_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__subtypes__list'), AbstractClause(clause_text='BASED_ON_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE', node_name='class__based_on__list', full_text='BASED_ON_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__based_on__list'), AbstractClause(clause_text='DEPENDENTS_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE', node_name='class__dependents__list', full_text='DEPENDENTS_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__dependents__list'), AbstractClause(clause_text='IS_VALUE_TYPE_QF COLON BOOLEAN NEWLINE', node_name='class__is_value_type__bool', full_text='IS_VALUE_TYPE_QF COLON BOOLEAN NEWLINE -> class__is_value_type__bool'), AbstractClause(clause_text='WHERE_QF COLON ONE_LINER NEWLINE', node_name='class__where__simple', full_text='WHERE_QF COLON ONE_LINER NEWLINE -> class__where__simple'), AbstractClause(clause_text='attribute+', node_name='class__attributes__list', full_text='attribute+ -> class__attributes__list'), AbstractClause(clause_text='attribute_section+', node_name='class__attribute_sections__list', full_text='attribute_section+ -> class__attribute_sections__list')]
body_clause is  AbstractDisjunction(clause_text='', node_name='', full_text='component_clause\n\t\t|\tNAME_QF COLON UPPER_CAMEL NEWLINE -> class__name__simple\n\t\t|\tPLURAL_QF COLON UPPER_CAMEL NEWLINE -> class__plural__simple\n\t\t|\tSUBTYPE_OF_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__subtype_of__list\n\t\t|\tSUBTYPES_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__subtypes__list\n\t\t|\tBASED_ON_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__based_on__list\n\t\t|\tDEPENDENTS_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__dependents__list\n\t\t|\tIS_VALUE_TYPE_QF COLON BOOLEAN NEWLINE -> class__is_value_type__bool\n\t\t|\tWHERE_QF COLON ONE_LINER NEWLINE -> class__where__simple\n\t\t|\tattribute+ -> class__attributes__list\n\t\t|\tattribute_section+ -> class__attribute_sections__list', disjuncts=[AbstractClause(clause_text='component_clause', node_name='', full_text='component_clause'), AbstractClause(clause_text='NAME_QF COLON UPPER_CAMEL NEWLINE', node_name='class__name__simple', full_text='NAME_QF COLON UPPER_CAMEL NEWLINE -> class__name__simple'), AbstractClause(clause_text='PLURAL_QF COLON UPPER_CAMEL NEWLINE', node_name='class__plural__simple', full_text='PLURAL_QF COLON UPPER_CAMEL NEWLINE -> class__plural__simple'), AbstractClause(clause_text='SUBTYPE_OF_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE', node_name='class__subtype_of__list', full_text='SUBTYPE_OF_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__subtype_of__list'), AbstractClause(clause_text='SUBTYPES_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE', node_name='class__subtypes__list', full_text='SUBTYPES_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__subtypes__list'), AbstractClause(clause_text='BASED_ON_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE', node_name='class__based_on__list', full_text='BASED_ON_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__based_on__list'), AbstractClause(clause_text='DEPENDENTS_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE', node_name='class__dependents__list', full_text='DEPENDENTS_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__dependents__list'), AbstractClause(clause_text='IS_VALUE_TYPE_QF COLON BOOLEAN NEWLINE', node_name='class__is_value_type__bool', full_text='IS_VALUE_TYPE_QF COLON BOOLEAN NEWLINE -> class__is_value_type__bool'), AbstractClause(clause_text='WHERE_QF COLON ONE_LINER NEWLINE', node_name='class__where__simple', full_text='WHERE_QF COLON ONE_LINER NEWLINE -> class__where__simple'), AbstractClause(clause_text='attribute+', node_name='class__attributes__list', full_text='attribute+ -> class__attributes__list'), AbstractClause(clause_text='attribute_section+', node_name='class__attribute_sections__list', full_text='attribute_section+ -> class__attribute_sections__list')])
Adding rule2:  AbstractNTRule()
for class_clause to component_clause
		|	NAME_QF COLON UPPER_CAMEL NEWLINE -> class__name__simple
		|	PLURAL_QF COLON UPPER_CAMEL NEWLINE -> class__plural__simple
		|	SUBTYPE_OF_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__subtype_of__list
		|	SUBTYPES_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__subtypes__list
		|	BASED_ON_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__based_on__list
		|	DEPENDENTS_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__dependents__list
		|	IS_VALUE_TYPE_QF COLON BOOLEAN NEWLINE -> class__is_value_type__bool
		|	WHERE_QF COLON ONE_LINER NEWLINE -> class__where__simple
		|	attribute+ -> class__attributes__list
		|	attribute_section+ -> class__attribute_sections__list
Adding rule2:  AbstractNTRule()
for Class to value_type | reference_type
		|	class_header  (class_clause)*
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . <  Called by _gen_rules_for_class with args ('Class', <class 'Lit_01.Lit_01.Class'>, {'name', 'one_liner'}) {}
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is UpperCamel
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'class_casing.UpperCamel'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned UPPER_CAMEL
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is OneLiner
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.OneLiner'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned ONE_LINER
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . >  Returned [AbstractRule(), AbstractRule()]
Value rule is: class__name__value: UPPER_CAMEL
... added as class__name__value: UPPER_CAMEL
Value rule is: class__one_liner__value: ONE_LINER
... added as class__one_liner__value: ONE_LINER
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'ReferenceType', <class 'Lit_01.Lit_01.ReferenceType'>) {}
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . <  Called by _gen_rules_for_class with args ('ReferenceType',) {}
[pom_grammar_generator.py:844 -     _generate_type_hierarchy_clause()] . . subtypes of ReferenceType are []
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . >  Returned None
[pom_grammar_generator.py:469 -                _gen_rules_for_class()] . Class ReferenceType is not abstract, generating own rule with clauses
[pom_grammar_generator.py:478 -                      _assess_fields()] . <  Called by _gen_rules_for_class with args (<class 'Lit_01.Lit_01.ReferenceType'>,) {}
[pom_grammar_generator.py:734 -                      _assess_fields()] . . Assessed: <class 'Lit_01.Lit_01.ReferenceType'>...
[pom_grammar_generator.py:735 -                      _assess_fields()] . . ... New fields for <class 'Lit_01.Lit_01.ReferenceType'> are set()
[pom_grammar_generator.py:736 -                      _assess_fields()] . . ... Redefined fields for <class 'Lit_01.Lit_01.ReferenceType'> are set()
[pom_grammar_generator.py:737 -                      _assess_fields()] . . ... Inherited fields for <class 'Lit_01.Lit_01.ReferenceType'> are {'one_liner', 'elaboration', 'attributes', 'name', '_type', 'plural', 'is_value_type', 'based_on', 'where', 'annotations', 'subtypes', 'attribute_sections', 'abbreviation', 'subtype_of', 'dependents'}
[pom_grammar_generator.py:738 -                      _assess_fields()] . . ... Inherits from for <class 'Lit_01.Lit_01.ReferenceType'> are {'Class'}
[pom_grammar_generator.py:478 -                      _assess_fields()] . >  Returned (set(), set(), {'one_liner', 'elaboration', 'attributes', 'name', '_type', 'plural', 'is_value_type', 'based_on', 'where', 'annotations', 'subtypes', 'attribute_sections', 'abbreviation', 'subtype_of', 'dependents'}, {'Class'})
[pom_grammar_generator.py:496 -                _gen_rules_for_class()] . Header template is _ {name}{? - {one_liner}} NEWLINE
[pom_grammar_generator.py:500 -                _gen_rules_for_class()] . Header clause is UNDERSCORE reference_type__name__value [ DASH reference_type__one_liner__value ] NEWLINE
[pom_grammar_generator.py:505 -                         find_fields()] . <  Called by _gen_rules_for_class with args () {}
[pom_grammar_generator.py:505 -                         find_fields()] . >  Returned {'name', 'one_liner'}
Adding rule2:  AbstractNTRule()
for reference_type_header to UNDERSCORE reference_type__name__value [ DASH reference_type__one_liner__value ] NEWLINE
[pom_grammar_generator.py:509 -                _gen_rules_for_class()] . Header clause is: UNDERSCORE reference_type__name__value [ DASH reference_type__one_liner__value ] NEWLINE
RHS is  'UNDERSCORE reference_type__name__value [ DASH reference_type__one_liner__value ] NEWLINE'
[pom_grammar_generator.py:510 -                _gen_rules_for_class()] . Header rule is: reference_type_header: UNDERSCORE reference_type__name__value [ DASH reference_type__one_liner__value ] NEWLINE
[pom_grammar_generator.py:517 -                _gen_rules_for_class()] . Ancestor clauses for ReferenceType are [AbstractClause(clause_text='class_clause', node_name='', full_text='class_clause')]
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . <  Called by _gen_rules_for_class with args ('ReferenceType', <class 'Lit_01.Lit_01.ReferenceType'>, {'one_liner', 'elaboration', 'attributes', 'name', '_type', 'plural', 'is_value_type', 'based_on', 'where', 'annotations', 'subtypes', 'attribute_sections', 'abbreviation', 'subtype_of', 'dependents'}) {}
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . >  Returned []
Adding rule2:  AbstractNTRule()
for ReferenceType to reference_type_header  (class_clause)*
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . <  Called by _gen_rules_for_class with args ('ReferenceType', <class 'Lit_01.Lit_01.ReferenceType'>, {'name', 'one_liner'}) {}
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is UpperCamel
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'class_casing.UpperCamel'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned UPPER_CAMEL
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is OneLiner
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.OneLiner'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned ONE_LINER
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . >  Returned [AbstractRule(), AbstractRule()]
Value rule is: reference_type__name__value: UPPER_CAMEL
... added as reference_type__name__value: UPPER_CAMEL
Value rule is: reference_type__one_liner__value: ONE_LINER
... added as reference_type__one_liner__value: ONE_LINER
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'ValueType', <class 'Lit_01.Lit_01.ValueType'>) {}
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . <  Called by _gen_rules_for_class with args ('ValueType',) {}
[pom_grammar_generator.py:844 -     _generate_type_hierarchy_clause()] . . subtypes of ValueType are []
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . >  Returned None
[pom_grammar_generator.py:469 -                _gen_rules_for_class()] . Class ValueType is not abstract, generating own rule with clauses
[pom_grammar_generator.py:478 -                      _assess_fields()] . <  Called by _gen_rules_for_class with args (<class 'Lit_01.Lit_01.ValueType'>,) {}
[pom_grammar_generator.py:734 -                      _assess_fields()] . . Assessed: <class 'Lit_01.Lit_01.ValueType'>...
[pom_grammar_generator.py:735 -                      _assess_fields()] . . ... New fields for <class 'Lit_01.Lit_01.ValueType'> are set()
[pom_grammar_generator.py:736 -                      _assess_fields()] . . ... Redefined fields for <class 'Lit_01.Lit_01.ValueType'> are set()
[pom_grammar_generator.py:737 -                      _assess_fields()] . . ... Inherited fields for <class 'Lit_01.Lit_01.ValueType'> are {'one_liner', 'elaboration', 'attributes', 'name', '_type', 'plural', 'is_value_type', 'based_on', 'where', 'annotations', 'subtypes', 'attribute_sections', 'abbreviation', 'subtype_of', 'dependents'}
[pom_grammar_generator.py:738 -                      _assess_fields()] . . ... Inherits from for <class 'Lit_01.Lit_01.ValueType'> are {'Class'}
[pom_grammar_generator.py:478 -                      _assess_fields()] . >  Returned (set(), set(), {'one_liner', 'elaboration', 'attributes', 'name', '_type', 'plural', 'is_value_type', 'based_on', 'where', 'annotations', 'subtypes', 'attribute_sections', 'abbreviation', 'subtype_of', 'dependents'}, {'Class'})
[pom_grammar_generator.py:496 -                _gen_rules_for_class()] . Header template is _  ValueType : {name}{? - {one_liner}} NEWLINE
[pom_grammar_generator.py:500 -                _gen_rules_for_class()] . Header clause is UNDERSCORE VALUETYPE_Q COLON value_type__name__value [ DASH value_type__one_liner__value ] NEWLINE
[pom_grammar_generator.py:505 -                         find_fields()] . <  Called by _gen_rules_for_class with args () {}
[pom_grammar_generator.py:505 -                         find_fields()] . >  Returned {'name', 'one_liner'}
Adding rule2:  AbstractNTRule()
for value_type_header to UNDERSCORE VALUETYPE_Q COLON value_type__name__value [ DASH value_type__one_liner__value ] NEWLINE
[pom_grammar_generator.py:509 -                _gen_rules_for_class()] . Header clause is: UNDERSCORE VALUETYPE_Q COLON value_type__name__value [ DASH value_type__one_liner__value ] NEWLINE
RHS is  'UNDERSCORE VALUETYPE_Q COLON value_type__name__value [ DASH value_type__one_liner__value ] NEWLINE'
[pom_grammar_generator.py:510 -                _gen_rules_for_class()] . Header rule is: value_type_header: UNDERSCORE VALUETYPE_Q COLON value_type__name__value [ DASH value_type__one_liner__value ] NEWLINE
[pom_grammar_generator.py:517 -                _gen_rules_for_class()] . Ancestor clauses for ValueType are [AbstractClause(clause_text='class_clause', node_name='', full_text='class_clause')]
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . <  Called by _gen_rules_for_class with args ('ValueType', <class 'Lit_01.Lit_01.ValueType'>, {'one_liner', 'elaboration', 'attributes', 'name', '_type', 'plural', 'is_value_type', 'based_on', 'where', 'annotations', 'subtypes', 'attribute_sections', 'abbreviation', 'subtype_of', 'dependents'}) {}
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . >  Returned []
Adding rule2:  AbstractNTRule()
for ValueType to value_type_header  (class_clause)*
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . <  Called by _gen_rules_for_class with args ('ValueType', <class 'Lit_01.Lit_01.ValueType'>, {'name', 'one_liner'}) {}
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is UpperCamel
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'class_casing.UpperCamel'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned UPPER_CAMEL
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is OneLiner
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.OneLiner'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned ONE_LINER
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . >  Returned [AbstractRule(), AbstractRule()]
Value rule is: value_type__name__value: UPPER_CAMEL
... added as value_type__name__value: UPPER_CAMEL
Value rule is: value_type__one_liner__value: ONE_LINER
... added as value_type__one_liner__value: ONE_LINER
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'SubjectE', <class 'Lit_01.Lit_01.SubjectE'>) {}
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . <  Called by _gen_rules_for_class with args ('SubjectE',) {}
[pom_grammar_generator.py:844 -     _generate_type_hierarchy_clause()] . . subtypes of SubjectE are ['SubjectD']
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . >  Returned subject_d
[pom_grammar_generator.py:469 -                _gen_rules_for_class()] . Class SubjectE is not abstract, generating own rule with clauses
[pom_grammar_generator.py:478 -                      _assess_fields()] . <  Called by _gen_rules_for_class with args (<class 'Lit_01.Lit_01.SubjectE'>,) {}
[pom_grammar_generator.py:734 -                      _assess_fields()] . . Assessed: <class 'Lit_01.Lit_01.SubjectE'>...
[pom_grammar_generator.py:735 -                      _assess_fields()] . . ... New fields for <class 'Lit_01.Lit_01.SubjectE'> are {'classes'}
[pom_grammar_generator.py:736 -                      _assess_fields()] . . ... Redefined fields for <class 'Lit_01.Lit_01.SubjectE'> are set()
[pom_grammar_generator.py:737 -                      _assess_fields()] . . ... Inherited fields for <class 'Lit_01.Lit_01.SubjectE'> are {'one_liner', 'elaboration', 'name', '_type', 'annotations', 'abbreviation'}
[pom_grammar_generator.py:738 -                      _assess_fields()] . . ... Inherits from for <class 'Lit_01.Lit_01.SubjectE'> are {'Component'}
[pom_grammar_generator.py:478 -                      _assess_fields()] . >  Returned ({'classes'}, set(), {'one_liner', 'elaboration', 'name', '_type', 'annotations', 'abbreviation'}, {'Component'})
[pom_grammar_generator.py:496 -                _gen_rules_for_class()] . Header template is #####  {{name}{? - {one_liner}} NEWLINE
[pom_grammar_generator.py:500 -                _gen_rules_for_class()] . Header clause is HASH HASH HASH HASH HASH LBRACE subject_e__name__value [ DASH subject_e__one_liner__value ] NEWLINE
[pom_grammar_generator.py:505 -                         find_fields()] . <  Called by _gen_rules_for_class with args () {}
[pom_grammar_generator.py:505 -                         find_fields()] . >  Returned {'name', 'one_liner'}
Adding rule2:  AbstractNTRule()
for subject_e_header to HASH HASH HASH HASH HASH LBRACE subject_e__name__value [ DASH subject_e__one_liner__value ] NEWLINE
[pom_grammar_generator.py:509 -                _gen_rules_for_class()] . Header clause is: HASH HASH HASH HASH HASH LBRACE subject_e__name__value [ DASH subject_e__one_liner__value ] NEWLINE
RHS is  'HASH HASH HASH HASH HASH LBRACE subject_e__name__value [ DASH subject_e__one_liner__value ] NEWLINE'
[pom_grammar_generator.py:510 -                _gen_rules_for_class()] . Header rule is: subject_e_header: HASH HASH HASH HASH HASH LBRACE subject_e__name__value [ DASH subject_e__one_liner__value ] NEWLINE
[pom_grammar_generator.py:517 -                _gen_rules_for_class()] . Ancestor clauses for SubjectE are [AbstractClause(clause_text='component_clause', node_name='', full_text='component_clause')]
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . <  Called by _gen_rules_for_class with args ('SubjectE', <class 'Lit_01.Lit_01.SubjectE'>, {'one_liner', 'elaboration', 'name', '_type', 'annotations', 'abbreviation'}) {}
[class_field_type.py:328 -                        value_phrase()] . . <  Called by value_phrase with args ({'list': '{element}+', 'field_value': '{field_value}'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is Class
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.Class'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned False
[class_field_type.py:328 -                        value_phrase()] . . >  Returned class
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . >  Returned [AbstractClause(clause_text='class+', node_name='subject_e__classes__list', full_text='class+ -> subject_e__classes__list')]
[pom_grammar_generator.py:521 -                _gen_rules_for_class()] . Field clauses for SubjectE are [AbstractClause(clause_text='class+', node_name='subject_e__classes__list', full_text='class+ -> subject_e__classes__list')]
body_clause is  AbstractDisjunction(clause_text='', node_name='', full_text='component_clause\n\t\t|\tclass+ -> subject_e__classes__list', disjuncts=[AbstractClause(clause_text='component_clause', node_name='', full_text='component_clause'), AbstractClause(clause_text='class+', node_name='subject_e__classes__list', full_text='class+ -> subject_e__classes__list')])
Adding rule2:  AbstractNTRule()
for subject_e_clause to component_clause
		|	class+ -> subject_e__classes__list
Adding rule2:  AbstractNTRule()
for SubjectE to subject_d
		|	subject_e_header  (subject_e_clause)*
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . <  Called by _gen_rules_for_class with args ('SubjectE', <class 'Lit_01.Lit_01.SubjectE'>, {'name', 'one_liner'}) {}
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is CamelCase
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'class_casing.CamelCase'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned CAMEL_CASE
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is OneLiner
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.OneLiner'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned ONE_LINER
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . >  Returned [AbstractRule(), AbstractRule()]
Value rule is: subject_e__name__value: CAMEL_CASE
... added as subject_e__name__value: CAMEL_CASE
Value rule is: subject_e__one_liner__value: ONE_LINER
... added as subject_e__one_liner__value: ONE_LINER
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'SubjectD', <class 'Lit_01.Lit_01.SubjectD'>) {}
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . <  Called by _gen_rules_for_class with args ('SubjectD',) {}
[pom_grammar_generator.py:844 -     _generate_type_hierarchy_clause()] . . subtypes of SubjectD are ['SubjectC']
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . >  Returned subject_c
[pom_grammar_generator.py:469 -                _gen_rules_for_class()] . Class SubjectD is not abstract, generating own rule with clauses
[pom_grammar_generator.py:478 -                      _assess_fields()] . <  Called by _gen_rules_for_class with args (<class 'Lit_01.Lit_01.SubjectD'>,) {}
[pom_grammar_generator.py:734 -                      _assess_fields()] . . Assessed: <class 'Lit_01.Lit_01.SubjectD'>...
[pom_grammar_generator.py:735 -                      _assess_fields()] . . ... New fields for <class 'Lit_01.Lit_01.SubjectD'> are {'subjects'}
[pom_grammar_generator.py:736 -                      _assess_fields()] . . ... Redefined fields for <class 'Lit_01.Lit_01.SubjectD'> are set()
[pom_grammar_generator.py:737 -                      _assess_fields()] . . ... Inherited fields for <class 'Lit_01.Lit_01.SubjectD'> are {'one_liner', 'elaboration', 'name', '_type', 'annotations', 'classes', 'abbreviation'}
[pom_grammar_generator.py:738 -                      _assess_fields()] . . ... Inherits from for <class 'Lit_01.Lit_01.SubjectD'> are {'SubjectE'}
[pom_grammar_generator.py:478 -                      _assess_fields()] . >  Returned ({'subjects'}, set(), {'one_liner', 'elaboration', 'name', '_type', 'annotations', 'classes', 'abbreviation'}, {'SubjectE'})
[pom_grammar_generator.py:496 -                _gen_rules_for_class()] . Header template is ####  {{name}{? - {one_liner}} NEWLINE
[pom_grammar_generator.py:500 -                _gen_rules_for_class()] . Header clause is HASH HASH HASH HASH LBRACE subject_d__name__value [ DASH subject_d__one_liner__value ] NEWLINE
[pom_grammar_generator.py:505 -                         find_fields()] . <  Called by _gen_rules_for_class with args () {}
[pom_grammar_generator.py:505 -                         find_fields()] . >  Returned {'name', 'one_liner'}
Adding rule2:  AbstractNTRule()
for subject_d_header to HASH HASH HASH HASH LBRACE subject_d__name__value [ DASH subject_d__one_liner__value ] NEWLINE
[pom_grammar_generator.py:509 -                _gen_rules_for_class()] . Header clause is: HASH HASH HASH HASH LBRACE subject_d__name__value [ DASH subject_d__one_liner__value ] NEWLINE
RHS is  'HASH HASH HASH HASH LBRACE subject_d__name__value [ DASH subject_d__one_liner__value ] NEWLINE'
[pom_grammar_generator.py:510 -                _gen_rules_for_class()] . Header rule is: subject_d_header: HASH HASH HASH HASH LBRACE subject_d__name__value [ DASH subject_d__one_liner__value ] NEWLINE
[pom_grammar_generator.py:517 -                _gen_rules_for_class()] . Ancestor clauses for SubjectD are [AbstractClause(clause_text='subject_e_clause', node_name='', full_text='subject_e_clause')]
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . <  Called by _gen_rules_for_class with args ('SubjectD', <class 'Lit_01.Lit_01.SubjectD'>, {'one_liner', 'elaboration', 'name', '_type', 'annotations', 'classes', 'abbreviation'}) {}
[class_field_type.py:328 -                        value_phrase()] . . <  Called by value_phrase with args ({'list': '{element}+', 'field_value': '{field_value}'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is SubjectE
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.SubjectE'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned False
[class_field_type.py:328 -                        value_phrase()] . . >  Returned subject_e
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . >  Returned [AbstractClause(clause_text='subject_e+', node_name='subject_d__subjects__list', full_text='subject_e+ -> subject_d__subjects__list')]
[pom_grammar_generator.py:521 -                _gen_rules_for_class()] . Field clauses for SubjectD are [AbstractClause(clause_text='subject_e+', node_name='subject_d__subjects__list', full_text='subject_e+ -> subject_d__subjects__list')]
body_clause is  AbstractDisjunction(clause_text='', node_name='', full_text='subject_e_clause\n\t\t|\tsubject_e+ -> subject_d__subjects__list', disjuncts=[AbstractClause(clause_text='subject_e_clause', node_name='', full_text='subject_e_clause'), AbstractClause(clause_text='subject_e+', node_name='subject_d__subjects__list', full_text='subject_e+ -> subject_d__subjects__list')])
Adding rule2:  AbstractNTRule()
for subject_d_clause to subject_e_clause
		|	subject_e+ -> subject_d__subjects__list
Adding rule2:  AbstractNTRule()
for SubjectD to subject_c
		|	subject_d_header  (subject_d_clause)*
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . <  Called by _gen_rules_for_class with args ('SubjectD', <class 'Lit_01.Lit_01.SubjectD'>, {'name', 'one_liner'}) {}
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is CamelCase
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'class_casing.CamelCase'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned CAMEL_CASE
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is OneLiner
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.OneLiner'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned ONE_LINER
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . >  Returned [AbstractRule(), AbstractRule()]
Value rule is: subject_d__name__value: CAMEL_CASE
... added as subject_d__name__value: CAMEL_CASE
Value rule is: subject_d__one_liner__value: ONE_LINER
... added as subject_d__one_liner__value: ONE_LINER
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'SubjectC', <class 'Lit_01.Lit_01.SubjectC'>) {}
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . <  Called by _gen_rules_for_class with args ('SubjectC',) {}
[pom_grammar_generator.py:844 -     _generate_type_hierarchy_clause()] . . subtypes of SubjectC are ['SubjectB']
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . >  Returned subject_b
[pom_grammar_generator.py:469 -                _gen_rules_for_class()] . Class SubjectC is not abstract, generating own rule with clauses
[pom_grammar_generator.py:478 -                      _assess_fields()] . <  Called by _gen_rules_for_class with args (<class 'Lit_01.Lit_01.SubjectC'>,) {}
[pom_grammar_generator.py:734 -                      _assess_fields()] . . Assessed: <class 'Lit_01.Lit_01.SubjectC'>...
[pom_grammar_generator.py:735 -                      _assess_fields()] . . ... New fields for <class 'Lit_01.Lit_01.SubjectC'> are set()
[pom_grammar_generator.py:736 -                      _assess_fields()] . . ... Redefined fields for <class 'Lit_01.Lit_01.SubjectC'> are {'subjects'}
[pom_grammar_generator.py:737 -                      _assess_fields()] . . ... Inherited fields for <class 'Lit_01.Lit_01.SubjectC'> are {'one_liner', 'elaboration', 'name', '_type', 'annotations', 'classes', 'abbreviation'}
[pom_grammar_generator.py:738 -                      _assess_fields()] . . ... Inherits from for <class 'Lit_01.Lit_01.SubjectC'> are {'SubjectD'}
[pom_grammar_generator.py:478 -                      _assess_fields()] . >  Returned (set(), {'subjects'}, {'one_liner', 'elaboration', 'name', '_type', 'annotations', 'classes', 'abbreviation'}, {'SubjectD'})
[pom_grammar_generator.py:496 -                _gen_rules_for_class()] . Header template is ###  {{name}{? - {one_liner}} NEWLINE
[pom_grammar_generator.py:500 -                _gen_rules_for_class()] . Header clause is HASH HASH HASH LBRACE subject_c__name__value [ DASH subject_c__one_liner__value ] NEWLINE
[pom_grammar_generator.py:505 -                         find_fields()] . <  Called by _gen_rules_for_class with args () {}
[pom_grammar_generator.py:505 -                         find_fields()] . >  Returned {'name', 'one_liner'}
Adding rule2:  AbstractNTRule()
for subject_c_header to HASH HASH HASH LBRACE subject_c__name__value [ DASH subject_c__one_liner__value ] NEWLINE
[pom_grammar_generator.py:509 -                _gen_rules_for_class()] . Header clause is: HASH HASH HASH LBRACE subject_c__name__value [ DASH subject_c__one_liner__value ] NEWLINE
RHS is  'HASH HASH HASH LBRACE subject_c__name__value [ DASH subject_c__one_liner__value ] NEWLINE'
[pom_grammar_generator.py:510 -                _gen_rules_for_class()] . Header rule is: subject_c_header: HASH HASH HASH LBRACE subject_c__name__value [ DASH subject_c__one_liner__value ] NEWLINE
[pom_grammar_generator.py:517 -                _gen_rules_for_class()] . Ancestor clauses for SubjectC are [AbstractClause(clause_text='subject_d_clause', node_name='', full_text='subject_d_clause')]
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . <  Called by _gen_rules_for_class with args ('SubjectC', <class 'Lit_01.Lit_01.SubjectC'>, {'one_liner', 'elaboration', 'name', '_type', 'annotations', 'classes', 'abbreviation'}) {}
[class_field_type.py:328 -                        value_phrase()] . . <  Called by value_phrase with args ({'list': '{element}+', 'field_value': '{field_value}'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is SubjectD
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.SubjectD'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned False
[class_field_type.py:328 -                        value_phrase()] . . >  Returned subject_d
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . >  Returned [AbstractClause(clause_text='subject_d+', node_name='subject_c__subjects__list', full_text='subject_d+ -> subject_c__subjects__list')]
[pom_grammar_generator.py:521 -                _gen_rules_for_class()] . Field clauses for SubjectC are [AbstractClause(clause_text='subject_d+', node_name='subject_c__subjects__list', full_text='subject_d+ -> subject_c__subjects__list')]
body_clause is  AbstractDisjunction(clause_text='', node_name='', full_text='subject_d_clause\n\t\t|\tsubject_d+ -> subject_c__subjects__list', disjuncts=[AbstractClause(clause_text='subject_d_clause', node_name='', full_text='subject_d_clause'), AbstractClause(clause_text='subject_d+', node_name='subject_c__subjects__list', full_text='subject_d+ -> subject_c__subjects__list')])
Adding rule2:  AbstractNTRule()
for subject_c_clause to subject_d_clause
		|	subject_d+ -> subject_c__subjects__list
Adding rule2:  AbstractNTRule()
for SubjectC to subject_b
		|	subject_c_header  (subject_c_clause)*
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . <  Called by _gen_rules_for_class with args ('SubjectC', <class 'Lit_01.Lit_01.SubjectC'>, {'name', 'one_liner'}) {}
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is CamelCase
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'class_casing.CamelCase'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned CAMEL_CASE
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is OneLiner
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.OneLiner'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned ONE_LINER
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . >  Returned [AbstractRule(), AbstractRule()]
Value rule is: subject_c__name__value: CAMEL_CASE
... added as subject_c__name__value: CAMEL_CASE
Value rule is: subject_c__one_liner__value: ONE_LINER
... added as subject_c__one_liner__value: ONE_LINER
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'SubjectB', <class 'Lit_01.Lit_01.SubjectB'>) {}
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . <  Called by _gen_rules_for_class with args ('SubjectB',) {}
[pom_grammar_generator.py:844 -     _generate_type_hierarchy_clause()] . . subtypes of SubjectB are ['LDM']
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . >  Returned ldm
[pom_grammar_generator.py:469 -                _gen_rules_for_class()] . Class SubjectB is not abstract, generating own rule with clauses
[pom_grammar_generator.py:478 -                      _assess_fields()] . <  Called by _gen_rules_for_class with args (<class 'Lit_01.Lit_01.SubjectB'>,) {}
[pom_grammar_generator.py:734 -                      _assess_fields()] . . Assessed: <class 'Lit_01.Lit_01.SubjectB'>...
[pom_grammar_generator.py:735 -                      _assess_fields()] . . ... New fields for <class 'Lit_01.Lit_01.SubjectB'> are set()
[pom_grammar_generator.py:736 -                      _assess_fields()] . . ... Redefined fields for <class 'Lit_01.Lit_01.SubjectB'> are {'subjects'}
[pom_grammar_generator.py:737 -                      _assess_fields()] . . ... Inherited fields for <class 'Lit_01.Lit_01.SubjectB'> are {'one_liner', 'elaboration', 'name', '_type', 'annotations', 'classes', 'abbreviation'}
[pom_grammar_generator.py:738 -                      _assess_fields()] . . ... Inherits from for <class 'Lit_01.Lit_01.SubjectB'> are {'SubjectC'}
[pom_grammar_generator.py:478 -                      _assess_fields()] . >  Returned (set(), {'subjects'}, {'one_liner', 'elaboration', 'name', '_type', 'annotations', 'classes', 'abbreviation'}, {'SubjectC'})
[pom_grammar_generator.py:496 -                _gen_rules_for_class()] . Header template is ##  {{name}{? - {one_liner}} NEWLINE
[pom_grammar_generator.py:500 -                _gen_rules_for_class()] . Header clause is HASH HASH LBRACE subject_b__name__value [ DASH subject_b__one_liner__value ] NEWLINE
[pom_grammar_generator.py:505 -                         find_fields()] . <  Called by _gen_rules_for_class with args () {}
[pom_grammar_generator.py:505 -                         find_fields()] . >  Returned {'name', 'one_liner'}
Adding rule2:  AbstractNTRule()
for subject_b_header to HASH HASH LBRACE subject_b__name__value [ DASH subject_b__one_liner__value ] NEWLINE
[pom_grammar_generator.py:509 -                _gen_rules_for_class()] . Header clause is: HASH HASH LBRACE subject_b__name__value [ DASH subject_b__one_liner__value ] NEWLINE
RHS is  'HASH HASH LBRACE subject_b__name__value [ DASH subject_b__one_liner__value ] NEWLINE'
[pom_grammar_generator.py:510 -                _gen_rules_for_class()] . Header rule is: subject_b_header: HASH HASH LBRACE subject_b__name__value [ DASH subject_b__one_liner__value ] NEWLINE
[pom_grammar_generator.py:517 -                _gen_rules_for_class()] . Ancestor clauses for SubjectB are [AbstractClause(clause_text='subject_c_clause', node_name='', full_text='subject_c_clause')]
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . <  Called by _gen_rules_for_class with args ('SubjectB', <class 'Lit_01.Lit_01.SubjectB'>, {'one_liner', 'elaboration', 'name', '_type', 'annotations', 'classes', 'abbreviation'}) {}
[class_field_type.py:328 -                        value_phrase()] . . <  Called by value_phrase with args ({'list': '{element}+', 'field_value': '{field_value}'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is SubjectC
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.SubjectC'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned False
[class_field_type.py:328 -                        value_phrase()] . . >  Returned subject_c
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . >  Returned [AbstractClause(clause_text='subject_c+', node_name='subject_b__subjects__list', full_text='subject_c+ -> subject_b__subjects__list')]
[pom_grammar_generator.py:521 -                _gen_rules_for_class()] . Field clauses for SubjectB are [AbstractClause(clause_text='subject_c+', node_name='subject_b__subjects__list', full_text='subject_c+ -> subject_b__subjects__list')]
body_clause is  AbstractDisjunction(clause_text='', node_name='', full_text='subject_c_clause\n\t\t|\tsubject_c+ -> subject_b__subjects__list', disjuncts=[AbstractClause(clause_text='subject_c_clause', node_name='', full_text='subject_c_clause'), AbstractClause(clause_text='subject_c+', node_name='subject_b__subjects__list', full_text='subject_c+ -> subject_b__subjects__list')])
Adding rule2:  AbstractNTRule()
for subject_b_clause to subject_c_clause
		|	subject_c+ -> subject_b__subjects__list
Adding rule2:  AbstractNTRule()
for SubjectB to ldm
		|	subject_b_header  (subject_b_clause)*
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . <  Called by _gen_rules_for_class with args ('SubjectB', <class 'Lit_01.Lit_01.SubjectB'>, {'name', 'one_liner'}) {}
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is CamelCase
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'class_casing.CamelCase'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned CAMEL_CASE
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is OneLiner
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.OneLiner'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned ONE_LINER
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . >  Returned [AbstractRule(), AbstractRule()]
Value rule is: subject_b__name__value: CAMEL_CASE
... added as subject_b__name__value: CAMEL_CASE
Value rule is: subject_b__one_liner__value: ONE_LINER
... added as subject_b__one_liner__value: ONE_LINER
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'LDM', <class 'Lit_01.Lit_01.LDM'>) {}
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . <  Called by _gen_rules_for_class with args ('LDM',) {}
[pom_grammar_generator.py:844 -     _generate_type_hierarchy_clause()] . . subtypes of LDM are []
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . >  Returned None
[pom_grammar_generator.py:469 -                _gen_rules_for_class()] . Class LDM is not abstract, generating own rule with clauses
[pom_grammar_generator.py:478 -                      _assess_fields()] . <  Called by _gen_rules_for_class with args (<class 'Lit_01.Lit_01.LDM'>,) {}
[pom_grammar_generator.py:734 -                      _assess_fields()] . . Assessed: <class 'Lit_01.Lit_01.LDM'>...
[pom_grammar_generator.py:735 -                      _assess_fields()] . . ... New fields for <class 'Lit_01.Lit_01.LDM'> are set()
[pom_grammar_generator.py:736 -                      _assess_fields()] . . ... Redefined fields for <class 'Lit_01.Lit_01.LDM'> are {'subjects'}
[pom_grammar_generator.py:737 -                      _assess_fields()] . . ... Inherited fields for <class 'Lit_01.Lit_01.LDM'> are {'one_liner', 'elaboration', 'name', '_type', 'annotations', 'classes', 'abbreviation'}
[pom_grammar_generator.py:738 -                      _assess_fields()] . . ... Inherits from for <class 'Lit_01.Lit_01.LDM'> are {'SubjectB'}
[pom_grammar_generator.py:478 -                      _assess_fields()] . >  Returned (set(), {'subjects'}, {'one_liner', 'elaboration', 'name', '_type', 'annotations', 'classes', 'abbreviation'}, {'SubjectB'})
[pom_grammar_generator.py:496 -                _gen_rules_for_class()] . Header template is #  {{name}{? - {one_liner}} NEWLINE
[pom_grammar_generator.py:500 -                _gen_rules_for_class()] . Header clause is HASH LBRACE ldm__name__value [ DASH ldm__one_liner__value ] NEWLINE
[pom_grammar_generator.py:505 -                         find_fields()] . <  Called by _gen_rules_for_class with args () {}
[pom_grammar_generator.py:505 -                         find_fields()] . >  Returned {'name', 'one_liner'}
Adding rule2:  AbstractNTRule()
for ldm_header to HASH LBRACE ldm__name__value [ DASH ldm__one_liner__value ] NEWLINE
[pom_grammar_generator.py:509 -                _gen_rules_for_class()] . Header clause is: HASH LBRACE ldm__name__value [ DASH ldm__one_liner__value ] NEWLINE
RHS is  'HASH LBRACE ldm__name__value [ DASH ldm__one_liner__value ] NEWLINE'
[pom_grammar_generator.py:510 -                _gen_rules_for_class()] . Header rule is: ldm_header: HASH LBRACE ldm__name__value [ DASH ldm__one_liner__value ] NEWLINE
[pom_grammar_generator.py:517 -                _gen_rules_for_class()] . Ancestor clauses for LDM are [AbstractClause(clause_text='subject_b_clause', node_name='', full_text='subject_b_clause')]
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . <  Called by _gen_rules_for_class with args ('LDM', <class 'Lit_01.Lit_01.LDM'>, {'one_liner', 'elaboration', 'name', '_type', 'annotations', 'classes', 'abbreviation'}) {}
[class_field_type.py:328 -                        value_phrase()] . . <  Called by value_phrase with args ({'list': '{element}+', 'field_value': '{field_value}'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is SubjectB
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.SubjectB'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned False
[class_field_type.py:328 -                        value_phrase()] . . >  Returned subject_b
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . >  Returned [AbstractClause(clause_text='subject_b+', node_name='ldm__subjects__list', full_text='subject_b+ -> ldm__subjects__list')]
[pom_grammar_generator.py:521 -                _gen_rules_for_class()] . Field clauses for LDM are [AbstractClause(clause_text='subject_b+', node_name='ldm__subjects__list', full_text='subject_b+ -> ldm__subjects__list')]
body_clause is  AbstractDisjunction(clause_text='', node_name='', full_text='subject_b_clause\n\t\t|\tsubject_b+ -> ldm__subjects__list', disjuncts=[AbstractClause(clause_text='subject_b_clause', node_name='', full_text='subject_b_clause'), AbstractClause(clause_text='subject_b+', node_name='ldm__subjects__list', full_text='subject_b+ -> ldm__subjects__list')])
Adding rule2:  AbstractNTRule()
for ldm_clause to subject_b_clause
		|	subject_b+ -> ldm__subjects__list
Adding rule2:  AbstractNTRule()
for LDM to ldm_header  (ldm_clause)*
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . <  Called by _gen_rules_for_class with args ('LDM', <class 'Lit_01.Lit_01.LDM'>, {'name', 'one_liner'}) {}
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is CamelCase
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'class_casing.CamelCase'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned CAMEL_CASE
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is OneLiner
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.OneLiner'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned ONE_LINER
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . >  Returned [AbstractRule(), AbstractRule()]
Value rule is: ldm__name__value: CAMEL_CASE
... added as ldm__name__value: CAMEL_CASE
Value rule is: ldm__one_liner__value: ONE_LINER
... added as ldm__one_liner__value: ONE_LINER
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'DataType', <class 'Lit_01.Lit_01.DataType'>) {}
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . <  Called by _gen_rules_for_class with args ('DataType',) {}
[pom_grammar_generator.py:844 -     _generate_type_hierarchy_clause()] . . subtypes of DataType are ['BaseDataType', 'ListDataType', 'SetDataType', 'MappingDataType']
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . >  Returned base_data_type | list_data_type | set_data_type | mapping_data_type
[pom_grammar_generator.py:469 -                _gen_rules_for_class()] . Class DataType is not abstract, generating own rule with clauses
[pom_grammar_generator.py:478 -                      _assess_fields()] . <  Called by _gen_rules_for_class with args (<class 'Lit_01.Lit_01.DataType'>,) {}
[pom_grammar_generator.py:734 -                      _assess_fields()] . . Assessed: <class 'Lit_01.Lit_01.DataType'>...
[pom_grammar_generator.py:735 -                      _assess_fields()] . . ... New fields for <class 'Lit_01.Lit_01.DataType'> are {'_type'}
[pom_grammar_generator.py:736 -                      _assess_fields()] . . ... Redefined fields for <class 'Lit_01.Lit_01.DataType'> are set()
[pom_grammar_generator.py:737 -                      _assess_fields()] . . ... Inherited fields for <class 'Lit_01.Lit_01.DataType'> are set()
[pom_grammar_generator.py:738 -                      _assess_fields()] . . ... Inherits from for <class 'Lit_01.Lit_01.DataType'> are set()
[pom_grammar_generator.py:478 -                      _assess_fields()] . >  Returned ({'_type'}, set(), set(), set())
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . <  Called by _gen_rules_for_class with args ('DataType', <class 'Lit_01.Lit_01.DataType'>, set()) {}
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . >  Returned []
Adding rule2:  AbstractNTRule()
for DataType to base_data_type | list_data_type | set_data_type | mapping_data_type
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'BaseDataType', <class 'Lit_01.Lit_01.BaseDataType'>) {}
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . <  Called by _gen_rules_for_class with args ('BaseDataType',) {}
[pom_grammar_generator.py:844 -     _generate_type_hierarchy_clause()] . . subtypes of BaseDataType are []
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . >  Returned None
[pom_grammar_generator.py:469 -                _gen_rules_for_class()] . Class BaseDataType is not abstract, generating own rule with clauses
[pom_grammar_generator.py:478 -                      _assess_fields()] . <  Called by _gen_rules_for_class with args (<class 'Lit_01.Lit_01.BaseDataType'>,) {}
[pom_grammar_generator.py:734 -                      _assess_fields()] . . Assessed: <class 'Lit_01.Lit_01.BaseDataType'>...
[pom_grammar_generator.py:735 -                      _assess_fields()] . . ... New fields for <class 'Lit_01.Lit_01.BaseDataType'> are {'is_value', 'class_name'}
[pom_grammar_generator.py:736 -                      _assess_fields()] . . ... Redefined fields for <class 'Lit_01.Lit_01.BaseDataType'> are set()
[pom_grammar_generator.py:737 -                      _assess_fields()] . . ... Inherited fields for <class 'Lit_01.Lit_01.BaseDataType'> are {'_type'}
[pom_grammar_generator.py:738 -                      _assess_fields()] . . ... Inherits from for <class 'Lit_01.Lit_01.BaseDataType'> are {'DataType'}
[pom_grammar_generator.py:478 -                      _assess_fields()] . >  Returned ({'is_value', 'class_name'}, set(), {'_type'}, {'DataType'})
[pom_grammar_generator.py:485 -                _gen_rules_for_class()] . Full template is {class_name} {? - {is_value}}
[pom_grammar_generator.py:486 -         _gen_full_class_by_template()] . <  Called by _gen_rules_for_class with args ('BaseDataType', PomTemplate({class_name} {? - {is_value}})) {}
[pom_grammar_generator.py:486 -         _gen_full_class_by_template()] . >  Returned base_data_type__class_name__value [ DASH base_data_type__is_value__value ]
[pom_grammar_generator.py:487 -                         find_fields()] . <  Called by _gen_rules_for_class with args () {}
[pom_grammar_generator.py:487 -                         find_fields()] . >  Returned {'is_value', 'class_name'}
Adding rule2:  AbstractNTRule()
for BaseDataType to base_data_type__class_name__value [ DASH base_data_type__is_value__value ]
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . <  Called by _gen_rules_for_class with args ('BaseDataType', <class 'Lit_01.Lit_01.BaseDataType'>, {'is_value', 'class_name'}) {}
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE', 'str': 'dull_str'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned STRING
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is ReferenceOrValue
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'class_pom_token.ReferenceOrValue'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned True
[class_field_type.py:259 -                        value_phrase()] . . . Presentable token
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned REFERENCE_OR_VALUE
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . >  Returned [AbstractRule(), AbstractRule()]
Value rule is: base_data_type__class_name__value: STRING
... added as base_data_type__class_name__value: STRING
Value rule is: base_data_type__is_value__value: REFERENCE_OR_VALUE
... added as base_data_type__is_value__value: REFERENCE_OR_VALUE
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'ListDataType', <class 'Lit_01.Lit_01.ListDataType'>) {}
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . <  Called by _gen_rules_for_class with args ('ListDataType',) {}
[pom_grammar_generator.py:844 -     _generate_type_hierarchy_clause()] . . subtypes of ListDataType are []
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . >  Returned None
[pom_grammar_generator.py:469 -                _gen_rules_for_class()] . Class ListDataType is not abstract, generating own rule with clauses
[pom_grammar_generator.py:478 -                      _assess_fields()] . <  Called by _gen_rules_for_class with args (<class 'Lit_01.Lit_01.ListDataType'>,) {}
[pom_grammar_generator.py:734 -                      _assess_fields()] . . Assessed: <class 'Lit_01.Lit_01.ListDataType'>...
[pom_grammar_generator.py:735 -                      _assess_fields()] . . ... New fields for <class 'Lit_01.Lit_01.ListDataType'> are {'element_type'}
[pom_grammar_generator.py:736 -                      _assess_fields()] . . ... Redefined fields for <class 'Lit_01.Lit_01.ListDataType'> are set()
[pom_grammar_generator.py:737 -                      _assess_fields()] . . ... Inherited fields for <class 'Lit_01.Lit_01.ListDataType'> are {'_type'}
[pom_grammar_generator.py:738 -                      _assess_fields()] . . ... Inherits from for <class 'Lit_01.Lit_01.ListDataType'> are {'DataType'}
[pom_grammar_generator.py:478 -                      _assess_fields()] . >  Returned ({'element_type'}, set(), {'_type'}, {'DataType'})
[pom_grammar_generator.py:485 -                _gen_rules_for_class()] . Full template is list of {element_type}
[pom_grammar_generator.py:486 -         _gen_full_class_by_template()] . <  Called by _gen_rules_for_class with args ('ListDataType', PomTemplate(list of {element_type})) {}
[pom_grammar_generator.py:486 -         _gen_full_class_by_template()] . >  Returned LIST_Q OF_Q list_data_type__element_type__value
[pom_grammar_generator.py:487 -                         find_fields()] . <  Called by _gen_rules_for_class with args () {}
[pom_grammar_generator.py:487 -                         find_fields()] . >  Returned {'element_type'}
Adding rule2:  AbstractNTRule()
for ListDataType to LIST_Q OF_Q list_data_type__element_type__value
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . <  Called by _gen_rules_for_class with args ('ListDataType', <class 'Lit_01.Lit_01.ListDataType'>, {'element_type'}) {}
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is DataType
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.DataType'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned False
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned data_type
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . >  Returned [AbstractRule()]
Value rule is: list_data_type__element_type__value: data_type
... added as list_data_type__element_type__value: data_type
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'MappingDataType', <class 'Lit_01.Lit_01.MappingDataType'>) {}
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . <  Called by _gen_rules_for_class with args ('MappingDataType',) {}
[pom_grammar_generator.py:844 -     _generate_type_hierarchy_clause()] . . subtypes of MappingDataType are []
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . >  Returned None
[pom_grammar_generator.py:469 -                _gen_rules_for_class()] . Class MappingDataType is not abstract, generating own rule with clauses
[pom_grammar_generator.py:478 -                      _assess_fields()] . <  Called by _gen_rules_for_class with args (<class 'Lit_01.Lit_01.MappingDataType'>,) {}
[pom_grammar_generator.py:734 -                      _assess_fields()] . . Assessed: <class 'Lit_01.Lit_01.MappingDataType'>...
[pom_grammar_generator.py:735 -                      _assess_fields()] . . ... New fields for <class 'Lit_01.Lit_01.MappingDataType'> are {'range_type', 'domain_type'}
[pom_grammar_generator.py:736 -                      _assess_fields()] . . ... Redefined fields for <class 'Lit_01.Lit_01.MappingDataType'> are set()
[pom_grammar_generator.py:737 -                      _assess_fields()] . . ... Inherited fields for <class 'Lit_01.Lit_01.MappingDataType'> are {'_type'}
[pom_grammar_generator.py:738 -                      _assess_fields()] . . ... Inherits from for <class 'Lit_01.Lit_01.MappingDataType'> are {'DataType'}
[pom_grammar_generator.py:478 -                      _assess_fields()] . >  Returned ({'range_type', 'domain_type'}, set(), {'_type'}, {'DataType'})
[pom_grammar_generator.py:485 -                _gen_rules_for_class()] . Full template is Mapping from {domain_type} to {range_type}
[pom_grammar_generator.py:486 -         _gen_full_class_by_template()] . <  Called by _gen_rules_for_class with args ('MappingDataType', PomTemplate(Mapping from {domain_type} to {range_type})) {}
[pom_grammar_generator.py:486 -         _gen_full_class_by_template()] . >  Returned MAPPING_Q FROM_Q mapping_data_type__domain_type__value TO_Q mapping_data_type__range_type__value
[pom_grammar_generator.py:487 -                         find_fields()] . <  Called by _gen_rules_for_class with args () {}
[pom_grammar_generator.py:487 -                         find_fields()] . >  Returned {'range_type', 'domain_type'}
Adding rule2:  AbstractNTRule()
for MappingDataType to MAPPING_Q FROM_Q mapping_data_type__domain_type__value TO_Q mapping_data_type__range_type__value
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . <  Called by _gen_rules_for_class with args ('MappingDataType', <class 'Lit_01.Lit_01.MappingDataType'>, {'range_type', 'domain_type'}) {}
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is DataType
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.DataType'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned False
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned data_type
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is DataType
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.DataType'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned False
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned data_type
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . >  Returned [AbstractRule(), AbstractRule()]
Value rule is: mapping_data_type__domain_type__value: data_type
... added as mapping_data_type__domain_type__value: data_type
Value rule is: mapping_data_type__range_type__value: data_type
... added as mapping_data_type__range_type__value: data_type
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'SetDataType', <class 'Lit_01.Lit_01.SetDataType'>) {}
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . <  Called by _gen_rules_for_class with args ('SetDataType',) {}
[pom_grammar_generator.py:844 -     _generate_type_hierarchy_clause()] . . subtypes of SetDataType are []
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . >  Returned None
[pom_grammar_generator.py:469 -                _gen_rules_for_class()] . Class SetDataType is not abstract, generating own rule with clauses
[pom_grammar_generator.py:478 -                      _assess_fields()] . <  Called by _gen_rules_for_class with args (<class 'Lit_01.Lit_01.SetDataType'>,) {}
[pom_grammar_generator.py:734 -                      _assess_fields()] . . Assessed: <class 'Lit_01.Lit_01.SetDataType'>...
[pom_grammar_generator.py:735 -                      _assess_fields()] . . ... New fields for <class 'Lit_01.Lit_01.SetDataType'> are {'element_type'}
[pom_grammar_generator.py:736 -                      _assess_fields()] . . ... Redefined fields for <class 'Lit_01.Lit_01.SetDataType'> are set()
[pom_grammar_generator.py:737 -                      _assess_fields()] . . ... Inherited fields for <class 'Lit_01.Lit_01.SetDataType'> are {'_type'}
[pom_grammar_generator.py:738 -                      _assess_fields()] . . ... Inherits from for <class 'Lit_01.Lit_01.SetDataType'> are {'DataType'}
[pom_grammar_generator.py:478 -                      _assess_fields()] . >  Returned ({'element_type'}, set(), {'_type'}, {'DataType'})
[pom_grammar_generator.py:485 -                _gen_rules_for_class()] . Full template is Set of {element_type}
[pom_grammar_generator.py:486 -         _gen_full_class_by_template()] . <  Called by _gen_rules_for_class with args ('SetDataType', PomTemplate(Set of {element_type})) {}
[pom_grammar_generator.py:486 -         _gen_full_class_by_template()] . >  Returned SET_Q OF_Q set_data_type__element_type__value
[pom_grammar_generator.py:487 -                         find_fields()] . <  Called by _gen_rules_for_class with args () {}
[pom_grammar_generator.py:487 -                         find_fields()] . >  Returned {'element_type'}
Adding rule2:  AbstractNTRule()
for SetDataType to SET_Q OF_Q set_data_type__element_type__value
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . <  Called by _gen_rules_for_class with args ('SetDataType', <class 'Lit_01.Lit_01.SetDataType'>, {'element_type'}) {}
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is DataType
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.DataType'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned False
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned data_type
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . >  Returned [AbstractRule()]
Value rule is: set_data_type__element_type__value: data_type
... added as set_data_type__element_type__value: data_type
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'DataTypeClause', <class 'Lit_01.Lit_01.DataTypeClause'>) {}
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . <  Called by _gen_rules_for_class with args ('DataTypeClause',) {}
[pom_grammar_generator.py:844 -     _generate_type_hierarchy_clause()] . . subtypes of DataTypeClause are []
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . >  Returned None
[pom_grammar_generator.py:469 -                _gen_rules_for_class()] . Class DataTypeClause is not abstract, generating own rule with clauses
[pom_grammar_generator.py:478 -                      _assess_fields()] . <  Called by _gen_rules_for_class with args (<class 'Lit_01.Lit_01.DataTypeClause'>,) {}
[pom_grammar_generator.py:734 -                      _assess_fields()] . . Assessed: <class 'Lit_01.Lit_01.DataTypeClause'>...
[pom_grammar_generator.py:735 -                      _assess_fields()] . . ... New fields for <class 'Lit_01.Lit_01.DataTypeClause'> are {'_type', 'cardinality', 'is_optional', 'data_type', 'is_required', 'is_also_optional'}
[pom_grammar_generator.py:736 -                      _assess_fields()] . . ... Redefined fields for <class 'Lit_01.Lit_01.DataTypeClause'> are set()
[pom_grammar_generator.py:737 -                      _assess_fields()] . . ... Inherited fields for <class 'Lit_01.Lit_01.DataTypeClause'> are set()
[pom_grammar_generator.py:738 -                      _assess_fields()] . . ... Inherits from for <class 'Lit_01.Lit_01.DataTypeClause'> are set()
[pom_grammar_generator.py:478 -                      _assess_fields()] . >  Returned ({'_type', 'cardinality', 'is_optional', 'data_type', 'is_required', 'is_also_optional'}, set(), set(), set())
[pom_grammar_generator.py:485 -                _gen_rules_for_class()] . Full template is {is_optional} {data_type}{? {cardinality}}
[pom_grammar_generator.py:486 -         _gen_full_class_by_template()] . <  Called by _gen_rules_for_class with args ('DataTypeClause', PomTemplate({is_optional} {data_type}{? {cardinality}})) {}
[pom_grammar_generator.py:486 -         _gen_full_class_by_template()] . >  Returned data_type_clause__is_optional__value data_type_clause__data_type__value [ data_type_clause__cardinality__value ]
[pom_grammar_generator.py:487 -                         find_fields()] . <  Called by _gen_rules_for_class with args () {}
[pom_grammar_generator.py:487 -                         find_fields()] . >  Returned {'data_type', 'cardinality', 'is_optional'}
Adding rule2:  AbstractNTRule()
for DataTypeClause to data_type_clause__is_optional__value data_type_clause__data_type__value [ data_type_clause__cardinality__value ]
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . <  Called by _gen_rules_for_class with args ('DataTypeClause', <class 'Lit_01.Lit_01.DataTypeClause'>, {'data_type', 'cardinality', 'is_optional'}) {}
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is DataType
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.DataType'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned False
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned data_type
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'bool': {'true': 'optional', 'false': 'required', 'is_explicit': False}, 'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned BOOLEAN
[pom_grammar_generator.py:824 -                        value_phrase()] . . <  Called by _generate_field_value_rule with args ({'field_value': '{field_name} COLON {field_value} NEWLINE', 'str': 'dull_str'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[pom_grammar_generator.py:824 -                        value_phrase()] . . >  Returned STRING
[pom_grammar_generator.py:566 -              _gen_field_value_rules()] . >  Returned [AbstractRule(), AbstractRule(), AbstractRule()]
Value rule is: data_type_clause__data_type__value: data_type
... added as data_type_clause__data_type__value: data_type
Value rule is: data_type_clause__is_optional__value: BOOLEAN
... added as data_type_clause__is_optional__value: BOOLEAN
Value rule is: data_type_clause__cardinality__value: STRING
... added as data_type_clause__cardinality__value: STRING
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'Emoji', <class 'class_pom_token.Emoji'>) {}
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'Formula', <class 'Lit_01.Lit_01.Formula'>) {}
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . <  Called by _gen_rules_for_class with args ('Formula',) {}
[pom_grammar_generator.py:844 -     _generate_type_hierarchy_clause()] . . subtypes of Formula are ['Constraint', 'Derivation', 'Default']
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . >  Returned constraint | derivation | default
[pom_grammar_generator.py:469 -                _gen_rules_for_class()] . Class Formula is not abstract, generating own rule with clauses
[pom_grammar_generator.py:478 -                      _assess_fields()] . <  Called by _gen_rules_for_class with args (<class 'Lit_01.Lit_01.Formula'>,) {}
[pom_grammar_generator.py:734 -                      _assess_fields()] . . Assessed: <class 'Lit_01.Lit_01.Formula'>...
[pom_grammar_generator.py:735 -                      _assess_fields()] . . ... New fields for <class 'Lit_01.Lit_01.Formula'> are {'english', '_type', 'code', '_as_entered'}
[pom_grammar_generator.py:736 -                      _assess_fields()] . . ... Redefined fields for <class 'Lit_01.Lit_01.Formula'> are set()
[pom_grammar_generator.py:737 -                      _assess_fields()] . . ... Inherited fields for <class 'Lit_01.Lit_01.Formula'> are set()
[pom_grammar_generator.py:738 -                      _assess_fields()] . . ... Inherits from for <class 'Lit_01.Lit_01.Formula'> are set()
[pom_grammar_generator.py:478 -                      _assess_fields()] . >  Returned ({'english', '_type', 'code', '_as_entered'}, set(), set(), set())
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . <  Called by _gen_rules_for_class with args ('Formula', <class 'Lit_01.Lit_01.Formula'>, set()) {}
[pom_grammar_generator.py:780 -                        value_phrase()] . . <  Called by _generate_field_clause with args ({'field_value': '{field_name} COLON {field_value} NEWLINE', 'str': 'dull_str'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[pom_grammar_generator.py:780 -                        value_phrase()] . . >  Returned STRING
[pom_grammar_generator.py:780 -                        value_phrase()] . . <  Called by _generate_field_clause with args ({'field_value': '{field_name} COLON {field_value} NEWLINE'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[class_field_type.py:257 -                        value_phrase()] . . . raw string is FormulaCoding
[class_field_type.py:258 -                is_presentable_token()] . . . <  Called by value_phrase with args () {}
[class_field_type.py:293 -                is_presentable_token()] . . . . class from hierarchy is <class 'Lit_01.Lit_01.FormulaCoding'>
[class_field_type.py:258 -                is_presentable_token()] . . . >  Returned False
[pom_grammar_generator.py:780 -                        value_phrase()] . . >  Returned formula_coding
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . >  Returned [AbstractClause(clause_text='ENGLISH_QF COLON STRING NEWLINE', node_name='formula__english__str', full_text='ENGLISH_QF COLON STRING NEWLINE -> formula__english__str'), AbstractClause(clause_text='CODE_QF COLON formula_coding NEWLINE', node_name='formula__code__simple', full_text='CODE_QF COLON formula_coding NEWLINE -> formula__code__simple')]
[pom_grammar_generator.py:521 -                _gen_rules_for_class()] . Field clauses for Formula are [AbstractClause(clause_text='ENGLISH_QF COLON STRING NEWLINE', node_name='formula__english__str', full_text='ENGLISH_QF COLON STRING NEWLINE -> formula__english__str'), AbstractClause(clause_text='CODE_QF COLON formula_coding NEWLINE', node_name='formula__code__simple', full_text='CODE_QF COLON formula_coding NEWLINE -> formula__code__simple')]
body_clause is  AbstractDisjunction(clause_text='', node_name='', full_text='ENGLISH_QF COLON STRING NEWLINE -> formula__english__str\n\t\t|\tCODE_QF COLON formula_coding NEWLINE -> formula__code__simple', disjuncts=[AbstractClause(clause_text='ENGLISH_QF COLON STRING NEWLINE', node_name='formula__english__str', full_text='ENGLISH_QF COLON STRING NEWLINE -> formula__english__str'), AbstractClause(clause_text='CODE_QF COLON formula_coding NEWLINE', node_name='formula__code__simple', full_text='CODE_QF COLON formula_coding NEWLINE -> formula__code__simple')])
Adding rule2:  AbstractNTRule()
for formula_clause to ENGLISH_QF COLON STRING NEWLINE -> formula__english__str
		|	CODE_QF COLON formula_coding NEWLINE -> formula__code__simple
Adding rule2:  AbstractNTRule()
for Formula to constraint | derivation | default
		|	( formula_clause )+
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'Constraint', <class 'Lit_01.Lit_01.Constraint'>) {}
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . <  Called by _gen_rules_for_class with args ('Constraint',) {}
[pom_grammar_generator.py:844 -     _generate_type_hierarchy_clause()] . . subtypes of Constraint are []
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . >  Returned None
[pom_grammar_generator.py:469 -                _gen_rules_for_class()] . Class Constraint is not abstract, generating own rule with clauses
[pom_grammar_generator.py:478 -                      _assess_fields()] . <  Called by _gen_rules_for_class with args (<class 'Lit_01.Lit_01.Constraint'>,) {}
[pom_grammar_generator.py:734 -                      _assess_fields()] . . Assessed: <class 'Lit_01.Lit_01.Constraint'>...
[pom_grammar_generator.py:735 -                      _assess_fields()] . . ... New fields for <class 'Lit_01.Lit_01.Constraint'> are {'message', 'severity'}
[pom_grammar_generator.py:736 -                      _assess_fields()] . . ... Redefined fields for <class 'Lit_01.Lit_01.Constraint'> are set()
[pom_grammar_generator.py:737 -                      _assess_fields()] . . ... Inherited fields for <class 'Lit_01.Lit_01.Constraint'> are {'english', '_type', 'code', '_as_entered'}
[pom_grammar_generator.py:738 -                      _assess_fields()] . . ... Inherits from for <class 'Lit_01.Lit_01.Constraint'> are {'Formula'}
[pom_grammar_generator.py:478 -                      _assess_fields()] . >  Returned ({'message', 'severity'}, set(), {'english', '_type', 'code', '_as_entered'}, {'Formula'})
[pom_grammar_generator.py:517 -                _gen_rules_for_class()] . Ancestor clauses for Constraint are [AbstractClause(clause_text='formula_clause', node_name='', full_text='formula_clause')]
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . <  Called by _gen_rules_for_class with args ('Constraint', <class 'Lit_01.Lit_01.Constraint'>, {'english', '_type', 'code', '_as_entered'}) {}
[pom_grammar_generator.py:780 -                        value_phrase()] . . <  Called by _generate_field_clause with args ({'field_value': '{field_name} COLON {field_value} NEWLINE', 'str': 'dull_str'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[pom_grammar_generator.py:780 -                        value_phrase()] . . >  Returned STRING
[pom_grammar_generator.py:780 -                        value_phrase()] . . <  Called by _generate_field_clause with args ({'field_value': '{field_name} COLON {field_value} NEWLINE', 'str': 'dull_str'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[pom_grammar_generator.py:780 -                        value_phrase()] . . >  Returned STRING
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . >  Returned [AbstractClause(clause_text='MESSAGE_QF COLON STRING NEWLINE', node_name='constraint__message__str', full_text='MESSAGE_QF COLON STRING NEWLINE -> constraint__message__str'), AbstractClause(clause_text='SEVERITY_QF COLON STRING NEWLINE', node_name='constraint__severity__str', full_text='SEVERITY_QF COLON STRING NEWLINE -> constraint__severity__str')]
[pom_grammar_generator.py:521 -                _gen_rules_for_class()] . Field clauses for Constraint are [AbstractClause(clause_text='MESSAGE_QF COLON STRING NEWLINE', node_name='constraint__message__str', full_text='MESSAGE_QF COLON STRING NEWLINE -> constraint__message__str'), AbstractClause(clause_text='SEVERITY_QF COLON STRING NEWLINE', node_name='constraint__severity__str', full_text='SEVERITY_QF COLON STRING NEWLINE -> constraint__severity__str')]
body_clause is  AbstractDisjunction(clause_text='', node_name='', full_text='formula_clause\n\t\t|\tMESSAGE_QF COLON STRING NEWLINE -> constraint__message__str\n\t\t|\tSEVERITY_QF COLON STRING NEWLINE -> constraint__severity__str', disjuncts=[AbstractClause(clause_text='formula_clause', node_name='', full_text='formula_clause'), AbstractClause(clause_text='MESSAGE_QF COLON STRING NEWLINE', node_name='constraint__message__str', full_text='MESSAGE_QF COLON STRING NEWLINE -> constraint__message__str'), AbstractClause(clause_text='SEVERITY_QF COLON STRING NEWLINE', node_name='constraint__severity__str', full_text='SEVERITY_QF COLON STRING NEWLINE -> constraint__severity__str')])
Adding rule2:  AbstractNTRule()
for constraint_clause to formula_clause
		|	MESSAGE_QF COLON STRING NEWLINE -> constraint__message__str
		|	SEVERITY_QF COLON STRING NEWLINE -> constraint__severity__str
Adding rule2:  AbstractNTRule()
for Constraint to ( constraint_clause )+
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'Default', <class 'Lit_01.Lit_01.Default'>) {}
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . <  Called by _gen_rules_for_class with args ('Default',) {}
[pom_grammar_generator.py:844 -     _generate_type_hierarchy_clause()] . . subtypes of Default are []
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . >  Returned None
[pom_grammar_generator.py:469 -                _gen_rules_for_class()] . Class Default is not abstract, generating own rule with clauses
[pom_grammar_generator.py:478 -                      _assess_fields()] . <  Called by _gen_rules_for_class with args (<class 'Lit_01.Lit_01.Default'>,) {}
[pom_grammar_generator.py:734 -                      _assess_fields()] . . Assessed: <class 'Lit_01.Lit_01.Default'>...
[pom_grammar_generator.py:735 -                      _assess_fields()] . . ... New fields for <class 'Lit_01.Lit_01.Default'> are set()
[pom_grammar_generator.py:736 -                      _assess_fields()] . . ... Redefined fields for <class 'Lit_01.Lit_01.Default'> are set()
[pom_grammar_generator.py:737 -                      _assess_fields()] . . ... Inherited fields for <class 'Lit_01.Lit_01.Default'> are {'english', '_type', 'code', '_as_entered'}
[pom_grammar_generator.py:738 -                      _assess_fields()] . . ... Inherits from for <class 'Lit_01.Lit_01.Default'> are {'Formula'}
[pom_grammar_generator.py:478 -                      _assess_fields()] . >  Returned (set(), set(), {'english', '_type', 'code', '_as_entered'}, {'Formula'})
[pom_grammar_generator.py:517 -                _gen_rules_for_class()] . Ancestor clauses for Default are [AbstractClause(clause_text='formula_clause', node_name='', full_text='formula_clause')]
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . <  Called by _gen_rules_for_class with args ('Default', <class 'Lit_01.Lit_01.Default'>, {'english', '_type', 'code', '_as_entered'}) {}
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . >  Returned []
Adding rule2:  AbstractNTRule()
for Default to ( formula_clause )+
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'Derivation', <class 'Lit_01.Lit_01.Derivation'>) {}
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . <  Called by _gen_rules_for_class with args ('Derivation',) {}
[pom_grammar_generator.py:844 -     _generate_type_hierarchy_clause()] . . subtypes of Derivation are []
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . >  Returned None
[pom_grammar_generator.py:469 -                _gen_rules_for_class()] . Class Derivation is not abstract, generating own rule with clauses
[pom_grammar_generator.py:478 -                      _assess_fields()] . <  Called by _gen_rules_for_class with args (<class 'Lit_01.Lit_01.Derivation'>,) {}
[pom_grammar_generator.py:734 -                      _assess_fields()] . . Assessed: <class 'Lit_01.Lit_01.Derivation'>...
[pom_grammar_generator.py:735 -                      _assess_fields()] . . ... New fields for <class 'Lit_01.Lit_01.Derivation'> are set()
[pom_grammar_generator.py:736 -                      _assess_fields()] . . ... Redefined fields for <class 'Lit_01.Lit_01.Derivation'> are set()
[pom_grammar_generator.py:737 -                      _assess_fields()] . . ... Inherited fields for <class 'Lit_01.Lit_01.Derivation'> are {'english', '_type', 'code', '_as_entered'}
[pom_grammar_generator.py:738 -                      _assess_fields()] . . ... Inherits from for <class 'Lit_01.Lit_01.Derivation'> are {'Formula'}
[pom_grammar_generator.py:478 -                      _assess_fields()] . >  Returned (set(), set(), {'english', '_type', 'code', '_as_entered'}, {'Formula'})
[pom_grammar_generator.py:517 -                _gen_rules_for_class()] . Ancestor clauses for Derivation are [AbstractClause(clause_text='formula_clause', node_name='', full_text='formula_clause')]
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . <  Called by _gen_rules_for_class with args ('Derivation', <class 'Lit_01.Lit_01.Derivation'>, {'english', '_type', 'code', '_as_entered'}) {}
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . >  Returned []
Adding rule2:  AbstractNTRule()
for Derivation to ( formula_clause )+
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'FormulaCoding', <class 'Lit_01.Lit_01.FormulaCoding'>) {}
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . <  Called by _gen_rules_for_class with args ('FormulaCoding',) {}
[pom_grammar_generator.py:844 -     _generate_type_hierarchy_clause()] . . subtypes of FormulaCoding are []
[pom_grammar_generator.py:463 -     _generate_type_hierarchy_clause()] . >  Returned None
[pom_grammar_generator.py:469 -                _gen_rules_for_class()] . Class FormulaCoding is not abstract, generating own rule with clauses
[pom_grammar_generator.py:478 -                      _assess_fields()] . <  Called by _gen_rules_for_class with args (<class 'Lit_01.Lit_01.FormulaCoding'>,) {}
[pom_grammar_generator.py:734 -                      _assess_fields()] . . Assessed: <class 'Lit_01.Lit_01.FormulaCoding'>...
[pom_grammar_generator.py:735 -                      _assess_fields()] . . ... New fields for <class 'Lit_01.Lit_01.FormulaCoding'> are {'content', '_type'}
[pom_grammar_generator.py:736 -                      _assess_fields()] . . ... Redefined fields for <class 'Lit_01.Lit_01.FormulaCoding'> are set()
[pom_grammar_generator.py:737 -                      _assess_fields()] . . ... Inherited fields for <class 'Lit_01.Lit_01.FormulaCoding'> are set()
[pom_grammar_generator.py:738 -                      _assess_fields()] . . ... Inherits from for <class 'Lit_01.Lit_01.FormulaCoding'> are set()
[pom_grammar_generator.py:478 -                      _assess_fields()] . >  Returned ({'content', '_type'}, set(), set(), set())
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . <  Called by _gen_rules_for_class with args ('FormulaCoding', <class 'Lit_01.Lit_01.FormulaCoding'>, set()) {}
[pom_grammar_generator.py:780 -                        value_phrase()] . . <  Called by _generate_field_clause with args ({'field_value': '{field_name} COLON {field_value} NEWLINE', 'str': 'dull_str'},) {}
[class_field_type.py:253 -                        value_phrase()] . . . In value phrase for simple type
[pom_grammar_generator.py:780 -                        value_phrase()] . . >  Returned STRING
[pom_grammar_generator.py:519 -                  _gen_field_clauses()] . >  Returned [AbstractClause(clause_text='CONTENT_QF COLON STRING NEWLINE', node_name='formula_coding__content__str', full_text='CONTENT_QF COLON STRING NEWLINE -> formula_coding__content__str')]
[pom_grammar_generator.py:521 -                _gen_rules_for_class()] . Field clauses for FormulaCoding are [AbstractClause(clause_text='CONTENT_QF COLON STRING NEWLINE', node_name='formula_coding__content__str', full_text='CONTENT_QF COLON STRING NEWLINE -> formula_coding__content__str')]
body_clause is  AbstractDisjunction(clause_text='', node_name='', full_text='CONTENT_QF COLON STRING NEWLINE -> formula_coding__content__str', disjuncts=[AbstractClause(clause_text='CONTENT_QF COLON STRING NEWLINE', node_name='formula_coding__content__str', full_text='CONTENT_QF COLON STRING NEWLINE -> formula_coding__content__str')])
Adding rule2:  AbstractNTRule()
for formula_coding_clause to CONTENT_QF COLON STRING NEWLINE -> formula_coding__content__str
Adding rule2:  AbstractNTRule()
for FormulaCoding to ( formula_coding_clause )+
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'IsOptional', <class 'class_pom_token.IsOptional'>) {}
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'IsReallyRequired', <class 'class_pom_token.IsReallyRequired'>) {}
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'OneLiner', <class 'Lit_01.Lit_01.OneLiner'>) {}
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'Paragraph', <class 'Lit_01.Lit_01.Paragraph'>) {}
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] <  Called by _generate_grammar_classes with args (AbstractSection(), 'ReferenceOrValue', <class 'class_pom_token.ReferenceOrValue'>) {}
[pom_grammar_generator.py:433 -                _gen_rules_for_class()] >  Returned None
case_insensitive is i!
[pom_grammar_generator.py:377 -      _generate_grammar_class_tokens()] Token pattern: "optional"i | "true"i | "sure"i | "yes"i | "required"i | "false"i | "no way"i
[pom_grammar_generator.py:377 -      _generate_grammar_class_tokens()] Token pattern: "reference"i | "value"i
[pom_grammar_generator.py:377 -      _generate_grammar_class_tokens()] Token pattern: "required"i | "true"i | "sure"i | "yes"i | "optional"i | "false"i | "no way"i
[pom_grammar_generator.py:396 -      _generate_grammar_class_tokens()] Token pattern: /(?:[A-Za-z][A-Za-z0-9]*)(?:\s+(?:[A-Za-z][A-Za-z0-9]*))*/
[pom_grammar_generator.py:403 -      _generate_grammar_class_tokens()] Bases of Presentable token UpperCamel are ['CamelCase']
[pom_grammar_generator.py:407 -      _generate_grammar_class_tokens()] .. and base cls is <class 'class_casing.CamelCase'>
[pom_grammar_generator.py:409 -      _generate_grammar_class_tokens()] .. and base pattern is /(?:[A-Za-z][A-Za-z0-9]*)(?:\s+(?:[A-Za-z][A-Za-z0-9]*))*/
[pom_grammar_generator.py:396 -      _generate_grammar_class_tokens()] Token pattern: /(?:[A-Za-z][A-Za-z0-9]*)(?:\s+(?:[A-Za-z][A-Za-z0-9]*))*/
[pom_grammar_generator.py:403 -      _generate_grammar_class_tokens()] Bases of Presentable token LowerCamel are ['CamelCase']
[pom_grammar_generator.py:407 -      _generate_grammar_class_tokens()] .. and base cls is <class 'class_casing.CamelCase'>
[pom_grammar_generator.py:409 -      _generate_grammar_class_tokens()] .. and base pattern is /(?:[A-Za-z][A-Za-z0-9]*)(?:\s+(?:[A-Za-z][A-Za-z0-9]*))*/
[pom_grammar_generator.py:396 -      _generate_grammar_class_tokens()] Token pattern: /(?:[A-Za-z][A-Za-z0-9]*)(?:\s+(?:[A-Za-z][A-Za-z0-9]*))*/
[pom_grammar_generator.py:403 -      _generate_grammar_class_tokens()] Bases of Presentable token CamelCase are []
[pom_grammar_generator.py:396 -      _generate_grammar_class_tokens()] Token pattern: /\d+(.*?)[\u263a-\U0001f645]/
[pom_grammar_generator.py:403 -      _generate_grammar_class_tokens()] Bases of Presentable token Emoji are []
[pom_grammar_generator.py:396 -      _generate_grammar_class_tokens()] Token pattern: /<<<.*>>>/
[pom_grammar_generator.py:403 -      _generate_grammar_class_tokens()] Bases of Presentable token Paragraph are []
[pom_grammar_generator.py:396 -      _generate_grammar_class_tokens()] Token pattern: /<<<.*>>>/
[pom_grammar_generator.py:403 -      _generate_grammar_class_tokens()] Bases of Presentable token OneLiner are []
[pom_grammar_generator.py:396 -      _generate_grammar_class_tokens()] Token pattern: /(?:[A-Za-z][A-Za-z0-9]*)(?:\s+(?:[A-Za-z][A-Za-z0-9]*))*/
[pom_grammar_generator.py:403 -      _generate_grammar_class_tokens()] Bases of Presentable token ClassName are ['UpperCamel']
[pom_grammar_generator.py:407 -      _generate_grammar_class_tokens()] .. and base cls is <class 'class_casing.UpperCamel'>
[pom_grammar_generator.py:409 -      _generate_grammar_class_tokens()] .. and base pattern is /(?:[A-Za-z][A-Za-z0-9]*)(?:\s+(?:[A-Za-z][A-Za-z0-9]*))*/
[pom_grammar_generator.py:396 -      _generate_grammar_class_tokens()] Token pattern: /(?:[A-Za-z][A-Za-z0-9]*)(?:\s+(?:[A-Za-z][A-Za-z0-9]*))*/
[pom_grammar_generator.py:403 -      _generate_grammar_class_tokens()] Bases of Presentable token Label are ['UpperCamel']
[pom_grammar_generator.py:407 -      _generate_grammar_class_tokens()] .. and base cls is <class 'class_casing.UpperCamel'>
[pom_grammar_generator.py:409 -      _generate_grammar_class_tokens()] .. and base pattern is /(?:[A-Za-z][A-Za-z0-9]*)(?:\s+(?:[A-Za-z][A-Za-z0-9]*))*/
Field terminals:  {'MAPPING_Q', 'VALUETYPE_Q', 'TO_Q', 'LIST_Q', 'OF_Q', 'COMPONENT_Q', 'FIELDVALUE_Q', 'SET_Q', 'FROM_Q'}
Punctuation used:  {'LBRACE', 'NEWLINE', 'UNDERSCORE', 'HASH', 'RPAREN', 'DASH', 'LPAREN', 'COLON'}
RHS is  'annotation\n\t\t|\tcomponent\n\t\t|\tdata_type\n\t\t|\tdata_type_clause\n\t\t|\tformula_coding\n\t\t|\tformula'
RHS is  'start+\t// For any number of any NT'
RHS is  '[ annotation__emoji__value ] annotation__label__value COLON annotation__content__value NEWLINE'
RHS is  'COMPONENT_Q COLON component__name__value [ DASH component__one_liner__value ] NEWLINE'
RHS is  'NAME_QF COLON CAMEL_CASE NEWLINE -> component__name__simple\n\t\t|\tONE_LINER_QF COLON ONE_LINER NEWLINE -> component__one_liner__simple\n\t\t|\tABBREVIATION_QF COLON UPPER_CAMEL NEWLINE -> component__abbreviation__simple\n\t\t|\tPARAGRAPH+ -> component__elaboration__list\n\t\t|\tannotation+ -> component__annotations__list'
RHS is  'subject_e | class | attribute_section | attribute\n\t\t|\tcomponent_header  (component_clause)*'
RHS is  'DASH attribute__name__value [ DASH attribute__one_liner__value ] [ LPAREN attribute__data_type_clause__value RPAREN ] NEWLINE'
RHS is  'component_clause\n\t\t|\tNAME_QF COLON LOWER_CAMEL NEWLINE -> attribute__name__simple\n\t\t|\tDATA_TYPE_CLAUSE_QF COLON data_type_clause NEWLINE -> attribute__data_type_clause__simple\n\t\t|\tDERIVATION_QF COLON derivation NEWLINE -> attribute__derivation__simple\n\t\t|\tDEFAULT_QF COLON default NEWLINE -> attribute__default__simple\n\t\t|\tconstraint+ -> attribute__constraints__list'
RHS is  'attribute_header  (attribute_clause)*'
RHS is  'DASH attribute_section__name__value [ DASH attribute_section__one_liner__value ] [ LPAREN attribute_section__is_required__value RPAREN ] NEWLINE'
RHS is  'component_clause\n\t\t|\tIS_REQUIRED_QF COLON IS_REALLY_REQUIRED NEWLINE -> attribute_section__is_required__simple\n\t\t|\tattribute+ -> attribute_section__attributes__list'
RHS is  'attribute_section_header  (attribute_section_clause)*'
RHS is  'UNDERSCORE class__name__value [ DASH class__one_liner__value ] NEWLINE'
RHS is  'component_clause\n\t\t|\tNAME_QF COLON UPPER_CAMEL NEWLINE -> class__name__simple\n\t\t|\tPLURAL_QF COLON UPPER_CAMEL NEWLINE -> class__plural__simple\n\t\t|\tSUBTYPE_OF_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__subtype_of__list\n\t\t|\tSUBTYPES_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__subtypes__list\n\t\t|\tBASED_ON_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__based_on__list\n\t\t|\tDEPENDENTS_QF COLON CLASS_NAME (COMMA CLASS_NAME)* NEWLINE -> class__dependents__list\n\t\t|\tIS_VALUE_TYPE_QF COLON BOOLEAN NEWLINE -> class__is_value_type__bool\n\t\t|\tWHERE_QF COLON ONE_LINER NEWLINE -> class__where__simple\n\t\t|\tattribute+ -> class__attributes__list\n\t\t|\tattribute_section+ -> class__attribute_sections__list'
RHS is  'value_type | reference_type\n\t\t|\tclass_header  (class_clause)*'
RHS is  'UNDERSCORE reference_type__name__value [ DASH reference_type__one_liner__value ] NEWLINE'
RHS is  'reference_type_header  (class_clause)*'
RHS is  'UNDERSCORE VALUETYPE_Q COLON value_type__name__value [ DASH value_type__one_liner__value ] NEWLINE'
RHS is  'value_type_header  (class_clause)*'
RHS is  'HASH HASH HASH HASH HASH LBRACE subject_e__name__value [ DASH subject_e__one_liner__value ] NEWLINE'
RHS is  'component_clause\n\t\t|\tclass+ -> subject_e__classes__list'
RHS is  'subject_d\n\t\t|\tsubject_e_header  (subject_e_clause)*'
RHS is  'HASH HASH HASH HASH LBRACE subject_d__name__value [ DASH subject_d__one_liner__value ] NEWLINE'
RHS is  'subject_e_clause\n\t\t|\tsubject_e+ -> subject_d__subjects__list'
RHS is  'subject_c\n\t\t|\tsubject_d_header  (subject_d_clause)*'
RHS is  'HASH HASH HASH LBRACE subject_c__name__value [ DASH subject_c__one_liner__value ] NEWLINE'
RHS is  'subject_d_clause\n\t\t|\tsubject_d+ -> subject_c__subjects__list'
RHS is  'subject_b\n\t\t|\tsubject_c_header  (subject_c_clause)*'
RHS is  'HASH HASH LBRACE subject_b__name__value [ DASH subject_b__one_liner__value ] NEWLINE'
RHS is  'subject_c_clause\n\t\t|\tsubject_c+ -> subject_b__subjects__list'
RHS is  'ldm\n\t\t|\tsubject_b_header  (subject_b_clause)*'
RHS is  'HASH LBRACE ldm__name__value [ DASH ldm__one_liner__value ] NEWLINE'
RHS is  'subject_b_clause\n\t\t|\tsubject_b+ -> ldm__subjects__list'
RHS is  'ldm_header  (ldm_clause)*'
RHS is  'base_data_type | list_data_type | set_data_type | mapping_data_type'
RHS is  'base_data_type__class_name__value [ DASH base_data_type__is_value__value ]'
RHS is  'LIST_Q OF_Q list_data_type__element_type__value'
RHS is  'MAPPING_Q FROM_Q mapping_data_type__domain_type__value TO_Q mapping_data_type__range_type__value'
RHS is  'SET_Q OF_Q set_data_type__element_type__value'
RHS is  'data_type_clause__is_optional__value data_type_clause__data_type__value [ data_type_clause__cardinality__value ]'
RHS is  'ENGLISH_QF COLON STRING NEWLINE -> formula__english__str\n\t\t|\tCODE_QF COLON formula_coding NEWLINE -> formula__code__simple'
RHS is  'constraint | derivation | default\n\t\t|\t( formula_clause )+'
RHS is  'formula_clause\n\t\t|\tMESSAGE_QF COLON STRING NEWLINE -> constraint__message__str\n\t\t|\tSEVERITY_QF COLON STRING NEWLINE -> constraint__severity__str'
RHS is  '( constraint_clause )+'
RHS is  '( formula_clause )+'
RHS is  '( formula_clause )+'
RHS is  'CONTENT_QF COLON STRING NEWLINE -> formula_coding__content__str'
RHS is  '( formula_coding_clause )+'
======================
  find_terminal_conflicts   
======================
======================
  find_rule_overlaps   
======================
SKIPPING OVERLAPS
[pom_grammar.py:214 -                          save_rules()] Saved grammar rules to C:\Users\fmkat\OneDrive\AllFMKFIles\AllVSCode\FMKProjects\Presentable\models\Lit_01\Lit_01_dull_grammar.lark
[pom_grammar.py:235 -                      save_templates()] Saved templates to C:\Users\fmkat\OneDrive\AllFMKFIles\AllVSCode\FMKProjects\Presentable\models\Lit_01\Lit_01_dull_templates.hbs
[pom_grammar.py:84 -                            __init__()] PresentableGrammar initialization complete
[do_pom_test.py:14 -                            test_pom()] Grammar created
<pom_grammar.PresentableGrammar object at 0x000002014F095A90>
[do_pom_test.py:18 -                            test_pom()] Trying file models/Lit_01/SamplerClass.md
Text is:  _ SampleClassB - with text and maybe two lines 
dependents: Abc, Def,
  XYZ
abbreviation: CSample
subtype of: B, C, D
subtype of: B

====

dependents: Abc, Def
subtypeof: SampleClassB
subtype of: B, C, D

- color - blue
- flavor - lime

_ SecondClass - with its own comment
subtypes: X, Y, Z 
suggestion: Why not do something but only one line works 
dependents: Abc, Def
based on: Something, SomethingElse
=====
plural: BSamples
where: A = B
- color - blue
- flavor - lime
=====



Lines are: (29)

 _ SampleClassB - with text and maybe two lines 

 dependents: Abc, Def,

   XYZ

 abbreviation: CSample

 subtype of: B, C, D

 subtype of: B

 

 ====

 

 dependents: Abc, Def

 subtypeof: SampleClassB

 subtype of: B, C, D

 

 - color - blue

 - flavor - lime

 

 _ SecondClass - with its own comment

 subtypes: X, Y, Z 

 suggestion: Why not do something but only one line works 

 dependents: Abc, Def

 based on: Something, SomethingElse

 =====

 plural: BSamples

 where: A = B

 - color - blue

 - flavor - lime

 =====

 

 
DEBUG: collecting_text - Found header: _ SampleClassB - with text and maybe two lines
DEBUG:  - Found annotation with label: dependents
DEBUG: collecting_header - Found annotation: dependents: Abc, Def,
DEBUG: collecting_annotation - Found text: XYZ
DEBUG:  - Found annotation with label: abbreviation
DEBUG: collecting_annotation - Found annotation: abbreviation: CSample
DEBUG:  - Found annotation with label: subtype of
DEBUG: collecting_annotation - Found annotation: subtype of: B, C, D
DEBUG:  - Found annotation with label: subtype of
DEBUG: collecting_annotation - Found annotation: subtype of: B
DEBUG: collecting_annotation - Found blank: 
DEBUG: All line types seen: {'blank', 'text', 'annotation', 'header'}
blank
text
annotation
header

MarkedLines are: (7)
	 _ SampleClassB - <<<with text and maybe two lines>>> ; 

	 dependents: Abc, Def,
	   XYZ
	 abbreviation: CSample
	 subtype of: B, C, D
	 subtype of: B
	 <<<

Trimmed lines are: (7)
	 _ SampleClassB - <<<with text and maybe two lines>>>
	 dependents: Abc, Def,
	   XYZ
	 abbreviation: CSample
	 subtype of: B, C, D
	 subtype of: B
	 <<<

Marked text is: 
[ _ SampleClassB - <<<with text and maybe two lines>>>
dependents: Abc, Def,
  XYZ
abbreviation: CSample
subtype of: B, C, D
subtype of: B
<<<
 
]

DEBUG TOKENS

===== TOKEN DEBUGGING =====
Error creating lexer: Rule 'COLON' used but not defined (in rule formula_clause)

Manual tokenization:
  Line 1, Col 1: UNDERSCORE -> '_'
  Line 1, Col 3: UPPER_CAMEL -> 'SampleClassB'
  Line 1, Col 16: DASH -> '-'
  Line 1, Col 18: MARKED_TEXT -> '<<<with text and maybe two lines>>>'
  Line 2, Col 1: LOWER_CAMEL -> 'dependents'
  Line 2, Col 11: COLON -> ':'
  Line 2, Col 13: UPPER_CAMEL -> 'Abc'
  Line 2, Col 16: UNMATCHABLE -> ','
  Line 2, Col 18: UPPER_CAMEL -> 'Def'
  Line 2, Col 21: UNMATCHABLE -> ','
  Line 3, Col 3: UPPER_CAMEL -> 'XYZ'
  Line 4, Col 1: LOWER_CAMEL -> 'abbreviation'
  Line 4, Col 13: COLON -> ':'
  Line 4, Col 15: UPPER_CAMEL -> 'CSample'
  Line 5, Col 1: LOWER_CAMEL -> 'subtype'
  Line 5, Col 9: LOWER_CAMEL -> 'of'
  Line 5, Col 11: COLON -> ':'
  Line 5, Col 13: UPPER_CAMEL -> 'B'
  Line 5, Col 14: UNMATCHABLE -> ','
  Line 5, Col 16: UPPER_CAMEL -> 'C'
  Line 5, Col 17: UNMATCHABLE -> ','
  Line 5, Col 19: UPPER_CAMEL -> 'D'
  Line 6, Col 1: LOWER_CAMEL -> 'subtype'
  Line 6, Col 9: LOWER_CAMEL -> 'of'
  Line 6, Col 11: COLON -> ':'
  Line 6, Col 13: UPPER_CAMEL -> 'B'
  Line 7, Col 1: UNMATCHABLE -> '<'
  Line 7, Col 2: UNMATCHABLE -> '<'
  Line 7, Col 3: UNMATCHABLE -> '<'

DEBUG INCREMENTAL

===== INCREMENTAL PARSING =====

Trying to parse lines 1-1:
Input: _ SampleClassB - <<<with text and maybe two lines>>>


[pom_parser.py:84 -                            __init__()] PomParser initialized
[pom_grammar.py:524 -                               parse()] Parsing input text (length: 54)
[pom_parser.py:113 -                         _get_parser()] Creating new Lark parser with settings: {'start': 'start', 'parser': 'earley', 'debug': True, 'ambiguity': 'resolve'}
[pom_parser.py:147 -                               parse()] Parsing input text
[pom_parser.py:149 -                               parse()] Input parsed successfully
[pom_parser.py:155 -                               parse()] Visiting parse tree to build model object
[pom_parser.py:157 -                               parse()] Created model object: list
  SUCCESS!
---- Prettier Parse Tree ----
'_SampleClassB-<<<with text and...' Rule: start
'_SampleClassB-<<<with text and...'   Rule: component
'_SampleClassB-<<<with text and...'     Rule: class
'_SampleClassB-<<<with text and...'       Rule: reference_type
'_SampleClassB-<<<with text and...'         Rule: reference_type_header
'_'                                           Token: UNDERSCORE
'SampleClassB'                                Rule: reference_type__name__value
'SampleClassB'                                  Token: UPPER_CAMEL
'-'                                           Token: DASH
'<<<with text and maybe two lin...'           Rule: reference_type__one_liner__value
'<<<with text and maybe two lin...'             Token: ONE_LINER
'\n'                                          Token: NEWLINE
-----------------------------

Trying to parse lines 1-2:
Input: _ SampleClassB - <<<with text and maybe two lines>>>
dependents: Abc, Def,


[pom_grammar.py:524 -                               parse()] Parsing input text (length: 76)
[pom_parser.py:147 -                               parse()] Parsing input text
[pom_parser.py:176 -                               parse()] Error during parsing: Unexpected end-of-input. Expected one of: 
	* CLASS_NAME

 Softer FAILURE - parse tree is 'None' 

Trying to parse lines 1-3:
Input: _ SampleClassB - <<<with text and maybe two lines>>>
dependents: Abc, Def,
  XYZ


[pom_grammar.py:524 -                               parse()] Parsing input text (length: 82)
[pom_parser.py:147 -                               parse()] Parsing input text
[pom_parser.py:149 -                               parse()] Input parsed successfully
[pom_parser.py:155 -                               parse()] Visiting parse tree to build model object
[pom_parser.py:157 -                               parse()] Created model object: list
  SUCCESS!
---- Prettier Parse Tree ----
'_SampleClassB-<<<with text and...' Rule: start
'_SampleClassB-<<<with text and...'   Rule: component
'_SampleClassB-<<<with text and...'     Rule: class
'_SampleClassB-<<<with text and...'       Rule: reference_type
'_SampleClassB-<<<with text and...'         Rule: reference_type_header
'_'                                           Token: UNDERSCORE
'SampleClassB'                                Rule: reference_type__name__value
'SampleClassB'                                  Token: UPPER_CAMEL
'-'                                           Token: DASH
'<<<with text and maybe two lin...'           Rule: reference_type__one_liner__value
'<<<with text and maybe two lin...'             Token: ONE_LINER
'\n'                                          Token: NEWLINE
'dependents:Abc,Def,XYZ\n'                  Rule: class__dependents__list
'dependents'                                  Token: DEPENDENTS_QF
':'                                           Token: COLON
'Abc'                                         Token: CLASS_NAME
','                                           Token: COMMA
'Def'                                         Token: CLASS_NAME
','                                           Token: COMMA
'XYZ'                                         Token: CLASS_NAME
'\n'                                          Token: NEWLINE
-----------------------------

Trying to parse lines 1-4:
Input: _ SampleClassB - <<<with text and maybe two lines>>>
dependents: Abc, Def,
  XYZ
abbreviation: CSample


[pom_grammar.py:524 -                               parse()] Parsing input text (length: 104)
[pom_parser.py:147 -                               parse()] Parsing input text
[pom_parser.py:170 -                               parse()] Unexpected character during parsing: No terminal matches ':' in the current parser context, at line 4 col 13

abbreviation: CSample
            ^
Expected one of: 
	* COMMA
	* NEWLINE

 Softer FAILURE - parse tree is 'None' 

Trying to parse lines 1-5:
Input: _ SampleClassB - <<<with text and maybe two lines>>>
dependents: Abc, Def,
  XYZ
abbreviation: CSample
subtype of: B, C, D


[pom_grammar.py:524 -                               parse()] Parsing input text (length: 124)
[pom_parser.py:147 -                               parse()] Parsing input text
[pom_parser.py:170 -                               parse()] Unexpected character during parsing: No terminal matches ':' in the current parser context, at line 4 col 13

abbreviation: CSample
            ^
Expected one of: 
	* COMMA
	* NEWLINE

 Softer FAILURE - parse tree is 'None' 

Trying to parse lines 1-6:
Input: _ SampleClassB - <<<with text and maybe two lines>>>
dependents: Abc, Def,
  XYZ
abbreviation: CSample
subtype of: B, C, D
subtype of: B


[pom_grammar.py:524 -                               parse()] Parsing input text (length: 138)
[pom_parser.py:147 -                               parse()] Parsing input text
[pom_parser.py:170 -                               parse()] Unexpected character during parsing: No terminal matches ':' in the current parser context, at line 4 col 13

abbreviation: CSample
            ^
Expected one of: 
	* COMMA
	* NEWLINE

 Softer FAILURE - parse tree is 'None' 

Trying to parse lines 1-7:
Input: _ SampleClassB - <<<with text and maybe two lines>>>
dependents: Abc, Def,
  XYZ
abbreviation: CSample
subtype of: B, C, D
subtype of: B
<<<


[pom_grammar.py:524 -                               parse()] Parsing input text (length: 142)
[pom_parser.py:147 -                               parse()] Parsing input text
[pom_parser.py:170 -                               parse()] Unexpected character during parsing: No terminal matches ':' in the current parser context, at line 4 col 13

abbreviation: CSample
            ^
Expected one of: 
	* COMMA
	* NEWLINE

 Softer FAILURE - parse tree is 'None' 

Trying to parse lines 1-8:
Input: _ SampleClassB - <<<with text and maybe two lines>>>
dependents: Abc, Def,
  XYZ
abbreviation: CSample
subtype of: B, C, D
subtype of: B
<<<



[pom_grammar.py:524 -                               parse()] Parsing input text (length: 143)
[pom_parser.py:147 -                               parse()] Parsing input text
[pom_parser.py:170 -                               parse()] Unexpected character during parsing: No terminal matches ':' in the current parser context, at line 4 col 13

abbreviation: CSample
            ^
Expected one of: 
	* COMMA
	* NEWLINE

 Softer FAILURE - parse tree is 'None' 

Successfully parsed up to line 3 out of 8

Problem area may be around:
    Line 3:   XYZ
>>> Line 4: abbreviation: CSample
    Line 5: subtype of: B, C, D

DEBUG WITH TRACE

===== TRACING PARSE RULES =====
Parse error during tracing: No terminal matches ':' in the current parser context, at line 4 col 13

abbreviation: CSample
            ^
Expected one of: 
	* COMMA
	* NEWLINE

[do_pom_test.py:20 -                            test_pom()] Done testing POM
