All tests passed!
Testing:  _ **Component** - A building block
{
  "line_type": "Class",
  "prefix": "_",
  "rest_of_line": "**Component** - A building block"
}
Testing:  üîÑ **Default**: value
{
  "line_type": "labeled_value",
  "emoji": "\ud83d\udd04",
  "label": "Default",
  "value": "value"
}
TestingHeader:  _ **Component** - An element (Type)
{
  "prefix": "_",
  "name": "Component",
  "one_liner": "An element",
  "parenthetical": "Type"
}
TestingHeader:  _ **Component** - An element  with a two             line oneliner(Type)
{
  "prefix": "_",
  "name": "Component",
  "one_liner": "An element  with a two             line oneliner",
  "parenthetical": "Type"
}

TestingAnnotation:  üîÑ **Default**: value if none provided
{
  "emoji": "\ud83d\udd04",
  "label": "Default",
  "value": "value if none provided"
}
Renders as: üîÑ Default: value if none provided

TestingAnnotation:  ***Example***: "LDM" is the short form of "Literate Data Model".
{
  "emoji": "",
  "label": "Example",
  "value": "\"LDM\" is the short form of \"Literate Data Model\"."
}
Renders as: Example: "LDM" is the short form of "Literate Data Model".

TestingAnnotation:  üîÑ ***NoteA***: This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.
{
  "emoji": "\ud83d\udd04",
  "label": "NoteA",
  "value": "This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source."
}
Renders as: üîÑ NoteA: This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.

TestingAnnotation:  ‚ÑπÔ∏è  ***NoteA***: This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.
{
  "emoji": "",
  "label": "\u2139\ufe0f  NoteA",
  "value": "This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source."
}
Renders as: ‚ÑπÔ∏è  NoteA: This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.

TestingAnnotation:  ‚ÑπÔ∏è ***Note***: This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.
{
  "emoji": "",
  "label": "\u2139\ufe0f Note",
  "value": "This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source."
}
Renders as: ‚ÑπÔ∏è Note: This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.

TestingAnnotation:  wildly: This is an unregistered annotation
{
  "emoji": "",
  "label": "wildly",
  "value": "This is an unregistered annotation"
}
Renders as: wildly: This is an unregistered annotation
BY PRI
Section5_Head -- 10
Section4_Head -- 9
Section3_Head -- 8
Section2_Head -- 7
AttributeSection_Head -- 2
ABBREVIATION -- 1
NAME -- 1
PLURAL -- 1
MINERNOTE -- 1
MAJORNOTE -- 1
NOTE -- 1
ISSUE -- 1
EXAMPLE -- 1
SEE -- 1
LDM_Head -- 1
Class_Head -- 1
ABBREVIATION -- 1
NAME -- 1
PLURAL -- 1
MINERNOTE -- 1
MAJORNOTE -- 1
NOTE -- 1
ISSUE -- 1
EXAMPLE -- 1
SEE -- 1
AttributeSection_Head -- 1
Attribute_Head -- 1
ABBREVIATION -- 1
NAME -- 1
PLURAL -- 1
MINERNOTE -- 1
MAJORNOTE -- 1
NOTE -- 1
ISSUE -- 1
EXAMPLE -- 1
SEE -- 1
Class_Head -- 1
SUBTYPE_OF -- 1
SUBTYPES -- 1
BASED_ON -- 1
DEPENDENTS -- 1
CONSTRAINT -- 1
DEPENDENT_OF -- 1
WHERE -- 1
Attribute_Head -- 1
ABBREVIATION -- 1
NAME -- 1
PLURAL -- 1
MINERNOTE -- 1
MAJORNOTE -- 1
NOTE -- 1
ISSUE -- 1
EXAMPLE -- 1
SEE -- 1
Attribute_Head -- 1
DATA_TYPE -- 1
INVERSE -- 1
INVERSE_OF -- 1
OVERRIDES -- 1
DERIVATION -- 1
DEFAULT -- 1
CONSTRAINT -- 1
CODE -- 1
ENGLISH -- 1
MESSAGE -- 1
SEVERITY -- 1
WILD -- -1
WILD -- -1
WILD -- -1
WILD -- -1
parts needed:  {'LDM', 'Default', 'Annotation', 'Section4', 'Section3', 'Constraint', 'Section2', 'Attribute', 'Derivation', 'Class', 'Section5', 'AttributeSection'}
Part Parts:
 {
  "Document": [
    "Annotation",
    "LDM",
    "Class",
    "Section2",
    "Section3",
    "Section4",
    "Section5"
  ],
  "LDM": [
    "Annotation",
    "Class",
    "Section2",
    "Section3",
    "Section4",
    "Section5"
  ],
  "Section2": [
    "Annotation",
    "Class",
    "Section3",
    "Section4",
    "Section5"
  ],
  "Section3": [
    "Annotation",
    "Class",
    "Section4",
    "Section5"
  ],
  "Section4": [
    "Annotation",
    "Class",
    "Section5"
  ],
  "Section5": [
    "Annotation",
    "Class"
  ],
  "Class": [
    "Annotation",
    "AttributeSection",
    "Attribute",
    "Constraint"
  ],
  "AttributeSection": [
    "Annotation",
    "Attribute"
  ],
  "Attribute": [
    "Annotation",
    "Derivation",
    "Default",
    "Constraint"
  ]
}
Part Labels:
 {
  "Document": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "MINERNOTE",
    "MAJORNOTE",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "WILD",
    "Section5_Head",
    "Section4_Head",
    "Section3_Head",
    "Section2_Head",
    "LDM_Head",
    "Class_Head"
  ],
  "LDM": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "MINERNOTE",
    "MAJORNOTE",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "WILD",
    "Section5_Head",
    "Section4_Head",
    "Section3_Head",
    "Section2_Head",
    "LDM_Head",
    "Class_Head"
  ],
  "Section2": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "MINERNOTE",
    "MAJORNOTE",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "WILD",
    "Section5_Head",
    "Section4_Head",
    "Section3_Head",
    "Section2_Head",
    "LDM_Head",
    "Class_Head"
  ],
  "Section3": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "MINERNOTE",
    "MAJORNOTE",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "WILD",
    "Section5_Head",
    "Section4_Head",
    "Section3_Head",
    "Section2_Head",
    "LDM_Head",
    "Class_Head"
  ],
  "Section4": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "MINERNOTE",
    "MAJORNOTE",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "WILD",
    "Section5_Head",
    "Section4_Head",
    "Section3_Head",
    "Section2_Head",
    "LDM_Head",
    "Class_Head"
  ],
  "Section5": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "MINERNOTE",
    "MAJORNOTE",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "WILD",
    "Section5_Head",
    "Section4_Head",
    "Section3_Head",
    "Section2_Head",
    "LDM_Head",
    "Class_Head"
  ],
  "Class": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "MINERNOTE",
    "MAJORNOTE",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "WILD",
    "Class_Head",
    "SUBTYPE_OF",
    "SUBTYPES",
    "BASED_ON",
    "DEPENDENTS",
    "CONSTRAINT",
    "DEPENDENT_OF",
    "WHERE",
    "AttributeSection_Head",
    "Attribute_Head"
  ],
  "AttributeSection": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "MINERNOTE",
    "MAJORNOTE",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "WILD",
    "AttributeSection_Head",
    "Attribute_Head"
  ],
  "Attribute": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "MINERNOTE",
    "MAJORNOTE",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "WILD",
    "Attribute_Head",
    "DATA_TYPE",
    "INVERSE",
    "INVERSE_OF",
    "OVERRIDES",
    "DERIVATION",
    "DEFAULT",
    "CONSTRAINT"
  ],
  "Derivation": [
    "CODE",
    "ENGLISH",
    "MESSAGE",
    "SEVERITY"
  ],
  "Default": [
    "CODE",
    "ENGLISH",
    "MESSAGE",
    "SEVERITY"
  ],
  "Constraint": [
    "CODE",
    "ENGLISH",
    "MESSAGE",
    "SEVERITY"
  ]
}
Majors
{'Constraint', 'Derivation', 'Annotation', 'Default'}
Headed parts
{'LDM', 'Section4', 'Section3', 'Section2', 'Attribute', 'Class', 'Section5', 'AttributeSection'}
Parts to list 
 {'Constraint', 'Annotation'}
Listed parts 
 {'LDM', 'Annotation', 'Section4', 'Section3', 'Constraint', 'Section2', 'Attribute', 'Class', 'Section5', 'AttributeSection'}
PARSING samples/LDMMeta.md
Starting code bock - for label CODE_FENCE
FOUND CODE BLOCK: ['Sample code block between paragraphs', 'x <  y and y > z', '```']
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.', extra_text=[])], extra_text=[]), TypedLine(type_label='CODE_FENCE', line_Type=None, content='```', extra_text=['Sample code block between paragraphs', 'x <  y and y > z', '```']), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.', extra_text=[])], extra_text=[])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.', extra_text=[])], extra_text=[]), TypedLine(type_label='CODE_FENCE', line_Type=None, content='```', extra_text=['Sample code block between paragraphs', 'x <  y and y > z', '```']), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.', extra_text=[])], extra_text=[])]
FOUND EXTRA TEXT
..now included in:  Class_Head: _ **Component** - An element or building block of the literate data model with an extendedOneLiner
Starting code bock - for label CODE_FENCE
FOUND CODE BLOCK: ['Sample code block between paragraphs', 'x <  y and y > z', '```']
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.', extra_text=[])], extra_text=[]), TypedLine(type_label='CODE_FENCE', line_Type=None, content='```', extra_text=['Sample code block between paragraphs', 'x <  y and y > z', '```']), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.', extra_text=[])], extra_text=[])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.', extra_text=[])], extra_text=[]), TypedLine(type_label='CODE_FENCE', line_Type=None, content='```', extra_text=['Sample code block between paragraphs', 'x <  y and y > z', '```']), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.', extra_text=[])], extra_text=[])]
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Trying an elaboration for a subtypes clauses.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of second paragraph.', extra_text=[])], extra_text=[])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Trying an elaboration for a subtypes clauses.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of second paragraph.', extra_text=[])], extra_text=[])]
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Trying an elaboration for an Attribute declaration clauses.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of second paragraph.', extra_text=[])], extra_text=[])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Trying an elaboration for an Attribute declaration clauses.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of second paragraph.', extra_text=[])], extra_text=[])]
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Trying an elaboration for an InverseOf clause on an attribute declaration clauses.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of second paragraph.', extra_text=[])], extra_text=[])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Trying an elaboration for an InverseOf clause on an attribute declaration clauses.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of second paragraph.', extra_text=[])], extra_text=[])]
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Trying an elaboration for a Default declaration clause - ie first part of a Default Formuka object', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of second paragraph.', extra_text=[])], extra_text=[])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Trying an elaboration for a Default declaration clause - ie first part of a Default Formuka object', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of second paragraph.', extra_text=[])], extra_text=[])]
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Trying an elaboration for a Default code clause - ie subsequent  part of a Default Formuka object', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of second paragraph.', extra_text=[])], extra_text=[])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Trying an elaboration for a Default code clause - ie subsequent  part of a Default Formuka object', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='End of first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Start of second paragraph.', extra_text=[])], extra_text=[])]
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üîÑ'}]: üîÑ ***Default***: false
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üîÑ'}]: üîÑ ***Default***: false
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üîÑ'}]: üîÑ  ***Note***: This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üîÑ'}]: üîÑ  ***Note***: This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content="And after that very long onelner on the Note, here's additional elaboration on  it", extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='With a second line in the first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='And another paragraph, too.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='Also with a second line', extra_text=[])], extra_text=[])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content="And after that very long onelner on the Note, here's additional elaboration on  it", extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='With a second line in the first paragraph', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='And another paragraph, too.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='Also with a second line', extra_text=[])], extra_text=[])]
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üÜé'}]: üÜé ***Derivation***: ""
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üÜé'}]: üÜé ***Derivation***: ""
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üÜé'}]: üÜé ***Derivation***: ""
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üÜé'}]: üÜé ***Derivation***: ""
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üÜé'}]: üÜé ***Derivation***: mdPrefix + name + " - " + oneLiner + mdSuffix
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üÜé'}]: üÜé ***Derivation***: mdPrefix + name + " - " + oneLiner + mdSuffix
FOUND EXTRA TEXT
..now included in:  Class_Head: _ **AnnotationType** - a kind of note, or aside, used to call attention to additional information about some Component.And it can be continued on fresh lines. 
+ However many you want. 
+ But only up to a blank line or other clause
FOUND EXTRA TEXT
..now included in:  NOTE: ***Note***: Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.
FOUND EXTRA TEXT
..now included in:  Class_Head: _ ValueType: **Annotation**A note or comment associated with a model element
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='But any short label is valid.', extra_text=[])], extra_text=[])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='But any short label is valid.', extra_text=[])], extra_text=[])]
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üîÑ'}]: üîÑ ***Default***: false
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üîÑ'}]: üîÑ ***Default***: false
found EMOJIS [{'match_start': 0, 'match_end': 2, 'emoji': '‚ÑπÔ∏è'}]: ‚ÑπÔ∏è ***Note***: This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.
found EMOJIS [{'match_start': 0, 'match_end': 2, 'emoji': '‚ÑπÔ∏è'}]: ‚ÑπÔ∏è ***Note***: This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.
Starting code bock - for label CODE_FENCE
found EMOJIS [{'match_start': 8, 'match_end': 9, 'emoji': '‚ùå'}]: emoji: "‚ùå",
found EMOJIS [{'match_start': 8, 'match_end': 10, 'emoji': '‚ö†Ô∏è'}]: emoji: "‚ö†Ô∏è",
found EMOJIS [{'match_start': 8, 'match_end': 9, 'emoji': 'üìò'}]: emoji: "üìò",
found EMOJIS [{'match_start': 8, 'match_end': 10, 'emoji': '‚ö†Ô∏è'}]: emoji: "‚ö†Ô∏è",
found EMOJIS [{'match_start': 8, 'match_end': 9, 'emoji': '‚ùì'}]: emoji: "‚ùì",
found EMOJIS [{'match_start': 8, 'match_end': 9, 'emoji': 'üí°'}]: emoji: "üí°",
found EMOJIS [{'match_start': 8, 'match_end': 10, 'emoji': '‚ÑπÔ∏è'}]: emoji: "‚ÑπÔ∏è",
found EMOJIS [{'match_start': 8, 'match_end': 9, 'emoji': 'üìå'}]: emoji: "üìå",
found EMOJIS [{'match_start': 8, 'match_end': 9, 'emoji': 'üåê'}]: emoji: "üåê",
found EMOJIS [{'match_start': 8, 'match_end': 9, 'emoji': 'üîç'}]: emoji: "üîç",
FOUND CODE BLOCK: ['interface AnnotationType {', 'label: string;', 'emoji: string;', 'emojiName: string;', 'emojiUnicode: string;', 'purpose: string;', '}', '// LINK: LiterateDataModel.annotationTypes', 'const annotationTypes: AnnotationType[] = [', '{', 'label: "Error",', 'emoji: "",', 'emojiName: "cross_mark",', 'emojiUnicode: "U+274C",', 'purpose: "Indicates a critical error or failure in the model."', '},', '{', 'label: "Warning",', 'emoji: "",', 'emojiName: "warning",', 'emojiUnicode: "U+26A0",', 'purpose: "Indicates a potential issue or warning in the model."', '},', '{', 'label: "Note",', 'emoji: "",', 'emojiName: "blue_book",', 'emojiUnicode: "U+1F4D8",', 'purpose: "Provides additional context, explanations, or clarifications for the annotated element."', '},', '{', 'label: "Issue",', 'emoji: "",', 'emojiName: "warning",', 'emojiUnicode: "U+26A0",', 'purpose: "Highlights a potential issue or error that needs to be addressed or resolved."', '},', '{', 'label: "Question",', 'emoji: "",', 'emojiName: "question",', 'emojiUnicode: "U+2753",', 'purpose: "Raises a question or seeks further clarification about the annotated element."', '},', '{', 'label: "Suggestion",', 'emoji: "",', 'emojiName: "bulb",', 'emojiUnicode: "U+1F4A1",', 'purpose: "Provides a suggestion or recommendation for improving the model or the annotated element."', '},', '{', 'label: "Info",', 'emoji: "",', 'emojiName: "information_source",', 'emojiUnicode: "U+2139",', 'purpose: "Offers relevant information, facts, or details about the annotated element."', '},', '{', 'label: "Todo",', 'emoji: "",', 'emojiName: "pushpin",', 'emojiUnicode: "U+1F4CC",', 'purpose: "Indicates a pending task, action item, or future work related to the annotated element."', '},', '{', 'label: "Reference",', 'emoji: "",', 'emojiName: "globe_with_meridians",', 'emojiUnicode: "U+1F310",', 'purpose: "Provides a reference or link to an external resource or documentation."', '},', '{', 'label: "See",', 'emoji: "",', 'emojiName: "mag",', 'emojiUnicode: "U+1F50D",', 'purpose: "Indicates a cross-reference to another relevant element within the model."', '}', '];', '```']
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='These are the recognized Annotation Types for the LDM model.', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.', extra_text=[])], extra_text=[]), TypedLine(type_label='CODE_FENCE', line_Type=None, content='```', extra_text=['interface AnnotationType {', 'label: string;', 'emoji: string;', 'emojiName: string;', 'emojiUnicode: string;', 'purpose: string;', '}', '// LINK: LiterateDataModel.annotationTypes', 'const annotationTypes: AnnotationType[] = [', '{', 'label: "Error",', 'emoji: "",', 'emojiName: "cross_mark",', 'emojiUnicode: "U+274C",', 'purpose: "Indicates a critical error or failure in the model."', '},', '{', 'label: "Warning",', 'emoji: "",', 'emojiName: "warning",', 'emojiUnicode: "U+26A0",', 'purpose: "Indicates a potential issue or warning in the model."', '},', '{', 'label: "Note",', 'emoji: "",', 'emojiName: "blue_book",', 'emojiUnicode: "U+1F4D8",', 'purpose: "Provides additional context, explanations, or clarifications for the annotated element."', '},', '{', 'label: "Issue",', 'emoji: "",', 'emojiName: "warning",', 'emojiUnicode: "U+26A0",', 'purpose: "Highlights a potential issue or error that needs to be addressed or resolved."', '},', '{', 'label: "Question",', 'emoji: "",', 'emojiName: "question",', 'emojiUnicode: "U+2753",', 'purpose: "Raises a question or seeks further clarification about the annotated element."', '},', '{', 'label: "Suggestion",', 'emoji: "",', 'emojiName: "bulb",', 'emojiUnicode: "U+1F4A1",', 'purpose: "Provides a suggestion or recommendation for improving the model or the annotated element."', '},', '{', 'label: "Info",', 'emoji: "",', 'emojiName: "information_source",', 'emojiUnicode: "U+2139",', 'purpose: "Offers relevant information, facts, or details about the annotated element."', '},', '{', 'label: "Todo",', 'emoji: "",', 'emojiName: "pushpin",', 'emojiUnicode: "U+1F4CC",', 'purpose: "Indicates a pending task, action item, or future work related to the annotated element."', '},', '{', 'label: "Reference",', 'emoji: "",', 'emojiName: "globe_with_meridians",', 'emojiUnicode: "U+1F310",', 'purpose: "Provides a reference or link to an external resource or documentation."', '},', '{', 'label: "See",', 'emoji: "",', 'emojiName: "mag",', 'emojiUnicode: "U+1F50D",', 'purpose: "Indicates a cross-reference to another relevant element within the model."', '}', '];', '```'])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='These are the recognized Annotation Types for the LDM model.', extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.', extra_text=[])], extra_text=[]), TypedLine(type_label='CODE_FENCE', line_Type=None, content='```', extra_text=['interface AnnotationType {', 'label: string;', 'emoji: string;', 'emojiName: string;', 'emojiUnicode: string;', 'purpose: string;', '}', '// LINK: LiterateDataModel.annotationTypes', 'const annotationTypes: AnnotationType[] = [', '{', 'label: "Error",', 'emoji: "",', 'emojiName: "cross_mark",', 'emojiUnicode: "U+274C",', 'purpose: "Indicates a critical error or failure in the model."', '},', '{', 'label: "Warning",', 'emoji: "",', 'emojiName: "warning",', 'emojiUnicode: "U+26A0",', 'purpose: "Indicates a potential issue or warning in the model."', '},', '{', 'label: "Note",', 'emoji: "",', 'emojiName: "blue_book",', 'emojiUnicode: "U+1F4D8",', 'purpose: "Provides additional context, explanations, or clarifications for the annotated element."', '},', '{', 'label: "Issue",', 'emoji: "",', 'emojiName: "warning",', 'emojiUnicode: "U+26A0",', 'purpose: "Highlights a potential issue or error that needs to be addressed or resolved."', '},', '{', 'label: "Question",', 'emoji: "",', 'emojiName: "question",', 'emojiUnicode: "U+2753",', 'purpose: "Raises a question or seeks further clarification about the annotated element."', '},', '{', 'label: "Suggestion",', 'emoji: "",', 'emojiName: "bulb",', 'emojiUnicode: "U+1F4A1",', 'purpose: "Provides a suggestion or recommendation for improving the model or the annotated element."', '},', '{', 'label: "Info",', 'emoji: "",', 'emojiName: "information_source",', 'emojiUnicode: "U+2139",', 'purpose: "Offers relevant information, facts, or details about the annotated element."', '},', '{', 'label: "Todo",', 'emoji: "",', 'emojiName: "pushpin",', 'emojiUnicode: "U+1F4CC",', 'purpose: "Indicates a pending task, action item, or future work related to the annotated element."', '},', '{', 'label: "Reference",', 'emoji: "",', 'emojiName: "globe_with_meridians",', 'emojiUnicode: "U+1F310",', 'purpose: "Provides a reference or link to an external resource or documentation."', '},', '{', 'label: "See",', 'emoji: "",', 'emojiName: "mag",', 'emojiUnicode: "U+1F50D",', 'purpose: "Indicates a cross-reference to another relevant element within the model."', '}', '];', '```'])]
FOUND EXTRA TEXT
..now included in:  Class_Head: _ **LiterateDataModel** - A representation of a domain's entities, attributes, and relationships,along with explanatory text and examples
FOUND EXTRA TEXT
..now included in:  Attribute_Head: - allSubjects - list of all classes in the model, as ordered in thedefinition of the model. (List of Classes)
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üÜé'}]: üÜé ***Derivation***: "# "
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üÜé'}]: üÜé ***Derivation***: "# "
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üÜé'}]: üÜé ***Derivation***: mdPrefix + name
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üÜé'}]: üÜé ***Derivation***: mdPrefix + name
FOUND EXTRA TEXT
..now included in:  Class_Head: _ **Subject**A specific topic or theme within the model
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Subjects are the chapters an sections of the model.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='A subject need not contain any Classes if it‚Äôs just expository.', extra_text=[])], extra_text=[])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Subjects are the chapters an sections of the model.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='A subject need not contain any Classes if it‚Äôs just expository.', extra_text=[])], extra_text=[])]
FOUND EXTRA TEXT
..now included in:  ISSUE: ***Issue***: define chapter, section, subsection as levels?***DSL***: Generally, it is best to present the classes within a Subject in top down order:
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='***DSL***:  the Classes within a Subject are always displayed before the childSubjects.', extra_text=[])], extra_text=[])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='***DSL***:  the Classes within a Subject are always displayed before the childSubjects.', extra_text=[])], extra_text=[])]
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üÜé'}]: üÜé ***Derivation***: levelIndicator + " "
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üÜé'}]: üÜé ***Derivation***: levelIndicator + " "
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üÜé'}]: üÜé ***Derivation***: mdPrefix + name.
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üÜé'}]: üÜé ***Derivation***: mdPrefix + name.
FOUND EXTRA TEXT
..now included in:  Class_Head: _ **SubjectArea**A main topic or area of focus within the model, containing related subjects and classes
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Might be Books for the Book class or other regular plurals.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='But also might be People for Person.', extra_text=[])], extra_text=[])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Might be Books for the Book class or other regular plurals.', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='But also might be People for Person.', extra_text=[])], extra_text=[])]
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.', extra_text=[])], extra_text=[])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.', extra_text=[])], extra_text=[])]
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.', extra_text=[])], extra_text=[])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.', extra_text=[])], extra_text=[])]
FOUND EXTRA TEXT
..now included in:  NOTE: Note: Constraints may be expressed on either the Class or the Attribute. Always?Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.
FOUND EXTRA TEXT
..now included in:  INVERSE: ***Inverse of***:UniqueKey.basedOn
FOUND EXTRA TEXT
..now included in:  Attribute_Head: - **name** (Upper Name).Usually ByThis or ByThat
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='***DSL***:  Shown in the DSL as', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='> Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='on the super class. And as', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='> Subtype of: SuperClass byBrand', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='on the subclass.', extra_text=[])], extra_text=[])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='***DSL***:  Shown in the DSL as', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='> Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='on the super class. And as', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='> Subtype of: SuperClass byBrand', extra_text=[]), TypedLine(type_label='TEXT_LINE', line_Type=None, content='on the subclass.', extra_text=[])], extra_text=[])]
FOUND EXTRA TEXT
..now included in:  NOTE: Note: every class can have an unnamed subtyping.Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üÜé'}]: üÜé ***Derivation***: "ValueType: ".
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üÜé'}]: üÜé ***Derivation***: "ValueType: ".
FOUND EXTRA TEXT
..now included in:  Class_Head: _ **CodeType**A data type or enumeration used in the model
FOUND EXTRA TEXT
..now included in:  Attribute_Head: - List the code values as a bulletted list inside the description of the attribute in the form:‚Äò**code**: description‚Äô
found EMOJIS [{'match_start': 2, 'match_end': 3, 'emoji': 'üëç'}]: > üëç **Issue**: introduce PureLists?
FOUND EXTRA TEXT
..now included in:  CONSTRAINT: Constraint: no repetitions allowed in keyAttributes> üëç **Issue**: introduce PureLists?
FOUND EXTRA TEXT
..now included in:  Class_Head: _If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked. 
+ &nbsp; 
+ But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üîÑ'}]: üîÑ ***Default***: "_ "
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üîÑ'}]: üîÑ ***Default***: "_ "
FOUND EXTRA TEXT
..now included in:  Class_Head: _ **Attribute**A property or characteristic of a class
FOUND EXTRA TEXT
..now included in:  Attribute_Head: - **dataType** - The kind of object to which the attribute refers.  _(DataType)_H 
+ In the simplest cases, the data type will be a class. And the specifier is the just the name of that class.
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='But,', extra_text=[])], extra_text=[])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='But,', extra_text=[])], extra_text=[])]
FOUND EXTRA TEXT
..now included in:  DEFAULT: ***Default:***  For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.', extra_text=[])], extra_text=[])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.', extra_text=[])], extra_text=[])]
FOUND EXTRA TEXT
..now included in:  Attribute_Head: - **default** - The rule or formula for calculating the value, if no value is suppliedNow running to a second line with the parenthentical on yet a third line 
+ (Derivation, optional)
FOUND EXTRA TEXT
..now included in:  NOTE: Note: even when an Attribute has a default derivation, there‚Äôs no guarantee that every instance will have an assigned value. Example needed.And let's see if the note can span extra lines, too
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content="Yes, it handled extra lines.  Let's see about additional paras for an annotation", extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Last paragraph here', extra_text=[])], extra_text=[])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content="Yes, it handled extra lines.  Let's see about additional paras for an annotation", extra_text=[])], extra_text=[]), TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='Last paragraph here', extra_text=[])], extra_text=[])]
FOUND EXTRA TEXT
..now included in:  Class_Head: _ ***ValueType:*** **Derivation**A rule or formula for deriving the value of an attribute
FOUND EXTRA TEXT
..now included in:  Class_Head: _ ***ValueType:*** **Constraint**A rule, condition, or validation that must be satisfied by the model
FOUND EXTRA TEXT
..now included in:  Class_Head: _ **Method**A behavior or operation associated with a class
FOUND EXTRA TEXT
..now included in:  Class_Head: _ **Parameter**An input to a method
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='*ValueType*:**Data Type**', extra_text=[])], extra_text=[])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='*ValueType*:**Data Type**', extra_text=[])], extra_text=[])]
FOUND EXTRA TEXT
..now included in:  Class_Head: _ **Simple Data Type*****SubtpeOf***: DataType
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='insert Camel Case.md', extra_text=[])], extra_text=[])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='insert Camel Case.md', extra_text=[])], extra_text=[])]
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.', extra_text=[])], extra_text=[])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.', extra_text=[])], extra_text=[])]
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üö´'}]: üö´ ***Constraint***: Must follow the camel case naming convention and not be empty.
found EMOJIS [{'match_start': 0, 'match_end': 1, 'emoji': 'üö´'}]: üö´ ***Constraint***: Must follow the camel case naming convention and not be empty.
found EMOJIS [{'match_start': 2, 'match_end': 3, 'emoji': 'üìù'}]: > üìù ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='> üìù ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.', extra_text=[])], extra_text=[])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='> üìù ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.', extra_text=[])], extra_text=[])]
FOUND EXTRA TEXT
..now included in:  SUBTYPE_OF: Subtype of: ValueTypeA basic, built-in data type
FOUND EXTRA TEXT
..now included in:  Class_Head: _Values:_**String** 
+ **Integer** 
+ **Decimal** 
+ **Boolean** 
+ **Date** 
+ **Time** 
+ **DateTime**
Closing elaboration on finding Something Special
..open_elaboration:  [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='===', extra_text=[])], extra_text=[])]
..added Elaboration to current part (for Something Special):  ELABORATION: [TypedLine(type_label='PARAGRAPH', line_Type=None, content=[TypedLine(type_label='TEXT_LINE', line_Type=None, content='===', extra_text=[])], extra_text=[])]
FOUND EXTRA TEXT
..now included in:  Section2_Head: ## AppendicesInsert More Sidebars.md 
+ Insert Overrides.md 
+ insert LDM Intro.md 
+ Insert OCL.md 
+ Insert Camel Case.md
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Example', 'value': '"LDM" is the short form of "Literate Data Model".'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'wildly', 'value': 'This is an unregistered annotation'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'minorNote', 'value': 'This is a minor note'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'majorNote', 'value': 'And this is a major note. Both should be annotations'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'text', 'content': 'See. this is not included in the extra text.'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Issue', 'value': 'define chapter, section, subsection as levels?***DSL***: Generally, it is best to present the classes within a Subject in top down order:'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'basedOn and dependentOf are being used synonymousle in this metamodel.'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'issue', 'value': 'fix that'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Example', 'value': 'in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Example', 'value': 'For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'Constraints may be expressed on either the Class or the Attribute. Always?Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'every class can have an unnamed subtyping.Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': "Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:"}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'A possible value for an enumerated data class  DependentOf', 'value': 'CodeType'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Issue', 'value': 'need ascending descending to support index keys or ordering keys.'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'order unimportant for Unique Keys.'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'See', 'value': 'the section below on Data Type Specifiers.'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'For example', 'value': ''}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'how this works with optionality'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': "even when an Attribute has a default derivation, there‚Äôs no guarantee that every instance will have an assigned value. Example needed.And let's see if the note can span extra lines, too"}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Issue', 'value': 'on insert vs on access?'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'Note', 'value': 'from Class.constraints'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'text', 'content': '_Example:_ "firstName", "orderDate", "customerID"'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'labeled_value', 'emoji': '', 'label': 'ModelingNote', 'value': '* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'text', 'content': '_Example:_ "Customer", "ProductCategory", "PaymentMethod"'}
the dict:  {'_type': 'Annotation'}
Annotation dict:  {'line_type': 'text', 'content': '_Example:_ "firstName", "orderTotal", "shippingAddress"'}
the dict:  {'_type': 'Annotation'}
Returned from dict creation
