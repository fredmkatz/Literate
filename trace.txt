final pattern for abbreviation = [_\*]*abbreviation[_\*:]*
final pattern for name = [_\*]*name[_\*:]*
final pattern for plural = [_\*]*plural[_\*:]*
final pattern for note = [_\*]*note[_\*:]*
final pattern for issue = [_\*]*issue[_\*:]*
final pattern for example = [_\*]*example[_\*:]*
final pattern for see = [_\*]*see[_\*:]*
final pattern for subtype of = [_\*]*subtype\s?of[_\*:]*
final pattern for subtypes = [_\*]*subtypes[_\*:]*
final pattern for based on = [_\*]*based\s?on[_\*:]*
final pattern for dependents = [_\*]*dependents[_\*:]*
final pattern for Constraint = [_\*]*Constraint[_\*:]*
final pattern for dependent of = [_\*]*dependent\s?of[_\*:]*
final pattern for where = [_\*]*where[_\*:]*
final pattern for plural = [_\*]*plural[_\*:]*
final pattern for data type = [_\*]*data\s?type[_\*:]*
final pattern for inverse = [_\*]*inverse[_\*:]*
final pattern for inverse of = [_\*]*inverse\s?of[_\*:]*
final pattern for overrides = [_\*]*overrides[_\*:]*
final pattern for Derivation = [_\*]*Derivation[_\*:]*
final pattern for Default = [_\*]*Default[_\*:]*
final pattern for code = [_\*]*code[_\*:]*
final pattern for english = [_\*]*english[_\*:]*
final pattern for message = [_\*]*message[_\*:]*
final pattern for severity = [_\*]*severity[_\*:]*
final pattern for value type = [_\*]*value\s?type[_\*:]*
All tests passed!
final pattern for abbreviation = [_\*]*abbreviation[_\*:]*
final pattern for name = [_\*]*name[_\*:]*
final pattern for plural = [_\*]*plural[_\*:]*
final pattern for note = [_\*]*note[_\*:]*
final pattern for issue = [_\*]*issue[_\*:]*
final pattern for example = [_\*]*example[_\*:]*
final pattern for see = [_\*]*see[_\*:]*
final pattern for subtype of = [_\*]*subtype\s?of[_\*:]*
final pattern for subtypes = [_\*]*subtypes[_\*:]*
final pattern for based on = [_\*]*based\s?on[_\*:]*
final pattern for dependents = [_\*]*dependents[_\*:]*
final pattern for Constraint = [_\*]*Constraint[_\*:]*
final pattern for dependent of = [_\*]*dependent\s?of[_\*:]*
final pattern for where = [_\*]*where[_\*:]*
final pattern for Constraint = [_\*]*Constraint[_\*:]*
final pattern for data type = [_\*]*data\s?type[_\*:]*
final pattern for inverse = [_\*]*inverse[_\*:]*
final pattern for inverse of = [_\*]*inverse\s?of[_\*:]*
final pattern for overrides = [_\*]*overrides[_\*:]*
final pattern for Derivation = [_\*]*Derivation[_\*:]*
final pattern for Default = [_\*]*Default[_\*:]*
final pattern for Constraint = [_\*]*Constraint[_\*:]*
final pattern for code = [_\*]*code[_\*:]*
final pattern for english = [_\*]*english[_\*:]*
final pattern for message = [_\*]*message[_\*:]*
final pattern for severity = [_\*]*severity[_\*:]*
All clauses: 60:
 [
  {
    "line_label": "ABBREVIATION",
    "word": "abbreviation",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*abbreviation[_\\*:]*"
  },
  {
    "line_label": "NAME",
    "word": "name",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*name[_\\*:]*"
  },
  {
    "line_label": "PLURAL",
    "word": "plural",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*plural[_\\*:]*"
  },
  {
    "line_label": "NOTE",
    "class_started": "Annotation",
    "word": "note",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*note[_\\*:]*"
  },
  {
    "line_label": "ISSUE",
    "class_started": "Annotation",
    "word": "issue",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*issue[_\\*:]*"
  },
  {
    "line_label": "EXAMPLE",
    "class_started": "Annotation",
    "word": "example",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*example[_\\*:]*"
  },
  {
    "line_label": "SEE",
    "class_started": "Annotation",
    "word": "see",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*see[_\\*:]*"
  },
  {
    "line_label": "Section5_Head",
    "class_started": "Section5",
    "starter_pattern": "#####"
  },
  {
    "line_label": "Section4_Head",
    "class_started": "Section4",
    "starter_pattern": "####"
  },
  {
    "line_label": "Section3_Head",
    "class_started": "Section3",
    "starter_pattern": "###"
  },
  {
    "line_label": "Section2_Head",
    "class_started": "Section2",
    "starter_pattern": "##"
  },
  {
    "line_label": "LDM_Head",
    "class_started": "LDM",
    "starter_pattern": "#"
  },
  {
    "line_label": "CodeBlock_Head",
    "class_started": "CodeBlock",
    "starter_pattern": "```"
  },
  {
    "line_label": "Class_Head",
    "class_started": "Class",
    "starter_pattern": "_"
  },
  {
    "line_label": "ABBREVIATION",
    "word": "abbreviation",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*abbreviation[_\\*:]*"
  },
  {
    "line_label": "NAME",
    "word": "name",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*name[_\\*:]*"
  },
  {
    "line_label": "PLURAL",
    "word": "plural",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*plural[_\\*:]*"
  },
  {
    "line_label": "NOTE",
    "class_started": "Annotation",
    "word": "note",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*note[_\\*:]*"
  },
  {
    "line_label": "ISSUE",
    "class_started": "Annotation",
    "word": "issue",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*issue[_\\*:]*"
  },
  {
    "line_label": "EXAMPLE",
    "class_started": "Annotation",
    "word": "example",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*example[_\\*:]*"
  },
  {
    "line_label": "SEE",
    "class_started": "Annotation",
    "word": "see",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*see[_\\*:]*"
  },
  {
    "line_label": "AttributeSection_Head",
    "class_started": "AttributeSection",
    "starter_pattern": "__"
  },
  {
    "line_label": "Attribute_Head",
    "class_started": "Attribute",
    "starter_pattern": "-"
  },
  {
    "line_label": "ABBREVIATION",
    "word": "abbreviation",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*abbreviation[_\\*:]*"
  },
  {
    "line_label": "NAME",
    "word": "name",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*name[_\\*:]*"
  },
  {
    "line_label": "PLURAL",
    "word": "plural",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*plural[_\\*:]*"
  },
  {
    "line_label": "NOTE",
    "class_started": "Annotation",
    "word": "note",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*note[_\\*:]*"
  },
  {
    "line_label": "ISSUE",
    "class_started": "Annotation",
    "word": "issue",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*issue[_\\*:]*"
  },
  {
    "line_label": "EXAMPLE",
    "class_started": "Annotation",
    "word": "example",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*example[_\\*:]*"
  },
  {
    "line_label": "SEE",
    "class_started": "Annotation",
    "word": "see",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*see[_\\*:]*"
  },
  {
    "line_label": "Class_Head",
    "class_started": "Class",
    "starter_pattern": "_"
  },
  {
    "line_label": "SUBTYPE_OF",
    "word": "subtype of",
    "is_list": true,
    "is_cum": true,
    "parse_function": "parse_name_list",
    "kw_pattern": "[_\\*]*subtype\\s?of[_\\*:]*"
  },
  {
    "line_label": "SUBTYPES",
    "word": "subtypes",
    "is_list": true,
    "is_cum": true,
    "parse_function": "parse_name_list",
    "kw_pattern": "[_\\*]*subtypes[_\\*:]*"
  },
  {
    "line_label": "BASED_ON",
    "word": "based on",
    "is_list": true,
    "is_cum": true,
    "parse_function": "parse_name_list",
    "kw_pattern": "[_\\*]*based\\s?on[_\\*:]*"
  },
  {
    "line_label": "DEPENDENTS",
    "word": "dependents",
    "is_list": true,
    "is_cum": true,
    "parse_function": "parse_name_list",
    "kw_pattern": "[_\\*]*dependents[_\\*:]*"
  },
  {
    "line_label": "CONSTRAINT",
    "class_started": "Constraint",
    "word": "Constraint",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*Constraint[_\\*:]*"
  },
  {
    "line_label": "DEPENDENT_OF",
    "word": "dependent of",
    "is_list": true,
    "is_cum": true,
    "parse_function": "parse_name_list",
    "kw_pattern": "[_\\*]*dependent\\s?of[_\\*:]*"
  },
  {
    "line_label": "WHERE",
    "word": "where",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*where[_\\*:]*"
  },
  {
    "line_label": "CONSTRAINT",
    "class_started": "Constraint",
    "word": "Constraint",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*Constraint[_\\*:]*"
  },
  {
    "line_label": "AttributeSection_Head",
    "class_started": "AttributeSection",
    "starter_pattern": "__"
  },
  {
    "line_label": "Attribute_Head",
    "class_started": "Attribute",
    "starter_pattern": "-"
  },
  {
    "line_label": "ABBREVIATION",
    "word": "abbreviation",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*abbreviation[_\\*:]*"
  },
  {
    "line_label": "NAME",
    "word": "name",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*name[_\\*:]*"
  },
  {
    "line_label": "PLURAL",
    "word": "plural",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*plural[_\\*:]*"
  },
  {
    "line_label": "NOTE",
    "class_started": "Annotation",
    "word": "note",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*note[_\\*:]*"
  },
  {
    "line_label": "ISSUE",
    "class_started": "Annotation",
    "word": "issue",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*issue[_\\*:]*"
  },
  {
    "line_label": "EXAMPLE",
    "class_started": "Annotation",
    "word": "example",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*example[_\\*:]*"
  },
  {
    "line_label": "SEE",
    "class_started": "Annotation",
    "word": "see",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*see[_\\*:]*"
  },
  {
    "line_label": "Attribute_Head",
    "class_started": "Attribute",
    "starter_pattern": "-"
  },
  {
    "line_label": "DATA_TYPE",
    "word": "data type",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*data\\s?type[_\\*:]*"
  },
  {
    "line_label": "INVERSE",
    "word": "inverse",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_attribute_reference",
    "kw_pattern": "[_\\*]*inverse[_\\*:]*"
  },
  {
    "line_label": "INVERSE_OF",
    "word": "inverse of",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_attribute_reference",
    "kw_pattern": "[_\\*]*inverse\\s?of[_\\*:]*"
  },
  {
    "line_label": "OVERRIDES",
    "word": "overrides",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_attribute_reference",
    "kw_pattern": "[_\\*]*overrides[_\\*:]*"
  },
  {
    "line_label": "DERIVATION",
    "class_started": "Derivation",
    "word": "Derivation",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*Derivation[_\\*:]*"
  },
  {
    "line_label": "DEFAULT",
    "class_started": "Default",
    "word": "Default",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*Default[_\\*:]*"
  },
  {
    "line_label": "CONSTRAINT",
    "class_started": "Constraint",
    "word": "Constraint",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*Constraint[_\\*:]*"
  },
  {
    "line_label": "CODE",
    "word": "code",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*code[_\\*:]*"
  },
  {
    "line_label": "ENGLISH",
    "word": "english",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*english[_\\*:]*"
  },
  {
    "line_label": "MESSAGE",
    "word": "message",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*message[_\\*:]*"
  },
  {
    "line_label": "SEVERITY",
    "word": "severity",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*severity[_\\*:]*"
  }
]
All clause specs: 33:
 [
  {
    "line_label": "ABBREVIATION",
    "word": "abbreviation",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*abbreviation[_\\*:]*"
  },
  {
    "line_label": "NAME",
    "word": "name",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*name[_\\*:]*"
  },
  {
    "line_label": "PLURAL",
    "word": "plural",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*plural[_\\*:]*"
  },
  {
    "line_label": "NOTE",
    "class_started": "Annotation",
    "word": "note",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*note[_\\*:]*"
  },
  {
    "line_label": "ISSUE",
    "class_started": "Annotation",
    "word": "issue",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*issue[_\\*:]*"
  },
  {
    "line_label": "EXAMPLE",
    "class_started": "Annotation",
    "word": "example",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*example[_\\*:]*"
  },
  {
    "line_label": "SEE",
    "class_started": "Annotation",
    "word": "see",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*see[_\\*:]*"
  },
  {
    "line_label": "Section5_Head",
    "class_started": "Section5",
    "starter_pattern": "#####"
  },
  {
    "line_label": "Section4_Head",
    "class_started": "Section4",
    "starter_pattern": "####"
  },
  {
    "line_label": "Section3_Head",
    "class_started": "Section3",
    "starter_pattern": "###"
  },
  {
    "line_label": "Section2_Head",
    "class_started": "Section2",
    "starter_pattern": "##"
  },
  {
    "line_label": "LDM_Head",
    "class_started": "LDM",
    "starter_pattern": "#"
  },
  {
    "line_label": "CodeBlock_Head",
    "class_started": "CodeBlock",
    "starter_pattern": "```"
  },
  {
    "line_label": "Class_Head",
    "class_started": "Class",
    "starter_pattern": "_"
  },
  {
    "line_label": "ABBREVIATION",
    "word": "abbreviation",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*abbreviation[_\\*:]*"
  },
  {
    "line_label": "NAME",
    "word": "name",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*name[_\\*:]*"
  },
  {
    "line_label": "PLURAL",
    "word": "plural",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*plural[_\\*:]*"
  },
  {
    "line_label": "NOTE",
    "class_started": "Annotation",
    "word": "note",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*note[_\\*:]*"
  },
  {
    "line_label": "ISSUE",
    "class_started": "Annotation",
    "word": "issue",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*issue[_\\*:]*"
  },
  {
    "line_label": "EXAMPLE",
    "class_started": "Annotation",
    "word": "example",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*example[_\\*:]*"
  },
  {
    "line_label": "SEE",
    "class_started": "Annotation",
    "word": "see",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*see[_\\*:]*"
  },
  {
    "line_label": "AttributeSection_Head",
    "class_started": "AttributeSection",
    "starter_pattern": "__"
  },
  {
    "line_label": "Attribute_Head",
    "class_started": "Attribute",
    "starter_pattern": "-"
  },
  {
    "line_label": "ABBREVIATION",
    "word": "abbreviation",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*abbreviation[_\\*:]*"
  },
  {
    "line_label": "NAME",
    "word": "name",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*name[_\\*:]*"
  },
  {
    "line_label": "PLURAL",
    "word": "plural",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*plural[_\\*:]*"
  },
  {
    "line_label": "NOTE",
    "class_started": "Annotation",
    "word": "note",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*note[_\\*:]*"
  },
  {
    "line_label": "ISSUE",
    "class_started": "Annotation",
    "word": "issue",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*issue[_\\*:]*"
  },
  {
    "line_label": "EXAMPLE",
    "class_started": "Annotation",
    "word": "example",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*example[_\\*:]*"
  },
  {
    "line_label": "SEE",
    "class_started": "Annotation",
    "word": "see",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*see[_\\*:]*"
  },
  {
    "line_label": "Class_Head",
    "class_started": "Class",
    "starter_pattern": "_"
  },
  {
    "line_label": "SUBTYPE_OF",
    "word": "subtype of",
    "is_list": true,
    "is_cum": true,
    "parse_function": "parse_name_list",
    "kw_pattern": "[_\\*]*subtype\\s?of[_\\*:]*"
  },
  {
    "line_label": "SUBTYPES",
    "word": "subtypes",
    "is_list": true,
    "is_cum": true,
    "parse_function": "parse_name_list",
    "kw_pattern": "[_\\*]*subtypes[_\\*:]*"
  },
  {
    "line_label": "BASED_ON",
    "word": "based on",
    "is_list": true,
    "is_cum": true,
    "parse_function": "parse_name_list",
    "kw_pattern": "[_\\*]*based\\s?on[_\\*:]*"
  },
  {
    "line_label": "DEPENDENTS",
    "word": "dependents",
    "is_list": true,
    "is_cum": true,
    "parse_function": "parse_name_list",
    "kw_pattern": "[_\\*]*dependents[_\\*:]*"
  },
  {
    "line_label": "CONSTRAINT",
    "class_started": "Constraint",
    "word": "Constraint",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*Constraint[_\\*:]*"
  },
  {
    "line_label": "DEPENDENT_OF",
    "word": "dependent of",
    "is_list": true,
    "is_cum": true,
    "parse_function": "parse_name_list",
    "kw_pattern": "[_\\*]*dependent\\s?of[_\\*:]*"
  },
  {
    "line_label": "WHERE",
    "word": "where",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*where[_\\*:]*"
  },
  {
    "line_label": "CONSTRAINT",
    "class_started": "Constraint",
    "word": "Constraint",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*Constraint[_\\*:]*"
  },
  {
    "line_label": "AttributeSection_Head",
    "class_started": "AttributeSection",
    "starter_pattern": "__"
  },
  {
    "line_label": "Attribute_Head",
    "class_started": "Attribute",
    "starter_pattern": "-"
  },
  {
    "line_label": "ABBREVIATION",
    "word": "abbreviation",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*abbreviation[_\\*:]*"
  },
  {
    "line_label": "NAME",
    "word": "name",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*name[_\\*:]*"
  },
  {
    "line_label": "PLURAL",
    "word": "plural",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*plural[_\\*:]*"
  },
  {
    "line_label": "NOTE",
    "class_started": "Annotation",
    "word": "note",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*note[_\\*:]*"
  },
  {
    "line_label": "ISSUE",
    "class_started": "Annotation",
    "word": "issue",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*issue[_\\*:]*"
  },
  {
    "line_label": "EXAMPLE",
    "class_started": "Annotation",
    "word": "example",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*example[_\\*:]*"
  },
  {
    "line_label": "SEE",
    "class_started": "Annotation",
    "word": "see",
    "is_list": false,
    "is_cum": true,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*see[_\\*:]*"
  },
  {
    "line_label": "Attribute_Head",
    "class_started": "Attribute",
    "starter_pattern": "-"
  },
  {
    "line_label": "DATA_TYPE",
    "word": "data type",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*data\\s?type[_\\*:]*"
  },
  {
    "line_label": "INVERSE",
    "word": "inverse",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_attribute_reference",
    "kw_pattern": "[_\\*]*inverse[_\\*:]*"
  },
  {
    "line_label": "INVERSE_OF",
    "word": "inverse of",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_attribute_reference",
    "kw_pattern": "[_\\*]*inverse\\s?of[_\\*:]*"
  },
  {
    "line_label": "OVERRIDES",
    "word": "overrides",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_attribute_reference",
    "kw_pattern": "[_\\*]*overrides[_\\*:]*"
  },
  {
    "line_label": "DERIVATION",
    "class_started": "Derivation",
    "word": "Derivation",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*Derivation[_\\*:]*"
  },
  {
    "line_label": "DEFAULT",
    "class_started": "Default",
    "word": "Default",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*Default[_\\*:]*"
  },
  {
    "line_label": "CONSTRAINT",
    "class_started": "Constraint",
    "word": "Constraint",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*Constraint[_\\*:]*"
  },
  {
    "line_label": "CODE",
    "word": "code",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*code[_\\*:]*"
  },
  {
    "line_label": "ENGLISH",
    "word": "english",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*english[_\\*:]*"
  },
  {
    "line_label": "MESSAGE",
    "word": "message",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*message[_\\*:]*"
  },
  {
    "line_label": "SEVERITY",
    "word": "severity",
    "is_list": false,
    "is_cum": false,
    "parse_function": "parse_trivial",
    "kw_pattern": "[_\\*]*severity[_\\*:]*"
  }
]
parts needed:  {'Annotation', 'Section3', 'AttributeSection', 'LDM', 'Default', 'Section5', 'Constraint', 'Derivation', 'CodeBlock', 'Section2', 'Attribute', 'Class', 'Section4'}
final pattern for value type = [_\*]*value\s?type[_\*:]*
final pattern for Annotation = [_\*]*Annotation[_\*:]*
Part Parts:
 {
  "Document": [
    "LDM",
    "Section2",
    "Section3",
    "Section4",
    "Section5"
  ],
  "LDM": [
    "Class",
    "Section2",
    "Section3",
    "Section4",
    "Section5"
  ],
  "Section2": [
    "Class",
    "Section3",
    "Section4",
    "Section5"
  ],
  "Section3": [
    "Class",
    "Section4",
    "Section5"
  ],
  "Section4": [
    "Class",
    "Section5"
  ],
  "Section5": [
    "Class"
  ],
  "Class": [
    "AttributeSection",
    "Attribute",
    "Constraint"
  ],
  "AttributeSection": [
    "Attribute"
  ],
  "Attribute": [
    "Derivation",
    "Default",
    "Constraint"
  ]
}
Part Labels:
 {
  "Document": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "Section5_Head",
    "Section4_Head",
    "Section3_Head",
    "Section2_Head",
    "LDM_Head",
    "CodeBlock_Head",
    "Class_Head"
  ],
  "LDM": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "Section5_Head",
    "Section4_Head",
    "Section3_Head",
    "Section2_Head",
    "LDM_Head",
    "CodeBlock_Head",
    "Class_Head"
  ],
  "Section2": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "Section5_Head",
    "Section4_Head",
    "Section3_Head",
    "Section2_Head",
    "LDM_Head",
    "CodeBlock_Head",
    "Class_Head"
  ],
  "Section3": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "Section5_Head",
    "Section4_Head",
    "Section3_Head",
    "Section2_Head",
    "LDM_Head",
    "CodeBlock_Head",
    "Class_Head"
  ],
  "Section4": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "Section5_Head",
    "Section4_Head",
    "Section3_Head",
    "Section2_Head",
    "LDM_Head",
    "CodeBlock_Head",
    "Class_Head"
  ],
  "Section5": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "Section5_Head",
    "Section4_Head",
    "Section3_Head",
    "Section2_Head",
    "LDM_Head",
    "CodeBlock_Head",
    "Class_Head"
  ],
  "Class": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "Class_Head",
    "SUBTYPE_OF",
    "SUBTYPES",
    "BASED_ON",
    "DEPENDENTS",
    "CONSTRAINT",
    "DEPENDENT_OF",
    "WHERE",
    "CONSTRAINT",
    "AttributeSection_Head",
    "Attribute_Head"
  ],
  "AttributeSection": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "AttributeSection_Head",
    "Attribute_Head"
  ],
  "Attribute": [
    "ABBREVIATION",
    "NAME",
    "PLURAL",
    "NOTE",
    "ISSUE",
    "EXAMPLE",
    "SEE",
    "Attribute_Head",
    "DATA_TYPE",
    "INVERSE",
    "INVERSE_OF",
    "OVERRIDES",
    "DERIVATION",
    "DEFAULT",
    "CONSTRAINT"
  ],
  "Derivation": [
    "CODE",
    "ENGLISH",
    "MESSAGE",
    "SEVERITY"
  ],
  "Default": [
    "CODE",
    "ENGLISH",
    "MESSAGE",
    "SEVERITY"
  ],
  "Constraint": [
    "CODE",
    "ENGLISH",
    "MESSAGE",
    "SEVERITY"
  ],
  "CodeBlock": [
    "CODE",
    "ENGLISH",
    "MESSAGE",
    "SEVERITY"
  ]
}
Found LDM_Head: # Literate Data Model
For LDM_Head: # Literate Data Model
  new: LDM
Found new part: LDM
... LDM does fit into Document; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Section2_Head: ## Preliminaries
For Section2_Head: ## Preliminaries
  new: Section2
Found new part: Section2
... Section2 does fit into LDM; creating subpart
Found BLANK_LINE: 
Found TEXT_LINE: In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.
Found BLANK_LINE: 
Found TEXT_LINE: We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ **Component** - An element or building block of the literate data model
For Class_Head: _ **Component** - An element or building block of the literate data model
  new: Class
Found new part: Class
... Class does fit into Section2; creating subpart
Found Attribute_Head: - **normalName** - the name of the component, not in camel case (*String*)
For Attribute_Head: - **normalName** - the name of the component, not in camel case (*String*)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found Attribute_Head: - **name** - The name of the component (CamelName)
For Attribute_Head: - **name** - The name of the component (CamelName)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Attribute_Head: - **qualifiedName** - (*QualifiedCamel*)
For Attribute_Head: - **qualifiedName** - (*QualifiedCamel*)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - **abbreviatedName** - a short form of the component's name, used for cross references and improved readability. (*CamelName*)
For Attribute_Head: - **abbreviatedName** - a short form of the component's name, used for cross references and improved readability. (*CamelName*)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found DEFAULT: ***Default***: name
For DEFAULT: ***Default***: name
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
Found EXAMPLE: ***Example***: "LDM" is the short form of "Literate Data Model".
For EXAMPLE: ***Example***: "LDM" is the short form of "Literate Data Model".
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Default
..But Annotation not eligible for Attribute
..But Annotation not eligible for Class
..But Annotation not eligible for Section2
..But Annotation not eligible for LDM
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found BLANK_LINE: 
Found Attribute_Head: - **oneLiner** - A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _(RichLine)_
For Attribute_Head: - **oneLiner** - A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _(RichLine)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Annotation
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found BLANK_LINE: 
Found Attribute_Head: - **elaboration** - A more detailed explanation or discussion of the component _(RichText)_
For Attribute_Head: - **elaboration** - A more detailed explanation or discussion of the component _(RichText)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found BLANK_LINE: 
Found Class_Head: __***For Machinery*** - mechanical attributes
For Class_Head: __***For Machinery*** - mechanical attributes
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found Attribute_Head: - **isEmbellishment** - Indicates whether this component is an embellishment added during post-parsing processing _(Boolean)_
For Attribute_Head: - **isEmbellishment** - Indicates whether this component is an embellishment added during post-parsing processing _(Boolean)_
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found DEFAULT: ***Default***: false
For DEFAULT: ***Default***: false
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
Found NOTE: ***Note***: This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.
For NOTE: ***Note***: This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Default
..But Annotation not eligible for Attribute
..But Annotation not eligible for Class
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found Class_Head: __***Markdown Support***
For Class_Head: __***Markdown Support***
  new: Class
Found new part: Class
..But Class not eligible for Annotation
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found Attribute_Head: - **mdPrefix** (*[String](#string)*)
For Attribute_Head: - **mdPrefix** (*[String](#string)*)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found DERIVATION: ***Derivation***: ""
For DERIVATION: ***Derivation***: ""
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
Found Attribute_Head: - **mdSuffix** (*[String](#string)*)
For Attribute_Head: - **mdSuffix** (*[String](#string)*)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Derivation
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found DERIVATION: ***Derivation***: ""
For DERIVATION: ***Derivation***: ""
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
Found Attribute_Head: - **mdTopLine** (*[String](#string)*)
For Attribute_Head: - **mdTopLine** (*[String](#string)*)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Derivation
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found DERIVATION: ***Derivation***: mdPrefix + name + " - " + oneLiner + mdSuffix
For DERIVATION: ***Derivation***: mdPrefix + name + " - " + oneLiner + mdSuffix
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ **AnnotationType** - a kind of note, or aside, used to call attention to additional information about some Component.
FOUND EXTRA TEXT
..now included in:  Class_Head: _ **AnnotationType** - a kind of note, or aside, used to call attention to additional information about some Component.
ExtraText = 
And it can be continued on fresh lines.
	However many you want.
	But only up to a blank line or other clause

For Class_Head: _ **AnnotationType** - a kind of note, or aside, used to call attention to additional information about some Component.
ExtraText = 
And it can be continued on fresh lines.
	However many you want.
	But only up to a blank line or other clause

  new: Class
Found new part: Class
..But Class not eligible for Derivation
..But Class not eligible for Attribute
..But Class not eligible for Class
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found BLANK_LINE: 
Found SEE: See. this is not included in the extra text.
For SEE: See. this is not included in the extra text.
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Class
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found BLANK_LINE: 
Found BASED_ON: ***Based on*** : Literate Data Model
Found NOTE: ***Note***: Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.
FOUND EXTRA TEXT
..now included in:  NOTE: ***Note***: Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.
ExtraText = 
But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.

For NOTE: ***Note***: Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.
ExtraText = 
But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.

  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Annotation
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found Attribute_Head: - **emoji** - an emoji (Emoji)
For Attribute_Head: - **emoji** - an emoji (Emoji)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Annotation
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found Attribute_Head: - **emojiName** - an emoji (String)
For Attribute_Head: - **emojiName** - an emoji (String)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found Attribute_Head: - **emojiUnicode** - the Unicode for the emoji (Unicode)
For Attribute_Head: - **emojiUnicode** - the Unicode for the emoji (Unicode)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found Attribute_Head: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_
For Attribute_Head: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found Attribute_Head: - **plural** - the plural form of the label (*UpperCamel*).
For Attribute_Head: - **plural** - the plural form of the label (*UpperCamel*).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found DEFAULT: Default: based on label
For DEFAULT: Default: based on label
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
Found Attribute_Head: - **Purpose** - the intended reason for the annotation.
For Attribute_Head: - **Purpose** - the intended reason for the annotation.
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Default
..But Attribute not eligible for Attribute
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ ValueType: **Annotation**
FOUND EXTRA TEXT
..now included in:  Class_Head: _ ValueType: **Annotation**
ExtraText = 
A note or comment associated with a model element

For Class_Head: _ ValueType: **Annotation**
ExtraText = 
A note or comment associated with a model element

  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found BASED_ON: ***Based on***: Component
Found Attribute_Head: - **annotationType** - (optional Annotation Type)
For Attribute_Head: - **annotationType** - (optional Annotation Type)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found NOTE: Note: An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.
For NOTE: Note: An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Attribute
..But Annotation not eligible for Class
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found Attribute_Head: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_
For Attribute_Head: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Annotation
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found BLANK_LINE: 
Found TEXT_LINE: But any short label is valid.
Found DEFAULT: Default: from annotationType
For DEFAULT: Default: from annotationType
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
Found BLANK_LINE: 
Found Attribute_Head: - **Emoji** - (optional Emoji)
For Attribute_Head: - **Emoji** - (optional Emoji)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Default
..But Attribute not eligible for Attribute
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found DEFAULT: Default: from annotation type
For DEFAULT: Default: from annotation type
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Attribute_Head: - **content** - The content or body of the annotation (*RichText*)​​​​​​​
For Attribute_Head: - **content** - The content or body of the annotation (*RichText*)​​​​​​​
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Default
..But Attribute not eligible for Attribute
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found Class_Head: __***For Machinery***
For Class_Head: __***For Machinery***
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found Attribute_Head: - **isEmbellishment** - Indicates whether this annotation is an embellishment added during post-parsing processing _(Boolean)_
For Attribute_Head: - **isEmbellishment** - Indicates whether this annotation is an embellishment added during post-parsing processing _(Boolean)_
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found DEFAULT: ***Default***: false
For DEFAULT: ***Default***: false
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
Found NOTE: ***Note***: This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.
For NOTE: ***Note***: This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Default
..But Annotation not eligible for Attribute
..But Annotation not eligible for Class
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found BLANK_LINE: 
Found Section3_Head: ### Annotation Types Used
For Section3_Head: ### Annotation Types Used
  new: Section3
Found new part: Section3
..But Section3 not eligible for Annotation
... Section3 does fit into Document; creating subpart
Found BLANK_LINE: 
Found TEXT_LINE: These are the recognized Annotation Types for the LDM model.
Found BLANK_LINE: 
Found BLANK_LINE: 
Found TEXT_LINE: And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.
Found BLANK_LINE: 
Found CodeBlock_Head: ```typescript
FOUND EXTRA TEXT
..now included in:  CodeBlock_Head: ```typescript
ExtraText = 
interface AnnotationType {
	label: string;
	emoji: string;
	emojiName: string;
	emojiUnicode: string;
	purpose: string;
	}
	// LINK: LiterateDataModel.annotationTypes
	const annotationTypes: AnnotationType[] = [
	{
	label: "Error",
	emoji: "",
	emojiName: "cross_mark",
	emojiUnicode: "U+274C",
	purpose: "Indicates a critical error or failure in the model."
	},
	{
	label: "Warning",
	emoji: "",
	emojiName: "warning",
	emojiUnicode: "U+26A0",
	purpose: "Indicates a potential issue or warning in the model."
	},
	{
	label: "Note",
	emoji: "",
	emojiName: "blue_book",
	emojiUnicode: "U+1F4D8",
	purpose: "Provides additional context, explanations, or clarifications for the annotated element."
	},
	{
	label: "Issue",
	emoji: "",
	emojiName: "warning",
	emojiUnicode: "U+26A0",
	purpose: "Highlights a potential issue or error that needs to be addressed or resolved."
	},
	{
	label: "Question",
	emoji: "",
	emojiName: "question",
	emojiUnicode: "U+2753",
	purpose: "Raises a question or seeks further clarification about the annotated element."
	},
	{
	label: "Suggestion",
	emoji: "",
	emojiName: "bulb",
	emojiUnicode: "U+1F4A1",
	purpose: "Provides a suggestion or recommendation for improving the model or the annotated element."
	},
	{
	label: "Info",
	emoji: "",
	emojiName: "information_source",
	emojiUnicode: "U+2139",
	purpose: "Offers relevant information, facts, or details about the annotated element."
	},
	{
	label: "Todo",
	emoji: "",
	emojiName: "pushpin",
	emojiUnicode: "U+1F4CC",
	purpose: "Indicates a pending task, action item, or future work related to the annotated element."
	},
	{
	label: "Reference",
	emoji: "",
	emojiName: "globe_with_meridians",
	emojiUnicode: "U+1F310",
	purpose: "Provides a reference or link to an external resource or documentation."
	},
	{
	label: "See",
	emoji: "",
	emojiName: "mag",
	emojiUnicode: "U+1F50D",
	purpose: "Indicates a cross-reference to another relevant element within the model."
	}
	];

For CodeBlock_Head: ```typescript
ExtraText = 
interface AnnotationType {
	label: string;
	emoji: string;
	emojiName: string;
	emojiUnicode: string;
	purpose: string;
	}
	// LINK: LiterateDataModel.annotationTypes
	const annotationTypes: AnnotationType[] = [
	{
	label: "Error",
	emoji: "",
	emojiName: "cross_mark",
	emojiUnicode: "U+274C",
	purpose: "Indicates a critical error or failure in the model."
	},
	{
	label: "Warning",
	emoji: "",
	emojiName: "warning",
	emojiUnicode: "U+26A0",
	purpose: "Indicates a potential issue or warning in the model."
	},
	{
	label: "Note",
	emoji: "",
	emojiName: "blue_book",
	emojiUnicode: "U+1F4D8",
	purpose: "Provides additional context, explanations, or clarifications for the annotated element."
	},
	{
	label: "Issue",
	emoji: "",
	emojiName: "warning",
	emojiUnicode: "U+26A0",
	purpose: "Highlights a potential issue or error that needs to be addressed or resolved."
	},
	{
	label: "Question",
	emoji: "",
	emojiName: "question",
	emojiUnicode: "U+2753",
	purpose: "Raises a question or seeks further clarification about the annotated element."
	},
	{
	label: "Suggestion",
	emoji: "",
	emojiName: "bulb",
	emojiUnicode: "U+1F4A1",
	purpose: "Provides a suggestion or recommendation for improving the model or the annotated element."
	},
	{
	label: "Info",
	emoji: "",
	emojiName: "information_source",
	emojiUnicode: "U+2139",
	purpose: "Offers relevant information, facts, or details about the annotated element."
	},
	{
	label: "Todo",
	emoji: "",
	emojiName: "pushpin",
	emojiUnicode: "U+1F4CC",
	purpose: "Indicates a pending task, action item, or future work related to the annotated element."
	},
	{
	label: "Reference",
	emoji: "",
	emojiName: "globe_with_meridians",
	emojiUnicode: "U+1F310",
	purpose: "Provides a reference or link to an external resource or documentation."
	},
	{
	label: "See",
	emoji: "",
	emojiName: "mag",
	emojiUnicode: "U+1F50D",
	purpose: "Indicates a cross-reference to another relevant element within the model."
	}
	];

  new: CodeBlock
Starting code bock - CodeBlock with label CodeBlock_Head
Consumed through  {final_label}:  CodeBlock_Head: ```
FOUND CODE BLOCK: ['```']
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Section2_Head: ## The Model and its Subjects
For Section2_Head: ## The Model and its Subjects
  new: Section2
Found new part: Section2
..But Section2 not eligible for Section3
... Section2 does fit into Document; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ **LiterateDataModel** - A representation of a domain's entities, attributes, and relationships,
FOUND EXTRA TEXT
..now included in:  Class_Head: _ **LiterateDataModel** - A representation of a domain's entities, attributes, and relationships,
ExtraText = 
along with explanatory text and examples

For Class_Head: _ **LiterateDataModel** - A representation of a domain's entities, attributes, and relationships,
ExtraText = 
along with explanatory text and examples

  new: Class
Found new part: Class
... Class does fit into Section2; creating subpart
Found ABBREVIATION: ***Abbreviation***: LDM
Found PLURAL: _Plural:_ LiterateDataModels
Found Class_Head: _Subtype of:_ Component
For Class_Head: _Subtype of:_ Component
  new: Class
Found new part: Class
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Attribute_Head: - name (UpperCamel )
For Attribute_Head: - name (UpperCamel )
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - allSubjects - list of all classes in the model, as ordered in the
FOUND EXTRA TEXT
..now included in:  Attribute_Head: - allSubjects - list of all classes in the model, as ordered in the
ExtraText = 
definition of the model. (List of Classes)

For Attribute_Head: - allSubjects - list of all classes in the model, as ordered in the
ExtraText = 
definition of the model. (List of Classes)

  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found DERIVATION: Derivation: gathering s.allSubjects over s in subjectAreas
For DERIVATION: Derivation: gathering s.allSubjects over s in subjectAreas
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
Found BLANK_LINE: 
Found CONSTRAINT: ***Constraint***: Subject names must be unique across the model.
For CONSTRAINT: ***Constraint***: Subject names must be unique across the model.
  new: Constraint
Found new part: Constraint
..But Constraint not eligible for Derivation
... Constraint does fit into Attribute; creating subpart
Found Attribute_Head: - allClasses - list of all classes in the model, as ordered in the definition of the model. (List of Classes)
For Attribute_Head: - allClasses - list of all classes in the model, as ordered in the definition of the model. (List of Classes)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Constraint
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found DERIVATION: Derivation: gathering s.allClasses over s in allSubjects.
For DERIVATION: Derivation: gathering s.allClasses over s in allSubjects.
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
Found CONSTRAINT: ***Constraint***: Class names must be unique across the model.
For CONSTRAINT: ***Constraint***: Class names must be unique across the model.
  new: Constraint
Found new part: Constraint
..But Constraint not eligible for Derivation
... Constraint does fit into Attribute; creating subpart
Found BLANK_LINE: 
Found Class_Head: __ 	***Modeling Configuration***
For Class_Head: __ 	***Modeling Configuration***
  new: Class
Found new part: Class
..But Class not eligible for Constraint
..But Class not eligible for Attribute
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
Found Attribute_Head: - **annotationTypes** - (List of AnnotationTypes)
For Attribute_Head: - **annotationTypes** - (List of AnnotationTypes)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - **Preferred Coding Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Coding Language).
For Attribute_Head: - **Preferred Coding Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Coding Language).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found DEFAULT: Default: OCL
For DEFAULT: Default: OCL
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
Found Attribute_Head: - **alternate Coding Languages** -  (optional List of Coding Languages).
For Attribute_Head: - **alternate Coding Languages** -  (optional List of Coding Languages).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Default
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - **Preferred Template Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Template Language).
For Attribute_Head: - **Preferred Template Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Template Language).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found DEFAULT: Default: Handlebars
For DEFAULT: Default: Handlebars
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
Found Attribute_Head: - **alternate Template Languages** -  (optional List of Template Languages).
For Attribute_Head: - **alternate Template Languages** -  (optional List of Template Languages).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Default
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - **aiFunctions** - A list of functions that require sophisticated AI-powered implementation *(List of String)*
For Attribute_Head: - **aiFunctions** - A list of functions that require sophisticated AI-powered implementation *(List of String)*
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found DERIVATION: Derivation: ['aiEnglishPlural()']
For DERIVATION: Derivation: ['aiEnglishPlural()']
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
Found BLANK_LINE: 
Found Class_Head: __***Markdown Support***
For Class_Head: __***Markdown Support***
  new: Class
Found new part: Class
..But Class not eligible for Derivation
..But Class not eligible for Attribute
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
Found Attribute_Head: - **mdPrefix** (*[String](#string)*)
For Attribute_Head: - **mdPrefix** (*[String](#string)*)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found DERIVATION: ***Derivation***: "# "
For DERIVATION: ***Derivation***: "# "
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
Found BLANK_LINE: 
Found Attribute_Head: - **mdTopLine** (*[String](#string)*)
For Attribute_Head: - **mdTopLine** (*[String](#string)*)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Derivation
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found DERIVATION: ***Derivation***: mdPrefix + name
For DERIVATION: ***Derivation***: mdPrefix + name
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ **Subject**
FOUND EXTRA TEXT
..now included in:  Class_Head: _ **Subject**
ExtraText = 
A specific topic or theme within the model

For Class_Head: _ **Subject**
ExtraText = 
A specific topic or theme within the model

  new: Class
Found new part: Class
..But Class not eligible for Derivation
..But Class not eligible for Attribute
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
Found PLURAL: _Plural:_ Subjects
Found Class_Head: _Subtype of:_ Component
For Class_Head: _Subtype of:_ Component
  new: Class
Found new part: Class
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
Found DEPENDENT_OF: Dependent of: LiterateDataModel
Found BLANK_LINE: 
Found TEXT_LINE: Subjects are the chapters an sections of the model.
Found TEXT_LINE: A subject need not contain any Classes if it’s just expository.
Found BLANK_LINE: 
Found Attribute_Head: - name (UpperCamel )
For Attribute_Head: - name (UpperCamel )
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - **parentSubject** - The parent subject, if any, under which this subject is nested _(Subject, optional)_
For Attribute_Head: - **parentSubject** - The parent subject, if any, under which this subject is nested _(Subject, optional)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found Attribute_Head: - **Classes** - The major classes related to this subject, in the order in which they should be presented _(ListOf Classes)_
For Attribute_Head: - **Classes** - The major classes related to this subject, in the order in which they should be presented _(ListOf Classes)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found ISSUE: ***Issue***: define chapter, section, subsection as levels?
FOUND EXTRA TEXT
..now included in:  ISSUE: ***Issue***: define chapter, section, subsection as levels?
ExtraText = 
***DSL***: Generally, it is best to present the classes within a Subject in top down order:

For ISSUE: ***Issue***: define chapter, section, subsection as levels?
ExtraText = 
***DSL***: Generally, it is best to present the classes within a Subject in top down order:

  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Attribute
..But Annotation not eligible for Class
..But Annotation not eligible for Section2
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found Attribute_Head: - Each Class should be followed first by the classes that are dependent on it, and then
For Attribute_Head: - Each Class should be followed first by the classes that are dependent on it, and then
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Annotation
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found Attribute_Head: - By its subtype classes.
For Attribute_Head: - By its subtype classes.
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Attribute_Head: - **childSubjects** - Any child subjects nested under this subject, in the order in which they should be presented _(ListOf Subjects)_
For Attribute_Head: - **childSubjects** - Any child subjects nested under this subject, in the order in which they should be presented _(ListOf Subjects)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found INVERSE: inverse of: Subject.parentSubject.
Found BLANK_LINE: 
Found TEXT_LINE: ***DSL***:  the Classes within a Subject are always displayed before the childSubjects.
Found BLANK_LINE: 
Found Class_Head: __***Markdown Support***
For Class_Head: __***Markdown Support***
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found Attribute_Head: - **mdPrefix** (*[String](#string)*)
For Attribute_Head: - **mdPrefix** (*[String](#string)*)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found DERIVATION: ***Derivation***: levelIndicator + " "
For DERIVATION: ***Derivation***: levelIndicator + " "
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
Found BLANK_LINE: 
Found Attribute_Head: - **mdTopLine** (*[String](#string)*)
For Attribute_Head: - **mdTopLine** (*[String](#string)*)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Derivation
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found DERIVATION: ***Derivation***: mdPrefix + name.
For DERIVATION: ***Derivation***: mdPrefix + name.
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
Found BLANK_LINE: 
Found Class_Head: _ **SubjectArea**
FOUND EXTRA TEXT
..now included in:  Class_Head: _ **SubjectArea**
ExtraText = 
A main topic or area of focus within the model, containing related subjects and classes

For Class_Head: _ **SubjectArea**
ExtraText = 
A main topic or area of focus within the model, containing related subjects and classes

  new: Class
Found new part: Class
..But Class not eligible for Derivation
..But Class not eligible for Attribute
..But Class not eligible for Class
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found PLURAL: _Plural:_ SubjectAreas
Found Class_Head: _Subtype of:_ Subject
For Class_Head: _Subtype of:_ Subject
  new: Class
Found new part: Class
..But Class not eligible for Class
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found Class_Head: _Where:_ parentSubject is absent
For Class_Head: _Where:_ parentSubject is absent
  new: Class
Found new part: Class
..But Class not eligible for Class
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Section3_Head: ### Classes
For Section3_Head: ### Classes
  new: Section3
Found new part: Section3
..But Section3 not eligible for Class
... Section3 does fit into Document; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ **Class** - A key entity or object type in the model, often corresponding to a real-world concept
For Class_Head: _ **Class** - A key entity or object type in the model, often corresponding to a real-world concept
  new: Class
Found new part: Class
... Class does fit into Section3; creating subpart
Found BLANK_LINE: 
Found PLURAL: _Plural:_ Classes
Found Class_Head: _Subtype of:_ Component
For Class_Head: _Subtype of:_ Component
  new: Class
Found new part: Class
..But Class not eligible for Class
... Class does fit into Section3; creating subpart
Found CONSTRAINT: ***Constraint***: Within each Class, attribute names must be unique.
For CONSTRAINT: ***Constraint***: Within each Class, attribute names must be unique.
  new: Constraint
Found new part: Constraint
... Constraint does fit into Class; creating subpart
Found Attribute_Head: - **pluralForm** - the normal English plural form of the name of the Class (UpperName)
For Attribute_Head: - **pluralForm** - the normal English plural form of the name of the Class (UpperName)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Constraint
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found TEXT_LINE: Might be Books for the Book class or other regular plurals.
Found TEXT_LINE: But also might be People for Person.
Found BLANK_LINE: 
Found NOTE: Note: When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.
For NOTE: Note: When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Attribute
..But Annotation not eligible for Class
..But Annotation not eligible for Section3
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found BLANK_LINE: 
Found TEXT_LINE: The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.
Found DEFAULT: ***Default***: the regular plural, formed by adding "s" or "es".
For DEFAULT: ***Default***: the regular plural, formed by adding "s" or "es".
  new: Default
Found new part: Default
..But Default not eligible for Annotation
..But Default not eligible for Document
... Default does fit into Document; creating subpart
Found Attribute_Head: - **basedOn** - the Class or Classes on which this class is dependent (SetOf Classes).
For Attribute_Head: - **basedOn** - the Class or Classes on which this class is dependent (SetOf Classes).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Default
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found TEXT_LINE: This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.
Found BLANK_LINE: 
Found NOTE: Note: basedOn and dependentOf are being used synonymousle in this metamodel.
For NOTE: Note: basedOn and dependentOf are being used synonymousle in this metamodel.
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Attribute
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found ISSUE: issue: fix that
For ISSUE: issue: fix that
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Annotation
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Attribute_Head: - **supertypes** - The parent class(es) from which this class inherits attributes _(ListOf Classes)_
For Attribute_Head: - **supertypes** - The parent class(es) from which this class inherits attributes _(ListOf Classes)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Annotation
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found BLANK_LINE: 
Found Attribute_Head: - **subtypings** - the criteria, or dimensions, by which the class can be divided into subtypes (list of Subtypings).
For Attribute_Head: - **subtypings** - the criteria, or dimensions, by which the class can be divided into subtypes (list of Subtypings).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found BLANK_LINE: 
Found EXAMPLE: Example: in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).
For EXAMPLE: Example: in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Attribute
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Attribute_Head: - **subtypes** - Any subtypes or specializations of this class based on it’s subtypings. _(ListOf Classes)_
For Attribute_Head: - **subtypes** - Any subtypes or specializations of this class based on it’s subtypings. _(ListOf Classes)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Annotation
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found EXAMPLE: Example: For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.
For EXAMPLE: Example: For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Attribute
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Attribute_Head: - **attributes** - The attributes or properties of the class, in the order in which they should be presented _(ListOf Attributes)_
For Attribute_Head: - **attributes** - The attributes or properties of the class, in the order in which they should be presented _(ListOf Attributes)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Annotation
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found Attribute_Head: - **attributeSections** - additional attributes or properties of the class, grouped for clarity and elaboration.  _(ListOf AttributeSections)_
For Attribute_Head: - **attributeSections** - additional attributes or properties of the class, grouped for clarity and elaboration.  _(ListOf AttributeSections)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found BLANK_LINE: 
Found Attribute_Head: - **constraints** - Any constraints, rules, or validations specific to this class _(ListOf Constraints)_
For Attribute_Head: - **constraints** - Any constraints, rules, or validations specific to this class _(ListOf Constraints)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found NOTE: Note: Constraints may be expressed on either the Class or the Attribute. Always?
FOUND EXTRA TEXT
..now included in:  NOTE: Note: Constraints may be expressed on either the Class or the Attribute. Always?
ExtraText = 
Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.

For NOTE: Note: Constraints may be expressed on either the Class or the Attribute. Always?
ExtraText = 
Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.

  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Attribute
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found Attribute_Head: - **methods** - Any behaviors or operations associated with this class _(ListOf Methods)_
For Attribute_Head: - **methods** - Any behaviors or operations associated with this class _(ListOf Methods)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Annotation
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found BLANK_LINE: 
Found Class_Head: __ ***Implied Attributes***
For Class_Head: __ ***Implied Attributes***
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found Attribute_Head: - **dependents** - the Classes which are basedOn this Class (optional SetOf Classes).
For Attribute_Head: - **dependents** - the Classes which are basedOn this Class (optional SetOf Classes).
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found INVERSE: ***Inverse of***: Class.basedOn
Found Attribute_Head: - UniqueKeys - (optional Set of UniqueKeys).
For Attribute_Head: - UniqueKeys - (optional Set of UniqueKeys).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found INVERSE: ***Inverse of***:
FOUND EXTRA TEXT
..now included in:  INVERSE: ***Inverse of***:
ExtraText = 
UniqueKey.basedOn

Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ **Subtyping** - a way in which subtypes of a Class may be classified (Subtype of Component).
For Class_Head: _ **Subtyping** - a way in which subtypes of a Class may be classified (Subtype of Component).
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Class
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found DEPENDENT_OF: ***Dependent of:*** Class
Found Attribute_Head: - **name** (Upper Name).
FOUND EXTRA TEXT
..now included in:  Attribute_Head: - **name** (Upper Name).
ExtraText = 
Usually ByThis or ByThat

For Attribute_Head: - **name** (Upper Name).
ExtraText = 
Usually ByThis or ByThat

  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - **is exclusive** (Boolean).
For Attribute_Head: - **is exclusive** (Boolean).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found DEFAULT: Default: true
For DEFAULT: Default: true
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
Found Attribute_Head: - **is exhaustive** (Boolean).
For Attribute_Head: - **is exhaustive** (Boolean).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Default
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found DEFAULT: Default: true
For DEFAULT: Default: true
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
Found Attribute_Head: - **classes** (List of Classes).
For Attribute_Head: - **classes** (List of Classes).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Default
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found TEXT_LINE: ***DSL***:  Shown in the DSL as
Found TEXT_LINE: > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)
Found TEXT_LINE: on the super class. And as
Found TEXT_LINE: > Subtype of: SuperClass byBrand
Found TEXT_LINE: on the subclass.
Found BLANK_LINE: 
Found NOTE: Note: every class can have an unnamed subtyping.
FOUND EXTRA TEXT
..now included in:  NOTE: Note: every class can have an unnamed subtyping.
ExtraText = 
Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.

For NOTE: Note: every class can have an unnamed subtyping.
ExtraText = 
Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.

  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Attribute
..But Annotation not eligible for Class
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found BLANK_LINE: 
Found Class_Head: _ **ValueType** -
For Class_Head: _ **ValueType** -
  new: Class
Found new part: Class
..But Class not eligible for Annotation
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found SUBTYPE_OF: Subtype of: Class.
Found Class_Head: __***Markdown Support***
For Class_Head: __***Markdown Support***
  new: Class
Found new part: Class
..But Class not eligible for Class
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found Attribute_Head: - ***mdPrefix*** (*[String](#string)*)
For Attribute_Head: - ***mdPrefix*** (*[String](#string)*)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found DERIVATION: ***Derivation***: "ValueType: ".
For DERIVATION: ***Derivation***: "ValueType: ".
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ **Reference Type**:
For Class_Head: _ **Reference Type**:
  new: Class
Found new part: Class
..But Class not eligible for Derivation
..But Class not eligible for Attribute
..But Class not eligible for Class
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found SUBTYPE_OF: Subtype of: Class.
Found BLANK_LINE: 
Found Class_Head: _ **CodeType**
FOUND EXTRA TEXT
..now included in:  Class_Head: _ **CodeType**
ExtraText = 
A data type or enumeration used in the model

For Class_Head: _ **CodeType**
ExtraText = 
A data type or enumeration used in the model

  new: Class
Found new part: Class
..But Class not eligible for Class
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found Class_Head: _Subtype of:_ ValueType.
For Class_Head: _Subtype of:_ ValueType.
  new: Class
Found new part: Class
..But Class not eligible for Class
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found NOTE: Note: Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:
For NOTE: Note: Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Class
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found Attribute_Head: - List the code values as a bulletted list inside the description of the attribute in the form:
FOUND EXTRA TEXT
..now included in:  Attribute_Head: - List the code values as a bulletted list inside the description of the attribute in the form:
ExtraText = 
‘**code**: description’

For Attribute_Head: - List the code values as a bulletted list inside the description of the attribute in the form:
ExtraText = 
‘**code**: description’

  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Annotation
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found Attribute_Head: - A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.
For Attribute_Head: - A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found Attribute_Head: - isCaptive - the code type was implied by use in an attribute and is only used for that attribute (Boolean) as
For Attribute_Head: - isCaptive - the code type was implied by use in an attribute and is only used for that attribute (Boolean) as
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found Class_Head: _ **Code Value**
FOUND EXTRA TEXT
..now included in:  Class_Head: _ **Code Value**
ExtraText = 
A possible value for an enumerated data class  DependentOf: CodeType

For Class_Head: _ **Code Value**
ExtraText = 
A possible value for an enumerated data class  DependentOf: CodeType

  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found BLANK_LINE: 
Found Attribute_Head: - **code** - A short code or abbreviationi for the value _(NameString)_
For Attribute_Head: - **code** - A short code or abbreviationi for the value _(NameString)_
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - **description** - an explanation of what the code means (*RichText*)
For Attribute_Head: - **description** - an explanation of what the code means (*RichText*)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ **Key** - a list of attributes of a class
For Class_Head: _ **Key** - a list of attributes of a class
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Class
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found SUBTYPE_OF: Subtype of: Component
Found DEPENDENT_OF: DependentOf: Class
Found Attribute_Head: - keyAttributes - the attributes of the base Class. (List of Attributes ).
For Attribute_Head: - keyAttributes - the attributes of the base Class. (List of Attributes ).
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found CONSTRAINT: Constraint: each attribute must be a direct or inherited of the base class.
For CONSTRAINT: Constraint: each attribute must be a direct or inherited of the base class.
  new: Constraint
Found new part: Constraint
... Constraint does fit into Attribute; creating subpart
Found CONSTRAINT: Constraint: no repetitions allowed in keyAttributes
FOUND EXTRA TEXT
..now included in:  CONSTRAINT: Constraint: no repetitions allowed in keyAttributes
ExtraText = 
>  **Issue**: introduce PureLists?

For CONSTRAINT: Constraint: no repetitions allowed in keyAttributes
ExtraText = 
>  **Issue**: introduce PureLists?

  new: Constraint
Found new part: Constraint
..But Constraint not eligible for Constraint
... Constraint does fit into Attribute; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found ISSUE: Issue: need ascending descending to support index keys or ordering keys.
For ISSUE: Issue: need ascending descending to support index keys or ordering keys.
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Constraint
..But Annotation not eligible for Attribute
..But Annotation not eligible for Class
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found BLANK_LINE: 
Found Class_Head: _ **UniqueKey** - a list of attributes on which instances of the base class may be keyed.
For Class_Head: _ **UniqueKey** - a list of attributes on which instances of the base class may be keyed.
  new: Class
Found new part: Class
..But Class not eligible for Annotation
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found SUBTYPE_OF: Subtype of: Key
Found BLANK_LINE: 
Found NOTE: Note: order unimportant for Unique Keys.
For NOTE: Note: order unimportant for Unique Keys.
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Class
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found BLANK_LINE: 
Found Section2_Head: ## Attributes
For Section2_Head: ## Attributes
  new: Section2
Found new part: Section2
..But Section2 not eligible for Annotation
... Section2 does fit into Document; creating subpart
Found BLANK_LINE: 
Found Class_Head: _ **Attribute Section** - a group of attributes for a class that merit a shared explanation.
For Class_Head: _ **Attribute Section** - a group of attributes for a class that merit a shared explanation.
  new: Class
Found new part: Class
... Class does fit into Section2; creating subpart
Found SUBTYPE_OF: ***SubtypeOf***: Component.
Found BASED_ON: ***Based on***: Class
Found Attribute_Head: -	isOptional - whether the attributes in this section, taken together, are optional. (Boolean)
For Attribute_Head: -	isOptional - whether the attributes in this section, taken together, are optional. (Boolean)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found Class_Head: _
FOUND EXTRA TEXT
..now included in:  Class_Head: _
ExtraText = 
If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.
	&nbsp;
	But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.

For Class_Head: _
ExtraText = 
If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.
	&nbsp;
	But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.

  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
Found BLANK_LINE: 
Found Class_Head: __***Markdown Support***
For Class_Head: __***Markdown Support***
  new: Class
Found new part: Class
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
Found Attribute_Head: - **mdPrefix** (*[String](#string)*)
For Attribute_Head: - **mdPrefix** (*[String](#string)*)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found DEFAULT: ***Default***: "_ "
For DEFAULT: ***Default***: "_ "
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
Found Attribute_Head: - **mdTopLine** (*[String](#string)*).
For Attribute_Head: - **mdTopLine** (*[String](#string)*).
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Default
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found Class_Head: _ **Attribute**
FOUND EXTRA TEXT
..now included in:  Class_Head: _ **Attribute**
ExtraText = 
A property or characteristic of a class

For Class_Head: _ **Attribute**
ExtraText = 
A property or characteristic of a class

  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
Found PLURAL: _Plural:_ Attributes
Found Class_Head: _Subtype of:_ Component
For Class_Head: _Subtype of:_ Component
  new: Class
Found new part: Class
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
Found BASED_ON: *Based on*: AttributeSection
Found Attribute_Head: - **name** - (Lower Camel).
For Attribute_Head: - **name** - (Lower Camel).
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found OVERRIDES: Overrides: CamelName
Found Attribute_Head: - **dataType** - The kind of object to which the attribute refers.  _(DataType)_
FOUND EXTRA TEXT
..now included in:  Attribute_Head: - **dataType** - The kind of object to which the attribute refers.  _(DataType)_
ExtraText = 
H
	In the simplest cases, the data type will be a class. And the specifier is the just the name of that class.

For Attribute_Head: - **dataType** - The kind of object to which the attribute refers.  _(DataType)_
ExtraText = 
H
	In the simplest cases, the data type will be a class. And the specifier is the just the name of that class.

  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found TEXT_LINE: But,
Found Attribute_Head: - List of Editions
For Attribute_Head: - List of Editions
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - Set of Edition
For Attribute_Head: - Set of Edition
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - ... and more complicated cases.
For Attribute_Head: - ... and more complicated cases.
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found SEE: ***See***: the section below on Data Type Specifiers.
For SEE: ***See***: the section below on Data Type Specifiers.
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Attribute
..But Annotation not eligible for Class
..But Annotation not eligible for Section2
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found BLANK_LINE: 
Found Class_Head: __ **Cardinalities**.
For Class_Head: __ **Cardinalities**.
  new: Class
Found new part: Class
..But Class not eligible for Annotation
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found Attribute_Head: - **isOptional** - Indicates whether the attribute must have a value for every instance of the class _(Boolean)_
For Attribute_Head: - **isOptional** - Indicates whether the attribute must have a value for every instance of the class _(Boolean)_
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found DEFAULT: ***Default:*** False
For DEFAULT: ***Default:*** False
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
Found BLANK_LINE: 
Found Attribute_Head: - **cardinality** - The cardinality of the relationship represented by the attribute _(CardinalityCode)_
For Attribute_Head: - **cardinality** - The cardinality of the relationship represented by the attribute _(CardinalityCode)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Default
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found DEFAULT: ***Default:***
For DEFAULT: ***Default:***
  new: Default
Found new part: Default
... Default does fit into Attribute; creating subpart
Found Attribute_Head: - For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.
For Attribute_Head: - For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Default
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.
For Attribute_Head: - For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found TEXT_LINE: ***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.
Found TEXT_LINE: For example:
Found Attribute_Head: - author (1:1 Author)
For Attribute_Head: - author (1:1 Author)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - books (optional N:M Set of Books)
For Attribute_Head: - books (optional N:M Set of Books)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found NOTE: ***Note***: how this works with optionality
For NOTE: ***Note***: how this works with optionality
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Attribute
..But Annotation not eligible for Class
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found BLANK_LINE: 
Found Class_Head: __ ***Inverse Attributes***
For Class_Head: __ ***Inverse Attributes***
  new: Class
Found new part: Class
..But Class not eligible for Annotation
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found Attribute_Head: - **isInvertible** - (Boolean)
For Attribute_Head: - **isInvertible** - (Boolean)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found DERIVATION: ***Derivation***: true if the data type is a class or a simple collection of members of a class.
For DERIVATION: ***Derivation***: true if the data type is a class or a simple collection of members of a class.
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
Found Attribute_Head: - **inverseClass** - the class which contains, or would contain the inverse attribute (optional Class)
For Attribute_Head: - **inverseClass** - the class which contains, or would contain the inverse attribute (optional Class)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Derivation
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found DERIVATION: ***Derivation***: from the data type. Null unless arrribute is invertible.
For DERIVATION: ***Derivation***: from the data type. Null unless arrribute is invertible.
  new: Derivation
Found new part: Derivation
... Derivation does fit into Attribute; creating subpart
Found Attribute_Head: - **inverseAttribute** - (optional Attribute)
For Attribute_Head: - **inverseAttribute** - (optional Attribute)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Derivation
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - **inverseIsOptional** - (optional Attribute)
For Attribute_Head: - **inverseIsOptional** - (optional Attribute)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found Class_Head: _ ***Formulas***
For Class_Head: _ ***Formulas***
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Class
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found BLANK_LINE: 
Found Attribute_Head: - **default** - The rule or formula for calculating the value, if no value is supplied _(Derivation, optional)_
For Attribute_Head: - **default** - The rule or formula for calculating the value, if no value is supplied _(Derivation, optional)_
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found NOTE: Note: even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.
For NOTE: Note: even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Attribute
..But Annotation not eligible for Class
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found BLANK_LINE: 
Found Attribute_Head: - **derivation** - For derived attributes, the rule or formula for calculating the value _(Derivation, optional)_
For Attribute_Head: - **derivation** - For derived attributes, the rule or formula for calculating the value _(Derivation, optional)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Annotation
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found ISSUE: ***Issue***: on insert vs on access?
For ISSUE: ***Issue***: on insert vs on access?
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Attribute
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found Attribute_Head: - **constraints** - Any validation rules specific to this attribute _(ListOf Constraints)_
For Attribute_Head: - **constraints** - Any validation rules specific to this attribute _(ListOf Constraints)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Annotation
..But Attribute not eligible for Document
... Attribute does fit into Document; creating subpart
Found NOTE: Note: from Class.constraints
For NOTE: Note: from Class.constraints
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Attribute
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found BLANK_LINE: 
Found Class_Head: __Override Tracking
For Class_Head: __Override Tracking
  new: Class
Found new part: Class
..But Class not eligible for Annotation
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found Attribute_Head: - Overrides
For Attribute_Head: - Overrides
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ ***ValueType:*** **Derivation**
FOUND EXTRA TEXT
..now included in:  Class_Head: _ ***ValueType:*** **Derivation**
ExtraText = 
A rule or formula for deriving the value of an attribute

For Class_Head: _ ***ValueType:*** **Derivation**
ExtraText = 
A rule or formula for deriving the value of an attribute

  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Class
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found PLURAL: _Plural:_ Derivations
Found Attribute_Head: - **statement** - An English language statement of the derivation rule _(RichText)_
For Attribute_Head: - **statement** - An English language statement of the derivation rule _(RichText)_
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - **expression** - The formal expression of the derivation in a programming language _(CodeExpression)_
For Attribute_Head: - **expression** - The formal expression of the derivation in a programming language _(CodeExpression)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ ***ValueType:*** **Constraint**
FOUND EXTRA TEXT
..now included in:  Class_Head: _ ***ValueType:*** **Constraint**
ExtraText = 
A rule, condition, or validation that must be satisfied by the model

For Class_Head: _ ***ValueType:*** **Constraint**
ExtraText = 
A rule, condition, or validation that must be satisfied by the model

  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Class
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found PLURAL: _Plural:_ Constraints
Found Class_Head: _Subtype of:_ Component
For Class_Head: _Subtype of:_ Component
  new: Class
Found new part: Class
..But Class not eligible for Class
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found Attribute_Head: - **statement** - An English language statement of the constraint _(RichText)_
For Attribute_Head: - **statement** - An English language statement of the constraint _(RichText)_
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - **expression** - The formal expression of the constraint in a programming language (e.g., OCL _(CodeExpression)_
For Attribute_Head: - **expression** - The formal expression of the constraint in a programming language (e.g., OCL _(CodeExpression)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - **severity** -  (Code)
For Attribute_Head: - **severity** -  (Code)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: -- **Warning** - nothing fatal; just a caution
For Attribute_Head: -- **Warning** - nothing fatal; just a caution
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: -- **Error** - serious. Fix now
For Attribute_Head: -- **Error** - serious. Fix now
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - **Message** - (Template)
For Attribute_Head: - **Message** - (Template)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found Class_Head: _ **Class Constraint**
For Class_Head: _ **Class Constraint**
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Class
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found SUBTYPE_OF: **Subtype of**: Constraint
Found BASED_ON: ***Based on***: Class.
Found BLANK_LINE: 
Found Class_Head: _ **Attribute Constraint**
For Class_Head: _ **Attribute Constraint**
  new: Class
Found new part: Class
..But Class not eligible for Class
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found SUBTYPE_OF: ***Subtype of***: Constraint
Found BASED_ON: ***Based on***: Attribute
Found BLANK_LINE: 
Found Class_Head: _ **CodeExpression**
For Class_Head: _ **CodeExpression**
  new: Class
Found new part: Class
..But Class not eligible for Class
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found Attribute_Head: - **Language** - the programming language (Code)
For Attribute_Head: - **Language** - the programming language (Code)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: -- OCL: Object Constraint Language
For Attribute_Head: -- OCL: Object Constraint Language
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: -- Java: Java
For Attribute_Head: -- Java: Java
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - **Expression** (String)
For Attribute_Head: - **Expression** (String)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found Section2_Head: ## Methods
For Section2_Head: ## Methods
  new: Section2
Found new part: Section2
..But Section2 not eligible for Attribute
..But Section2 not eligible for Class
... Section2 does fit into Document; creating subpart
Found Class_Head: _ **Method**
FOUND EXTRA TEXT
..now included in:  Class_Head: _ **Method**
ExtraText = 
A behavior or operation associated with a class

For Class_Head: _ **Method**
ExtraText = 
A behavior or operation associated with a class

  new: Class
Found new part: Class
... Class does fit into Section2; creating subpart
Found PLURAL: _Plural:_ Methods
Found Class_Head: _Subtype of:_ Component
For Class_Head: _Subtype of:_ Component
  new: Class
Found new part: Class
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
Found Attribute_Head: - **parameters** - The input parameters of the method _(ListOf Parameters)_
For Attribute_Head: - **parameters** - The input parameters of the method _(ListOf Parameters)_
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - **returnType** - The data type of the value returned by the method _(DataType )_
For Attribute_Head: - **returnType** - The data type of the value returned by the method _(DataType )_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found Class_Head: _ **Parameter**
FOUND EXTRA TEXT
..now included in:  Class_Head: _ **Parameter**
ExtraText = 
An input to a method

For Class_Head: _ **Parameter**
ExtraText = 
An input to a method

  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
Found PLURAL: _Plural:_ Parameters
Found Class_Head: _Subtype of:_ Component
For Class_Head: _Subtype of:_ Component
  new: Class
Found new part: Class
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
Found Attribute_Head: - **type** - The data type of the parameter _(DataType )_
For Attribute_Head: - **type** - The data type of the parameter _(DataType )_
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - **cardinality** - The cardinality of the parameter (e.g., optional, required) _(AttributeCardinality)_
For Attribute_Head: - **cardinality** - The cardinality of the parameter (e.g., optional, required) _(AttributeCardinality)_
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found Section2_Head: ## Data Types
For Section2_Head: ## Data Types
  new: Section2
Found new part: Section2
..But Section2 not eligible for Attribute
..But Section2 not eligible for Class
..But Section2 not eligible for Section2
... Section2 does fit into Document; creating subpart
Found BLANK_LINE: 
Found TEXT_LINE: *ValueType*:**Data Type**
Found BLANK_LINE: 
Found Class_Head: _ **Simple Data Type**
FOUND EXTRA TEXT
..now included in:  Class_Head: _ **Simple Data Type**
ExtraText = 
***SubtpeOf***: DataType

For Class_Head: _ **Simple Data Type**
ExtraText = 
***SubtpeOf***: DataType

  new: Class
Found new part: Class
... Class does fit into Section2; creating subpart
Found Attribute_Head: - **coreClass** - (Class)
For Attribute_Head: - **coreClass** - (Class)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ **Complex Data Type**
For Class_Head: _ **Complex Data Type**
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
Found Attribute_Head: - **aggregation** (Aggregating Operator)
For Attribute_Head: - **aggregation** (Aggregating Operator)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - **aggregatedTypes** (List of DataTypes)
For Attribute_Head: - **aggregatedTypes** (List of DataTypes)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found Class_Head: _ **Aggregating Operator**
For Class_Head: _ **Aggregating Operator**
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Class
... Class does fit into Section2; creating subpart
Found BLANK_LINE: 
Found Attribute_Head: - **Name**- (Code)
For Attribute_Head: - **Name**- (Code)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: -- **SetOf**
For Attribute_Head: -- **SetOf**
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: -- **ListOf**
For Attribute_Head: -- **ListOf**
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: -- **Mapping**
For Attribute_Head: -- **Mapping**
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - **arity** - (Integer)
For Attribute_Head: - **arity** - (Integer)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - **spelling** - (Template)
For Attribute_Head: - **spelling** - (Template)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Section2_Head: ## Low level Data Types
For Section2_Head: ## Low level Data Types
  new: Section2
Found new part: Section2
..But Section2 not eligible for Attribute
..But Section2 not eligible for Class
..But Section2 not eligible for Section2
... Section2 does fit into Document; creating subpart
Found BLANK_LINE: 
Found TEXT_LINE: insert Camel Case.md
Found BLANK_LINE: 
Found Class_Head: _ ***ValueType***: **CamelName**
For Class_Head: _ ***ValueType***: **CamelName**
  new: Class
Found new part: Class
... Class does fit into Section2; creating subpart
Found BLANK_LINE: 
Found TEXT_LINE: A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.
Found SUBTYPE_OF: ***Subtype of***: String
Found Attribute_Head: - value: the string (String)
For Attribute_Head: - value: the string (String)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found CONSTRAINT: ***Constraint***: Must follow the camel case naming convention and not be empty.
For CONSTRAINT: ***Constraint***: Must follow the camel case naming convention and not be empty.
  new: Constraint
Found new part: Constraint
... Constraint does fit into Attribute; creating subpart
Found EXAMPLE: _Example:_ "firstName", "orderDate", "customerID"
For EXAMPLE: _Example:_ "firstName", "orderDate", "customerID"
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Constraint
..But Annotation not eligible for Attribute
..But Annotation not eligible for Class
..But Annotation not eligible for Section2
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found BLANK_LINE: 
Found TEXT_LINE: >  ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.
Found BLANK_LINE: 
Found BLANK_LINE: 
Found TEXT_LINE: *ModelingNote:* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.
Found BLANK_LINE: 
Found Class_Head: _ **UpperCamel**- a CamelName that begins with a capital letter
For Class_Head: _ **UpperCamel**- a CamelName that begins with a capital letter
  new: Class
Found new part: Class
..But Class not eligible for Annotation
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found SUBTYPE_OF: **Subtype of**: CamelName
Found WHERE: **Where**: content begins with an upper case letter.
Found EXAMPLE: _Example:_ "Customer", "ProductCategory", "PaymentMethod"
For EXAMPLE: _Example:_ "Customer", "ProductCategory", "PaymentMethod"
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Class
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found Class_Head: _ **LowerCamel** - a CamelName that begins with a lower case letter
For Class_Head: _ **LowerCamel** - a CamelName that begins with a lower case letter
  new: Class
Found new part: Class
..But Class not eligible for Annotation
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found SUBTYPE_OF: **Subtype of**: CamelName
Found WHERE: **Where**: content begins with a lower case letter.
Found BLANK_LINE: 
Found EXAMPLE: _Example:_ "firstName", "orderTotal", "shippingAddress"
For EXAMPLE: _Example:_ "firstName", "orderTotal", "shippingAddress"
  new: Annotation
Found new part: Annotation
..But Annotation not eligible for Class
..But Annotation not eligible for Document
... Annotation does fit into Document; creating subpart
Found BLANK_LINE: 
Found Class_Head: _ **Qualified Camel** - an expression consisting of Camel Names separated by periods
For Class_Head: _ **Qualified Camel** - an expression consisting of Camel Names separated by periods
  new: Class
Found new part: Class
..But Class not eligible for Annotation
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found SUBTYPE_OF: ***Subtype of***: String
Found CONSTRAINT: ***Constraint***: content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.
For CONSTRAINT: ***Constraint***: content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.
  new: Constraint
Found new part: Constraint
... Constraint does fit into Class; creating subpart
Found BLANK_LINE: 
Found Class_Head: _ **RichText**.  A string with markup for block level formatting.
For Class_Head: _ **RichText**.  A string with markup for block level formatting.
  new: Class
Found new part: Class
..But Class not eligible for Constraint
..But Class not eligible for Class
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found SUBTYPE_OF: ***SubtypeOf***: String
Found BLANK_LINE: 
Found Attribute_Head: - **value** - the string content (string)
For Attribute_Head: - **value** - the string content (string)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - **format** - the rich text coding language used (Code)
For Attribute_Head: - **format** - the rich text coding language used (Code)
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - **HTML**
For Attribute_Head: - **HTML**
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found Attribute_Head: - **MarkDown**
For Attribute_Head: - **MarkDown**
  new: Attribute
Found new part: Attribute
..But Attribute not eligible for Attribute
... Attribute does fit into Class; creating subpart
Found BLANK_LINE: 
Found Class_Head: _  **RichLine**   - String with markup for line level formatting.
For Class_Head: _  **RichLine**   - String with markup for line level formatting.
  new: Class
Found new part: Class
..But Class not eligible for Attribute
..But Class not eligible for Class
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found SUBTYPE_OF: ***SubtypeOf***: RichText
Found BLANK_LINE: 
Found Attribute_Head: - **value** - the string content (string)
For Attribute_Head: - **value** - the string content (string)
  new: Attribute
Found new part: Attribute
... Attribute does fit into Class; creating subpart
Found CONSTRAINT: ***Constraint***: must not containa line break or new line character
For CONSTRAINT: ***Constraint***: must not containa line break or new line character
  new: Constraint
Found new part: Constraint
... Constraint does fit into Attribute; creating subpart
Found BLANK_LINE: 
Found Class_Head: _ **PrimitiveType**
For Class_Head: _ **PrimitiveType**
  new: Class
Found new part: Class
..But Class not eligible for Constraint
..But Class not eligible for Attribute
..But Class not eligible for Class
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found SUBTYPE_OF: Subtype of: ValueType
FOUND EXTRA TEXT
..now included in:  SUBTYPE_OF: Subtype of: ValueType
ExtraText = 
A basic, built-in data type

Found Class_Head: _Values:_
FOUND EXTRA TEXT
..now included in:  Class_Head: _Values:_
ExtraText = 
**String**
	**Integer**
	**Decimal**
	**Boolean**
	**Date**
	**Time**
	**DateTime**

For Class_Head: _Values:_
ExtraText = 
**String**
	**Integer**
	**Decimal**
	**Boolean**
	**Date**
	**Time**
	**DateTime**

  new: Class
Found new part: Class
..But Class not eligible for Class
..But Class not eligible for Document
... Class does fit into Document; creating subpart
Found BLANK_LINE: 
Found TEXT_LINE: ===
Found Section2_Head: ## Appendices
FOUND EXTRA TEXT
..now included in:  Section2_Head: ## Appendices
ExtraText = 
Insert More Sidebars.md
	Insert Overrides.md
	insert LDM Intro.md
	Insert OCL.md
	Insert Camel Case.md

For Section2_Head: ## Appendices
ExtraText = 
Insert More Sidebars.md
	Insert Overrides.md
	insert LDM Intro.md
	Insert OCL.md
	Insert Camel Case.md

  new: Section2
Found new part: Section2
..But Section2 not eligible for Class
... Section2 does fit into Document; creating subpart
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Found BLANK_LINE: 
Displaying parsed document
Document - <class 'ldm_parse_core.DocPart'> 
. LDM - <class 'ldm_parse_core.ComponentChunk'> 
. . LDM_Head: # Literate Data Model
. . BLANK_LINE: 
. . BLANK_LINE: 
. . BLANK_LINE: 
. . Section2 - <class 'ldm_parse_core.ComponentChunk'> 
. . . Section2_Head: ## Preliminaries
. . . BLANK_LINE: 
. . . TEXT_LINE: In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.
. . . BLANK_LINE: 
. . . TEXT_LINE: We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.
. . . BLANK_LINE: 
. . . BLANK_LINE: 
. . . Class - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Class_Head: _ **Component** - An element or building block of the literate data model
. . . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . . Attribute_Head: - **normalName** - the name of the component, not in camel case (*String*)
. . . . . BLANK_LINE: 
. . . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . . Attribute_Head: - **name** - The name of the component (CamelName)
. . . . . BLANK_LINE: 
. . . . . BLANK_LINE: 
. . . . . BLANK_LINE: 
. . . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . . Attribute_Head: - **qualifiedName** - (*QualifiedCamel*)
. . . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . . Attribute_Head: - **abbreviatedName** - a short form of the component's name, used for cross references and improved readability. (*CamelName*)
. . . . . BLANK_LINE: 
. . . . . Default - <class 'ldm_parse_core.FormulaChunk'> 
. . . . . . DEFAULT: ***Default***: name
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . EXAMPLE: ***Example***: "LDM" is the short form of "Literate Data Model".
. . BLANK_LINE: 
. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - **oneLiner** - A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _(RichLine)_
. . BLANK_LINE: 
. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - **elaboration** - A more detailed explanation or discussion of the component _(RichText)_
. . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: __***For Machinery*** - mechanical attributes
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **isEmbellishment** - Indicates whether this component is an embellishment added during post-parsing processing _(Boolean)_
. . . Default - <class 'ldm_parse_core.FormulaChunk'> 
. . . . DEFAULT: ***Default***: false
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . NOTE: ***Note***: This attribute is set to true for components that are automatically generated or added during the fleshing out, review, or rendering processes, such as implied attributes or suggested model elements. It helps distinguish embellishments from the core model elements defined in the original LDM source.
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: __***Markdown Support***
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **mdPrefix** (*[String](#string)*)
. . . Derivation - <class 'ldm_parse_core.FormulaChunk'> 
. . . . DERIVATION: ***Derivation***: ""
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **mdSuffix** (*[String](#string)*)
. . . Derivation - <class 'ldm_parse_core.FormulaChunk'> 
. . . . DERIVATION: ***Derivation***: ""
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **mdTopLine** (*[String](#string)*)
. . . Derivation - <class 'ldm_parse_core.FormulaChunk'> 
. . . . DERIVATION: ***Derivation***: mdPrefix + name + " - " + oneLiner + mdSuffix
. . . . BLANK_LINE: 
. . . . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _ **AnnotationType** - a kind of note, or aside, used to call attention to additional information about some Component.
ExtraText = 
And it can be continued on fresh lines.
	However many you want.
	But only up to a blank line or other clause

. . BLANK_LINE: 
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . SEE: See. this is not included in the extra text.
. . BLANK_LINE: 
. . BASED_ON: ***Based on*** : Literate Data Model
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . NOTE: ***Note***: Each LDM declares a set of Annotation Types, with defined labels, emojis, and clearly documented purposes. These are *recognized* or *registered* Annotation Types.
ExtraText = 
But, if none of these fit, you can  introduce an Annotation with any label. It would have an *ad hoc* Annotation Type.

. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - **emoji** - an emoji (Emoji)
. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - **emojiName** - an emoji (String)
. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - **emojiUnicode** - the Unicode for the emoji (Unicode)
. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_
. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - **plural** - the plural form of the label (*UpperCamel*).
. . Default - <class 'ldm_parse_core.FormulaChunk'> 
. . . DEFAULT: Default: based on label
. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - **Purpose** - the intended reason for the annotation.
. . BLANK_LINE: 
. . BLANK_LINE: 
. . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _ ValueType: **Annotation**
ExtraText = 
A note or comment associated with a model element

. . BASED_ON: ***Based on***: Component
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **annotationType** - (optional Annotation Type)
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . NOTE: Note: An Annotation is considered to *recognized* if the label is associated with an Annotation Type. otherwise it is *ad hoc*.
. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_
. . BLANK_LINE: 
. . TEXT_LINE: But any short label is valid.
. . Default - <class 'ldm_parse_core.FormulaChunk'> 
. . . DEFAULT: Default: from annotationType
. . . BLANK_LINE: 
. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - **Emoji** - (optional Emoji)
. . Default - <class 'ldm_parse_core.FormulaChunk'> 
. . . DEFAULT: Default: from annotation type
. . . BLANK_LINE: 
. . . BLANK_LINE: 
. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - **content** - The content or body of the annotation (*RichText*)​​​​​​​
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: __***For Machinery***
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **isEmbellishment** - Indicates whether this annotation is an embellishment added during post-parsing processing _(Boolean)_
. . . Default - <class 'ldm_parse_core.FormulaChunk'> 
. . . . DEFAULT: ***Default***: false
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . NOTE: ***Note***: This attribute is set to true for annotations that are automatically generated or added during the fleshing out, review, or rendering processes, such as suggestions, issues, or diagnostic messages. It helps distinguish embellishment annotations from the annotations defined in the original LDM source.
. . BLANK_LINE: 
. Section3 - <class 'ldm_parse_core.ComponentChunk'> 
. . Section3_Head: ### Annotation Types Used
. . BLANK_LINE: 
. . TEXT_LINE: These are the recognized Annotation Types for the LDM model.
. . BLANK_LINE: 
. . BLANK_LINE: 
. . TEXT_LINE: And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.
. . BLANK_LINE: 
. . CodeBlock_Head: ```typescript
ExtraText = 
```

. . BLANK_LINE: 
. . BLANK_LINE: 
. . BLANK_LINE: 
. . BLANK_LINE: 
. . BLANK_LINE: 
. . BLANK_LINE: 
. . BLANK_LINE: 
. . BLANK_LINE: 
. Section2 - <class 'ldm_parse_core.ComponentChunk'> 
. . Section2_Head: ## The Model and its Subjects
. . BLANK_LINE: 
. . BLANK_LINE: 
. . Class - <class 'ldm_parse_core.ComponentChunk'> 
. . . Class_Head: _ **LiterateDataModel** - A representation of a domain's entities, attributes, and relationships,
ExtraText = 
along with explanatory text and examples

. . . ABBREVIATION: ***Abbreviation***: LDM
. . . PLURAL: _Plural:_ LiterateDataModels
. . Class - <class 'ldm_parse_core.ComponentChunk'> 
. . . Class_Head: _Subtype of:_ Component
. . . BLANK_LINE: 
. . . BLANK_LINE: 
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - name (UpperCamel )
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - allSubjects - list of all classes in the model, as ordered in the
ExtraText = 
definition of the model. (List of Classes)

. . . . Derivation - <class 'ldm_parse_core.FormulaChunk'> 
. . . . . DERIVATION: Derivation: gathering s.allSubjects over s in subjectAreas
. . . . . BLANK_LINE: 
. . . . Constraint - <class 'ldm_parse_core.FormulaChunk'> 
. . . . . CONSTRAINT: ***Constraint***: Subject names must be unique across the model.
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - allClasses - list of all classes in the model, as ordered in the definition of the model. (List of Classes)
. . . . Derivation - <class 'ldm_parse_core.FormulaChunk'> 
. . . . . DERIVATION: Derivation: gathering s.allClasses over s in allSubjects.
. . . . Constraint - <class 'ldm_parse_core.FormulaChunk'> 
. . . . . CONSTRAINT: ***Constraint***: Class names must be unique across the model.
. . . . . BLANK_LINE: 
. . Class - <class 'ldm_parse_core.ComponentChunk'> 
. . . Class_Head: __ 	***Modeling Configuration***
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **annotationTypes** - (List of AnnotationTypes)
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **Preferred Coding Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Coding Language).
. . . . Default - <class 'ldm_parse_core.FormulaChunk'> 
. . . . . DEFAULT: Default: OCL
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **alternate Coding Languages** -  (optional List of Coding Languages).
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **Preferred Template Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Template Language).
. . . . Default - <class 'ldm_parse_core.FormulaChunk'> 
. . . . . DEFAULT: Default: Handlebars
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **alternate Template Languages** -  (optional List of Template Languages).
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **aiFunctions** - A list of functions that require sophisticated AI-powered implementation *(List of String)*
. . . . Derivation - <class 'ldm_parse_core.FormulaChunk'> 
. . . . . DERIVATION: Derivation: ['aiEnglishPlural()']
. . . . . BLANK_LINE: 
. . Class - <class 'ldm_parse_core.ComponentChunk'> 
. . . Class_Head: __***Markdown Support***
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **mdPrefix** (*[String](#string)*)
. . . . Derivation - <class 'ldm_parse_core.FormulaChunk'> 
. . . . . DERIVATION: ***Derivation***: "# "
. . . . . BLANK_LINE: 
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **mdTopLine** (*[String](#string)*)
. . . . Derivation - <class 'ldm_parse_core.FormulaChunk'> 
. . . . . DERIVATION: ***Derivation***: mdPrefix + name
. . . . . BLANK_LINE: 
. . . . . BLANK_LINE: 
. . Class - <class 'ldm_parse_core.ComponentChunk'> 
. . . Class_Head: _ **Subject**
ExtraText = 
A specific topic or theme within the model

. . . PLURAL: _Plural:_ Subjects
. . Class - <class 'ldm_parse_core.ComponentChunk'> 
. . . Class_Head: _Subtype of:_ Component
. . . DEPENDENT_OF: Dependent of: LiterateDataModel
. . . BLANK_LINE: 
. . . TEXT_LINE: Subjects are the chapters an sections of the model.
. . . TEXT_LINE: A subject need not contain any Classes if it’s just expository.
. . . BLANK_LINE: 
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - name (UpperCamel )
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **parentSubject** - The parent subject, if any, under which this subject is nested _(Subject, optional)_
. . . . BLANK_LINE: 
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **Classes** - The major classes related to this subject, in the order in which they should be presented _(ListOf Classes)_
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . ISSUE: ***Issue***: define chapter, section, subsection as levels?
ExtraText = 
***DSL***: Generally, it is best to present the classes within a Subject in top down order:

. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - Each Class should be followed first by the classes that are dependent on it, and then
. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - By its subtype classes.
. . BLANK_LINE: 
. . BLANK_LINE: 
. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - **childSubjects** - Any child subjects nested under this subject, in the order in which they should be presented _(ListOf Subjects)_
. . INVERSE: inverse of: Subject.parentSubject.
. . BLANK_LINE: 
. . TEXT_LINE: ***DSL***:  the Classes within a Subject are always displayed before the childSubjects.
. . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: __***Markdown Support***
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **mdPrefix** (*[String](#string)*)
. . . Derivation - <class 'ldm_parse_core.FormulaChunk'> 
. . . . DERIVATION: ***Derivation***: levelIndicator + " "
. . . . BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **mdTopLine** (*[String](#string)*)
. . . Derivation - <class 'ldm_parse_core.FormulaChunk'> 
. . . . DERIVATION: ***Derivation***: mdPrefix + name.
. . . . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _ **SubjectArea**
ExtraText = 
A main topic or area of focus within the model, containing related subjects and classes

. . PLURAL: _Plural:_ SubjectAreas
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _Subtype of:_ Subject
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _Where:_ parentSubject is absent
. . BLANK_LINE: 
. . BLANK_LINE: 
. Section3 - <class 'ldm_parse_core.ComponentChunk'> 
. . Section3_Head: ### Classes
. . BLANK_LINE: 
. . BLANK_LINE: 
. . Class - <class 'ldm_parse_core.ComponentChunk'> 
. . . Class_Head: _ **Class** - A key entity or object type in the model, often corresponding to a real-world concept
. . . BLANK_LINE: 
. . . PLURAL: _Plural:_ Classes
. . Class - <class 'ldm_parse_core.ComponentChunk'> 
. . . Class_Head: _Subtype of:_ Component
. . . Constraint - <class 'ldm_parse_core.FormulaChunk'> 
. . . . CONSTRAINT: ***Constraint***: Within each Class, attribute names must be unique.
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **pluralForm** - the normal English plural form of the name of the Class (UpperName)
. . . . BLANK_LINE: 
. . . . TEXT_LINE: Might be Books for the Book class or other regular plurals.
. . . . TEXT_LINE: But also might be People for Person.
. . . . BLANK_LINE: 
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . NOTE: Note: When inputting a model, you will rarely need to specify the plural form. The input program will just look it up.
. . BLANK_LINE: 
. . TEXT_LINE: The exception is when a common noun has two plural forms, like People and Persons. But this is unusual.
. Default - <class 'ldm_parse_core.FormulaChunk'> 
. . DEFAULT: ***Default***: the regular plural, formed by adding "s" or "es".
. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - **basedOn** - the Class or Classes on which this class is dependent (SetOf Classes).
. . BLANK_LINE: 
. . BLANK_LINE: 
. . TEXT_LINE: This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.
. . BLANK_LINE: 
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . NOTE: Note: basedOn and dependentOf are being used synonymousle in this metamodel.
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . ISSUE: issue: fix that
. . BLANK_LINE: 
. . BLANK_LINE: 
. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - **supertypes** - The parent class(es) from which this class inherits attributes _(ListOf Classes)_
. . BLANK_LINE: 
. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - **subtypings** - the criteria, or dimensions, by which the class can be divided into subtypes (list of Subtypings).
. . BLANK_LINE: 
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . EXAMPLE: Example: in a library model, the `Book` class could have subtypings based on genre (e.g., Fiction, Non-fiction), format (e.g., Hardcover, Paperback), or subject (e.g., Science, History).
. . BLANK_LINE: 
. . BLANK_LINE: 
. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - **subtypes** - Any subtypes or specializations of this class based on it’s subtypings. _(ListOf Classes)_
. . BLANK_LINE: 
. . BLANK_LINE: 
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . EXAMPLE: Example: For instance, using the `Book` example, the subtypes could include `FictionBook`, `Non-fictionBook`, `HardcoverBook`, `PaperbackBook`, `ScienceBook`, and `HistoryBook`.
. . BLANK_LINE: 
. . BLANK_LINE: 
. . BLANK_LINE: 
. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - **attributes** - The attributes or properties of the class, in the order in which they should be presented _(ListOf Attributes)_
. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - **attributeSections** - additional attributes or properties of the class, grouped for clarity and elaboration.  _(ListOf AttributeSections)_
. . BLANK_LINE: 
. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - **constraints** - Any constraints, rules, or validations specific to this class _(ListOf Constraints)_
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . NOTE: Note: Constraints may be expressed on either the Class or the Attribute. Always?
ExtraText = 
Add examples where clarity would favor one or the other.   Sometimes just a matter of taste.

. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - **methods** - Any behaviors or operations associated with this class _(ListOf Methods)_
. . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: __ ***Implied Attributes***
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **dependents** - the Classes which are basedOn this Class (optional SetOf Classes).
. . . BLANK_LINE: 
. . . INVERSE: ***Inverse of***: Class.basedOn
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - UniqueKeys - (optional Set of UniqueKeys).
. . . BLANK_LINE: 
. . . INVERSE: ***Inverse of***:
ExtraText = 
UniqueKey.basedOn

. . . BLANK_LINE: 
. . . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _ **Subtyping** - a way in which subtypes of a Class may be classified (Subtype of Component).
. . DEPENDENT_OF: ***Dependent of:*** Class
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **name** (Upper Name).
ExtraText = 
Usually ByThis or ByThat

. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **is exclusive** (Boolean).
. . . Default - <class 'ldm_parse_core.FormulaChunk'> 
. . . . DEFAULT: Default: true
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **is exhaustive** (Boolean).
. . . Default - <class 'ldm_parse_core.FormulaChunk'> 
. . . . DEFAULT: Default: true
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **classes** (List of Classes).
. . . BLANK_LINE: 
. . . TEXT_LINE: ***DSL***:  Shown in the DSL as
. . . TEXT_LINE: > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)
. . . TEXT_LINE: on the super class. And as
. . . TEXT_LINE: > Subtype of: SuperClass byBrand
. . . TEXT_LINE: on the subclass.
. . . BLANK_LINE: 
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . NOTE: Note: every class can have an unnamed subtyping.
ExtraText = 
Also,  each subtyping is by default Exclusive and  Exhaustive. So those stipulations may be omitted.

. . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _ **ValueType** -
. . SUBTYPE_OF: Subtype of: Class.
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: __***Markdown Support***
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - ***mdPrefix*** (*[String](#string)*)
. . . Derivation - <class 'ldm_parse_core.FormulaChunk'> 
. . . . DERIVATION: ***Derivation***: "ValueType: ".
. . . . BLANK_LINE: 
. . . . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _ **Reference Type**:
. . SUBTYPE_OF: Subtype of: Class.
. . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _ **CodeType**
ExtraText = 
A data type or enumeration used in the model

. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _Subtype of:_ ValueType.
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . NOTE: Note: Often, a CodeType will be assigned to just one attribute in the model.  In such cases, there's no need to declare a new Code Type and invent a name for it.  Instead:
. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - List the code values as a bulletted list inside the description of the attribute in the form:
ExtraText = 
‘**code**: description’

. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.
. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - isCaptive - the code type was implied by use in an attribute and is only used for that attribute (Boolean) as
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _ **Code Value**
ExtraText = 
A possible value for an enumerated data class  DependentOf: CodeType

. . BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **code** - A short code or abbreviationi for the value _(NameString)_
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **description** - an explanation of what the code means (*RichText*)
. . . BLANK_LINE: 
. . . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _ **Key** - a list of attributes of a class
. . SUBTYPE_OF: Subtype of: Component
. . DEPENDENT_OF: DependentOf: Class
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - keyAttributes - the attributes of the base Class. (List of Attributes ).
. . . BLANK_LINE: 
. . . Constraint - <class 'ldm_parse_core.FormulaChunk'> 
. . . . CONSTRAINT: Constraint: each attribute must be a direct or inherited of the base class.
. . . Constraint - <class 'ldm_parse_core.FormulaChunk'> 
. . . . CONSTRAINT: Constraint: no repetitions allowed in keyAttributes
ExtraText = 
>  **Issue**: introduce PureLists?

. . . . BLANK_LINE: 
. . . . BLANK_LINE: 
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . ISSUE: Issue: need ascending descending to support index keys or ordering keys.
. . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _ **UniqueKey** - a list of attributes on which instances of the base class may be keyed.
. . SUBTYPE_OF: Subtype of: Key
. . BLANK_LINE: 
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . NOTE: Note: order unimportant for Unique Keys.
. . BLANK_LINE: 
. Section2 - <class 'ldm_parse_core.ComponentChunk'> 
. . Section2_Head: ## Attributes
. . BLANK_LINE: 
. . Class - <class 'ldm_parse_core.ComponentChunk'> 
. . . Class_Head: _ **Attribute Section** - a group of attributes for a class that merit a shared explanation.
. . . SUBTYPE_OF: ***SubtypeOf***: Component.
. . . BASED_ON: ***Based on***: Class
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: -	isOptional - whether the attributes in this section, taken together, are optional. (Boolean)
. . Class - <class 'ldm_parse_core.ComponentChunk'> 
. . . Class_Head: _
ExtraText = 
If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.
	&nbsp;
	But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.

. . . BLANK_LINE: 
. . Class - <class 'ldm_parse_core.ComponentChunk'> 
. . . Class_Head: __***Markdown Support***
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **mdPrefix** (*[String](#string)*)
. . . . Default - <class 'ldm_parse_core.FormulaChunk'> 
. . . . . DEFAULT: ***Default***: "_ "
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **mdTopLine** (*[String](#string)*).
. . . . BLANK_LINE: 
. . Class - <class 'ldm_parse_core.ComponentChunk'> 
. . . Class_Head: _ **Attribute**
ExtraText = 
A property or characteristic of a class

. . . PLURAL: _Plural:_ Attributes
. . Class - <class 'ldm_parse_core.ComponentChunk'> 
. . . Class_Head: _Subtype of:_ Component
. . . BASED_ON: *Based on*: AttributeSection
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **name** - (Lower Camel).
. . . . OVERRIDES: Overrides: CamelName
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **dataType** - The kind of object to which the attribute refers.  _(DataType)_
ExtraText = 
H
	In the simplest cases, the data type will be a class. And the specifier is the just the name of that class.

. . . . BLANK_LINE: 
. . . . TEXT_LINE: But,
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - List of Editions
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - Set of Edition
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - ... and more complicated cases.
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . SEE: ***See***: the section below on Data Type Specifiers.
. . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: __ **Cardinalities**.
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **isOptional** - Indicates whether the attribute must have a value for every instance of the class _(Boolean)_
. . . BLANK_LINE: 
. . . Default - <class 'ldm_parse_core.FormulaChunk'> 
. . . . DEFAULT: ***Default:*** False
. . . . BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **cardinality** - The cardinality of the relationship represented by the attribute _(CardinalityCode)_
. . . BLANK_LINE: 
. . . Default - <class 'ldm_parse_core.FormulaChunk'> 
. . . . DEFAULT: ***Default:***
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.
. . . BLANK_LINE: 
. . . BLANK_LINE: 
. . . BLANK_LINE: 
. . . TEXT_LINE: ***DSL***: the cardinality of an attribute, if stated explicitly, should be placed just before the class name in the parenthetical data type specification after the one-liner.
. . . TEXT_LINE: For example:
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - author (1:1 Author)
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - books (optional N:M Set of Books)
. . . BLANK_LINE: 
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . NOTE: ***Note***: how this works with optionality
. . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: __ ***Inverse Attributes***
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **isInvertible** - (Boolean)
. . . Derivation - <class 'ldm_parse_core.FormulaChunk'> 
. . . . DERIVATION: ***Derivation***: true if the data type is a class or a simple collection of members of a class.
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **inverseClass** - the class which contains, or would contain the inverse attribute (optional Class)
. . . Derivation - <class 'ldm_parse_core.FormulaChunk'> 
. . . . DERIVATION: ***Derivation***: from the data type. Null unless arrribute is invertible.
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **inverseAttribute** - (optional Attribute)
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **inverseIsOptional** - (optional Attribute)
. . . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _ ***Formulas***
. . BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **default** - The rule or formula for calculating the value, if no value is supplied _(Derivation, optional)_
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . NOTE: Note: even when an Attribute has a default derivation, there’s no guarantee that every instance will have an assigned value. Example needed.
. . BLANK_LINE: 
. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - **derivation** - For derived attributes, the rule or formula for calculating the value _(Derivation, optional)_
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . ISSUE: ***Issue***: on insert vs on access?
. Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . Attribute_Head: - **constraints** - Any validation rules specific to this attribute _(ListOf Constraints)_
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . NOTE: Note: from Class.constraints
. . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: __Override Tracking
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - Overrides
. . . BLANK_LINE: 
. . . BLANK_LINE: 
. . . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _ ***ValueType:*** **Derivation**
ExtraText = 
A rule or formula for deriving the value of an attribute

. . PLURAL: _Plural:_ Derivations
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **statement** - An English language statement of the derivation rule _(RichText)_
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **expression** - The formal expression of the derivation in a programming language _(CodeExpression)_
. . . BLANK_LINE: 
. . . BLANK_LINE: 
. . . BLANK_LINE: 
. . . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _ ***ValueType:*** **Constraint**
ExtraText = 
A rule, condition, or validation that must be satisfied by the model

. . PLURAL: _Plural:_ Constraints
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _Subtype of:_ Component
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **statement** - An English language statement of the constraint _(RichText)_
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **expression** - The formal expression of the constraint in a programming language (e.g., OCL _(CodeExpression)_
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **severity** -  (Code)
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: -- **Warning** - nothing fatal; just a caution
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: -- **Error** - serious. Fix now
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **Message** - (Template)
. . . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _ **Class Constraint**
. . SUBTYPE_OF: **Subtype of**: Constraint
. . BASED_ON: ***Based on***: Class.
. . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _ **Attribute Constraint**
. . SUBTYPE_OF: ***Subtype of***: Constraint
. . BASED_ON: ***Based on***: Attribute
. . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _ **CodeExpression**
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **Language** - the programming language (Code)
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: -- OCL: Object Constraint Language
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: -- Java: Java
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **Expression** (String)
. Section2 - <class 'ldm_parse_core.ComponentChunk'> 
. . Section2_Head: ## Methods
. . Class - <class 'ldm_parse_core.ComponentChunk'> 
. . . Class_Head: _ **Method**
ExtraText = 
A behavior or operation associated with a class

. . . PLURAL: _Plural:_ Methods
. . Class - <class 'ldm_parse_core.ComponentChunk'> 
. . . Class_Head: _Subtype of:_ Component
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **parameters** - The input parameters of the method _(ListOf Parameters)_
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **returnType** - The data type of the value returned by the method _(DataType )_
. . . . BLANK_LINE: 
. . Class - <class 'ldm_parse_core.ComponentChunk'> 
. . . Class_Head: _ **Parameter**
ExtraText = 
An input to a method

. . . PLURAL: _Plural:_ Parameters
. . Class - <class 'ldm_parse_core.ComponentChunk'> 
. . . Class_Head: _Subtype of:_ Component
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **type** - The data type of the parameter _(DataType )_
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **cardinality** - The cardinality of the parameter (e.g., optional, required) _(AttributeCardinality)_
. . . . BLANK_LINE: 
. Section2 - <class 'ldm_parse_core.ComponentChunk'> 
. . Section2_Head: ## Data Types
. . BLANK_LINE: 
. . TEXT_LINE: *ValueType*:**Data Type**
. . BLANK_LINE: 
. . Class - <class 'ldm_parse_core.ComponentChunk'> 
. . . Class_Head: _ **Simple Data Type**
ExtraText = 
***SubtpeOf***: DataType

. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **coreClass** - (Class)
. . . . BLANK_LINE: 
. . . . BLANK_LINE: 
. . Class - <class 'ldm_parse_core.ComponentChunk'> 
. . . Class_Head: _ **Complex Data Type**
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **aggregation** (Aggregating Operator)
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **aggregatedTypes** (List of DataTypes)
. . . . BLANK_LINE: 
. . Class - <class 'ldm_parse_core.ComponentChunk'> 
. . . Class_Head: _ **Aggregating Operator**
. . . BLANK_LINE: 
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **Name**- (Code)
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: -- **SetOf**
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: -- **ListOf**
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: -- **Mapping**
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **arity** - (Integer)
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - **spelling** - (Template)
. . . . BLANK_LINE: 
. . . . BLANK_LINE: 
. Section2 - <class 'ldm_parse_core.ComponentChunk'> 
. . Section2_Head: ## Low level Data Types
. . BLANK_LINE: 
. . TEXT_LINE: insert Camel Case.md
. . BLANK_LINE: 
. . Class - <class 'ldm_parse_core.ComponentChunk'> 
. . . Class_Head: _ ***ValueType***: **CamelName**
. . . BLANK_LINE: 
. . . TEXT_LINE: A short string without punctuation or spaces, suitable for names, labels, or identifiers and presented in camel case.
. . . SUBTYPE_OF: ***Subtype of***: String
. . . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . . Attribute_Head: - value: the string (String)
. . . . Constraint - <class 'ldm_parse_core.FormulaChunk'> 
. . . . . CONSTRAINT: ***Constraint***: Must follow the camel case naming convention and not be empty.
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . EXAMPLE: _Example:_ "firstName", "orderDate", "customerID"
. . BLANK_LINE: 
. . TEXT_LINE: >  ***ModelingNote***: Putting the non-empty constraint on the CamelName value type is effective because it automatically applies to all attributes that use CamelName as their type. This ensures consistency and avoids the need to define the constraint separately for each attribute.
. . BLANK_LINE: 
. . BLANK_LINE: 
. . TEXT_LINE: *ModelingNote:* *CamelName* is presented here, just after its first usage by another class (Component), to provide context and understanding before it is used further in the model.
. . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _ **UpperCamel**- a CamelName that begins with a capital letter
. . SUBTYPE_OF: **Subtype of**: CamelName
. . WHERE: **Where**: content begins with an upper case letter.
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . EXAMPLE: _Example:_ "Customer", "ProductCategory", "PaymentMethod"
. . BLANK_LINE: 
. . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _ **LowerCamel** - a CamelName that begins with a lower case letter
. . SUBTYPE_OF: **Subtype of**: CamelName
. . WHERE: **Where**: content begins with a lower case letter.
. . BLANK_LINE: 
. Annotation - <class 'ldm_parse_core.DocPart'> 
. . EXAMPLE: _Example:_ "firstName", "orderTotal", "shippingAddress"
. . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _ **Qualified Camel** - an expression consisting of Camel Names separated by periods
. . SUBTYPE_OF: ***Subtype of***: String
. . Constraint - <class 'ldm_parse_core.FormulaChunk'> 
. . . CONSTRAINT: ***Constraint***: content consists of CamelNames, separated by periods.  Each of the camel names must be Upper Camel except, possibly, the first.
. . . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _ **RichText**.  A string with markup for block level formatting.
. . SUBTYPE_OF: ***SubtypeOf***: String
. . BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **value** - the string content (string)
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **format** - the rich text coding language used (Code)
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **HTML**
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **MarkDown**
. . . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _  **RichLine**   - String with markup for line level formatting.
. . SUBTYPE_OF: ***SubtypeOf***: RichText
. . BLANK_LINE: 
. . Attribute - <class 'ldm_parse_core.ComponentChunk'> 
. . . Attribute_Head: - **value** - the string content (string)
. . . Constraint - <class 'ldm_parse_core.FormulaChunk'> 
. . . . CONSTRAINT: ***Constraint***: must not containa line break or new line character
. . . . BLANK_LINE: 
. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _ **PrimitiveType**
. . SUBTYPE_OF: Subtype of: ValueType
ExtraText = 
A basic, built-in data type

. Class - <class 'ldm_parse_core.ComponentChunk'> 
. . Class_Head: _Values:_
ExtraText = 
**String**
	**Integer**
	**Decimal**
	**Boolean**
	**Date**
	**Time**
	**DateTime**

. . BLANK_LINE: 
. . TEXT_LINE: ===
. Section2 - <class 'ldm_parse_core.ComponentChunk'> 
. . Section2_Head: ## Appendices
ExtraText = 
Insert More Sidebars.md
	Insert Overrides.md
	insert LDM Intro.md
	Insert OCL.md
	Insert Camel Case.md

. . BLANK_LINE: 
. . BLANK_LINE: 
. . BLANK_LINE: 
. . BLANK_LINE: 
Processing Document - <class 'ldm_parse_core.DocPart'>
Processing . LDM - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: # Literate Data Model[]
Processing . . Section2 - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: ## Preliminaries[]
		ELABORATION is:  ['In Literate Data Modeling, the main components of interest are typically Classes, Attributes, Models, and Subjects. However, to streamline the model and promote reusability, we introduce a supertype called Component. By defining common attributes and behaviors in the Component class, we can inherit them in the subclasses, ensuring consistency and reducing duplication throughout the model.', 'We present the Component class first because it is a best practice in modeling to introduce supertypes before their subtypes. This approach allows readers to understand the general concepts and shared properties before delving into the specifics of each specialized component.']
Processing . . . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **Component** - An element or building block of the literate data model[]
Processing . . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **normalName** - the name of the component, not in camel case (*String*)[]
Fully procesed YAML Attribute Dict
 name: normalName
one_liner: the name of the component, not in camel case
parenthetical: '*String*'
full_header: '- **normalName** - the name of the component, not in camel case (*String*)[]'

Processing . . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **name** - The name of the component (CamelName)[]
Fully procesed YAML Attribute Dict
 name: name
one_liner: The name of the component
parenthetical: CamelName
full_header: '- **name** - The name of the component (CamelName)[]'

Processing . . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **qualifiedName** - (*QualifiedCamel*)[]
Fully procesed YAML Attribute Dict
 name: qualifiedName
one_liner: ''
parenthetical: '*QualifiedCamel*'
full_header: '- **qualifiedName** - (*QualifiedCamel*)[]'

Processing . . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **abbreviatedName** - a short form of the component's name, used for cross references and improved readability. (*CamelName*)[]
Processing . . . . . Default - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: abbreviatedName
one_liner: a short form of the component's name, used for cross references and improved
    readability.
parenthetical: '*CamelName*'
full_header: '- **abbreviatedName** - a short form of the component''s name, used
    for cross references and improved readability. (*CamelName*)[]'
Default_PARTS:
-   _type: Default
    top_text: ' name'

Fully procesed YAML Class Dict
 name: Component
one_liner: An element or building block of the literate data model[]
parenthetical: ''
full_header: _ **Component** - An element or building block of the literate data model[]
Attribute_PARTS:
-   name: normalName
    one_liner: the name of the component, not in camel case
    parenthetical: '*String*'
    full_header: '- **normalName** - the name of the component, not in camel case
        (*String*)[]'
-   name: name
    one_liner: The name of the component
    parenthetical: CamelName
    full_header: '- **name** - The name of the component (CamelName)[]'
-   name: qualifiedName
    one_liner: ''
    parenthetical: '*QualifiedCamel*'
    full_header: '- **qualifiedName** - (*QualifiedCamel*)[]'
-   name: abbreviatedName
    one_liner: a short form of the component's name, used for cross references and
        improved readability.
    parenthetical: '*CamelName*'
    full_header: '- **abbreviatedName** - a short form of the component''s name, used
        for cross references and improved readability. (*CamelName*)[]'
    Default_PARTS:
    -   _type: Default
        top_text: ' name'

Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **oneLiner** - A brief, one-line definition or description of the component, suitable for use in a descriptive table of contents. _(RichLine)_[]
Fully procesed YAML Attribute Dict
 name: oneLiner
one_liner: A brief, one-line definition or description of the component, suitable
    for use in a descriptive table of contents. _
parenthetical: RichLine
full_header: '- **oneLiner** - A brief, one-line definition or description of the
    component, suitable for use in a descriptive table of contents. _(RichLine)_[]'

Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **elaboration** - A more detailed explanation or discussion of the component _(RichText)_[]
Fully procesed YAML Attribute Dict
 name: elaboration
one_liner: A more detailed explanation or discussion of the component _
parenthetical: RichText
full_header: '- **elaboration** - A more detailed explanation or discussion of the
    component _(RichText)_[]'

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: __***For Machinery*** - mechanical attributes[]
Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **isEmbellishment** - Indicates whether this component is an embellishment added during post-parsing processing _(Boolean)_[]
Processing . . . Default - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: isEmbellishment
one_liner: Indicates whether this component is an embellishment added during post-parsing
    processing _
parenthetical: Boolean
full_header: '- **isEmbellishment** - Indicates whether this component is an embellishment
    added during post-parsing processing _(Boolean)_[]'
Default_PARTS:
-   _type: Default
    top_text: ' false'

Fully procesed YAML Class Dict
 name: For Machinery
one_liner: mechanical attributes[]
parenthetical: ''
full_header: __***For Machinery*** - mechanical attributes[]
Attribute_PARTS:
-   name: isEmbellishment
    one_liner: Indicates whether this component is an embellishment added during post-parsing
        processing _
    parenthetical: Boolean
    full_header: '- **isEmbellishment** - Indicates whether this component is an embellishment
        added during post-parsing processing _(Boolean)_[]'
    Default_PARTS:
    -   _type: Default
        top_text: ' false'

Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: __***Markdown Support***[]
Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **mdPrefix** (*[String](#string)*)[]
Processing . . . Derivation - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: mdPrefix
one_liner: ''
parenthetical: '*[String](#string'
full_header: '- **mdPrefix** (*[String](#string)*)[]'
Derivation_PARTS:
-   _type: Derivation
    top_text: ' ""'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **mdSuffix** (*[String](#string)*)[]
Processing . . . Derivation - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: mdSuffix
one_liner: ''
parenthetical: '*[String](#string'
full_header: '- **mdSuffix** (*[String](#string)*)[]'
Derivation_PARTS:
-   _type: Derivation
    top_text: ' ""'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **mdTopLine** (*[String](#string)*)[]
Processing . . . Derivation - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: mdTopLine
one_liner: ''
parenthetical: '*[String](#string'
full_header: '- **mdTopLine** (*[String](#string)*)[]'
Derivation_PARTS:
-   _type: Derivation
    top_text: ' mdPrefix + name + " - " + oneLiner + mdSuffix'

Fully procesed YAML Class Dict
 name: Markdown Support[]
one_liner: ''
parenthetical: ''
full_header: __***Markdown Support***[]
Attribute_PARTS:
-   name: mdPrefix
    one_liner: ''
    parenthetical: '*[String](#string'
    full_header: '- **mdPrefix** (*[String](#string)*)[]'
    Derivation_PARTS:
    -   _type: Derivation
        top_text: ' ""'
-   name: mdSuffix
    one_liner: ''
    parenthetical: '*[String](#string'
    full_header: '- **mdSuffix** (*[String](#string)*)[]'
    Derivation_PARTS:
    -   _type: Derivation
        top_text: ' ""'
-   name: mdTopLine
    one_liner: ''
    parenthetical: '*[String](#string'
    full_header: '- **mdTopLine** (*[String](#string)*)[]'
    Derivation_PARTS:
    -   _type: Derivation
        top_text: ' mdPrefix + name + " - " + oneLiner + mdSuffix'

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **AnnotationType** - a kind of note, or aside, used to call attention to additional information about some Component.['And it can be continued on fresh lines.', 'However many you want.', 'But only up to a blank line or other clause']
Fully procesed YAML Class Dict
 name: AnnotationType
one_liner: a kind of note, or aside, used to call attention to additional information
    about some Component.['And it can be continued on fresh lines.', 'However many
    you want.', 'But only up to a blank line or other clause']
parenthetical: ''
full_header: _ **AnnotationType** - a kind of note, or aside, used to call attention
    to additional information about some Component.['And it can be continued on fresh
    lines.', 'However many you want.', 'But only up to a blank line or other clause']

Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **emoji** - an emoji (Emoji)[]
Fully procesed YAML Attribute Dict
 name: emoji
one_liner: an emoji
parenthetical: Emoji
full_header: '- **emoji** - an emoji (Emoji)[]'

Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **emojiName** - an emoji (String)[]
Fully procesed YAML Attribute Dict
 name: emojiName
one_liner: an emoji
parenthetical: String
full_header: '- **emojiName** - an emoji (String)[]'

Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **emojiUnicode** - the Unicode for the emoji (Unicode)[]
Fully procesed YAML Attribute Dict
 name: emojiUnicode
one_liner: the Unicode for the emoji
parenthetical: Unicode
full_header: '- **emojiUnicode** - the Unicode for the emoji (Unicode)[]'

Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_[]
Fully procesed YAML Attribute Dict
 name: label
one_liner: A short label to indicate the purpose of the annotation _
parenthetical: CamelName
full_header: '- **label** - A short label to indicate the purpose of the annotation
    _(CamelName)_[]'

Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **plural** - the plural form of the label (*UpperCamel*).[]
Processing . . Default - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: plural
one_liner: the plural form of the label
parenthetical: '*UpperCamel*'
full_header: '- **plural** - the plural form of the label (*UpperCamel*).[]'
Default_PARTS:
-   _type: Default
    top_text: ' based on label'

Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **Purpose** - the intended reason for the annotation.[]
Fully procesed YAML Attribute Dict
 name: Purpose
one_liner: the intended reason for the annotation.[]
parenthetical: ''
full_header: '- **Purpose** - the intended reason for the annotation.[]'

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ ValueType: **Annotation**['A note or comment associated with a model element']
Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **annotationType** - (optional Annotation Type)[]
Fully procesed YAML Attribute Dict
 name: annotationType
one_liner: ''
parenthetical: optional Annotation Type
full_header: '- **annotationType** - (optional Annotation Type)[]'

Fully procesed YAML Class Dict
 name: 'ValueType: Annotation[''A note or comment associated with a model element'']'
one_liner: ''
parenthetical: ''
full_header: '_ ValueType: **Annotation**[''A note or comment associated with a model
    element'']'
Attribute_PARTS:
-   name: annotationType
    one_liner: ''
    parenthetical: optional Annotation Type
    full_header: '- **annotationType** - (optional Annotation Type)[]'

Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **label** - A short label to indicate the purpose of the annotation _(CamelName)_[]
Processing . . Default - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: label
one_liner: A short label to indicate the purpose of the annotation _
parenthetical: CamelName
full_header: '- **label** - A short label to indicate the purpose of the annotation
    _(CamelName)_[]'
Default_PARTS:
-   _type: Default
    top_text: ' from annotationType'

Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **Emoji** - (optional Emoji)[]
Processing . . Default - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: Emoji
one_liner: ''
parenthetical: optional Emoji
full_header: '- **Emoji** - (optional Emoji)[]'
Default_PARTS:
-   _type: Default
    top_text: ' from annotation type'

Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **content** - The content or body of the annotation (*RichText*)​​​​​​​[]
Fully procesed YAML Attribute Dict
 name: content
one_liner: The content or body of the annotation
parenthetical: '*RichText*'
full_header: "- **content** - The content or body of the annotation (*RichText*)\u200B\
    \u200B\u200B\u200B\u200B\u200B\u200B[]"

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: __***For Machinery***[]
Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **isEmbellishment** - Indicates whether this annotation is an embellishment added during post-parsing processing _(Boolean)_[]
Processing . . . Default - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: isEmbellishment
one_liner: Indicates whether this annotation is an embellishment added during post-parsing
    processing _
parenthetical: Boolean
full_header: '- **isEmbellishment** - Indicates whether this annotation is an embellishment
    added during post-parsing processing _(Boolean)_[]'
Default_PARTS:
-   _type: Default
    top_text: ' false'

Fully procesed YAML Class Dict
 name: For Machinery[]
one_liner: ''
parenthetical: ''
full_header: __***For Machinery***[]
Attribute_PARTS:
-   name: isEmbellishment
    one_liner: Indicates whether this annotation is an embellishment added during
        post-parsing processing _
    parenthetical: Boolean
    full_header: '- **isEmbellishment** - Indicates whether this annotation is an
        embellishment added during post-parsing processing _(Boolean)_[]'
    Default_PARTS:
    -   _type: Default
        top_text: ' false'

Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Section3 - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: ### Annotation Types Used[]
		ELABORATION is:  ['These are the recognized Annotation Types for the LDM model.', 'And this is how you register the AnnotationTyped for a model. By including this sort of array in the DSL document for the model.']
Processing . Section2 - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: ## The Model and its Subjects[]
Processing . . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **LiterateDataModel** - A representation of a domain's entities, attributes, and relationships,['along with explanatory text and examples']
Fully procesed YAML Class Dict
 name: LiterateDataModel
one_liner: A representation of a domain's entities, attributes, and relationships,['along
    with explanatory text and examples']
parenthetical: ''
full_header: _ **LiterateDataModel** - A representation of a domain's entities, attributes,
    and relationships,['along with explanatory text and examples']

Processing . . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _Subtype of:_ Component[]
Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - name (UpperCamel )[]
Fully procesed YAML Attribute Dict
 name: name
one_liner: ''
parenthetical: UpperCamel
full_header: '- name (UpperCamel )[]'

Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - allSubjects - list of all classes in the model, as ordered in the['definition of the model. (List of Classes)']
Processing . . . . Derivation - <class 'ldm_parse_core.FormulaChunk'>
Processing . . . . Constraint - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: allSubjects
one_liner: list of all classes in the model, as ordered in the['definition of the
    model.
parenthetical: List of Classes
full_header: '- allSubjects - list of all classes in the model, as ordered in the[''definition
    of the model. (List of Classes)'']'
Derivation_PARTS:
-   _type: Derivation
    top_text: ' gathering s.allSubjects over s in subjectAreas'
Constraint_PARTS:
-   _type: Constraint
    top_text: ' Subject names must be unique across the model.'

Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - allClasses - list of all classes in the model, as ordered in the definition of the model. (List of Classes)[]
Processing . . . . Derivation - <class 'ldm_parse_core.FormulaChunk'>
Processing . . . . Constraint - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: allClasses
one_liner: list of all classes in the model, as ordered in the definition of the model.
parenthetical: List of Classes
full_header: '- allClasses - list of all classes in the model, as ordered in the definition
    of the model. (List of Classes)[]'
Derivation_PARTS:
-   _type: Derivation
    top_text: ' gathering s.allClasses over s in allSubjects.'
Constraint_PARTS:
-   _type: Constraint
    top_text: ' Class names must be unique across the model.'

Fully procesed YAML Class Dict
 name: 'Subtype of: Component[]'
one_liner: ''
parenthetical: ''
full_header: _Subtype of:_ Component[]
Attribute_PARTS:
-   name: name
    one_liner: ''
    parenthetical: UpperCamel
    full_header: '- name (UpperCamel )[]'
-   name: allSubjects
    one_liner: list of all classes in the model, as ordered in the['definition of
        the model.
    parenthetical: List of Classes
    full_header: '- allSubjects - list of all classes in the model, as ordered in
        the[''definition of the model. (List of Classes)'']'
    Derivation_PARTS:
    -   _type: Derivation
        top_text: ' gathering s.allSubjects over s in subjectAreas'
    Constraint_PARTS:
    -   _type: Constraint
        top_text: ' Subject names must be unique across the model.'
-   name: allClasses
    one_liner: list of all classes in the model, as ordered in the definition of the
        model.
    parenthetical: List of Classes
    full_header: '- allClasses - list of all classes in the model, as ordered in the
        definition of the model. (List of Classes)[]'
    Derivation_PARTS:
    -   _type: Derivation
        top_text: ' gathering s.allClasses over s in allSubjects.'
    Constraint_PARTS:
    -   _type: Constraint
        top_text: ' Class names must be unique across the model.'

Processing . . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: __ 	***Modeling Configuration***[]
Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **annotationTypes** - (List of AnnotationTypes)[]
Fully procesed YAML Attribute Dict
 name: annotationTypes
one_liner: ''
parenthetical: List of AnnotationTypes
full_header: '- **annotationTypes** - (List of AnnotationTypes)[]'

Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **Preferred Coding Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Coding Language).[]
Processing . . . . Default - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: Preferred Coding Language
one_liner: the recommended lanquage  for expressing derivation, defaults, and constraints
parenthetical: Coding Language
full_header: '- **Preferred Coding Language** - the recommended lanquage  for expressing
    derivation, defaults, and constraints (Coding Language).[]'
Default_PARTS:
-   _type: Default
    top_text: ' OCL'

Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **alternate Coding Languages** -  (optional List of Coding Languages).[]
Fully procesed YAML Attribute Dict
 name: alternate Coding Languages
one_liner: ''
parenthetical: optional List of Coding Languages
full_header: '- **alternate Coding Languages** -  (optional List of Coding Languages).[]'

Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **Preferred Template Language** - the recommended lanquage  for expressing derivation, defaults, and constraints (Template Language).[]
Processing . . . . Default - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: Preferred Template Language
one_liner: the recommended lanquage  for expressing derivation, defaults, and constraints
parenthetical: Template Language
full_header: '- **Preferred Template Language** - the recommended lanquage  for expressing
    derivation, defaults, and constraints (Template Language).[]'
Default_PARTS:
-   _type: Default
    top_text: ' Handlebars'

Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **alternate Template Languages** -  (optional List of Template Languages).[]
Fully procesed YAML Attribute Dict
 name: alternate Template Languages
one_liner: ''
parenthetical: optional List of Template Languages
full_header: '- **alternate Template Languages** -  (optional List of Template Languages).[]'

Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **aiFunctions** - A list of functions that require sophisticated AI-powered implementation *(List of String)*[]
Processing . . . . Derivation - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: aiFunctions
one_liner: A list of functions that require sophisticated AI-powered implementation
    *
parenthetical: List of String
full_header: '- **aiFunctions** - A list of functions that require sophisticated AI-powered
    implementation *(List of String)*[]'
Derivation_PARTS:
-   _type: Derivation
    top_text: ' [''aiEnglishPlural()'']'

Fully procesed YAML Class Dict
 name: Modeling Configuration[]
one_liner: ''
parenthetical: ''
full_header: "__ \t***Modeling Configuration***[]"
Attribute_PARTS:
-   name: annotationTypes
    one_liner: ''
    parenthetical: List of AnnotationTypes
    full_header: '- **annotationTypes** - (List of AnnotationTypes)[]'
-   name: Preferred Coding Language
    one_liner: the recommended lanquage  for expressing derivation, defaults, and
        constraints
    parenthetical: Coding Language
    full_header: '- **Preferred Coding Language** - the recommended lanquage  for
        expressing derivation, defaults, and constraints (Coding Language).[]'
    Default_PARTS:
    -   _type: Default
        top_text: ' OCL'
-   name: alternate Coding Languages
    one_liner: ''
    parenthetical: optional List of Coding Languages
    full_header: '- **alternate Coding Languages** -  (optional List of Coding Languages).[]'
-   name: Preferred Template Language
    one_liner: the recommended lanquage  for expressing derivation, defaults, and
        constraints
    parenthetical: Template Language
    full_header: '- **Preferred Template Language** - the recommended lanquage  for
        expressing derivation, defaults, and constraints (Template Language).[]'
    Default_PARTS:
    -   _type: Default
        top_text: ' Handlebars'
-   name: alternate Template Languages
    one_liner: ''
    parenthetical: optional List of Template Languages
    full_header: '- **alternate Template Languages** -  (optional List of Template
        Languages).[]'
-   name: aiFunctions
    one_liner: A list of functions that require sophisticated AI-powered implementation
        *
    parenthetical: List of String
    full_header: '- **aiFunctions** - A list of functions that require sophisticated
        AI-powered implementation *(List of String)*[]'
    Derivation_PARTS:
    -   _type: Derivation
        top_text: ' [''aiEnglishPlural()'']'

Processing . . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: __***Markdown Support***[]
Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **mdPrefix** (*[String](#string)*)[]
Processing . . . . Derivation - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: mdPrefix
one_liner: ''
parenthetical: '*[String](#string'
full_header: '- **mdPrefix** (*[String](#string)*)[]'
Derivation_PARTS:
-   _type: Derivation
    top_text: ' "# "'

Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **mdTopLine** (*[String](#string)*)[]
Processing . . . . Derivation - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: mdTopLine
one_liner: ''
parenthetical: '*[String](#string'
full_header: '- **mdTopLine** (*[String](#string)*)[]'
Derivation_PARTS:
-   _type: Derivation
    top_text: ' mdPrefix + name'

Fully procesed YAML Class Dict
 name: Markdown Support[]
one_liner: ''
parenthetical: ''
full_header: __***Markdown Support***[]
Attribute_PARTS:
-   name: mdPrefix
    one_liner: ''
    parenthetical: '*[String](#string'
    full_header: '- **mdPrefix** (*[String](#string)*)[]'
    Derivation_PARTS:
    -   _type: Derivation
        top_text: ' "# "'
-   name: mdTopLine
    one_liner: ''
    parenthetical: '*[String](#string'
    full_header: '- **mdTopLine** (*[String](#string)*)[]'
    Derivation_PARTS:
    -   _type: Derivation
        top_text: ' mdPrefix + name'

Processing . . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **Subject**['A specific topic or theme within the model']
Fully procesed YAML Class Dict
 name: Subject['A specific topic or theme within the model']
one_liner: ''
parenthetical: ''
full_header: _ **Subject**['A specific topic or theme within the model']

Processing . . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _Subtype of:_ Component[]
		ELABORATION is:  ['Subjects are the chapters an sections of the model.\nA subject need not contain any Classes if it’s just expository.']
Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - name (UpperCamel )[]
Fully procesed YAML Attribute Dict
 name: name
one_liner: ''
parenthetical: UpperCamel
full_header: '- name (UpperCamel )[]'

Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **parentSubject** - The parent subject, if any, under which this subject is nested _(Subject, optional)_[]
Fully procesed YAML Attribute Dict
 name: parentSubject
one_liner: The parent subject, if any, under which this subject is nested _
parenthetical: Subject, optional
full_header: '- **parentSubject** - The parent subject, if any, under which this subject
    is nested _(Subject, optional)_[]'

Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **Classes** - The major classes related to this subject, in the order in which they should be presented _(ListOf Classes)_[]
Fully procesed YAML Attribute Dict
 name: Classes
one_liner: The major classes related to this subject, in the order in which they should
    be presented _
parenthetical: ListOf Classes
full_header: '- **Classes** - The major classes related to this subject, in the order
    in which they should be presented _(ListOf Classes)_[]'

Fully procesed YAML Class Dict
 name: 'Subtype of: Component[]'
one_liner: ''
parenthetical: ''
full_header: _Subtype of:_ Component[]
elaboration:
- "Subjects are the chapters an sections of the model.\nA subject need not contain\
    \ any Classes if it\u2019s just expository."
Attribute_PARTS:
-   name: name
    one_liner: ''
    parenthetical: UpperCamel
    full_header: '- name (UpperCamel )[]'
-   name: parentSubject
    one_liner: The parent subject, if any, under which this subject is nested _
    parenthetical: Subject, optional
    full_header: '- **parentSubject** - The parent subject, if any, under which this
        subject is nested _(Subject, optional)_[]'
-   name: Classes
    one_liner: The major classes related to this subject, in the order in which they
        should be presented _
    parenthetical: ListOf Classes
    full_header: '- **Classes** - The major classes related to this subject, in the
        order in which they should be presented _(ListOf Classes)_[]'

Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - Each Class should be followed first by the classes that are dependent on it, and then[]
Fully procesed YAML Attribute Dict
 name: Each Class should be followed first by the classes that are dependent on it,
    and then[]
one_liner: ''
parenthetical: ''
full_header: '- Each Class should be followed first by the classes that are dependent
    on it, and then[]'

Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - By its subtype classes.[]
Fully procesed YAML Attribute Dict
 name: By its subtype classes.[]
one_liner: ''
parenthetical: ''
full_header: '- By its subtype classes.[]'

Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **childSubjects** - Any child subjects nested under this subject, in the order in which they should be presented _(ListOf Subjects)_[]
		ELABORATION is:  ['***DSL***:  the Classes within a Subject are always displayed before the childSubjects.']
Fully procesed YAML Attribute Dict
 name: childSubjects
one_liner: Any child subjects nested under this subject, in the order in which they
    should be presented _
parenthetical: ListOf Subjects
full_header: '- **childSubjects** - Any child subjects nested under this subject,
    in the order in which they should be presented _(ListOf Subjects)_[]'
elaboration:
- '***DSL***:  the Classes within a Subject are always displayed before the childSubjects.'

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: __***Markdown Support***[]
Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **mdPrefix** (*[String](#string)*)[]
Processing . . . Derivation - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: mdPrefix
one_liner: ''
parenthetical: '*[String](#string'
full_header: '- **mdPrefix** (*[String](#string)*)[]'
Derivation_PARTS:
-   _type: Derivation
    top_text: ' levelIndicator + " "'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **mdTopLine** (*[String](#string)*)[]
Processing . . . Derivation - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: mdTopLine
one_liner: ''
parenthetical: '*[String](#string'
full_header: '- **mdTopLine** (*[String](#string)*)[]'
Derivation_PARTS:
-   _type: Derivation
    top_text: ' mdPrefix + name.'

Fully procesed YAML Class Dict
 name: Markdown Support[]
one_liner: ''
parenthetical: ''
full_header: __***Markdown Support***[]
Attribute_PARTS:
-   name: mdPrefix
    one_liner: ''
    parenthetical: '*[String](#string'
    full_header: '- **mdPrefix** (*[String](#string)*)[]'
    Derivation_PARTS:
    -   _type: Derivation
        top_text: ' levelIndicator + " "'
-   name: mdTopLine
    one_liner: ''
    parenthetical: '*[String](#string'
    full_header: '- **mdTopLine** (*[String](#string)*)[]'
    Derivation_PARTS:
    -   _type: Derivation
        top_text: ' mdPrefix + name.'

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **SubjectArea**['A main topic or area of focus within the model, containing related subjects and classes']
Fully procesed YAML Class Dict
 name: SubjectArea['A main topic or area of focus within the model, containing related
    subjects and classes']
one_liner: ''
parenthetical: ''
full_header: _ **SubjectArea**['A main topic or area of focus within the model, containing
    related subjects and classes']

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _Subtype of:_ Subject[]
Fully procesed YAML Class Dict
 name: 'Subtype of: Subject[]'
one_liner: ''
parenthetical: ''
full_header: _Subtype of:_ Subject[]

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _Where:_ parentSubject is absent[]
Fully procesed YAML Class Dict
 name: 'Where: parentSubject is absent[]'
one_liner: ''
parenthetical: ''
full_header: _Where:_ parentSubject is absent[]

Processing . Section3 - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: ### Classes[]
Processing . . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **Class** - A key entity or object type in the model, often corresponding to a real-world concept[]
Fully procesed YAML Class Dict
 name: Class
one_liner: A key entity or object type in the model, often corresponding to a real-world
    concept[]
parenthetical: ''
full_header: _ **Class** - A key entity or object type in the model, often corresponding
    to a real-world concept[]

Processing . . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _Subtype of:_ Component[]
Processing . . . Constraint - <class 'ldm_parse_core.FormulaChunk'>
Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **pluralForm** - the normal English plural form of the name of the Class (UpperName)[]
		ELABORATION is:  ['Might be Books for the Book class or other regular plurals.\nBut also might be People for Person.']
Fully procesed YAML Attribute Dict
 name: pluralForm
one_liner: the normal English plural form of the name of the Class
parenthetical: UpperName
full_header: '- **pluralForm** - the normal English plural form of the name of the
    Class (UpperName)[]'
elaboration:
- 'Might be Books for the Book class or other regular plurals.

    But also might be People for Person.'

Fully procesed YAML Class Dict
 name: 'Subtype of: Component[]'
one_liner: ''
parenthetical: ''
full_header: _Subtype of:_ Component[]
Constraint_PARTS:
-   _type: Constraint
    top_text: ' Within each Class, attribute names must be unique.'
Attribute_PARTS:
-   name: pluralForm
    one_liner: the normal English plural form of the name of the Class
    parenthetical: UpperName
    full_header: '- **pluralForm** - the normal English plural form of the name of
        the Class (UpperName)[]'
    elaboration:
    - 'Might be Books for the Book class or other regular plurals.

        But also might be People for Person.'

Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Default - <class 'ldm_parse_core.FormulaChunk'>
Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **basedOn** - the Class or Classes on which this class is dependent (SetOf Classes).[]
		ELABORATION is:  ['This is solely based on **Existence Dependency**. A true dependent entity cannot logically exist without the related parent entity. For instance, an Order Item cannot exist without an Order. If removing the parent entity logically implies removing the dependent entity, then it is a dependent entity.']
Fully procesed YAML Attribute Dict
 name: basedOn
one_liner: the Class or Classes on which this class is dependent
parenthetical: SetOf Classes
full_header: '- **basedOn** - the Class or Classes on which this class is dependent
    (SetOf Classes).[]'
elaboration:
- This is solely based on **Existence Dependency**. A true dependent entity cannot
    logically exist without the related parent entity. For instance, an Order Item
    cannot exist without an Order. If removing the parent entity logically implies
    removing the dependent entity, then it is a dependent entity.

Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **supertypes** - The parent class(es) from which this class inherits attributes _(ListOf Classes)_[]
Fully procesed YAML Attribute Dict
 name: supertypes
one_liner: The parent class
parenthetical: es
full_header: '- **supertypes** - The parent class(es) from which this class inherits
    attributes _(ListOf Classes)_[]'

Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **subtypings** - the criteria, or dimensions, by which the class can be divided into subtypes (list of Subtypings).[]
Fully procesed YAML Attribute Dict
 name: subtypings
one_liner: the criteria, or dimensions, by which the class can be divided into subtypes
parenthetical: list of Subtypings
full_header: '- **subtypings** - the criteria, or dimensions, by which the class can
    be divided into subtypes (list of Subtypings).[]'

Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **subtypes** - Any subtypes or specializations of this class based on it’s subtypings. _(ListOf Classes)_[]
Fully procesed YAML Attribute Dict
 name: subtypes
one_liner: "Any subtypes or specializations of this class based on it\u2019s subtypings.\
    \ _"
parenthetical: ListOf Classes
full_header: "- **subtypes** - Any subtypes or specializations of this class based\
    \ on it\u2019s subtypings. _(ListOf Classes)_[]"

Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **attributes** - The attributes or properties of the class, in the order in which they should be presented _(ListOf Attributes)_[]
Fully procesed YAML Attribute Dict
 name: attributes
one_liner: The attributes or properties of the class, in the order in which they should
    be presented _
parenthetical: ListOf Attributes
full_header: '- **attributes** - The attributes or properties of the class, in the
    order in which they should be presented _(ListOf Attributes)_[]'

Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **attributeSections** - additional attributes or properties of the class, grouped for clarity and elaboration.  _(ListOf AttributeSections)_[]
Fully procesed YAML Attribute Dict
 name: attributeSections
one_liner: additional attributes or properties of the class, grouped for clarity and
    elaboration.  _
parenthetical: ListOf AttributeSections
full_header: '- **attributeSections** - additional attributes or properties of the
    class, grouped for clarity and elaboration.  _(ListOf AttributeSections)_[]'

Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **constraints** - Any constraints, rules, or validations specific to this class _(ListOf Constraints)_[]
Fully procesed YAML Attribute Dict
 name: constraints
one_liner: Any constraints, rules, or validations specific to this class _
parenthetical: ListOf Constraints
full_header: '- **constraints** - Any constraints, rules, or validations specific
    to this class _(ListOf Constraints)_[]'

Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **methods** - Any behaviors or operations associated with this class _(ListOf Methods)_[]
Fully procesed YAML Attribute Dict
 name: methods
one_liner: Any behaviors or operations associated with this class _
parenthetical: ListOf Methods
full_header: '- **methods** - Any behaviors or operations associated with this class
    _(ListOf Methods)_[]'

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: __ ***Implied Attributes***[]
Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **dependents** - the Classes which are basedOn this Class (optional SetOf Classes).[]
Fully procesed YAML Attribute Dict
 name: dependents
one_liner: the Classes which are basedOn this Class
parenthetical: optional SetOf Classes
full_header: '- **dependents** - the Classes which are basedOn this Class (optional
    SetOf Classes).[]'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - UniqueKeys - (optional Set of UniqueKeys).[]
Fully procesed YAML Attribute Dict
 name: UniqueKeys
one_liner: ''
parenthetical: optional Set of UniqueKeys
full_header: '- UniqueKeys - (optional Set of UniqueKeys).[]'

Fully procesed YAML Class Dict
 name: Implied Attributes[]
one_liner: ''
parenthetical: ''
full_header: __ ***Implied Attributes***[]
Attribute_PARTS:
-   name: dependents
    one_liner: the Classes which are basedOn this Class
    parenthetical: optional SetOf Classes
    full_header: '- **dependents** - the Classes which are basedOn this Class (optional
        SetOf Classes).[]'
-   name: UniqueKeys
    one_liner: ''
    parenthetical: optional Set of UniqueKeys
    full_header: '- UniqueKeys - (optional Set of UniqueKeys).[]'

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **Subtyping** - a way in which subtypes of a Class may be classified (Subtype of Component).[]
Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **name** (Upper Name).['Usually ByThis or ByThat']
Fully procesed YAML Attribute Dict
 name: name
one_liner: ''
parenthetical: Upper Name
full_header: '- **name** (Upper Name).[''Usually ByThis or ByThat'']'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **is exclusive** (Boolean).[]
Processing . . . Default - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: is exclusive
one_liner: ''
parenthetical: Boolean
full_header: '- **is exclusive** (Boolean).[]'
Default_PARTS:
-   _type: Default
    top_text: ' true'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **is exhaustive** (Boolean).[]
Processing . . . Default - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: is exhaustive
one_liner: ''
parenthetical: Boolean
full_header: '- **is exhaustive** (Boolean).[]'
Default_PARTS:
-   _type: Default
    top_text: ' true'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **classes** (List of Classes).[]
		ELABORATION is:  ['***DSL***:  Shown in the DSL as\n> Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)\non the super class. And as\n> Subtype of: SuperClass byBrand\non the subclass.']
Fully procesed YAML Attribute Dict
 name: classes
one_liner: ''
parenthetical: List of Classes
full_header: '- **classes** (List of Classes).[]'
elaboration:
- '***DSL***:  Shown in the DSL as

    > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)

    on the super class. And as

    > Subtype of: SuperClass byBrand

    on the subclass.'

Fully procesed YAML Class Dict
 name: Subtyping
one_liner: a way in which subtypes of a Class may be classified
parenthetical: Subtype of Component
full_header: _ **Subtyping** - a way in which subtypes of a Class may be classified
    (Subtype of Component).[]
Attribute_PARTS:
-   name: name
    one_liner: ''
    parenthetical: Upper Name
    full_header: '- **name** (Upper Name).[''Usually ByThis or ByThat'']'
-   name: is exclusive
    one_liner: ''
    parenthetical: Boolean
    full_header: '- **is exclusive** (Boolean).[]'
    Default_PARTS:
    -   _type: Default
        top_text: ' true'
-   name: is exhaustive
    one_liner: ''
    parenthetical: Boolean
    full_header: '- **is exhaustive** (Boolean).[]'
    Default_PARTS:
    -   _type: Default
        top_text: ' true'
-   name: classes
    one_liner: ''
    parenthetical: List of Classes
    full_header: '- **classes** (List of Classes).[]'
    elaboration:
    - '***DSL***:  Shown in the DSL as

        > Subbtypes: byBrand - Brand1, Brand2,... (non exclusive, exhaustive)

        on the super class. And as

        > Subtype of: SuperClass byBrand

        on the subclass.'

Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **ValueType** -[]
Fully procesed YAML Class Dict
 name: ValueType
one_liner: '[]'
parenthetical: ''
full_header: _ **ValueType** -[]

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: __***Markdown Support***[]
Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - ***mdPrefix*** (*[String](#string)*)[]
Processing . . . Derivation - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: mdPrefix
one_liner: ''
parenthetical: '*[String](#string'
full_header: '- ***mdPrefix*** (*[String](#string)*)[]'
Derivation_PARTS:
-   _type: Derivation
    top_text: ' "ValueType'

Fully procesed YAML Class Dict
 name: Markdown Support[]
one_liner: ''
parenthetical: ''
full_header: __***Markdown Support***[]
Attribute_PARTS:
-   name: mdPrefix
    one_liner: ''
    parenthetical: '*[String](#string'
    full_header: '- ***mdPrefix*** (*[String](#string)*)[]'
    Derivation_PARTS:
    -   _type: Derivation
        top_text: ' "ValueType'

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **Reference Type**:[]
Fully procesed YAML Class Dict
 name: Reference Type:[]
one_liner: ''
parenthetical: ''
full_header: _ **Reference Type**:[]

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **CodeType**['A data type or enumeration used in the model']
Fully procesed YAML Class Dict
 name: CodeType['A data type or enumeration used in the model']
one_liner: ''
parenthetical: ''
full_header: _ **CodeType**['A data type or enumeration used in the model']

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _Subtype of:_ ValueType.[]
Fully procesed YAML Class Dict
 name: 'Subtype of: ValueType.[]'
one_liner: ''
parenthetical: ''
full_header: _Subtype of:_ ValueType.[]

Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - List the code values as a bulletted list inside the description of the attribute in the form:['‘**code**: description’']
Fully procesed YAML Attribute Dict
 name: "List the code values as a bulletted list inside the description of the attribute\
    \ in the form:['\u2018code: description\u2019']"
one_liner: ''
parenthetical: ''
full_header: "- List the code values as a bulletted list inside the description of\
    \ the attribute in the form:['\u2018**code**: description\u2019']"

Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - A Code Type will be created with the name [class][attribute]Code and the code values listed. That CodeType will be marked as isCaptive.[]
Fully procesed YAML Attribute Dict
 name: A Code Type will be created with the name [class][attribute]Code and the code
    values listed. That CodeType will be marked as isCaptive.[]
one_liner: ''
parenthetical: ''
full_header: '- A Code Type will be created with the name [class][attribute]Code and
    the code values listed. That CodeType will be marked as isCaptive.[]'

Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - isCaptive - the code type was implied by use in an attribute and is only used for that attribute (Boolean) as[]
Fully procesed YAML Attribute Dict
 name: isCaptive
one_liner: the code type was implied by use in an attribute and is only used for that
    attribute
parenthetical: Boolean
full_header: '- isCaptive - the code type was implied by use in an attribute and is
    only used for that attribute (Boolean) as[]'

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **Code Value**['A possible value for an enumerated data class  DependentOf: CodeType']
Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **code** - A short code or abbreviationi for the value _(NameString)_[]
Fully procesed YAML Attribute Dict
 name: code
one_liner: A short code or abbreviationi for the value _
parenthetical: NameString
full_header: '- **code** - A short code or abbreviationi for the value _(NameString)_[]'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **description** - an explanation of what the code means (*RichText*)[]
Fully procesed YAML Attribute Dict
 name: description
one_liner: an explanation of what the code means
parenthetical: '*RichText*'
full_header: '- **description** - an explanation of what the code means (*RichText*)[]'

Fully procesed YAML Class Dict
 name: 'Code Value[''A possible value for an enumerated data class  DependentOf: CodeType'']'
one_liner: ''
parenthetical: ''
full_header: '_ **Code Value**[''A possible value for an enumerated data class  DependentOf:
    CodeType'']'
Attribute_PARTS:
-   name: code
    one_liner: A short code or abbreviationi for the value _
    parenthetical: NameString
    full_header: '- **code** - A short code or abbreviationi for the value _(NameString)_[]'
-   name: description
    one_liner: an explanation of what the code means
    parenthetical: '*RichText*'
    full_header: '- **description** - an explanation of what the code means (*RichText*)[]'

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **Key** - a list of attributes of a class[]
Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - keyAttributes - the attributes of the base Class. (List of Attributes ).[]
Processing . . . Constraint - <class 'ldm_parse_core.FormulaChunk'>
Processing . . . Constraint - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: keyAttributes
one_liner: the attributes of the base Class.
parenthetical: List of Attributes
full_header: '- keyAttributes - the attributes of the base Class. (List of Attributes
    ).[]'
Constraint_PARTS:
-   _type: Constraint
    top_text: ' each attribute must be a direct or inherited of the base class.'
-   _type: Constraint
    top_text: ' no repetitions allowed in keyAttributes'

Fully procesed YAML Class Dict
 name: Key
one_liner: a list of attributes of a class[]
parenthetical: ''
full_header: _ **Key** - a list of attributes of a class[]
Attribute_PARTS:
-   name: keyAttributes
    one_liner: the attributes of the base Class.
    parenthetical: List of Attributes
    full_header: '- keyAttributes - the attributes of the base Class. (List of Attributes
        ).[]'
    Constraint_PARTS:
    -   _type: Constraint
        top_text: ' each attribute must be a direct or inherited of the base class.'
    -   _type: Constraint
        top_text: ' no repetitions allowed in keyAttributes'

Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **UniqueKey** - a list of attributes on which instances of the base class may be keyed.[]
Fully procesed YAML Class Dict
 name: UniqueKey
one_liner: a list of attributes on which instances of the base class may be keyed.[]
parenthetical: ''
full_header: _ **UniqueKey** - a list of attributes on which instances of the base
    class may be keyed.[]

Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Section2 - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: ## Attributes[]
Processing . . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **Attribute Section** - a group of attributes for a class that merit a shared explanation.[]
Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: -	isOptional - whether the attributes in this section, taken together, are optional. (Boolean)[]
Fully procesed YAML Attribute Dict
 name: isOptional
one_liner: whether the attributes in this section, taken together, are optional.
parenthetical: Boolean
full_header: "-\tisOptional - whether the attributes in this section, taken together,\
    \ are optional. (Boolean)[]"

Fully procesed YAML Class Dict
 name: Attribute Section
one_liner: a group of attributes for a class that merit a shared explanation.[]
parenthetical: ''
full_header: _ **Attribute Section** - a group of attributes for a class that merit
    a shared explanation.[]
Attribute_PARTS:
-   name: isOptional
    one_liner: whether the attributes in this section, taken together, are optional.
    parenthetical: Boolean
    full_header: "-\tisOptional - whether the attributes in this section, taken together,\
        \ are optional. (Boolean)[]"

Processing . . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _['If the Attribute Section is required,then each Attribute within the sectional is optional ot required, depending on how it is marked.', '&nbsp;', 'But if the Arrribute Section is optional each attribute in the section is only required if any attribute in the section is ptresent.']
Fully procesed YAML Class Dict
 name: '[''If the Attribute Section is required,then each Attribute within the sectional
    is optional ot required, depending on how it is marked.'', ''&nbsp;'', ''But if
    the Arrribute Section is optional each attribute in the section is only required
    if any attribute in the section is ptresent.'']'
one_liner: ''
parenthetical: ''
full_header: _['If the Attribute Section is required,then each Attribute within the
    sectional is optional ot required, depending on how it is marked.', '&nbsp;',
    'But if the Arrribute Section is optional each attribute in the section is only
    required if any attribute in the section is ptresent.']

Processing . . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: __***Markdown Support***[]
Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **mdPrefix** (*[String](#string)*)[]
Processing . . . . Default - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: mdPrefix
one_liner: ''
parenthetical: '*[String](#string'
full_header: '- **mdPrefix** (*[String](#string)*)[]'
Default_PARTS:
-   _type: Default
    top_text: ' "_ "'

Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **mdTopLine** (*[String](#string)*).[]
Fully procesed YAML Attribute Dict
 name: mdTopLine
one_liner: ''
parenthetical: '*[String](#string'
full_header: '- **mdTopLine** (*[String](#string)*).[]'

Fully procesed YAML Class Dict
 name: Markdown Support[]
one_liner: ''
parenthetical: ''
full_header: __***Markdown Support***[]
Attribute_PARTS:
-   name: mdPrefix
    one_liner: ''
    parenthetical: '*[String](#string'
    full_header: '- **mdPrefix** (*[String](#string)*)[]'
    Default_PARTS:
    -   _type: Default
        top_text: ' "_ "'
-   name: mdTopLine
    one_liner: ''
    parenthetical: '*[String](#string'
    full_header: '- **mdTopLine** (*[String](#string)*).[]'

Processing . . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **Attribute**['A property or characteristic of a class']
Fully procesed YAML Class Dict
 name: Attribute['A property or characteristic of a class']
one_liner: ''
parenthetical: ''
full_header: _ **Attribute**['A property or characteristic of a class']

Processing . . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _Subtype of:_ Component[]
Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **name** - (Lower Camel).[]
Fully procesed YAML Attribute Dict
 name: name
one_liner: ''
parenthetical: Lower Camel
full_header: '- **name** - (Lower Camel).[]'

Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **dataType** - The kind of object to which the attribute refers.  _(DataType)_['H', 'In the simplest cases, the data type will be a class. And the specifier is the just the name of that class.']
Fully procesed YAML Attribute Dict
 name: dataType
one_liner: The kind of object to which the attribute refers.  _
parenthetical: DataType
full_header: '- **dataType** - The kind of object to which the attribute refers.  _(DataType)_[''H'',
    ''In the simplest cases, the data type will be a class. And the specifier is the
    just the name of that class.'']'

Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - List of Editions[]
Fully procesed YAML Attribute Dict
 name: List of Editions[]
one_liner: ''
parenthetical: ''
full_header: '- List of Editions[]'

Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - Set of Edition[]
Fully procesed YAML Attribute Dict
 name: Set of Edition[]
one_liner: ''
parenthetical: ''
full_header: '- Set of Edition[]'

Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - ... and more complicated cases.[]
Fully procesed YAML Attribute Dict
 name: '... and more complicated cases.[]'
one_liner: ''
parenthetical: ''
full_header: '- ... and more complicated cases.[]'

Fully procesed YAML Class Dict
 name: 'Subtype of: Component[]'
one_liner: ''
parenthetical: ''
full_header: _Subtype of:_ Component[]
Attribute_PARTS:
-   name: name
    one_liner: ''
    parenthetical: Lower Camel
    full_header: '- **name** - (Lower Camel).[]'
-   name: dataType
    one_liner: The kind of object to which the attribute refers.  _
    parenthetical: DataType
    full_header: '- **dataType** - The kind of object to which the attribute refers.  _(DataType)_[''H'',
        ''In the simplest cases, the data type will be a class. And the specifier
        is the just the name of that class.'']'
-   name: List of Editions[]
    one_liner: ''
    parenthetical: ''
    full_header: '- List of Editions[]'
-   name: Set of Edition[]
    one_liner: ''
    parenthetical: ''
    full_header: '- Set of Edition[]'
-   name: '... and more complicated cases.[]'
    one_liner: ''
    parenthetical: ''
    full_header: '- ... and more complicated cases.[]'

Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: __ **Cardinalities**.[]
Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **isOptional** - Indicates whether the attribute must have a value for every instance of the class _(Boolean)_[]
Processing . . . Default - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: isOptional
one_liner: Indicates whether the attribute must have a value for every instance of
    the class _
parenthetical: Boolean
full_header: '- **isOptional** - Indicates whether the attribute must have a value
    for every instance of the class _(Boolean)_[]'
Default_PARTS:
-   _type: Default
    top_text: '*** False'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **cardinality** - The cardinality of the relationship represented by the attribute _(CardinalityCode)_[]
Processing . . . Default - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: cardinality
one_liner: The cardinality of the relationship represented by the attribute _
parenthetical: CardinalityCode
full_header: '- **cardinality** - The cardinality of the relationship represented
    by the attribute _(CardinalityCode)_[]'
Default_PARTS:
-   _type: Default
    top_text: '***'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - For a singular attribute, the default cardinality is N:1. If the attribute is 1:1, it must be stated explicitly.[]
Fully procesed YAML Attribute Dict
 name: For a singular attribute, the default cardinality is N:1. If the attribute is
    1:1, it must be stated explicitly.[]
one_liner: ''
parenthetical: ''
full_header: '- For a singular attribute, the default cardinality is N:1. If the attribute
    is 1:1, it must be stated explicitly.[]'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - For a collective attribute, the default is 1:N. If the attribute is N:M, it must be stated explicitly.[]
Fully procesed YAML Attribute Dict
 name: For a collective attribute, the default is 1:N. If the attribute is N:M, it
    must be stated explicitly.[]
one_liner: ''
parenthetical: ''
full_header: '- For a collective attribute, the default is 1:N. If the attribute is
    N:M, it must be stated explicitly.[]'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - author (1:1 Author)[]
Fully procesed YAML Attribute Dict
 name: author
one_liner: ''
parenthetical: 1:1 Author
full_header: '- author (1:1 Author)[]'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - books (optional N:M Set of Books)[]
Fully procesed YAML Attribute Dict
 name: books
one_liner: ''
parenthetical: optional N:M Set of Books
full_header: '- books (optional N:M Set of Books)[]'

Fully procesed YAML Class Dict
 name: Cardinalities.[]
one_liner: ''
parenthetical: ''
full_header: __ **Cardinalities**.[]
Attribute_PARTS:
-   name: isOptional
    one_liner: Indicates whether the attribute must have a value for every instance
        of the class _
    parenthetical: Boolean
    full_header: '- **isOptional** - Indicates whether the attribute must have a value
        for every instance of the class _(Boolean)_[]'
    Default_PARTS:
    -   _type: Default
        top_text: '*** False'
-   name: cardinality
    one_liner: The cardinality of the relationship represented by the attribute _
    parenthetical: CardinalityCode
    full_header: '- **cardinality** - The cardinality of the relationship represented
        by the attribute _(CardinalityCode)_[]'
    Default_PARTS:
    -   _type: Default
        top_text: '***'
-   name: For a singular attribute, the default cardinality is N:1. If the attribute
        is 1:1, it must be stated explicitly.[]
    one_liner: ''
    parenthetical: ''
    full_header: '- For a singular attribute, the default cardinality is N:1. If the
        attribute is 1:1, it must be stated explicitly.[]'
-   name: For a collective attribute, the default is 1:N. If the attribute is N:M,
        it must be stated explicitly.[]
    one_liner: ''
    parenthetical: ''
    full_header: '- For a collective attribute, the default is 1:N. If the attribute
        is N:M, it must be stated explicitly.[]'
-   name: author
    one_liner: ''
    parenthetical: 1:1 Author
    full_header: '- author (1:1 Author)[]'
-   name: books
    one_liner: ''
    parenthetical: optional N:M Set of Books
    full_header: '- books (optional N:M Set of Books)[]'

Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: __ ***Inverse Attributes***[]
Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **isInvertible** - (Boolean)[]
Processing . . . Derivation - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: isInvertible
one_liner: ''
parenthetical: Boolean
full_header: '- **isInvertible** - (Boolean)[]'
Derivation_PARTS:
-   _type: Derivation
    top_text: ' true if the data type is a class or a simple collection of members
        of a class.'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **inverseClass** - the class which contains, or would contain the inverse attribute (optional Class)[]
Processing . . . Derivation - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: inverseClass
one_liner: the class which contains, or would contain the inverse attribute
parenthetical: optional Class
full_header: '- **inverseClass** - the class which contains, or would contain the
    inverse attribute (optional Class)[]'
Derivation_PARTS:
-   _type: Derivation
    top_text: ' from the data type. Null unless arrribute is invertible.'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **inverseAttribute** - (optional Attribute)[]
Fully procesed YAML Attribute Dict
 name: inverseAttribute
one_liner: ''
parenthetical: optional Attribute
full_header: '- **inverseAttribute** - (optional Attribute)[]'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **inverseIsOptional** - (optional Attribute)[]
Fully procesed YAML Attribute Dict
 name: inverseIsOptional
one_liner: ''
parenthetical: optional Attribute
full_header: '- **inverseIsOptional** - (optional Attribute)[]'

Fully procesed YAML Class Dict
 name: Inverse Attributes[]
one_liner: ''
parenthetical: ''
full_header: __ ***Inverse Attributes***[]
Attribute_PARTS:
-   name: isInvertible
    one_liner: ''
    parenthetical: Boolean
    full_header: '- **isInvertible** - (Boolean)[]'
    Derivation_PARTS:
    -   _type: Derivation
        top_text: ' true if the data type is a class or a simple collection of members
            of a class.'
-   name: inverseClass
    one_liner: the class which contains, or would contain the inverse attribute
    parenthetical: optional Class
    full_header: '- **inverseClass** - the class which contains, or would contain
        the inverse attribute (optional Class)[]'
    Derivation_PARTS:
    -   _type: Derivation
        top_text: ' from the data type. Null unless arrribute is invertible.'
-   name: inverseAttribute
    one_liner: ''
    parenthetical: optional Attribute
    full_header: '- **inverseAttribute** - (optional Attribute)[]'
-   name: inverseIsOptional
    one_liner: ''
    parenthetical: optional Attribute
    full_header: '- **inverseIsOptional** - (optional Attribute)[]'

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ ***Formulas***[]
Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **default** - The rule or formula for calculating the value, if no value is supplied _(Derivation, optional)_[]
Fully procesed YAML Attribute Dict
 name: default
one_liner: The rule or formula for calculating the value, if no value is supplied
    _
parenthetical: Derivation, optional
full_header: '- **default** - The rule or formula for calculating the value, if no
    value is supplied _(Derivation, optional)_[]'

Fully procesed YAML Class Dict
 name: Formulas[]
one_liner: ''
parenthetical: ''
full_header: _ ***Formulas***[]
Attribute_PARTS:
-   name: default
    one_liner: The rule or formula for calculating the value, if no value is supplied
        _
    parenthetical: Derivation, optional
    full_header: '- **default** - The rule or formula for calculating the value, if
        no value is supplied _(Derivation, optional)_[]'

Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **derivation** - For derived attributes, the rule or formula for calculating the value _(Derivation, optional)_[]
Fully procesed YAML Attribute Dict
 name: derivation
one_liner: For derived attributes, the rule or formula for calculating the value _
parenthetical: Derivation, optional
full_header: '- **derivation** - For derived attributes, the rule or formula for calculating
    the value _(Derivation, optional)_[]'

Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **constraints** - Any validation rules specific to this attribute _(ListOf Constraints)_[]
Fully procesed YAML Attribute Dict
 name: constraints
one_liner: Any validation rules specific to this attribute _
parenthetical: ListOf Constraints
full_header: '- **constraints** - Any validation rules specific to this attribute
    _(ListOf Constraints)_[]'

Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: __Override Tracking[]
Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - Overrides[]
Fully procesed YAML Attribute Dict
 name: Overrides[]
one_liner: ''
parenthetical: ''
full_header: '- Overrides[]'

Fully procesed YAML Class Dict
 name: Override Tracking[]
one_liner: ''
parenthetical: ''
full_header: __Override Tracking[]
Attribute_PARTS:
-   name: Overrides[]
    one_liner: ''
    parenthetical: ''
    full_header: '- Overrides[]'

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ ***ValueType:*** **Derivation**['A rule or formula for deriving the value of an attribute']
Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **statement** - An English language statement of the derivation rule _(RichText)_[]
Fully procesed YAML Attribute Dict
 name: statement
one_liner: An English language statement of the derivation rule _
parenthetical: RichText
full_header: '- **statement** - An English language statement of the derivation rule
    _(RichText)_[]'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **expression** - The formal expression of the derivation in a programming language _(CodeExpression)_[]
Fully procesed YAML Attribute Dict
 name: expression
one_liner: The formal expression of the derivation in a programming language _
parenthetical: CodeExpression
full_header: '- **expression** - The formal expression of the derivation in a programming
    language _(CodeExpression)_[]'

Fully procesed YAML Class Dict
 name: 'ValueType: Derivation[''A rule or formula for deriving the value of an attribute'']'
one_liner: ''
parenthetical: ''
full_header: _ ***ValueType:*** **Derivation**['A rule or formula for deriving the
    value of an attribute']
Attribute_PARTS:
-   name: statement
    one_liner: An English language statement of the derivation rule _
    parenthetical: RichText
    full_header: '- **statement** - An English language statement of the derivation
        rule _(RichText)_[]'
-   name: expression
    one_liner: The formal expression of the derivation in a programming language _
    parenthetical: CodeExpression
    full_header: '- **expression** - The formal expression of the derivation in a
        programming language _(CodeExpression)_[]'

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ ***ValueType:*** **Constraint**['A rule, condition, or validation that must be satisfied by the model']
Fully procesed YAML Class Dict
 name: 'ValueType: Constraint[''A rule, condition, or validation that must be satisfied
    by the model'']'
one_liner: ''
parenthetical: ''
full_header: _ ***ValueType:*** **Constraint**['A rule, condition, or validation that
    must be satisfied by the model']

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _Subtype of:_ Component[]
Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **statement** - An English language statement of the constraint _(RichText)_[]
Fully procesed YAML Attribute Dict
 name: statement
one_liner: An English language statement of the constraint _
parenthetical: RichText
full_header: '- **statement** - An English language statement of the constraint _(RichText)_[]'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **expression** - The formal expression of the constraint in a programming language (e.g., OCL _(CodeExpression)_[]
Fully procesed YAML Attribute Dict
 name: expression
one_liner: The formal expression of the constraint in a programming language
parenthetical: e.g., OCL _(CodeExpression
full_header: '- **expression** - The formal expression of the constraint in a programming
    language (e.g., OCL _(CodeExpression)_[]'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **severity** -  (Code)[]
Fully procesed YAML Attribute Dict
 name: severity
one_liner: ''
parenthetical: Code
full_header: '- **severity** -  (Code)[]'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: -- **Warning** - nothing fatal; just a caution[]
Fully procesed YAML Attribute Dict
 name: ''
one_liner: '**Warning** - nothing fatal; just a caution[]'
parenthetical: ''
full_header: -- **Warning** - nothing fatal; just a caution[]

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: -- **Error** - serious. Fix now[]
Fully procesed YAML Attribute Dict
 name: ''
one_liner: '**Error** - serious. Fix now[]'
parenthetical: ''
full_header: -- **Error** - serious. Fix now[]

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **Message** - (Template)[]
Fully procesed YAML Attribute Dict
 name: Message
one_liner: ''
parenthetical: Template
full_header: '- **Message** - (Template)[]'

Fully procesed YAML Class Dict
 name: 'Subtype of: Component[]'
one_liner: ''
parenthetical: ''
full_header: _Subtype of:_ Component[]
Attribute_PARTS:
-   name: statement
    one_liner: An English language statement of the constraint _
    parenthetical: RichText
    full_header: '- **statement** - An English language statement of the constraint
        _(RichText)_[]'
-   name: expression
    one_liner: The formal expression of the constraint in a programming language
    parenthetical: e.g., OCL _(CodeExpression
    full_header: '- **expression** - The formal expression of the constraint in a
        programming language (e.g., OCL _(CodeExpression)_[]'
-   name: severity
    one_liner: ''
    parenthetical: Code
    full_header: '- **severity** -  (Code)[]'
-   name: ''
    one_liner: '**Warning** - nothing fatal; just a caution[]'
    parenthetical: ''
    full_header: -- **Warning** - nothing fatal; just a caution[]
-   name: ''
    one_liner: '**Error** - serious. Fix now[]'
    parenthetical: ''
    full_header: -- **Error** - serious. Fix now[]
-   name: Message
    one_liner: ''
    parenthetical: Template
    full_header: '- **Message** - (Template)[]'

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **Class Constraint**[]
Fully procesed YAML Class Dict
 name: Class Constraint[]
one_liner: ''
parenthetical: ''
full_header: _ **Class Constraint**[]

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **Attribute Constraint**[]
Fully procesed YAML Class Dict
 name: Attribute Constraint[]
one_liner: ''
parenthetical: ''
full_header: _ **Attribute Constraint**[]

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **CodeExpression**[]
Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **Language** - the programming language (Code)[]
Fully procesed YAML Attribute Dict
 name: Language
one_liner: the programming language
parenthetical: Code
full_header: '- **Language** - the programming language (Code)[]'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: -- OCL: Object Constraint Language[]
Fully procesed YAML Attribute Dict
 name: ''
one_liner: 'OCL: Object Constraint Language[]'
parenthetical: ''
full_header: '-- OCL: Object Constraint Language[]'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: -- Java: Java[]
Fully procesed YAML Attribute Dict
 name: ''
one_liner: 'Java: Java[]'
parenthetical: ''
full_header: '-- Java: Java[]'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **Expression** (String)[]
Fully procesed YAML Attribute Dict
 name: Expression
one_liner: ''
parenthetical: String
full_header: '- **Expression** (String)[]'

Fully procesed YAML Class Dict
 name: CodeExpression[]
one_liner: ''
parenthetical: ''
full_header: _ **CodeExpression**[]
Attribute_PARTS:
-   name: Language
    one_liner: the programming language
    parenthetical: Code
    full_header: '- **Language** - the programming language (Code)[]'
-   name: ''
    one_liner: 'OCL: Object Constraint Language[]'
    parenthetical: ''
    full_header: '-- OCL: Object Constraint Language[]'
-   name: ''
    one_liner: 'Java: Java[]'
    parenthetical: ''
    full_header: '-- Java: Java[]'
-   name: Expression
    one_liner: ''
    parenthetical: String
    full_header: '- **Expression** (String)[]'

Processing . Section2 - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: ## Methods[]
Processing . . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **Method**['A behavior or operation associated with a class']
Fully procesed YAML Class Dict
 name: Method['A behavior or operation associated with a class']
one_liner: ''
parenthetical: ''
full_header: _ **Method**['A behavior or operation associated with a class']

Processing . . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _Subtype of:_ Component[]
Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **parameters** - The input parameters of the method _(ListOf Parameters)_[]
Fully procesed YAML Attribute Dict
 name: parameters
one_liner: The input parameters of the method _
parenthetical: ListOf Parameters
full_header: '- **parameters** - The input parameters of the method _(ListOf Parameters)_[]'

Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **returnType** - The data type of the value returned by the method _(DataType )_[]
Fully procesed YAML Attribute Dict
 name: returnType
one_liner: The data type of the value returned by the method _
parenthetical: DataType
full_header: '- **returnType** - The data type of the value returned by the method
    _(DataType )_[]'

Fully procesed YAML Class Dict
 name: 'Subtype of: Component[]'
one_liner: ''
parenthetical: ''
full_header: _Subtype of:_ Component[]
Attribute_PARTS:
-   name: parameters
    one_liner: The input parameters of the method _
    parenthetical: ListOf Parameters
    full_header: '- **parameters** - The input parameters of the method _(ListOf Parameters)_[]'
-   name: returnType
    one_liner: The data type of the value returned by the method _
    parenthetical: DataType
    full_header: '- **returnType** - The data type of the value returned by the method
        _(DataType )_[]'

Processing . . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **Parameter**['An input to a method']
Fully procesed YAML Class Dict
 name: Parameter['An input to a method']
one_liner: ''
parenthetical: ''
full_header: _ **Parameter**['An input to a method']

Processing . . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _Subtype of:_ Component[]
Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **type** - The data type of the parameter _(DataType )_[]
Fully procesed YAML Attribute Dict
 name: type
one_liner: The data type of the parameter _
parenthetical: DataType
full_header: '- **type** - The data type of the parameter _(DataType )_[]'

Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **cardinality** - The cardinality of the parameter (e.g., optional, required) _(AttributeCardinality)_[]
Fully procesed YAML Attribute Dict
 name: cardinality
one_liner: The cardinality of the parameter
parenthetical: e.g., optional, required
full_header: '- **cardinality** - The cardinality of the parameter (e.g., optional,
    required) _(AttributeCardinality)_[]'

Fully procesed YAML Class Dict
 name: 'Subtype of: Component[]'
one_liner: ''
parenthetical: ''
full_header: _Subtype of:_ Component[]
Attribute_PARTS:
-   name: type
    one_liner: The data type of the parameter _
    parenthetical: DataType
    full_header: '- **type** - The data type of the parameter _(DataType )_[]'
-   name: cardinality
    one_liner: The cardinality of the parameter
    parenthetical: e.g., optional, required
    full_header: '- **cardinality** - The cardinality of the parameter (e.g., optional,
        required) _(AttributeCardinality)_[]'

Processing . Section2 - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: ## Data Types[]
		ELABORATION is:  ['*ValueType*:**Data Type**']
Processing . . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **Simple Data Type**['***SubtpeOf***: DataType']
Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **coreClass** - (Class)[]
Fully procesed YAML Attribute Dict
 name: coreClass
one_liner: ''
parenthetical: Class
full_header: '- **coreClass** - (Class)[]'

Fully procesed YAML Class Dict
 name: 'Simple Data Type[''SubtpeOf: DataType'']'
one_liner: ''
parenthetical: ''
full_header: '_ **Simple Data Type**[''***SubtpeOf***: DataType'']'
Attribute_PARTS:
-   name: coreClass
    one_liner: ''
    parenthetical: Class
    full_header: '- **coreClass** - (Class)[]'

Processing . . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **Complex Data Type**[]
Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **aggregation** (Aggregating Operator)[]
Fully procesed YAML Attribute Dict
 name: aggregation
one_liner: ''
parenthetical: Aggregating Operator
full_header: '- **aggregation** (Aggregating Operator)[]'

Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **aggregatedTypes** (List of DataTypes)[]
Fully procesed YAML Attribute Dict
 name: aggregatedTypes
one_liner: ''
parenthetical: List of DataTypes
full_header: '- **aggregatedTypes** (List of DataTypes)[]'

Fully procesed YAML Class Dict
 name: Complex Data Type[]
one_liner: ''
parenthetical: ''
full_header: _ **Complex Data Type**[]
Attribute_PARTS:
-   name: aggregation
    one_liner: ''
    parenthetical: Aggregating Operator
    full_header: '- **aggregation** (Aggregating Operator)[]'
-   name: aggregatedTypes
    one_liner: ''
    parenthetical: List of DataTypes
    full_header: '- **aggregatedTypes** (List of DataTypes)[]'

Processing . . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **Aggregating Operator**[]
Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **Name**- (Code)[]
Fully procesed YAML Attribute Dict
 name: Name
one_liner: ''
parenthetical: Code
full_header: '- **Name**- (Code)[]'

Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: -- **SetOf**[]
Fully procesed YAML Attribute Dict
 name: ''
one_liner: '**SetOf**[]'
parenthetical: ''
full_header: -- **SetOf**[]

Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: -- **ListOf**[]
Fully procesed YAML Attribute Dict
 name: ''
one_liner: '**ListOf**[]'
parenthetical: ''
full_header: -- **ListOf**[]

Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: -- **Mapping**[]
Fully procesed YAML Attribute Dict
 name: ''
one_liner: '**Mapping**[]'
parenthetical: ''
full_header: -- **Mapping**[]

Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **arity** - (Integer)[]
Fully procesed YAML Attribute Dict
 name: arity
one_liner: ''
parenthetical: Integer
full_header: '- **arity** - (Integer)[]'

Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **spelling** - (Template)[]
Fully procesed YAML Attribute Dict
 name: spelling
one_liner: ''
parenthetical: Template
full_header: '- **spelling** - (Template)[]'

Fully procesed YAML Class Dict
 name: Aggregating Operator[]
one_liner: ''
parenthetical: ''
full_header: _ **Aggregating Operator**[]
Attribute_PARTS:
-   name: Name
    one_liner: ''
    parenthetical: Code
    full_header: '- **Name**- (Code)[]'
-   name: ''
    one_liner: '**SetOf**[]'
    parenthetical: ''
    full_header: -- **SetOf**[]
-   name: ''
    one_liner: '**ListOf**[]'
    parenthetical: ''
    full_header: -- **ListOf**[]
-   name: ''
    one_liner: '**Mapping**[]'
    parenthetical: ''
    full_header: -- **Mapping**[]
-   name: arity
    one_liner: ''
    parenthetical: Integer
    full_header: '- **arity** - (Integer)[]'
-   name: spelling
    one_liner: ''
    parenthetical: Template
    full_header: '- **spelling** - (Template)[]'

Processing . Section2 - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: ## Low level Data Types[]
		ELABORATION is:  ['insert Camel Case.md']
Processing . . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ ***ValueType***: **CamelName**[]
Processing . . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - value: the string (String)[]
Processing . . . . Constraint - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: 'value: the string'
one_liner: ''
parenthetical: String
full_header: '- value: the string (String)[]'
Constraint_PARTS:
-   _type: Constraint
    top_text: ' Must follow the camel case naming convention and not be empty.'

Fully procesed YAML Class Dict
 name: 'ValueType: CamelName[]'
one_liner: ''
parenthetical: ''
full_header: '_ ***ValueType***: **CamelName**[]'
Attribute_PARTS:
-   name: 'value: the string'
    one_liner: ''
    parenthetical: String
    full_header: '- value: the string (String)[]'
    Constraint_PARTS:
    -   _type: Constraint
        top_text: ' Must follow the camel case naming convention and not be empty.'

Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **UpperCamel**- a CamelName that begins with a capital letter[]
Fully procesed YAML Class Dict
 name: UpperCamel
one_liner: a CamelName that begins with a capital letter[]
parenthetical: ''
full_header: _ **UpperCamel**- a CamelName that begins with a capital letter[]

Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **LowerCamel** - a CamelName that begins with a lower case letter[]
Fully procesed YAML Class Dict
 name: LowerCamel
one_liner: a CamelName that begins with a lower case letter[]
parenthetical: ''
full_header: _ **LowerCamel** - a CamelName that begins with a lower case letter[]

Processing . Annotation - <class 'ldm_parse_core.DocPart'>
Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **Qualified Camel** - an expression consisting of Camel Names separated by periods[]
Processing . . Constraint - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Class Dict
 name: Qualified Camel
one_liner: an expression consisting of Camel Names separated by periods[]
parenthetical: ''
full_header: _ **Qualified Camel** - an expression consisting of Camel Names separated
    by periods[]
Constraint_PARTS:
-   _type: Constraint
    top_text: ' content consists of CamelNames, separated by periods.  Each of the
        camel names must be Upper Camel except, possibly, the first.'

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **RichText**.  A string with markup for block level formatting.[]
Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **value** - the string content (string)[]
Fully procesed YAML Attribute Dict
 name: value
one_liner: the string content
parenthetical: string
full_header: '- **value** - the string content (string)[]'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **format** - the rich text coding language used (Code)[]
Fully procesed YAML Attribute Dict
 name: format
one_liner: the rich text coding language used
parenthetical: Code
full_header: '- **format** - the rich text coding language used (Code)[]'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **HTML**[]
Fully procesed YAML Attribute Dict
 name: HTML[]
one_liner: ''
parenthetical: ''
full_header: '- **HTML**[]'

Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **MarkDown**[]
Fully procesed YAML Attribute Dict
 name: MarkDown[]
one_liner: ''
parenthetical: ''
full_header: '- **MarkDown**[]'

Fully procesed YAML Class Dict
 name: RichText.  A string with markup for block level formatting.[]
one_liner: ''
parenthetical: ''
full_header: _ **RichText**.  A string with markup for block level formatting.[]
Attribute_PARTS:
-   name: value
    one_liner: the string content
    parenthetical: string
    full_header: '- **value** - the string content (string)[]'
-   name: format
    one_liner: the rich text coding language used
    parenthetical: Code
    full_header: '- **format** - the rich text coding language used (Code)[]'
-   name: HTML[]
    one_liner: ''
    parenthetical: ''
    full_header: '- **HTML**[]'
-   name: MarkDown[]
    one_liner: ''
    parenthetical: ''
    full_header: '- **MarkDown**[]'

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _  **RichLine**   - String with markup for line level formatting.[]
Processing . . Attribute - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: - **value** - the string content (string)[]
Processing . . . Constraint - <class 'ldm_parse_core.FormulaChunk'>
Fully procesed YAML Attribute Dict
 name: value
one_liner: the string content
parenthetical: string
full_header: '- **value** - the string content (string)[]'
Constraint_PARTS:
-   _type: Constraint
    top_text: ' must not containa line break or new line character'

Fully procesed YAML Class Dict
 name: RichLine
one_liner: String with markup for line level formatting.[]
parenthetical: ''
full_header: _  **RichLine**   - String with markup for line level formatting.[]
Attribute_PARTS:
-   name: value
    one_liner: the string content
    parenthetical: string
    full_header: '- **value** - the string content (string)[]'
    Constraint_PARTS:
    -   _type: Constraint
        top_text: ' must not containa line break or new line character'

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _ **PrimitiveType**[]
Fully procesed YAML Class Dict
 name: PrimitiveType[]
one_liner: ''
parenthetical: ''
full_header: _ **PrimitiveType**[]

Processing . Class - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: _Values:_['**String**', '**Integer**', '**Decimal**', '**Boolean**', '**Date**', '**Time**', '**DateTime**']
Fully procesed YAML Class Dict
 name: Values:['String', 'Integer', 'Decimal', 'Boolean', 'Date', 'Time', 'DateTime']
one_liner: ''
parenthetical: ''
full_header: _Values:_['**String**', '**Integer**', '**Decimal**', '**Boolean**',
    '**Date**', '**Time**', '**DateTime**']

Processing . Section2 - <class 'ldm_parse_core.ComponentChunk'>
ExtraText here...
		Full header is: ## Appendices['Insert More Sidebars.md', 'Insert Overrides.md', 'insert LDM Intro.md', 'Insert OCL.md', 'Insert Camel Case.md']
